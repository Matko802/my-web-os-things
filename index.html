<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <!-- Nerd Fonts - JetBrainsMono -->
    <link href="https://cdn.jsdelivr.net/gh/ryanoasis/nerd-fonts@v3.4.0/patched-fonts/JetBrainsMono/Ligatures/Regular/JetBrainsMonoNerdFont-Regular.ttf" rel="preload" as="font" type="font/ttf" crossorigin>
    <style>
      @font-face {
        font-family: 'JetBrainsMono Nerd Font';
        src: url('https://cdn.jsdelivr.net/gh/ryanoasis/nerd-fonts@v3.4.0/patched-fonts/JetBrainsMono/Ligatures/Regular/JetBrainsMonoNerdFont-Regular.ttf') format('truetype');
        font-weight: 400;
        font-style: normal;
        font-display: swap;
      }
      @font-face {
        font-family: 'JetBrainsMono Nerd Font';
        src: url('https://cdn.jsdelivr.net/gh/ryanoasis/nerd-fonts@v3.4.0/patched-fonts/JetBrainsMono/Ligatures/Bold/JetBrainsMonoNerdFont-Bold.ttf') format('truetype');
        font-weight: 700;
        font-style: normal;
        font-display: swap;
      }
    </style>
    <title>M OS - Modern Desktop</title>
    <meta name="description" content="M OS - A modern, sleek web desktop experience with draggable windows, dock, and apps." />
    <meta name="author" content="M OS" />

    <meta property="og:title" content="M OS - Modern Desktop" />
    <meta property="og:description" content="Experience M OS - a futuristic desktop in your browser" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="/" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="M OS - Modern Desktop" />
    <meta name="twitter:description" content="Experience M OS - a futuristic desktop with elegant design." />
    <link rel="canonical" href="/" />

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
      }
      
      /* Theme transitions only on specific UI elements - NOT globally to avoid flicker */
      .desktop-bg,
      .menubar,
      .dock,
      .window,
      .titlebar,
      .quick-settings,
      .settings-section,
      .toggle-switch,
      .dock-icon {
        transition: background-color 0.3s ease,
                    border-color 0.3s ease,
                    box-shadow 0.3s ease;
      }
      
      /* Smooth accent color transitions for all accent-colored UI elements */
      .accent-color-swatch,
      .accent-color-option,
      .dock-indicator,
      .dock-indicator-dot,
      .settings-nav-item,
      .toggle-switch .toggle-slider,
      .toggle-switch .toggle-slider::before,
      button,
      .btn,
      .icon-pack-option,
      .launchpad-icon,
      .menubar-item,
      .quick-settings-toggle,
      .progress-bar,
      .slider-thumb,
      [style*="accent"],
      [style*="primary"] {
        transition: background-color 0.25s ease,
                    border-color 0.25s ease,
                    box-shadow 0.25s ease,
                    color 0.25s ease,
                    fill 0.25s ease,
                    stroke 0.25s ease,
                    outline-color 0.25s ease,
                    transform 0.15s ease;
      }
      
      /* SVG icon color transitions */
      svg,
      svg path,
      svg circle,
      svg rect,
      svg line,
      svg polyline,
      svg polygon {
        transition: fill 0.25s ease,
                    stroke 0.25s ease,
                    color 0.25s ease;
      }
      
      /* Accent ring/outline transitions for color swatches */
      .accent-color-swatch::after,
      .accent-color-option::after {
        transition: opacity 0.2s ease,
                    transform 0.2s ease,
                    box-shadow 0.25s ease;
      }

      /* M OS Light Theme - DEFAULT - MONOCHROME */
      :root {
        --background: 0 0% 94%;
        --foreground: 0 0% 10%;
        --window-bg: 0 0% 100%;
        --window-border: 0 0% 70%;
        --titlebar-bg: 0 0% 97%;
        --dock-bg: 0 0% 100%;
        --menubar-bg: 0 0% 97%;
        --primary: 0 0% 15%;
        --primary-foreground: 0 0% 100%;
        --primary-glow: 0 0% 35%;
        --muted-foreground: 0 0% 40%;
        --accent: 0 0% 88%;
        --accent-hover: 0 0% 82%;
        --quick-settings-bg: 0 0% 100%;
        --quick-settings-item-bg: 0 0% 92%;
        --gradient-accent: linear-gradient(135deg, hsl(0 0% 25%), hsl(0 0% 45%));
        --shadow-color: 0 0% 60%;
        --destructive: 0 84% 55%;
        --border: 0 0% 75%;
        --input: 0 0% 94%;
        --secondary: 0 0% 94%;
        --secondary-foreground: 0 0% 10%;
        --slider-track: 0 0% 75%;
        --slider-fill: 0 0% 25%;
      }

      /* M OS Dark Theme - MONOCHROME */
      .dark {
        --background: 0 0% 6%;
        --foreground: 0 0% 95%;
        --window-bg: 0 0% 10%;
        --window-border: 0 0% 18%;
        --titlebar-bg: 0 0% 8%;
        --dock-bg: 0 0% 10%;
        --menubar-bg: 0 0% 8%;
        --primary: 0 0% 85%;
        --primary-foreground: 0 0% 10%;
        --primary-glow: 0 0% 70%;
        --accent: 0 0% 15%;
        --accent-hover: 0 0% 20%;
        --quick-settings-bg: 0 0% 10%;
        --quick-settings-item-bg: 0 0% 14%;
        --gradient-accent: linear-gradient(135deg, hsl(0 0% 40%), hsl(0 0% 60%));
        --shadow-color: 0 0% 3%;
        --destructive: 0 63% 31%;
        --border: 0 0% 18%;
        --input: 0 0% 14%;
        --secondary: 0 0% 14%;
        --secondary-foreground: 0 0% 95%;
        --slider-track: 0 0% 25%;
        --slider-fill: 0 0% 80%;
      }
      
      /* M Logo - Premium styling with theme inversion */
      .m-logo-circle {
        background: white;
        transition: background-color 0.3s ease, color 0.3s ease;
      }
      .m-logo-letter {
        color: black;
        transition: color 0.3s ease;
      }
      
      /* Light mode - invert to black circle with white M */
      :root:not(.dark) .m-logo-circle {
        background: hsl(220 20% 10%);
      }
      :root:not(.dark) .m-logo-letter {
        color: white;
      }
      
      /* M OS specific styles - remove macOS overrides */
      
      body {
        font-family: 'Space Grotesk', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        overflow: hidden;
        width: 100vw;
        height: 100vh;
        background: hsl(var(--background));
        color: hsl(var(--foreground));
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      body.no-animations *,
      body.no-animations *::before,
      body.no-animations *::after {
        animation-duration: 0s !important;
        animation-delay: 0s !important;
        transition-duration: 0s !important;
        transition-delay: 0s !important;
      }

      * {
        -webkit-tap-highlight-color: transparent;
      }

      input, textarea {
        caret-color: hsl(var(--foreground));
        user-select: text;
        -webkit-user-select: text;
        -moz-user-select: text;
        -ms-user-select: text;
        font-family: 'Space Grotesk', sans-serif;
      }

      .desktop {
        width: 100vw;
        height: 100vh;
        position: relative;
        overflow: hidden;
      }

      .desktop-bg {
        position: absolute;
        inset: 0;
        background: linear-gradient(135deg, hsl(0 0% 10%) 0%, hsl(0 0% 8%) 50%, hsl(0 0% 12%) 100%);
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        transition: opacity 0.6s ease-in-out;
      }
      
      /* Secondary background layer for crossfade effect */
      .desktop-bg-next {
        position: absolute;
        inset: 0;
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        opacity: 0;
        transition: opacity 0.6s ease-in-out;
        pointer-events: none;
      }
      
      .desktop-bg-next.visible {
        opacity: 1;
      }
      
      .dark .desktop-bg {
        background: linear-gradient(135deg, hsl(0 0% 6%) 0%, hsl(0 0% 4%) 50%, hsl(0 0% 8%) 100%);
      }
      
      :root .desktop-bg {
        background: linear-gradient(135deg, hsl(0 0% 92%) 0%, hsl(0 0% 88%) 50%, hsl(0 0% 90%) 100%);
      }
      
      /* Window transparency support */
      .window-transparent .window {
        background: hsl(var(--window-bg) / var(--window-opacity, 1)) !important;
        backdrop-filter: blur(var(--window-blur, 0px)) saturate(150%) !important;
        -webkit-backdrop-filter: blur(var(--window-blur, 0px)) saturate(150%) !important;
      }
      .window-transparent .window .titlebar {
        background: hsl(var(--titlebar-bg) / var(--window-opacity, 1)) !important;
      }
      .window-transparent .window .window-content {
        background: transparent !important;
      }
      
      /* Version Manager - transparent content to show window blur */
      .window[data-app="versionmanager"] .window-content {
        background: transparent !important;
      }
      
      .window[data-app="versionmanager"] .versionmanager-container {
        background: transparent !important;
      }
      
      .window[data-app="versionmanager"] .versionmanager-sidebar {
        background: hsl(var(--accent) / 0.3) !important;
      }

      .settings-container {
        display: flex;
        height: 100%;
        overflow: hidden;
      }

      .settings-sidebar {
        width: 240px;
        background: hsl(var(--accent) / 0.3);
        border-right: 1px solid hsl(var(--window-border));
        overflow-y: auto;
        flex-shrink: 0;
        scrollbar-width: thin;
        scrollbar-color: rgba(128, 128, 128, 0.5) transparent;
      }

      .settings-sidebar::-webkit-scrollbar {
        width: 8px;
      }

      .settings-sidebar::-webkit-scrollbar-track {
        background: transparent;
      }

      .settings-sidebar::-webkit-scrollbar-thumb {
        background: rgba(128, 128, 128, 0.5);
        border-radius: 10px;
        border: 2px solid transparent;
        background-clip: padding-box;
      }

      .settings-sidebar::-webkit-scrollbar-thumb:hover {
        background: rgba(128, 128, 128, 0.7);
        background-clip: padding-box;
      }

      .settings-search {
        padding: 12px;
        border-bottom: 1px solid hsl(var(--window-border));
      }

      .settings-search input {
        width: 100%;
        padding: 6px 10px;
        background: hsl(var(--background));
        border: 1px solid hsl(var(--border));
        border-radius: 6px;
        font-size: 13px;
        color: hsl(var(--foreground));
        outline: none;
        transition: all 0.2s;
      }

      .settings-search input::placeholder {
        color: hsl(var(--muted-foreground));
      }

      .settings-search input:focus {
        border-color: hsl(var(--primary));
        box-shadow: 0 0 0 2px hsl(var(--primary) / 0.1);
      }

      .settings-nav-item {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 8px 12px;
        margin: 2px 8px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 13px;
        color: hsl(var(--foreground));
        transition: all 0.15s;
        user-select: none;
      }

      .settings-nav-item:hover {
        background: hsl(var(--accent) / 0.5);
      }

      .settings-nav-item.active {
        background: hsl(var(--primary));
        color: hsl(var(--primary-foreground));
        font-weight: 500;
      }

      .settings-nav-item svg {
        width: 18px;
        height: 18px;
        flex-shrink: 0;
      }

      .settings-content {
        flex: 1;
        padding: 32px;
        overflow-y: auto;
        overflow-x: hidden;
        scrollbar-width: auto;
        scrollbar-color: auto;
        -webkit-overflow-scrolling: touch;
      }
      
      /* Ensure all interactive elements in settings are clickable */
      .settings-content button,
      .settings-content select,
      .settings-content input,
      .settings-content .toggle-switch,
      .settings-content .wallpaper-upload-btn,
      .settings-content .wallpaper-reset-btn,
      .settings-content .wallpaper-thumbnail {
        cursor: pointer;
        position: relative;
        z-index: 5;
      }

      .settings-content::-webkit-scrollbar {
        width: 15px;
      }

      .settings-content::-webkit-scrollbar-track {
        background: transparent;
      }

      .settings-content::-webkit-scrollbar-thumb {
        background: rgba(128, 128, 128, 0.5);
        border-radius: 10px;
        border: 3px solid transparent;
        background-clip: padding-box;
      }

      .settings-content::-webkit-scrollbar-thumb:hover {
        background: rgba(128, 128, 128, 0.7);
        background-clip: padding-box;
      }

      .settings-section {
        margin-bottom: 32px;
        padding-bottom: 24px;
        border-bottom: 1px solid hsl(var(--window-border));
        transition: border-color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .settings-section:last-child {
        border-bottom: none;
      }

      .settings-title {
        font-size: 18px;
        font-weight: 600;
        margin-bottom: 16px;
        color: hsl(var(--foreground));
        transition: color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .settings-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 0;
        position: relative;
      }

      .settings-label {
        font-size: 14px;
        color: hsl(var(--foreground));
        transition: color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .settings-description {
        font-size: 12px;
        color: hsl(var(--muted-foreground));
        margin-top: 4px;
        transition: color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }
      
      /* Toast position selector buttons */
      .toast-pos-btn {
        padding: 12px 16px;
        background: hsl(var(--accent));
        color: hsl(var(--foreground));
        border: none;
        border-radius: 8px;
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      
      .toast-pos-btn:hover:not(.active) {
        background: hsl(var(--accent-hover));
      }
      
      .toast-pos-btn.active {
        background: hsl(var(--primary));
        color: hsl(var(--primary-foreground));
      }
      
      /* Ensure toggle switches and buttons are always clickable */
      .toggle-switch {
        position: relative;
        z-index: 10;
        flex-shrink: 0;
      }
      
      .settings-item button,
      .settings-item select,
      .settings-item input {
        position: relative;
        z-index: 10;
      }

      .toggle-switch {
        position: relative;
        width: 44px;
        height: 24px;
        background: hsl(var(--accent));
        border-radius: 12px;
        cursor: pointer;
        transition: background 0.25s cubic-bezier(0.34, 1.56, 0.64, 1),
                    box-shadow 0.25s cubic-bezier(0.34, 1.56, 0.64, 1),
                    transform 0.15s ease;
        will-change: background, box-shadow, transform;
        transform: translateZ(0);
        -webkit-transform: translateZ(0);
        flex-shrink: 0;
        z-index: 10;
      }

      .toggle-switch:hover {
        box-shadow: 0 0 0 3px hsl(var(--primary) / 0.15);
      }

      .toggle-switch:active {
        transform: scale(0.95);
      }

      .toggle-switch:active .toggle-switch-thumb {
        transform: translateX(0) scale(1.1);
      }

      .toggle-switch.active:active .toggle-switch-thumb {
        transform: translateX(20px) scale(1.1);
      }

      .toggle-switch.active {
        background: hsl(var(--primary));
        box-shadow: 0 0 12px hsl(var(--primary) / 0.4);
      }
      
      /* Toggle success animation */
      .toggle-switch.just-toggled {
        animation: toggle-pulse 0.4s ease-out;
      }
      
      @keyframes toggle-pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.08); }
        100% { transform: scale(1); }
      }

      .toggle-switch-thumb {
        position: absolute;
        top: 2px;
        left: 2px;
        width: 20px;
        height: 20px;
        background: white;
        border-radius: 10px;
        transition: transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1),
                    box-shadow 0.25s cubic-bezier(0.34, 1.56, 0.64, 1),
                    background 0.2s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        will-change: transform;
        transform: translateZ(0);
        -webkit-transform: translateZ(0);
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
        pointer-events: none;
      }
      
      :root:not(.dark) .toggle-switch.active .toggle-switch-thumb {
        background: var(--toggle-thumb-color, white);
      }
      
      .dark .toggle-switch-thumb {
        background: hsl(var(--foreground));
      }
      
      .dark .toggle-switch.active .toggle-switch-thumb {
        background: var(--toggle-thumb-color, hsl(0 0% 10%));
      }

      .toggle-switch.active .toggle-switch-thumb {
        transform: translateX(20px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25);
      }
      
      /* Settings Toast Notifications */
      .settings-toast-container {
        position: fixed;
        bottom: 100px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10000;
        display: flex;
        flex-direction: column;
        gap: 8px;
        pointer-events: none;
      }
      
      .settings-toast {
        background: hsl(var(--window-bg));
        border: 1px solid hsl(var(--window-border));
        border-radius: 12px;
        padding: 12px 20px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 13px;
        color: hsl(var(--foreground));
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        animation: toast-in 0.3s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        pointer-events: auto;
      }
      
      .settings-toast.toast-out {
        animation: toast-out 0.25s ease-in forwards;
      }
      
      .settings-toast-icon {
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        flex-shrink: 0;
      }
      
      .settings-toast-icon.success {
        background: hsl(var(--primary));
        color: hsl(var(--primary-foreground));
      }
      
      .settings-toast-icon.info {
        background: hsl(220 80% 50%);
        color: white;
      }
      
      .settings-toast-icon svg {
        width: 12px;
        height: 12px;
      }
      
      @keyframes toast-in {
        0% {
          opacity: 0;
          transform: translateY(20px) scale(0.9);
        }
        100% {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
      }
      
      @keyframes toast-out {
        0% {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
        100% {
          opacity: 0;
          transform: translateY(-10px) scale(0.9);
        }
      }
      
      /* Notification Toast - Enhanced System-wide notifications */
      .notification-toast-container {
        position: fixed;
        z-index: 100000;
        display: flex;
        flex-direction: column;
        gap: 10px;
        pointer-events: none;
        padding: 12px;
        perspective: 1000px;
      }
      
      .notification-toast-container.top-center {
        top: 40px;
        left: 50%;
        transform: translateX(-50%);
        align-items: center;
      }
      
      .notification-toast-container.top-left {
        top: 40px;
        left: 12px;
        align-items: flex-start;
      }
      
      .notification-toast-container.top-right {
        top: 40px;
        right: 12px;
        align-items: flex-end;
      }
      
      .notification-toast-container.bottom-center {
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%);
        align-items: center;
      }
      
      .notification-toast-container.bottom-left {
        bottom: 80px;
        left: 12px;
        align-items: flex-start;
      }
      
      .notification-toast-container.bottom-right {
        bottom: 80px;
        right: 12px;
        align-items: flex-end;
      }
      
      .notification-toast {
        background: hsl(var(--window-bg) / 0.92);
        border: 1px solid hsl(var(--window-border) / 0.6);
        border-radius: 16px;
        padding: 14px 18px;
        box-shadow: 
          0 20px 40px -10px rgba(0, 0, 0, 0.35),
          0 8px 16px -6px rgba(0, 0, 0, 0.2),
          0 0 0 1px hsl(var(--window-border) / 0.2),
          inset 0 1px 0 0 hsl(0 0% 100% / 0.06);
        display: flex;
        align-items: flex-start;
        gap: 12px;
        font-size: 13px;
        color: hsl(var(--foreground));
        backdrop-filter: blur(40px) saturate(180%);
        -webkit-backdrop-filter: blur(40px) saturate(180%);
        animation: notification-toast-in 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        pointer-events: auto;
        max-width: 380px;
        min-width: 280px;
        cursor: pointer;
        transition: 
          transform 0.25s cubic-bezier(0.34, 1.56, 0.64, 1),
          box-shadow 0.25s ease,
          background 0.2s ease;
        transform-style: preserve-3d;
        will-change: transform, opacity;
      }
      
      .notification-toast:hover {
        transform: scale(1.03) translateY(-2px);
        box-shadow: 
          0 28px 50px -12px rgba(0, 0, 0, 0.4),
          0 12px 24px -8px rgba(0, 0, 0, 0.25),
          0 0 0 1px hsl(var(--window-border) / 0.4),
          inset 0 1px 0 0 hsl(0 0% 100% / 0.08);
      }
      
      .notification-toast:active {
        transform: scale(0.98);
        transition-duration: 0.1s;
      }
      
      .notification-toast.toast-out {
        animation: notification-toast-out 0.35s cubic-bezier(0.4, 0, 1, 1) forwards;
      }
      
      .notification-toast-icon {
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 12px;
        flex-shrink: 0;
        background: linear-gradient(135deg, hsl(var(--primary) / 0.2), hsl(var(--primary) / 0.08));
        box-shadow: 0 2px 8px hsl(var(--primary) / 0.15);
        animation: notif-icon-pulse 2s ease-in-out infinite;
      }
      
      @keyframes notif-icon-pulse {
        0%, 100% { box-shadow: 0 2px 8px hsl(var(--primary) / 0.15); }
        50% { box-shadow: 0 4px 16px hsl(var(--primary) / 0.25); }
      }
      
      .notification-toast-icon svg {
        width: 20px;
        height: 20px;
        color: hsl(var(--primary));
        animation: notif-icon-bounce 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) 0.2s both;
      }
      
      @keyframes notif-icon-bounce {
        0% { transform: scale(0) rotate(-45deg); }
        60% { transform: scale(1.2) rotate(10deg); }
        100% { transform: scale(1) rotate(0deg); }
      }
      
      .notification-toast-icon img {
        width: 100%;
        height: 100%;
        border-radius: 12px;
        object-fit: cover;
      }
      
      .notification-toast-content {
        flex: 1;
        min-width: 0;
        animation: notif-content-slide 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) 0.1s both;
      }
      
      @keyframes notif-content-slide {
        0% { opacity: 0; transform: translateX(-8px); }
        100% { opacity: 1; transform: translateX(0); }
      }
      
      .notification-toast-app {
        font-size: 11px;
        color: hsl(var(--muted-foreground));
        margin-bottom: 3px;
        text-transform: uppercase;
        letter-spacing: 0.04em;
        font-weight: 600;
      }
      
      .notification-toast-title {
        font-size: 14px;
        font-weight: 600;
        color: hsl(var(--foreground));
        margin-bottom: 4px;
        line-height: 1.3;
      }
      
      .notification-toast-message {
        font-size: 13px;
        color: hsl(var(--muted-foreground));
        line-height: 1.45;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }
      
      .notification-toast-close {
        width: 26px;
        height: 26px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 8px;
        background: transparent;
        border: none;
        color: hsl(var(--muted-foreground));
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
        flex-shrink: 0;
        margin-top: -2px;
        margin-right: -4px;
        opacity: 0;
        transform: scale(0.8);
      }
      
      .notification-toast:hover .notification-toast-close {
        opacity: 1;
        transform: scale(1);
      }
      
      .notification-toast-close:hover {
        background: hsl(var(--accent));
        color: hsl(var(--foreground));
        transform: scale(1.1);
      }
      
      .notification-toast-close:active {
        transform: scale(0.9);
      }
      
      .notification-toast-close svg {
        width: 14px;
        height: 14px;
      }
      
      /* Enhanced notification entrance animation with bounce */
      @keyframes notification-toast-in {
        0% {
          opacity: 0;
          transform: translateY(-30px) scale(0.85) rotateX(15deg);
          filter: blur(4px);
        }
        50% {
          opacity: 1;
          transform: translateY(6px) scale(1.02) rotateX(-2deg);
          filter: blur(0);
        }
        70% {
          transform: translateY(-3px) scale(0.99) rotateX(1deg);
        }
        100% {
          opacity: 1;
          transform: translateY(0) scale(1) rotateX(0deg);
          filter: blur(0);
        }
      }
      
      /* Smooth exit animation */
      @keyframes notification-toast-out {
        0% {
          opacity: 1;
          transform: translateY(0) scale(1) rotateX(0deg);
          filter: blur(0);
        }
        100% {
          opacity: 0;
          transform: translateY(-25px) scale(0.9) rotateX(10deg);
          filter: blur(3px);
        }
      }
      
      /* Stacked notifications effect */
      .notification-toast:nth-child(2) {
        transform: scale(0.96) translateY(-4px);
        opacity: 0.85;
      }
      
      .notification-toast:nth-child(3) {
        transform: scale(0.92) translateY(-8px);
        opacity: 0.7;
      }
      
      .notification-toast:nth-child(n+4) {
        display: none;
      }
      
      /* Progress bar for auto-dismiss */
      .notification-toast::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 16px;
        right: 16px;
        height: 3px;
        background: hsl(var(--primary) / 0.3);
        border-radius: 2px;
        transform-origin: left;
        animation: notif-progress 4s linear forwards;
      }
      
      @keyframes notif-progress {
        from { transform: scaleX(1); }
        to { transform: scaleX(0); }
      }
      
      .notification-toast:hover::after {
        animation-play-state: paused;
      }

      .wallpaper-upload-btn {
        padding: 8px 16px;
        background: hsl(var(--primary));
        color: hsl(var(--primary-foreground));
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        z-index: 10;
      }

      .wallpaper-upload-btn:hover {
        transform: scale(1.05);
        box-shadow: 0 4px 12px hsl(var(--primary) / 0.3);
      }

      .wallpaper-upload-btn:active {
        transform: scale(0.98);
      }
      
      /* Ensure all buttons in settings are clickable */
      .settings-section button,
      .settings-content button {
        position: relative;
        z-index: 10;
        cursor: pointer;
      }
      
      /* Fix select elements */
      .settings-section select,
      .settings-content select {
        position: relative;
        z-index: 10;
        cursor: pointer;
      }
      
      /* Fix input elements */
      .settings-section input,
      .settings-content input {
        position: relative;
        z-index: 10;
      }
      
      /* Range slider specific fixes */
      .settings-section input[type="range"],
      .settings-content input[type="range"] {
        -webkit-appearance: none;
        appearance: none;
        cursor: pointer;
        z-index: 15;
      }
      
      .settings-section input[type="range"]::-webkit-slider-thumb,
      .settings-content input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: white;
        cursor: pointer;
        border: 2px solid hsl(var(--primary));
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      }
      
      /* Clickable elements in settings */
      .settings-content [onclick],
      .settings-section [onclick] {
        cursor: pointer;
      }

      .wallpaper-preview {
        margin-top: 12px;
        width: 100%;
        height: 120px;
        border-radius: 8px;
        background-size: cover;
        background-position: center;
        border: 1px solid hsl(var(--window-border));
        transition: border-color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .wallpaper-actions {
        display: flex;
        gap: 8px;
        margin-top: 12px;
      }

      .wallpaper-reset-btn {
        padding: 6px 12px;
        background: hsl(var(--accent));
        color: hsl(var(--foreground));
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 13px;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .wallpaper-reset-btn:hover {
        background: hsl(var(--accent) / 0.8);
      }
      
      .wallpaper-reset-btn.destructive {
        background: hsl(var(--destructive));
        color: hsl(var(--destructive-foreground));
      }
      
      .wallpaper-reset-btn.destructive:hover {
        background: hsl(0 72% 50%);
        transform: scale(1.02);
        box-shadow: 0 4px 12px hsl(var(--destructive) / 0.4);
      }
      
      .wallpaper-reset-btn.destructive:active {
        transform: scale(0.98);
      }

      /* macOS-style slider thumb */
      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: white;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(0, 0, 0, 0.1);
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease;
      }
      input[type="range"]::-webkit-slider-thumb:hover {
        transform: scale(1.1);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.35), 0 0 0 1px rgba(0, 0, 0, 0.15);
      }
      input[type="range"]::-webkit-slider-thumb:active {
        transform: scale(1.05);
      }
      input[type="range"]::-moz-range-thumb {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: white;
        border: none;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(0, 0, 0, 0.1);
        cursor: pointer;
      }

      .wallpaper-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
        gap: 16px;
        margin-top: 16px;
      }

      .wallpaper-option {
        position: relative;
        width: 100%;
        aspect-ratio: 16 / 9;
        border-radius: 8px;
        background-size: cover;
        background-position: center;
        border: 2px solid hsl(var(--window-border));
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        overflow: hidden;
      }

      .wallpaper-option:hover {
        border-color: hsl(var(--primary));
        transform: scale(1.05);
        box-shadow: 0 8px 24px hsl(var(--primary) / 0.2);
      }

      .wallpaper-option:active {
        transform: scale(0.98);
      }

      .wallpaper-option.active {
        border-color: hsl(var(--primary));
        box-shadow: 0 0 0 3px hsl(var(--primary) / 0.3);
      }

      .wallpaper-option-label {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        background: linear-gradient(to top, rgba(0,0,0,0.7), transparent);
        color: white;
        padding: 8px 12px;
        font-size: 12px;
        font-weight: 500;
      }

      /* M OS Menubar - 28px height with smaller buttons */
      .menubar {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        height: 28px;
        background: hsl(var(--menubar-bg) / 0.85);
        backdrop-filter: blur(20px) saturate(150%);
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 12px;
        z-index: 20000;
        font-size: 12px;
        font-weight: 500;
        user-select: none;
        border-bottom: 1px solid hsl(var(--window-border) / 0.5);
      }
      
      .dark .menubar {
        background: hsl(var(--menubar-bg) / 0.9);
        border-bottom: 1px solid hsl(var(--window-border) / 0.3);
      }
      
      .menubar-center {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        font-size: 12px;
        font-weight: 600;
        color: hsl(var(--foreground));
        letter-spacing: 0.02em;
      }

      .menubar-left,
      .menubar-right {
        display: flex;
        align-items: center;
        gap: 2px;
      }

      .menubar button {
        background: none;
        border: none;
        color: hsl(var(--foreground));
        cursor: pointer;
        padding: 2px 8px;
        border-radius: 4px;
        transition: all 0.15s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 500;
        font-family: 'Space Grotesk', sans-serif;
        font-size: 12px;
        height: 22px;
        line-height: 1;
      }

      .menubar button:hover {
        background: hsl(var(--accent));
      }
      
      .menubar button:active {
        background: hsl(var(--accent-hover));
        transform: scale(0.98);
      }
      
      /* M OS Control Center - Enhanced Animations */
      .quick-settings {
        position: fixed;
        top: 34px;
        left: var(--qs-left, auto);
        right: var(--qs-right, 12px);
        width: 320px;
        background: hsl(var(--quick-settings-bg) / 0.92);
        backdrop-filter: blur(40px) saturate(180%);
        -webkit-backdrop-filter: blur(40px) saturate(180%);
        border-radius: 18px;
        padding: 16px;
        z-index: 10001;
        box-shadow: 
          0 25px 50px -12px hsl(var(--shadow-color) / 0.4),
          0 12px 24px -8px hsl(var(--shadow-color) / 0.3),
          0 0 0 1px hsl(var(--window-border) / 0.4),
          inset 0 1px 0 0 hsl(0 0% 100% / 0.05);
        opacity: 0;
        transform: scale(0.5);
        transform-origin: var(--qs-origin-x, calc(100% - 60px)) top;
        pointer-events: none;
        transition: 
          opacity 0.35s cubic-bezier(0.34, 1.56, 0.64, 1),
          transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1),
          backdrop-filter 0.3s ease;
        will-change: transform, opacity;
      }
      
      .dark .quick-settings {
        box-shadow: 
          0 25px 50px -12px rgba(0,0,0,0.7),
          0 12px 24px -8px rgba(0,0,0,0.5),
          0 0 0 1px hsl(var(--window-border) / 0.3),
          inset 0 1px 0 0 hsl(0 0% 100% / 0.03);
      }
      
      .quick-settings.active {
        opacity: 1;
        transform: scale(1);
        pointer-events: auto;
        animation: qsPanelOpen 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      }
      
      @keyframes qsPanelOpen {
        0% { 
          transform: scale(0.4); 
          opacity: 0;
          border-radius: 24px;
        }
        50% { 
          transform: scale(1.03);
          border-radius: 16px;
        }
        70% { 
          transform: scale(0.98);
        }
        100% { 
          transform: scale(1); 
          opacity: 1;
          border-radius: 18px;
        }
      }
      
      .quick-settings.closing {
        opacity: 0;
        transform: scale(0.6);
        pointer-events: none;
        transition: 
          opacity 0.2s cubic-bezier(0.4, 0, 1, 1),
          transform 0.2s cubic-bezier(0.4, 0, 1, 1);
      }
      
      /* Enhanced staggered animation for quick settings items */
      .quick-settings.active:not(.skip-animation) .quick-settings-volume {
        animation: qsItemSlideUp 0.45s cubic-bezier(0.34, 1.56, 0.64, 1) 0.06s both;
      }
      
      .quick-settings.active:not(.skip-animation) .quick-settings-icons {
        animation: qsIconGridReveal 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) 0.12s both;
      }
      
      .quick-settings.active:not(.skip-animation) .quick-settings-icons .quick-settings-icon-btn {
        animation: qsIconPop 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) both;
      }
      
      .quick-settings.active:not(.skip-animation) .quick-settings-icons .quick-settings-icon-btn:nth-child(1) { animation-delay: 0.14s; }
      .quick-settings.active:not(.skip-animation) .quick-settings-icons .quick-settings-icon-btn:nth-child(2) { animation-delay: 0.18s; }
      .quick-settings.active:not(.skip-animation) .quick-settings-icons .quick-settings-icon-btn:nth-child(3) { animation-delay: 0.22s; }
      .quick-settings.active:not(.skip-animation) .quick-settings-icons .quick-settings-icon-btn:nth-child(4) { animation-delay: 0.26s; }
      .quick-settings.active:not(.skip-animation) .quick-settings-icons .quick-settings-icon-btn:nth-child(5) { animation-delay: 0.30s; }
      .quick-settings.active:not(.skip-animation) .quick-settings-icons .quick-settings-icon-btn:nth-child(6) { animation-delay: 0.34s; }
      
      .quick-settings.active:not(.skip-animation) .quick-settings-option {
        animation: qsItemSlideUp 0.45s cubic-bezier(0.34, 1.56, 0.64, 1) 0.25s both;
      }
      
      .quick-settings.active:not(.skip-animation) .quick-settings-option:nth-child(2) { animation-delay: 0.30s; }
      .quick-settings.active:not(.skip-animation) .quick-settings-option:nth-child(3) { animation-delay: 0.35s; }
      
      /* When skip-animation is set, items should be visible immediately without animation */
      .quick-settings.active.skip-animation .quick-settings-volume,
      .quick-settings.active.skip-animation .quick-settings-icons,
      .quick-settings.active.skip-animation .quick-settings-icons .quick-settings-icon-btn,
      .quick-settings.active.skip-animation .quick-settings-option {
        opacity: 1;
        transform: translateY(0) scale(1);
        animation: none;
      }
      
      @keyframes qsItemSlideUp {
        0% {
          opacity: 0;
          transform: translateY(16px) scale(0.95);
          filter: blur(4px);
        }
        100% {
          opacity: 1;
          transform: translateY(0) scale(1);
          filter: blur(0);
        }
      }
      
      @keyframes qsIconGridReveal {
        0% {
          opacity: 0;
          transform: translateY(12px);
        }
        100% {
          opacity: 1;
          transform: translateY(0);
        }
      }
      
      @keyframes qsIconPop {
        0% {
          opacity: 0;
          transform: scale(0.5) translateY(8px);
        }
        60% {
          transform: scale(1.08) translateY(-2px);
        }
        100% {
          opacity: 1;
          transform: scale(1) translateY(0);
        }
      }
      
      /* Legacy animation fallback */
      @keyframes qsItemIn {
        from {
          opacity: 0;
          transform: translateY(-8px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      
      .quick-settings-volume {
        display: flex;
        align-items: center;
        gap: 14px;
        padding: 14px 16px;
        background: hsl(var(--quick-settings-item-bg));
        border-radius: 12px;
        margin-bottom: 14px;
        transition: 
          background-color 0.3s ease,
          transform 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
      }
      
      .quick-settings-volume:hover {
        background: hsl(var(--quick-settings-item-bg) / 0.8);
      }
      
      .quick-settings-volume svg {
        width: 22px;
        height: 22px;
        color: hsl(var(--foreground));
        flex-shrink: 0;
        transition: 
          color 0.3s ease,
          transform 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
      }
      
      .quick-settings-volume:hover svg {
        transform: scale(1.1);
      }
      
      .volume-slider {
        flex: 1;
        height: 6px;
        background: hsl(var(--slider-track));
        border-radius: 3px;
        position: relative;
        cursor: pointer;
        transition: 
          background-color 0.3s ease,
          height 0.2s ease;
        overflow: visible;
      }
      
      .volume-slider:hover {
        height: 8px;
      }
      
      .volume-slider-fill {
        position: absolute;
        left: 0;
        top: 0;
        height: 100%;
        background: hsl(var(--slider-fill));
        border-radius: 3px;
        width: 60%;
        transition: width 0.15s ease;
        box-shadow: 0 0 8px hsl(var(--slider-fill) / 0.3);
      }
      
      .volume-slider-thumb {
        position: absolute;
        right: 0;
        top: 50%;
        transform: translate(50%, -50%) scale(1);
        width: 16px;
        height: 16px;
        background: hsl(var(--foreground));
        border-radius: 50%;
        box-shadow: 
          0 2px 6px rgba(0,0,0,0.25),
          0 0 0 2px hsl(var(--foreground) / 0.15);
        transition: 
          transform 0.25s cubic-bezier(0.34, 1.56, 0.64, 1),
          box-shadow 0.25s ease;
        pointer-events: none;
      }
      
      .volume-slider:hover .volume-slider-thumb {
        transform: translate(50%, -50%) scale(1.15);
        box-shadow: 
          0 4px 12px rgba(0,0,0,0.35),
          0 0 0 3px hsl(var(--foreground) / 0.2);
      }
      
      .volume-slider:active .volume-slider-thumb {
        transform: translate(50%, -50%) scale(1.05);
      }
      
      /* Icon Grid for Control Center - Enhanced */
      .quick-settings-icons {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
        margin-bottom: 14px;
      }
      
      .quick-settings-icon-btn {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 8px;
        padding: 18px 10px;
        background: hsl(var(--quick-settings-item-bg));
        border-radius: 14px;
        cursor: pointer;
        transition: 
          all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1),
          box-shadow 0.25s ease;
        border: none;
        color: hsl(var(--foreground));
        position: relative;
        overflow: hidden;
      }
      
      /* Subtle gradient overlay on hover */
      .quick-settings-icon-btn::before {
        content: '';
        position: absolute;
        inset: 0;
        background: linear-gradient(135deg, hsl(0 0% 100% / 0.08), transparent 60%);
        opacity: 0;
        transition: opacity 0.25s ease;
        pointer-events: none;
      }
      
      .quick-settings-icon-btn:hover::before {
        opacity: 1;
      }
      
      .quick-settings-icon-btn:hover {
        background: hsl(var(--accent));
        transform: translateY(-3px) scale(1.04);
        box-shadow: 0 8px 20px -6px hsl(var(--shadow-color) / 0.3);
      }
      
      .quick-settings-icon-btn:active {
        transform: translateY(0) scale(0.96);
        transition-duration: 0.1s;
      }
      
      .quick-settings-icon-btn.active {
        background: hsl(var(--primary));
        color: hsl(var(--primary-foreground)) !important;
        box-shadow: 0 6px 20px -4px hsl(var(--primary) / 0.4);
      }
      
      .quick-settings-icon-btn.active svg {
        animation: qsIconActivePulse 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
      }
      
      @keyframes qsIconActivePulse {
        0% { transform: scale(0.8); }
        50% { transform: scale(1.15); }
        100% { transform: scale(1); }
      }
      
      .quick-settings-icon-btn.active svg,
      .quick-settings-icon-btn.active span {
        color: hsl(var(--primary-foreground)) !important;
      }
      
      .quick-settings-icon-btn.active:hover {
        background: hsl(var(--primary) / 0.85);
        transform: translateY(-2px) scale(1.02);
      }
      
      .quick-settings-icon-btn.destructive {
        background: hsl(var(--destructive));
        color: hsl(var(--destructive-foreground));
      }
      
      .quick-settings-icon-btn.destructive:hover {
        background: hsl(0 72% 45%);
        transform: translateY(-3px) scale(1.04);
        box-shadow: 0 8px 20px -6px hsl(var(--destructive) / 0.4);
      }
      
      .quick-settings-icon-btn svg {
        width: 24px;
        height: 24px;
        transition: 
          color 0.3s ease,
          transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      }
      
      .quick-settings-icon-btn:hover svg {
        transform: scale(1.08);
      }
      
      .quick-settings-icon-btn span {
        font-size: 11px;
        font-weight: 500;
        text-align: center;
        line-height: 1.2;
      }
      
      .quick-settings-toggle {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 14px 16px;
        background: hsl(var(--ubuntu-orange));
        border-radius: 8px;
        margin-bottom: 8px;
        cursor: pointer;
        transition: all 0.2s;
      }
      
      .quick-settings-toggle:hover {
        transform: scale(1.02);
      }
      
      .quick-settings-toggle:active {
        transform: scale(0.98);
      }
      
      .quick-settings-toggle-label {
        display: flex;
        align-items: center;
        gap: 10px;
        color: white;
        font-weight: 500;
        font-size: 14px;
      }
      
      .quick-settings-toggle-label svg {
        width: 20px;
        height: 20px;
      }
      
      .quick-settings-option {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px;
        background: hsl(var(--quick-settings-item-bg));
        border-radius: 8px;
        margin-bottom: 8px;
        transition: background-color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }
      
      .quick-settings-option-label {
        color: hsl(var(--foreground));
        font-size: 13px;
        transition: color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }
      
      .quick-settings-option-value {
        color: hsl(var(--muted-foreground));
        font-size: 12px;
        transition: color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }
      
      /* Notification Panel - Enhanced with premium animations */
      .notification-panel {
        position: fixed;
        top: 34px;
        left: var(--notif-left, auto);
        right: var(--notif-right, 12px);
        width: 380px;
        max-height: calc(100vh - 100px);
        background: hsl(var(--quick-settings-bg) / 0.92);
        backdrop-filter: blur(40px) saturate(180%);
        -webkit-backdrop-filter: blur(40px) saturate(180%);
        border-radius: 20px;
        z-index: 10001;
        box-shadow: 
          0 25px 60px -15px hsl(var(--shadow-color) / 0.4),
          0 12px 30px -10px hsl(var(--shadow-color) / 0.3),
          0 0 0 1px hsl(var(--window-border) / 0.4),
          inset 0 1px 0 0 hsl(0 0% 100% / 0.05);
        opacity: 0;
        transform: scale(0.5);
        transform-origin: var(--notif-origin-x, calc(100% - 120px)) top;
        pointer-events: none;
        transition: 
          opacity 0.35s cubic-bezier(0.34, 1.56, 0.64, 1),
          transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
        display: flex;
        flex-direction: column;
        overflow: hidden;
        will-change: transform, opacity;
      }
      
      .dark .notification-panel {
        box-shadow: 
          0 25px 60px -15px rgba(0,0,0,0.6),
          0 12px 30px -10px rgba(0,0,0,0.4),
          0 0 0 1px hsl(var(--window-border) / 0.3),
          inset 0 1px 0 0 hsl(0 0% 100% / 0.03);
      }
      
      .notification-panel.active {
        opacity: 1;
        transform: scale(1);
        pointer-events: auto;
        animation: notifPanelOpen 0.45s cubic-bezier(0.34, 1.56, 0.64, 1);
      }
      
      @keyframes notifPanelOpen {
        0% { 
          transform: scale(0.4);
          opacity: 0;
          border-radius: 28px;
        }
        50% { 
          transform: scale(1.02);
          border-radius: 18px;
        }
        70% { 
          transform: scale(0.98);
        }
        100% { 
          transform: scale(1);
          opacity: 1;
          border-radius: 20px;
        }
      }
      
      .notification-panel.closing {
        opacity: 0;
        transform: translateY(-16px) scale(0.96) rotateX(4deg);
        pointer-events: none;
        transition: 
          opacity 0.25s cubic-bezier(0.4, 0, 1, 1),
          transform 0.25s cubic-bezier(0.4, 0, 1, 1);
      }
      
      /* Clock Section - Top of Panel */
      .notification-clock-section {
        padding: 24px 20px;
        background: linear-gradient(180deg, hsl(var(--quick-settings-item-bg) / 0.4), transparent);
        position: relative;
        overflow: hidden;
      }
      
      /* Subtle glow behind clock */
      .notification-clock-section::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 150px;
        height: 150px;
        background: radial-gradient(circle, hsl(var(--primary) / 0.08), transparent 70%);
        transform: translate(-50%, -50%);
        pointer-events: none;
      }
      
      /* Enhanced animations with scale and blur */
      .notification-panel.active:not(.skip-animation) .notification-clock-section {
        animation: notifClockReveal 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) 0.08s both;
      }
      
      @keyframes notifClockReveal {
        0% {
          opacity: 0;
          transform: translateY(-12px) scale(0.95);
          filter: blur(4px);
        }
        100% {
          opacity: 1;
          transform: translateY(0) scale(1);
          filter: blur(0);
        }
      }
      
      .notification-clock-main {
        text-align: center;
        position: relative;
      }
      
      .notification-clock-time {
        font-size: 56px;
        font-weight: 200;
        color: hsl(var(--foreground));
        line-height: 1;
        font-variant-numeric: tabular-nums;
        letter-spacing: -2px;
        text-shadow: 0 2px 20px hsl(var(--foreground) / 0.1);
      }
      
      .notification-clock-date {
        font-size: 14px;
        color: hsl(var(--muted-foreground));
        margin-top: 8px;
        font-weight: 500;
        letter-spacing: 0.02em;
      }
      
      /* Legacy animation kept for compatibility */
      @keyframes notifSectionIn {
        from {
          opacity: 0;
          transform: translateY(-8px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      
      /* Calendar Section */
      .notification-calendar-section {
        padding: 12px 16px 16px;
        background: hsl(var(--quick-settings-item-bg) / 0.5);
        border-top: 1px solid hsl(var(--window-border) / 0.3);
      }
      
      .notification-panel.active:not(.skip-animation) .notification-calendar-section {
        animation: notifSectionIn 0.35s cubic-bezier(0.16, 1, 0.3, 1) 0.1s both;
      }
      
      .notification-calendar-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 12px;
      }
      
      .notification-calendar-month {
        font-size: 14px;
        font-weight: 500;
        color: hsl(var(--foreground));
      }
      
      .notification-calendar-nav {
        display: flex;
        gap: 4px;
      }
      
      .notification-calendar-nav button {
        padding: 6px;
        background: transparent;
        border: none;
        border-radius: 6px;
        color: hsl(var(--foreground));
        cursor: pointer;
        transition: all 0.15s ease;
      }
      
      .notification-calendar-nav button:hover {
        background: hsl(var(--accent));
        transform: scale(1.1);
      }
      
      .notification-calendar-nav button:active {
        transform: scale(0.95);
      }
      
      .notification-calendar-nav button svg {
        width: 14px;
        height: 14px;
      }
      
      .notification-calendar-weekdays {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
        gap: 2px;
        margin-bottom: 4px;
      }
      
      .notification-calendar-weekday {
        text-align: center;
        font-size: 11px;
        font-weight: 500;
        color: hsl(var(--muted-foreground));
        padding: 4px;
      }
      
      .notification-calendar-days {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
        gap: 2px;
      }
      
      .notification-calendar-day {
        aspect-ratio: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        color: hsl(var(--foreground));
        border-radius: 50%;
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
        position: relative;
      }
      
      .notification-calendar-day:hover {
        background: hsl(var(--accent));
        transform: scale(1.15);
      }
      
      .notification-calendar-day:active {
        transform: scale(0.95);
      }
      
      .notification-calendar-day.other-month {
        color: hsl(var(--muted-foreground) / 0.4);
      }
      
      .notification-calendar-day.today {
        background: hsl(var(--primary));
        color: hsl(var(--primary-foreground));
        font-weight: 600;
        box-shadow: 0 4px 12px hsl(var(--primary) / 0.5);
        animation: calendarTodayPulse 2s ease-in-out infinite;
      }
      
      @keyframes calendarTodayPulse {
        0%, 100% { box-shadow: 0 4px 12px hsl(var(--primary) / 0.5); }
        50% { box-shadow: 0 6px 20px hsl(var(--primary) / 0.7); }
      }
      
      .notification-calendar-day.today:hover {
        background: hsl(var(--primary) / 0.85);
        transform: scale(1.15);
      }
      
      /* Focus Timer Footer */
      .notification-footer {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 16px;
        border-top: 1px solid hsl(var(--window-border) / 0.3);
      }
      
      .notification-panel.active:not(.skip-animation) .notification-footer {
        animation: notifSectionIn 0.35s cubic-bezier(0.16, 1, 0.3, 1) 0.15s both;
      }
      
      /* When skip-animation is set, items should be visible immediately without animation */
      .notification-panel.active.skip-animation .notification-clock-section,
      .notification-panel.active.skip-animation .notification-calendar-section,
      .notification-panel.active.skip-animation .notification-footer {
        opacity: 1;
        transform: translateY(0);
      }
      
      .notification-footer-timer {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      
      .notification-footer-timer-btn {
        width: 28px;
        height: 28px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: hsl(var(--accent) / 0.5);
        border: none;
        border-radius: 6px;
        color: hsl(var(--foreground));
        cursor: pointer;
        transition: all 0.15s ease;
      }
      
      .notification-footer-timer-btn:hover {
        background: hsl(var(--accent));
        transform: scale(1.1);
      }
      
      .notification-footer-timer-btn:active {
        transform: scale(0.9);
      }
      
      .notification-footer-timer-btn svg {
        width: 14px;
        height: 14px;
      }
      
      .notification-footer-timer-value {
        font-size: 13px;
        font-weight: 500;
        color: hsl(var(--foreground));
        min-width: 50px;
        text-align: center;
        font-variant-numeric: tabular-nums;
      }
      
      .notification-footer-focus {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 14px;
        background: hsl(var(--primary));
        border: none;
        border-radius: 8px;
        color: hsl(var(--primary-foreground));
        font-size: 12px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
      }
      
      .notification-footer-focus:hover {
        background: hsl(var(--primary) / 0.85);
        transform: scale(1.03);
        box-shadow: 0 4px 12px hsl(var(--primary) / 0.3);
      }
      
      .notification-footer-focus:active {
        transform: scale(0.97);
      }
      
      .notification-footer-focus.active {
        background: #dc2626;
      }
      
      .notification-footer-focus.active:hover {
        background: #b91c1c;
        box-shadow: 0 4px 12px rgba(220, 38, 38, 0.3);
      }
      
      .notification-footer-focus svg {
        width: 14px;
        height: 14px;
      }
      
      /* Notifications Section */
      .notification-section {
        border-top: 1px solid hsl(var(--window-border) / 0.3);
        animation: notifSectionIn 0.35s cubic-bezier(0.16, 1, 0.3, 1) 0.2s both;
      }
      
      .notification-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 16px;
      }
      
      .notification-header-title {
        font-size: 13px;
        font-weight: 600;
        color: hsl(var(--foreground));
      }
      
      .notification-header-actions {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      
      .notification-header-btn {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 5px 10px;
        background: hsl(var(--accent) / 0.5);
        border: none;
        border-radius: 6px;
        color: hsl(var(--foreground));
        font-size: 11px;
        cursor: pointer;
        transition: all 0.15s ease;
      }
      
      .notification-header-btn:hover {
        background: hsl(var(--accent));
        transform: scale(1.02);
      }
      
      .notification-header-btn:active {
        transform: scale(0.98);
      }
      
      .notification-header-btn svg {
        width: 12px;
        height: 12px;
      }
      
      .notification-list {
        overflow-y: auto;
        padding: 0 12px 12px;
        max-height: 200px;
      }
      
      .notification-list::-webkit-scrollbar {
        width: 5px;
      }
      
      .notification-list::-webkit-scrollbar-track {
        background: transparent;
      }
      
      .notification-list::-webkit-scrollbar-thumb {
        background: hsl(var(--muted-foreground) / 0.3);
        border-radius: 3px;
      }
      
      .notification-item {
        display: flex;
        gap: 12px;
        padding: 12px;
        background: hsl(var(--quick-settings-item-bg));
        border-radius: 12px;
        margin-bottom: 8px;
        cursor: pointer;
        transition: all 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
        animation: notifItemSlideIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) both;
        position: relative;
        overflow: hidden;
      }
      
      .notification-item::before {
        content: '';
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        width: 3px;
        background: hsl(var(--primary));
        transform: scaleY(0);
        transition: transform 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
        border-radius: 0 2px 2px 0;
      }
      
      .notification-item:hover::before {
        transform: scaleY(1);
      }
      
      .notification-item:nth-child(1) { animation-delay: 0.05s; }
      .notification-item:nth-child(2) { animation-delay: 0.1s; }
      .notification-item:nth-child(3) { animation-delay: 0.15s; }
      .notification-item:nth-child(4) { animation-delay: 0.2s; }
      .notification-item:nth-child(5) { animation-delay: 0.25s; }
      
      .notification-item:last-child {
        margin-bottom: 0;
      }
      
      .notification-item:hover {
        background: hsl(var(--accent));
        transform: translateX(6px) scale(1.01);
        box-shadow: 0 4px 16px hsl(var(--shadow-color) / 0.15);
      }
      
      .notification-item:active {
        transform: translateX(4px) scale(0.98);
      }
      
      @keyframes notifItemSlideIn {
        0% {
          opacity: 0;
          transform: translateX(-20px) scale(0.95);
          filter: blur(2px);
        }
        60% {
          opacity: 1;
          transform: translateX(4px) scale(1.01);
        }
        100% {
          opacity: 1;
          transform: translateX(0) scale(1);
          filter: blur(0);
        }
      }
      
      /* Legacy animation kept for compatibility */
      @keyframes notifItemIn {
        from {
          opacity: 0;
          transform: translateX(-12px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }
      
      .notification-icon {
        width: 32px;
        height: 32px;
        border-radius: 8px;
        background: hsl(var(--primary) / 0.15);
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
      }
      
      .notification-icon svg {
        width: 16px;
        height: 16px;
        color: hsl(var(--primary));
      }
      
      .notification-icon img {
        width: 100%;
        height: 100%;
        border-radius: 8px;
        object-fit: cover;
      }
      
      .notification-content {
        flex: 1;
        min-width: 0;
      }
      
      .notification-app {
        font-size: 10px;
        color: hsl(var(--muted-foreground));
        margin-bottom: 2px;
        display: flex;
        align-items: center;
        gap: 6px;
      }
      
      .notification-time {
        font-size: 10px;
        color: hsl(var(--muted-foreground) / 0.7);
      }
      
      .notification-title {
        font-size: 12px;
        font-weight: 500;
        color: hsl(var(--foreground));
        margin-bottom: 2px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      
      .notification-body {
        font-size: 11px;
        color: hsl(var(--muted-foreground));
        line-height: 1.3;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }
      
      .notification-empty {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 30px 20px;
        color: hsl(var(--muted-foreground));
      }
      
      .notification-empty svg {
        width: 36px;
        height: 36px;
        margin-bottom: 10px;
        opacity: 0.4;
      }
      
      .notification-empty span {
        font-size: 13px;
      }
      

      .menubar button svg {
        width: 16px;
        height: 16px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        transition: color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .menubar-icon svg {
        width: 16px;
        height: 16px;
        transition: color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }
      
      .theme-toggle-icon {
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                    opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                    color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        will-change: transform, opacity;
      }
      
      .theme-toggle-icon:hover {
        transform: scale(1.15);
      }
      
      .theme-toggle-icon:active {
        transform: scale(0.9);
      }
      
      .theme-toggle-icon.transitioning {
        animation: themeIconRotate 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      }
      
      /* Quick Settings theme icon specific styles */
      .qs-theme-icon {
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .qs-theme-icon svg {
        width: 22px;
        height: 22px;
      }
      
      .qs-theme-icon.transitioning {
        animation: themeIconRotate 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      }
      
      @keyframes themeIconRotate {
        0% {
          transform: rotate(0deg) scale(1);
          opacity: 1;
        }
        50% {
          transform: rotate(180deg) scale(0.7);
          opacity: 0.3;
        }
        100% {
          transform: rotate(360deg) scale(1);
          opacity: 1;
        }
      }
      
      /* Theme switch pulse/glow animation - DISABLED */
      @keyframes themePulse {
        0%, 50%, 100% {
          box-shadow: none;
        }
      }
      
      .theme-pulse-active {
        animation: none;
      }
      
      /* Full screen glow overlay for theme switch - DISABLED */
      .theme-transition-overlay {
        display: none;
        pointer-events: none;
      }
      
      .theme-transition-overlay.active {
        animation: none;
        display: none;
      }
      
      @keyframes overlayPulse {
        0%, 40%, 100% {
          opacity: 0;
          background: none;
        }
      }

      .menubar,
      .titlebar,
      .dock,
      .dock-icon {
        user-select: none;
        -webkit-user-select: none;
      }

      .window-content {
        user-select: text;
        -webkit-user-select: text;
        overflow: auto;
        -webkit-overflow-scrolling: touch;
      }
      
      /* Ensure settings and other scrollable content work properly */
      .window-content .settings-container,
      .window-content .settings-content {
        position: relative;
      }

      .desktop,
      .menubar,
      .dock-container {
        -webkit-touch-callout: none;
        -webkit-tap-highlight-color: transparent;
      }

      .window.fullscreen {
        top: 0 !important;
        left: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        border-radius: 0 !important;
        z-index: 10001 !important;
      }
      
      .window.fullscreen .titlebar {
        display: none;
      }
      
      .window.fullscreen .window-content {
        padding: 0;
        height: 100%;
      }
      
      /* Ensure iframes in fullscreen can receive keyboard focus and events */
      .window.fullscreen iframe {
        width: 100%;
        height: 100%;
        border: none;
        outline: none;
      }
      
      .window.fullscreen .browser-container,
      .window.fullscreen .minecraft-container {
        height: 100%;
        display: flex;
        flex-direction: column;
      }
      
      .window.fullscreen .browser-container iframe,
      .window.fullscreen .minecraft-container iframe {
        flex: 1;
        min-height: 0;
      }
      
      /* Hide browser toolbar in fullscreen to give more space to the game/content */
      .window.fullscreen .browser-toolbar,
      .window.fullscreen .browser-tabs-container,
      .window.fullscreen .browser-bookmarks-bar {
        display: none;
      }
      
      /* Minecraft-specific optimizations for 3D/WebGL performance */
      .minecraft-container {
        position: relative;
        /* Removed contain: strict as it breaks WebGL context */
        /* Use content-visibility instead for performance */
        isolation: isolate;
        /* Ensure proper stacking for WebGL */
        z-index: 1;
      }
      
      .minecraft-container iframe {
        /* Disable CSS transitions on the iframe to prevent 3D render interruptions */
        transition: none !important;
        /* Force GPU acceleration without breaking WebGL */
        transform: translate3d(0, 0, 0);
        backface-visibility: hidden;
        /* Removed will-change: contents as it causes WebGL context issues */
        /* Allow the iframe to use hardware acceleration */
        -webkit-transform: translate3d(0, 0, 0);
      }
      
      /* Iframe click interceptor - prevents iframe from blocking OS UI interactions */
      .iframe-click-interceptor {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 10;
        background: transparent;
        display: none;
        cursor: default;
      }
      
      /* Show interceptor when window is inactive (not focused) */
      .window.inactive .iframe-click-interceptor {
        display: block;
      }
      
      /* Windows layer - contains all app windows with pointer-events isolated */
      .windows-layer {
        position: absolute;
        inset: 0;
        z-index: 100;
        pointer-events: none; /* Container doesn't capture events */
      }
      
      /* Individual windows get pointer-events back */
      .windows-layer .window {
        pointer-events: auto;
      }
      
      /* System UI layer - dock and menubar are ABOVE windows layer */
      .dock-container,
      .menubar {
        pointer-events: auto !important;
        position: fixed !important;
      }
      
      /* Ensure desktop shortcuts are always clickable */
      .desktop-shortcut {
        pointer-events: auto !important;
      }
      
      /* Exit fullscreen button overlay - always visible in fullscreen mode */
      .fullscreen-exit-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 40px;
        height: 40px;
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        color: white;
        cursor: pointer;
        z-index: 100000;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        transition: opacity 0.3s ease;
        pointer-events: auto;
      }
      
      .window.fullscreen:hover .fullscreen-exit-btn,
      .fullscreen-exit-btn:hover {
        opacity: 1;
      }
      
      .fullscreen-exit-btn:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: scale(1.05);
      }
      
      .fullscreen-exit-btn:active {
        transform: scale(0.95);
      }
      
      .fullscreen-exit-btn svg {
        width: 20px;
        height: 20px;
        stroke: currentColor;
        stroke-width: 2;
        fill: none;
      }
      
      /* Force the exit button to be above the iframe */
      .window.fullscreen .minecraft-container,
      .window.fullscreen .browser-container {
        position: relative;
      }

      .window.maximized {
        border-radius: 0 !important;
      }

      .window.maximizing, .window.restoring {
        will-change: transform, top, left, width, height, border-radius;
      }

      .dock-container {
        position: fixed;
        z-index: 19999;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }
      
      /* Default to LEFT for Ubuntu style */
      .dock-container.dock-left,
      .dock-container:not(.dock-bottom):not(.dock-right) {
        left: 8px;
        top: 50%;
        transform: translateY(-50%);
      }
      
      .dock-container.dock-bottom {
        bottom: 4px;
        left: 50%;
        transform: translateX(-50%);
        display: inline-flex;
        justify-content: center;
      }
      
      .dock-container.dock-right {
        right: 8px;
        top: 50%;
        transform: translateY(-50%);
      }

      /* M OS Dock */
      .dock {
        background: hsl(var(--dock-bg) / 0.55);
        backdrop-filter: blur(30px) saturate(180%);
        padding: 8px 12px;
        border-radius: 14px;
        box-shadow: 0 8px 32px hsl(var(--shadow-color) / 0.2), 0 0 0 1px hsl(var(--window-border) / 0.5);
        border: none;
        display: inline-flex;
        gap: 6px;
        transition: all 0.3s ease;
        position: relative;
        width: auto;
        height: 64px;
        align-items: center;
        overflow: visible;
      }
      
      .dark .dock {
        background: hsl(var(--dock-bg) / 0.6);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), 0 0 0 1px hsl(var(--window-border) / 0.3);
      }
      
      .dock-bottom .dock {
        flex-direction: row;
        align-items: center;
        padding: 6px 10px;
        width: auto;
        height: 60px;
        min-width: min-content;
        overflow: visible;
      }
      
      .dock-left .dock,
      .dock-container:not(.dock-bottom):not(.dock-right) .dock {
        flex-direction: column;
        align-items: center;
        padding: 6px 10px;
        height: auto;
        min-height: min-content;
      }
      
      .dock-right .dock {
        flex-direction: column;
        align-items: center;
        padding: 6px 10px;
        height: auto;
        min-height: min-content;
      }

      .dock-icon {
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: grab;
        transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275),
                    opacity 0.2s ease,
                    width 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275),
                    height 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        position: relative;
        will-change: transform;
        transform: translate3d(0, 0, 0);
        user-select: none;
        -webkit-user-select: none;
        -webkit-user-drag: none;
        flex-shrink: 0;
        margin: 0;
        transform-origin: center bottom;
      }
      
      /* Appearing animation for new dock icons - playful bounce */
      .dock-icon.appearing {
        animation: dockIconAppear 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
      }
      
      @keyframes dockIconAppear {
        0% {
          transform: scale(0) translate3d(0, 20px, 0) rotate(-15deg);
          opacity: 0;
        }
        50% {
          transform: scale(1.15) translate3d(0, -5px, 0) rotate(5deg);
          opacity: 1;
        }
        75% {
          transform: scale(0.95) translate3d(0, 2px, 0) rotate(-2deg);
        }
        100% {
          transform: scale(1) translate3d(0, 0, 0) rotate(0deg);
          opacity: 1;
        }
      }
      
      /* Dock icon click animation */
      .dock-icon.clicked {
        animation: dockIconClick 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      }
      
      @keyframes dockIconClick {
        0% { transform: scale(1); }
        40% { transform: scale(0.85); }
        100% { transform: scale(1); }
      }
      
      /* Dock icon sizing - dynamic based on scale and magnification */
      /* Bottom dock expands horizontally only, icons move up */
      .dock-bottom .dock-icon {
        width: calc(48px * var(--dock-scale, 1) * var(--icon-magnify, 1));
        height: calc(48px * var(--dock-scale, 1));
        transition: width 0.3s cubic-bezier(0.34, 1.56, 0.64, 1),
                    height 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      }
      
      /* Left/Right dock icons */
      .dock-left .dock-icon,
      .dock-right .dock-icon,
      .dock-container:not(.dock-bottom):not(.dock-right) .dock-icon {
        width: calc(48px * var(--dock-scale, 1) * var(--icon-magnify, 1));
        height: calc(48px * var(--dock-scale, 1) * var(--icon-magnify, 1));
        transition: width 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), 
                    height 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      }
      
      .dock-icon:active {
        cursor: grabbing;
      }
      
      .dock-icon.dragging {
        opacity: 0.85;
        z-index: 1000;
        cursor: grabbing;
        filter: brightness(1.1);
        transition: opacity 0.15s ease, filter 0.15s ease;
      }
      
      .dock-icon.drag-over {
        transform: translate3d(0, calc(-8px * var(--dock-scale, 1)), 0) scale3d(1.05, 1.05, 1);
      }
      
      .dock-icon.slide-left {
        transform: translateX(calc(-64px * var(--dock-scale, 1)));
        transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      }
      
      .dock-icon.slide-right {
        transform: translateX(calc(64px * var(--dock-scale, 1)));
        transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      }
      
      /* All dock icon SVGs scale uniformly */
      .dock-icon svg {
        width: calc(40px * var(--dock-scale, 1) * var(--icon-magnify, 1));
        height: calc(40px * var(--dock-scale, 1) * var(--icon-magnify, 1));
        color: white;
        transition: width 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), 
                    height 0.3s cubic-bezier(0.34, 1.56, 0.64, 1),
                    transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1),
                    filter 0.3s ease;
      }
      
      /* Light mode icon adjustments for monochrome pack - now handled natively with iconsMonochromeLight */
      
      /* Light mode glass icon adjustments */
      :root:not(.dark) .icon-pack-glass .dock-icon svg,
      :root:not(.dark) .icon-pack-glass .launchpad-icon svg,
      :root:not(.dark) .icon-pack-glass .desktop-shortcut svg {
        filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
      }
      
      /* Ensure accent icons look good in light mode */
      :root:not(.dark) .icon-pack-accent .dock-icon svg,
      :root:not(.dark) .icon-pack-accent .launchpad-icon svg {
        filter: drop-shadow(0 2px 4px rgba(0,0,0,0.15));
      }
      
      /* Fix white icons on bright backgrounds in light mode - General UI elements */
      /* These are elements that use currentColor or white fills that need to be visible in light mode */
      :root:not(.dark) .menubar-item svg,
      :root:not(.dark) .quick-settings-toggle svg,
      :root:not(.dark) .window-control svg {
        color: hsl(var(--foreground));
      }
      
      /* Ensure titlebar buttons remain visible in light mode */
      :root:not(.dark) .titlebar-btn svg {
        stroke: hsl(var(--foreground));
      }
      
      /* Settings sidebar icons in light mode */
      :root:not(.dark) .settings-nav-item svg {
        color: hsl(var(--foreground));
        stroke: hsl(var(--foreground));
      }
      
      /* Active settings nav item should have proper contrast */
      :root:not(.dark) .settings-nav-item.active svg {
        color: hsl(var(--primary-foreground));
        stroke: hsl(var(--primary-foreground));
      }
      
      /* Context menu icons in light mode */
      :root:not(.dark) .context-menu-item svg {
        color: hsl(var(--foreground));
        stroke: hsl(var(--foreground));
      }
      
      /* Quick settings panel in light mode */
      :root:not(.dark) .quick-settings svg {
        color: hsl(var(--foreground));
      }
      
      /* Notification panel icons in light mode */
      :root:not(.dark) .notification-panel svg {
        color: hsl(var(--foreground));
      }
      
      .dock-divider {
        background: hsl(var(--muted-foreground) / 0.3);
        flex-shrink: 0;
      }
      
      /* Ensure dock divider is visible in both themes */
      :root:not(.dark) .dock-divider {
        background: hsl(var(--foreground) / 0.2);
      }
      
      .dock-bottom .dock-divider {
        width: 1px;
        height: calc(40px * var(--dock-scale, 1));
        margin: 0 4px;
        transition: height 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      }
      
      .dock-left .dock-divider,
      .dock-right .dock-divider,
      .dock-container:not(.dock-bottom):not(.dock-right) .dock-divider {
        width: calc(40px * var(--dock-scale, 1) * var(--icon-magnify, 1));
        height: 1px;
        margin: 4px 0;
        transition: width 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      }

      .dock-tooltip {
        position: absolute;
        top: -50px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(50, 50, 60, 0.75);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        color: white;
        padding: 6px 14px;
        border-radius: 8px;
        font-size: 13px;
        font-weight: 500;
        white-space: nowrap;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s cubic-bezier(0.16, 1, 0.3, 1), transform 0.2s cubic-bezier(0.16, 1, 0.3, 1);
        will-change: opacity, transform;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5), 0 0 8px rgba(255, 255, 255, 0.15);
        box-shadow: 0 2px 12px rgba(0, 0, 0, 0.25), inset 0 1px 0 rgba(255, 255, 255, 0.15);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .dock-icon:hover .dock-tooltip {
        opacity: 1;
        transform: translateX(-50%) translateY(-4px);
      }
      
      /* Hide dock tooltips when dragging windows */
      body.window-dragging .dock-tooltip,
      body.window-dragging .dock-icon:hover .dock-tooltip {
        opacity: 0 !important;
        pointer-events: none !important;
      }

      .context-menu {
        position: fixed;
        background: hsl(var(--window-bg));
        border-radius: 8px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        padding: 4px;
        z-index: 99999;
        min-width: 180px;
        backdrop-filter: blur(20px);
        animation: contextMenuAppear 0.15s cubic-bezier(0.16, 1, 0.3, 1);
        transform-origin: top center;
        transition: background-color 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                    box-shadow 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      @keyframes contextMenuAppear {
        from {
          opacity: 0;
          transform: translate3d(0, -4px, 0) scale3d(0.96, 0.96, 1);
        }
        to {
          opacity: 1;
          transform: translate3d(0, 0, 0) scale3d(1, 1, 1);
        }
      }

      .context-menu-item {
        padding: 8px 12px;
        cursor: pointer;
        border-radius: 4px;
        font-size: 13px;
        transition: background 0.15s cubic-bezier(0.16, 1, 0.3, 1),
                    color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .context-menu-item:hover {
        background: hsl(var(--accent));
      }

      .context-menu-divider {
        height: 1px;
        background: hsl(var(--window-border));
        margin: 4px 0;
        transition: background-color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      /* Context Menu Right-Click Menu */
      .menubar-context-menu {
        position: fixed;
        background: hsl(var(--window-bg));
        border-radius: 8px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        padding: 4px;
        z-index: 100000;
        min-width: 200px;
        backdrop-filter: blur(20px);
        animation: contextMenuAppear 0.15s cubic-bezier(0.16, 1, 0.3, 1);
        transform-origin: top left;
      }

      .menubar-context-menu-header {
        padding: 8px 12px;
        font-size: 11px;
        font-weight: 600;
        color: hsl(var(--muted-foreground));
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }

      /* Context Menu Customization Mode */
      .menubar.customize-mode {
        border: 2px dashed hsl(var(--primary));
        background: hsl(var(--menubar-bg) / 0.95);
      }
      
      .menubar.customize-mode .context-menu-element {
        border: 1px dashed hsl(var(--primary) / 0.5);
        border-radius: 4px;
        cursor: move;
        transition: all 0.15s ease;
        padding: 2px 6px;
        margin: 0 2px;
      }
      
      .menubar.customize-mode .context-menu-element:hover {
        background: hsl(var(--primary) / 0.2);
        border-color: hsl(var(--primary));
      }
      
      .menubar.customize-mode .context-menu-element.dragging {
        opacity: 0.5;
        border-color: hsl(var(--primary));
        background: hsl(var(--primary) / 0.3);
      }
      
      .menubar.customize-mode .context-menu-element.drag-over {
        background: hsl(var(--primary) / 0.4);
        transform: scale(1.05);
      }
      
      .context-menu-customize-bar {
        position: fixed;
        top: 28px;
        left: 0;
        bottom: 0;
        width: 320px;
        background: hsl(var(--window-bg) / 0.95);
        backdrop-filter: blur(20px);
        border-radius: 0 16px 16px 0;
        padding: 16px;
        display: flex;
        flex-direction: column;
        gap: 12px;
        z-index: 10002;
        box-shadow: 8px 0 32px hsl(var(--shadow-color) / 0.4);
        border: 1px solid hsl(var(--window-border));
        border-left: none;
        animation: slideInFromLeft 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        overflow-y: auto;
      }
      
      @keyframes slideInFromLeft {
        from { transform: translateX(-100%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
      }
      
      .context-menu-customize-bar .widgets-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding-bottom: 12px;
        border-bottom: 1px solid hsl(var(--window-border));
      }
      
      .context-menu-customize-bar .widgets-header h2 {
        font-size: 16px;
        font-weight: 600;
        color: hsl(var(--foreground));
        margin: 0;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      
      .context-menu-customize-bar .widgets-search {
        width: 100%;
        padding: 10px 12px;
        border-radius: 8px;
        border: 1px solid hsl(var(--window-border));
        background: hsl(var(--accent));
        color: hsl(var(--foreground));
        font-size: 13px;
        outline: none;
        transition: all 0.15s ease;
      }
      
      .context-menu-customize-bar .widgets-search:focus {
        border-color: hsl(var(--primary));
        box-shadow: 0 0 0 2px hsl(var(--primary) / 0.2);
      }
      
      .context-menu-customize-bar .widgets-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
        flex: 1;
        overflow-y: auto;
        padding: 4px;
      }
      
      .context-menu-customize-bar .widget-card {
        background: hsl(var(--accent));
        border: 1px solid hsl(var(--window-border));
        border-radius: 12px;
        padding: 14px 12px;
        cursor: grab;
        transition: all 0.2s ease;
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
        gap: 8px;
      }
      
      .context-menu-customize-bar .widget-card:hover {
        background: hsl(var(--primary) / 0.15);
        border-color: hsl(var(--primary) / 0.5);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px hsl(var(--shadow-color) / 0.2);
      }
      
      .context-menu-customize-bar .widget-card:active {
        cursor: grabbing;
        transform: scale(0.98);
      }
      
      .context-menu-customize-bar .widget-card.in-use {
        opacity: 0.5;
        pointer-events: none;
      }
      
      .context-menu-customize-bar .widget-card .widget-icon {
        width: 48px;
        height: 48px;
        background: hsl(var(--primary) / 0.2);
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: hsl(var(--primary));
      }
      
      .context-menu-customize-bar .widget-card .widget-icon svg {
        width: 24px;
        height: 24px;
      }
      
      .context-menu-customize-bar .widget-card .widget-name {
        font-size: 12px;
        font-weight: 600;
        color: hsl(var(--foreground));
      }
      
      .context-menu-customize-bar .widget-card .widget-desc {
        font-size: 10px;
        color: hsl(var(--muted-foreground));
        line-height: 1.3;
      }
      
      .context-menu-customize-bar .widgets-footer {
        display: flex;
        gap: 8px;
        padding-top: 12px;
        border-top: 1px solid hsl(var(--window-border));
      }
      
      .context-menu-customize-bar span {
        font-size: 13px;
        font-weight: 500;
        color: hsl(var(--foreground));
      }
      
      .context-menu-customize-bar button {
        padding: 6px 14px;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.15s ease;
        border: none;
      }
      
      .context-menu-customize-bar .done-btn {
        background: hsl(var(--primary));
        color: hsl(var(--primary-foreground));
      }
      
      .context-menu-customize-bar .done-btn:hover {
        background: hsl(var(--primary) / 0.85);
        transform: scale(1.02);
      }
      
      .context-menu-customize-bar .reset-btn {
        background: hsl(var(--accent));
        color: hsl(var(--foreground));
      }
      
      .context-menu-customize-bar .reset-btn:hover {
        background: hsl(var(--accent-hover));
      }
      
      .context-menu-drop-zone {
        min-width: 40px;
        min-height: 20px;
        display: flex;
        align-items: center;
        gap: 2px;
        padding: 0 4px;
        position: relative;
      }
      
      .drop-zone-label {
        font-size: 10px;
        color: hsl(var(--muted-foreground) / 0.7);
        text-transform: uppercase;
        letter-spacing: 0.05em;
        padding: 2px 8px;
      }
      
      .context-menu-drop-zone.empty {
        border: 1px dashed hsl(var(--muted-foreground) / 0.3);
        border-radius: 4px;
      }
      
      .context-menu-drop-zone.drag-over {
        background: hsl(var(--primary) / 0.1);
        border-color: hsl(var(--primary));
      }
      
      .context-menu-element-label {
        position: absolute;
        top: -18px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 9px;
        color: hsl(var(--primary));
        background: hsl(var(--background));
        padding: 1px 4px;
        border-radius: 2px;
        white-space: nowrap;
        opacity: 0;
        transition: opacity 0.15s;
        pointer-events: none;
      }
      
      .menubar.customize-mode .context-menu-element:hover .context-menu-element-label {
        opacity: 1;
      }
      
      .context-menu-item.active {
        background: hsl(var(--primary) / 0.2);
        color: hsl(var(--primary));
      }
      
      .context-menu-item.destructive {
        color: #ef4444;
      }
      
      .context-menu-item.destructive:hover {
        background: rgba(239, 68, 68, 0.15);
      }
      
      .context-menu-separator {
        height: 1px;
        background: hsl(var(--window-border));
        margin: 4px 0;
      }
      
      .hidden-elements-list {
        display: none;
      }
      
      .hidden-elements-list span.label {
        display: none;
      }
      
      .hidden-element-btn {
        display: none;
      }
      
      .hidden-element-btn:hover {
        display: none;
      }
      
      .menubar-center {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        align-items: center;
        gap: 2px;
      }


      .launchpad-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(20px) saturate(120%);
        z-index: 99998;
        display: flex;
        flex-direction: column;
        opacity: 0;
        animation: launchpadFadeIn 0.3s cubic-bezier(0.16, 1, 0.3, 1) forwards;
      }

      .launchpad-overlay.closing {
        animation: launchpadFadeOut 0.3s cubic-bezier(0.4, 0, 1, 1) forwards !important;
        pointer-events: none;
      }

      @keyframes launchpadFadeIn {
        from {
          opacity: 0;
          backdrop-filter: blur(0px) saturate(100%);
        }
        to {
          opacity: 1;
          backdrop-filter: blur(20px) saturate(120%);
        }
      }

      @keyframes launchpadFadeOut {
        from {
          opacity: 1;
          backdrop-filter: blur(20px) saturate(120%);
        }
        to {
          opacity: 0;
          backdrop-filter: blur(0px) saturate(100%);
        }
      }

      .launchpad-search-container {
        display: flex;
        justify-content: center;
        padding: 40px 20px 20px;
        opacity: 0;
        transform: translateY(-30px);
        animation: slideDown 0.4s cubic-bezier(0.16, 1, 0.3, 1) 0.05s forwards;
      }

      .launchpad-overlay.closing .launchpad-search-container {
        animation: slideUp 0.25s cubic-bezier(0.4, 0, 1, 1) forwards !important;
      }

      @keyframes slideDown {
        from {
          opacity: 0;
          transform: translateY(-30px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @keyframes slideUp {
        from {
          opacity: 1;
          transform: translateY(0);
        }
        to {
          opacity: 0;
          transform: translateY(-30px);
        }
      }

      .launchpad-search {
        width: 100%;
        max-width: 600px;
        padding: 12px 20px;
        background: rgba(255, 255, 255, 0.15);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        color: white;
        font-size: 18px;
        outline: none;
        backdrop-filter: blur(10px);
        transition: all 0.2s ease;
      }

      .launchpad-search::placeholder {
        color: rgba(255, 255, 255, 0.6);
      }

      .launchpad-search:focus {
        background: rgba(255, 255, 255, 0.2);
        border-color: rgba(255, 255, 255, 0.4);
      }

      .launchpad-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
        gap: 40px;
        padding: 20px 80px 80px;
        height: 100%;
        overflow-y: auto;
        align-content: start;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        max-width: 1400px;
        margin: 0 auto;
        width: 100%;
        opacity: 0;
        transform: scale(0.9);
        animation: scaleIn 0.45s cubic-bezier(0.16, 1, 0.3, 1) 0.1s forwards;
      }

      .launchpad-overlay.closing .launchpad-grid {
        animation: scaleOut 0.25s cubic-bezier(0.4, 0, 1, 1) forwards !important;
      }

      @keyframes scaleIn {
        from {
          opacity: 0;
          transform: scale(0.9);
        }
        to {
          opacity: 1;
          transform: scale(1);
        }
      }

      @keyframes scaleOut {
        from {
          opacity: 1;
          transform: scale(1);
        }
        to {
          opacity: 0;
          transform: scale(0.9);
        }
      }

      .launchpad-grid::-webkit-scrollbar,
      .window-content::-webkit-scrollbar,
      .terminal-content::-webkit-scrollbar {
        width: 8px;
      }

      .launchpad-grid::-webkit-scrollbar-track,
      .window-content::-webkit-scrollbar-track,
      .terminal-content::-webkit-scrollbar-track {
        background: transparent;
      }

      .launchpad-grid::-webkit-scrollbar-thumb,
      .window-content::-webkit-scrollbar-thumb,
      .terminal-content::-webkit-scrollbar-thumb {
        background: hsl(var(--foreground) / 0);
        border-radius: 4px;
        transition: background 0.2s cubic-bezier(0.16, 1, 0.3, 1);
      }

      .launchpad-grid:hover::-webkit-scrollbar-thumb,
      .window-content:hover::-webkit-scrollbar-thumb,
      .terminal-content:hover::-webkit-scrollbar-thumb {
        background: hsl(var(--foreground) / 0.2);
      }
      
      .terminal-content:hover::-webkit-scrollbar-thumb {
        background: rgba(0, 255, 0, 0.2);
      }

      .launchpad-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        padding: 12px;
        border-radius: 12px;
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
        will-change: transform, background-color;
        transform: translate3d(0, 0, 0);
      }

      .launchpad-item:hover {
        background: rgba(255, 255, 255, 0.15);
        transform: translate3d(0, 0, 0) scale3d(1.08, 1.08, 1);
      }

      .launchpad-item:active {
        transform: translate3d(0, 0, 0) scale3d(0.95, 0.95, 1);
      }

      /* M OS Windows - GPU Accelerated */
      .window {
        position: fixed;
        background: hsl(var(--window-bg));
        border-radius: 10px;
        box-shadow: 0 8px 32px hsl(var(--shadow-color) / 0.2), 0 0 0 1px hsl(var(--window-border));
        display: flex;
        flex-direction: column;
        overflow: hidden;
        will-change: auto;
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
        transform: translateZ(0);
        -webkit-transform: translateZ(0);
        border: none;
        contain: layout style;
      }
      
      /* Only enable will-change during animations */
      .window.animating,
      .window.maximizing,
      .window.restoring,
      .window.snapping {
        will-change: transform, opacity, left, top, width, height;
      }
      
      /* Dragging window - no transitions, pure GPU */
      .window.dragging {
        transition: none !important;
        will-change: transform;
        cursor: grabbing;
      }
      
      /* Inactive window styles - only grey out titlebar buttons and text */
      .window.inactive .titlebar-button {
        opacity: 0.4;
      }
      
      .window.inactive .titlebar-title {
        opacity: 0.4;
      }
      
      .dark .window {
        box-shadow: 0 12px 48px rgba(0, 0, 0, 0.4), 0 0 0 1px hsl(var(--window-border));
      }

      .window.snapped,
      .window.maximizing,
      .window.maximized,
      .window.snapping {
        box-shadow: none !important;
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
        transform: translate3d(0, 0, 0);
      }
      
      .window.maximized,
      .window.snapped {
        box-shadow: none;
        border-radius: 0 !important;
      }
      
      .window.maximizing,
      .window.snapping,
      .window.restoring {
        will-change: left, top, width, height, border-radius;
        transition: left 0.3s cubic-bezier(0.16, 1, 0.3, 1),
                    top 0.3s cubic-bezier(0.16, 1, 0.3, 1),
                    width 0.3s cubic-bezier(0.16, 1, 0.3, 1),
                    height 0.3s cubic-bezier(0.16, 1, 0.3, 1),
                    border-radius 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      }

      .window.appearing {
        animation: windowAppear 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      }

      @keyframes windowAppear {
        from {
          opacity: 0;
          transform: scale3d(0.95, 0.95, 1) translateY(8px);
        }
        to {
          opacity: 1;
          transform: scale3d(1, 1, 1) translateY(0);
        }
      }

      /* M OS Titlebar */
      .titlebar {
        height: 40px;
        background: hsl(var(--titlebar-bg));
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 12px;
        cursor: move;
        user-select: none;
        border-bottom: 1px solid hsl(var(--window-border) / 0.5);
        position: relative;
      }

      .titlebar-buttons {
        display: flex;
        gap: 6px;
        position: absolute;
        left: 12px;
        right: auto;
      }

      /* M OS Window Controls - Modern circular buttons */
      .titlebar-button {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        border: none;
        cursor: pointer;
        transition: all 0.15s ease;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        background: hsl(var(--foreground) / 0.15);
      }

      .titlebar-button::before {
        content: '';
        position: absolute;
        opacity: 0.8;
        transition: opacity 0.15s ease;
      }

      .titlebar-button:hover {
        transform: scale(1.15);
      }
      
      .titlebar-button:hover::before {
        opacity: 1;
      }

      .titlebar-button:active {
        transform: scale(0.95);
      }

      /* Default order: close, maximize, minimize */
      .titlebar-button.close {
        order: 1;
      }
      
      .titlebar-button.maximize {
        order: 2;
      }
      
      .titlebar-button.minimize {
        order: 3;
      }
      
      /* Mirrored order: minimize, maximize, close (inverted) */
      .mirrored-controls .titlebar-button.minimize {
        order: 1;
      }
      
      .mirrored-controls .titlebar-button.maximize {
        order: 2;
      }
      
      .mirrored-controls .titlebar-button.close {
        order: 3;
      }
      
      .titlebar-button.minimize::before {
        width: 8px;
        height: 2px;
        background: hsl(var(--foreground));
        border-radius: 1px;
      }
      
      .titlebar-button.minimize:hover {
        background: hsl(45 90% 55%);
      }
      
      .titlebar-button.minimize:hover::before {
        background: hsl(45 20% 15%);
      }

      .titlebar-button.maximize::before {
        width: 6px;
        height: 6px;
        border: 1.5px solid hsl(var(--foreground));
        border-radius: 1px;
      }
      
      .window.maximized .titlebar-button.maximize::before,
      .window.fullscreen .titlebar-button.maximize::before {
        width: 5px;
        height: 5px;
        border: 1.5px solid hsl(var(--foreground));
        box-shadow: 2px -2px 0 0 hsl(var(--foreground));
        transform: translate(-1px, 1px);
      }
      
      .titlebar-button.maximize:hover {
        background: hsl(140 70% 45%);
      }
      
      .titlebar-button.maximize:hover::before {
        border-color: hsl(140 20% 15%);
      }
      
      .window.maximized .titlebar-button.maximize:hover::before,
      .window.fullscreen .titlebar-button.maximize:hover::before {
        border-color: hsl(140 20% 15%);
        box-shadow: 2px -2px 0 0 hsl(140 20% 15%);
      }

      .titlebar-button.close::before {
        content: '';
        font-size: 12px;
        font-weight: 600;
        color: hsl(var(--foreground));
        line-height: 1;
        opacity: 0.8;
      }
      
      .titlebar-button.close:hover {
        background: hsl(0 70% 55%);
      }
      
      .titlebar-button.close:hover::before {
        color: white;
        opacity: 1;
      }

      .titlebar-title {
        font-size: 13px;
        font-weight: 600;
        color: hsl(var(--foreground));
        letter-spacing: 0.01em;
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
      }

      /* Fullscreen button - appears on right side when window is maximized */
      .titlebar-fullscreen-btn {
        position: absolute;
        right: 16px;
        left: auto;
        display: none;
        align-items: center;
        justify-content: center;
        width: 24px;
        height: 24px;
        border-radius: 6px;
        background: hsl(var(--accent));
        border: 1px solid hsl(var(--window-border));
        cursor: pointer;
        transition: all 0.15s cubic-bezier(0.16, 1, 0.3, 1);
        opacity: 0.8;
      }

      .titlebar-fullscreen-btn:hover {
        background: hsl(var(--primary));
        opacity: 1;
        transform: scale(1.05);
      }

      .titlebar-fullscreen-btn:active {
        transform: scale(0.95);
      }

      .titlebar-fullscreen-btn svg {
        width: 14px;
        height: 14px;
        stroke: hsl(var(--foreground));
        stroke-width: 2;
        fill: none;
      }

      .titlebar-fullscreen-btn:hover svg {
        stroke: white;
      }

      /* Show fullscreen button only when window is maximized */
      .window.maximized .titlebar-fullscreen-btn {
        display: flex;
      }

      /* Mirrored layout - window buttons on right, fullscreen on left */
      .mirrored-controls .titlebar-buttons {
        left: auto !important;
        right: 12px !important;
      }
      
      .mirrored-controls .titlebar-fullscreen-btn {
        left: 12px !important;
        right: auto !important;
      }
      
      /* Warp animations - only trigger when class is added */
      .titlebar-buttons.animating-to-right {
        animation: warpToRight 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
      }
      
      .titlebar-buttons.animating-to-left {
        animation: warpToLeft 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
      }
      
      .titlebar-fullscreen-btn.animating-to-left {
        animation: warpToLeft 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
      }
      
      .titlebar-fullscreen-btn.animating-to-right {
        animation: warpToRight 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
      }
      
      @keyframes warpToRight {
        0% {
          transform: translateX(-80px) scale(0.7);
          opacity: 0;
        }
        60% {
          transform: translateX(8px) scale(1.08);
          opacity: 1;
        }
        100% {
          transform: translateX(0) scale(1);
          opacity: 1;
        }
      }
      
      @keyframes warpToLeft {
        0% {
          transform: translateX(80px) scale(0.7);
          opacity: 0;
        }
        60% {
          transform: translateX(-8px) scale(1.08);
          opacity: 1;
        }
        100% {
          transform: translateX(0) scale(1);
          opacity: 1;
        }
      }

      .window-content {
        flex: 1;
        overflow: auto;
        padding: 0;
        display: flex;
        flex-direction: column;
        transition: background-color 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                    color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        scrollbar-width: thin;
        scrollbar-color: rgba(128, 128, 128, 0.5) transparent;
      }

      .window-content::-webkit-scrollbar {
        width: 12px;
      }

      .window-content::-webkit-scrollbar-track {
        background: transparent;
      }

      .window-content::-webkit-scrollbar-thumb {
        background: rgba(128, 128, 128, 0.5);
        border-radius: 10px;
        border: 3px solid transparent;
        background-clip: padding-box;
      }

      .window-content::-webkit-scrollbar-thumb:hover {
        background: rgba(128, 128, 128, 0.7);
        background-clip: padding-box;
      }

      .resize-handle {
        position: absolute;
        z-index: 10;
      }
      
      .resize-handle.se { bottom: 0; right: 0; width: 16px; height: 16px; cursor: se-resize; }
      .resize-handle.sw { bottom: 0; left: 0; width: 16px; height: 16px; cursor: sw-resize; }
      .resize-handle.ne { top: 0; right: 0; width: 16px; height: 16px; cursor: ne-resize; }
      .resize-handle.nw { top: 0; left: 0; width: 16px; height: 16px; cursor: nw-resize; }
      .resize-handle.n { top: 0; left: 0; right: 0; height: 4px; cursor: n-resize; }
      .resize-handle.s { bottom: 0; left: 0; right: 0; height: 4px; cursor: s-resize; }
      .resize-handle.e { top: 0; bottom: 0; right: 0; width: 4px; cursor: e-resize; }
      .resize-handle.w { top: 0; bottom: 0; left: 0; width: 4px; cursor: w-resize; }

      .terminal-content {
        background: #000;
        color: #0f0;
        font-family: 'JetBrainsMono Nerd Font', 'JetBrains Mono', 'Courier New', monospace;
        padding: 0;
        height: 100%;
        overflow-y: auto;
        font-size: 14px;
        line-height: 1.5;
        user-select: text;
        -webkit-user-select: text;
        -moz-user-select: text;
        -ms-user-select: text;
      }

      .terminal-content::selection,
      .terminal-content *::selection {
        background: rgba(0, 255, 0, 0.3);
        color: #0f0;
      }

      .terminal-content::-moz-selection,
      .terminal-content *::-moz-selection {
        background: rgba(0, 255, 0, 0.3);
        color: #0f0;
      }

      .terminal-input::selection {
        background: rgba(0, 255, 0, 0.4);
        color: #0f0;
      }

      .terminal-input::-moz-selection {
        background: rgba(0, 255, 0, 0.4);
        color: #0f0;
      }

      .terminal-input-line {
        display: flex;
        gap: 8px;
      }

      .terminal-input {
        background: transparent;
        border: none;
        color: #0f0;
        font-family: 'JetBrainsMono Nerd Font', 'JetBrains Mono', 'Courier New', monospace;
        font-size: 14px;
        outline: none;
        flex: 1;
      }

      /* ========== BROWSER COMPONENT - REFACTORED ========== */
      
      /* Main browser container - creates stacking context */
      .browser-container {
        position: relative;
        isolation: isolate;
        display: flex;
        flex-direction: column;
        height: 100%;
        min-height: 100%;
        background: hsl(var(--window-bg));
        overflow: hidden;
      }
      
      /* Browser header section - contains tabs, bookmarks, toolbar */
      .browser-header {
        position: relative;
        z-index: 100;
        flex-shrink: 0;
        display: flex;
        flex-direction: column;
        background: hsl(var(--titlebar-bg));
      }

      /* Browser Tabs Container */
      .browser-tabs-container {
        position: relative;
        display: flex;
        align-items: center;
        background: hsl(var(--titlebar-bg));
        border-bottom: 1px solid hsl(var(--window-border));
        padding: 4px 8px 0 8px;
        gap: 2px;
        transition: background-color 0.3s ease;
      }
      
      /* Browser Toolbar */
      .browser-toolbar {
        position: relative;
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 12px;
        background: hsl(var(--titlebar-bg));
        border-bottom: 1px solid hsl(var(--window-border));
        transition: background-color 0.3s ease;
        z-index: 101;
        pointer-events: auto;
      }

      .browser-nav-buttons {
        display: flex;
        gap: 4px;
        pointer-events: auto;
        position: relative;
        z-index: 10;
      }

      .browser-nav-button {
        width: 32px;
        height: 32px;
        border: none;
        border-radius: 6px;
        background: hsl(var(--accent));
        color: hsl(var(--foreground));
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background 0.15s ease, transform 0.15s ease;
        pointer-events: auto;
        position: relative;
        z-index: 10;
      }

      .browser-nav-button:hover {
        background: hsl(var(--accent-hover));
        transform: scale(1.05);
      }
      
      .browser-nav-button:active {
        transform: scale(0.95);
      }

      .browser-nav-button svg {
        width: 18px;
        height: 18px;
        pointer-events: none;
      }

      .browser-address-bar {
        flex: 1;
        display: flex;
        align-items: center;
        background: hsl(var(--background));
        border-radius: 8px;
        padding: 0 12px;
        height: 32px;
        transition: background-color 0.3s ease;
      }

      .browser-address-bar svg {
        width: 16px;
        height: 16px;
        margin-right: 8px;
        color: hsl(var(--muted-foreground));
        flex-shrink: 0;
        pointer-events: none;
      }

      .browser-address-input {
        flex: 1;
        border: none;
        background: transparent;
        outline: none;
        font-size: 13px;
        color: hsl(var(--foreground));
        min-width: 0;
      }
      
      .browser-address-input::placeholder {
        color: hsl(var(--muted-foreground));
      }
      
      /* Browser Bookmarks Bar */
      .browser-bookmarks-bar {
        position: relative;
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 6px 12px;
        background: hsl(var(--titlebar-bg) / 0.5);
        border-bottom: 1px solid hsl(var(--window-border));
        overflow-x: auto;
        font-size: 12px;
        scrollbar-width: none;
      }
      
      .browser-bookmarks-bar::-webkit-scrollbar {
        display: none;
      }

      /* Browser content area - contains iframe */
      .browser-content-wrapper {
        position: relative;
        z-index: 1;
        flex: 1;
        min-height: 0;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      /* Browser iframe */
      .browser-iframe {
        position: relative;
        flex: 1;
        width: 100%;
        height: 100%;
        border: none;
        background: #fff;
        /* Ensure the iframe never overlays the browser chrome */
        z-index: 1;
      }
      
      /* Iframe click blocker overlay - prevents iframe from stealing clicks */
      .browser-iframe-blocker {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 50;
        background: transparent;
        display: none;
        cursor: default;
      }
      
      /* Show blocker when browser UI is being interacted with */
      .browser-container.ui-active .browser-iframe-blocker {
        display: block;
      }

      .browser-tab {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 12px;
        background: hsl(var(--accent) / 0.5);
        border-radius: 8px 8px 0 0;
        cursor: pointer;
        min-width: 120px;
        max-width: 200px;
        transition: all 0.15s cubic-bezier(0.16, 1, 0.3, 1);
        font-size: 13px;
        color: hsl(var(--muted-foreground));
        border: 1px solid transparent;
        border-bottom: none;
        position: relative;
      }

      .browser-tab:hover {
        background: hsl(var(--accent) / 0.8);
      }

      .browser-tab.active {
        background: hsl(var(--window-bg));
        color: hsl(var(--foreground));
        border-color: hsl(var(--window-border));
        border-bottom: none;
      }

      .browser-tab-loading {
        width: 14px;
        height: 14px;
        border: 2px solid hsl(var(--muted-foreground) / 0.3);
        border-top-color: hsl(var(--primary));
        border-radius: 50%;
        animation: tab-spin 0.8s linear infinite;
        flex-shrink: 0;
      }

      @keyframes tab-spin {
        to { transform: rotate(360deg); }
      }

      .browser-tab-favicon {
        width: 14px;
        height: 14px;
        flex-shrink: 0;
        object-fit: contain;
      }

      .browser-tab-title {
        flex: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .browser-tab-close {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0.6;
        transition: all 0.15s;
      }

      .browser-tab-close:hover {
        opacity: 1;
        background: hsl(var(--destructive) / 0.2);
        color: hsl(var(--destructive));
      }

      /* Per-tab iframe container */
      .browser-tab-iframes {
        position: relative;
        flex: 1;
        min-height: 0;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .browser-tab-iframe-wrapper {
        position: absolute;
        inset: 0;
        display: none;
      }

      .browser-tab-iframe-wrapper.active {
        display: flex;
        position: relative;
        flex: 1;
      }

      .browser-tab-iframe-wrapper iframe {
        flex: 1;
        width: 100%;
        height: 100%;
        border: none;
        background: #fff;
      }

      .browser-new-tab-btn {
        width: 32px;
        height: 32px;
        border-radius: 6px;
        border: none;
        background: hsl(var(--accent));
        color: hsl(var(--foreground));
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.15s cubic-bezier(0.16, 1, 0.3, 1);
      }

      .browser-new-tab-btn:hover {
        background: hsl(var(--accent) / 1.2);
        transform: scale3d(1.05, 1.05, 1);
      }

      /* Browser Bookmarks Bar - duplicate removed, using definition in browser header section */

      .browser-bookmark {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 4px 10px;
        background: hsl(var(--accent));
        border-radius: 6px;
        cursor: pointer;
        white-space: nowrap;
        transition: all 0.15s cubic-bezier(0.16, 1, 0.3, 1);
        color: hsl(var(--foreground));
      }

      .browser-bookmark:hover {
        background: hsl(var(--accent) / 1.2);
        transform: scale3d(1.02, 1.02, 1);
      }

      /* Vertical Tabs Mode */
      .browser-container.vertical-tabs {
        flex-direction: row;
      }
      
      .browser-container.vertical-tabs .browser-header {
        flex-direction: row;
      }
      
      .browser-container.vertical-tabs .browser-sidebar {
        width: 220px;
        display: flex;
        flex-direction: column;
        border-right: 1px solid hsl(var(--window-border));
        background: hsl(var(--titlebar-bg));
      }
      
      .browser-container.vertical-tabs .browser-tabs-container {
        flex-direction: column;
        overflow-y: auto;
        overflow-x: hidden;
        flex: 1;
        padding: 8px;
        gap: 4px;
      }
      
      .browser-container.vertical-tabs .browser-tab {
        min-width: unset;
        max-width: unset;
        width: 100%;
        border-radius: 8px;
        border: 1px solid transparent;
      }
      
      .browser-container.vertical-tabs .browser-tab.active {
        background: hsl(var(--primary) / 0.15);
        border-color: hsl(var(--primary) / 0.3);
      }
      
      .browser-container.vertical-tabs .browser-new-tab-btn {
        width: 100%;
        margin-top: 4px;
      }
      
      .browser-container.vertical-tabs .browser-main {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-width: 0;
      }
      
      .browser-container.vertical-tabs .browser-toolbar-wrapper {
        display: flex;
        flex-direction: column;
      }
      
      /* History Panel */
      .browser-history-panel {
        position: absolute;
        top: 0;
        right: 0;
        width: 320px;
        height: 100%;
        background: hsl(var(--window-bg));
        border-left: 1px solid hsl(var(--window-border));
        z-index: 100;
        display: flex;
        flex-direction: column;
        box-shadow: -4px 0 20px rgba(0, 0, 0, 0.1);
      }
      
      .browser-history-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 16px;
        border-bottom: 1px solid hsl(var(--window-border));
        background: hsl(var(--titlebar-bg));
      }
      
      .browser-history-header h3 {
        font-size: 14px;
        font-weight: 600;
        color: hsl(var(--foreground));
        margin: 0;
      }
      
      .browser-history-list {
        flex: 1;
        overflow-y: auto;
        padding: 8px;
      }
      
      .browser-history-item {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px 12px;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.15s;
        color: hsl(var(--foreground));
      }
      
      .browser-history-item:hover {
        background: hsl(var(--accent));
      }
      
      .browser-history-item-icon {
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: hsl(var(--muted-foreground));
      }
      
      .browser-history-item-text {
        flex: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        font-size: 13px;
      }
      
      .browser-history-item-time {
        font-size: 11px;
        color: hsl(var(--muted-foreground));
      }
      
      .browser-history-empty {
        text-align: center;
        padding: 40px 20px;
        color: hsl(var(--muted-foreground));
        font-size: 13px;
      }

      /* Browser Home Page */
      .browser-home {
        flex: 1;
        padding: 40px 20px;
        overflow-y: auto;
        overflow-x: hidden;
        background: hsl(var(--background));
        transition: background-color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        scrollbar-width: thin;
        scrollbar-color: rgba(128, 128, 128, 0.5) transparent;
        min-height: 0;
        max-height: 100%;
      }

      .browser-home::-webkit-scrollbar {
        width: 12px;
      }

      .browser-home::-webkit-scrollbar-track {
        background: transparent;
      }

      .browser-home::-webkit-scrollbar-thumb {
        background: rgba(128, 128, 128, 0.5);
        border-radius: 10px;
        border: 3px solid transparent;
        background-clip: padding-box;
      }

      .browser-home::-webkit-scrollbar-thumb:hover {
        background: rgba(128, 128, 128, 0.7);
        background-clip: padding-box;
      }

      .browser-home-title {
        font-size: 24px;
        font-weight: 600;
        margin-bottom: 30px;
        color: hsl(var(--foreground));
        transition: color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      /* M Search Engine Styles - Firefox-like New Tab */
      .m-search-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        padding: 80px 20px 30px;
        max-width: 600px;
        margin: 0 auto;
      }

      .m-search-logo {
        display: flex;
        align-items: center;
        gap: 14px;
        margin-bottom: 32px;
      }

      /* M Search Logo - matches menubar M logo (circle style) */
      .m-search-logo-circle {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        background: hsl(220 20% 10%);
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
        transition: background-color 0.3s ease;
      }
      
      .dark .m-search-logo-circle {
        background: white;
      }

      .m-search-logo-letter {
        font-size: 26px;
        font-weight: 600;
        color: white;
        font-family: 'Space Grotesk', sans-serif;
        letter-spacing: 0.02em;
        transition: color 0.3s ease;
      }
      
      .dark .m-search-logo-letter {
        color: hsl(220 20% 10%);
      }

      .m-search-logo-text {
        font-size: 36px;
        font-weight: 400;
        color: hsl(var(--foreground));
        letter-spacing: -0.5px;
        font-family: 'Space Grotesk', sans-serif;
      }

      .m-search-form {
        width: 100%;
        position: relative;
        margin-bottom: 20px;
      }

      .m-search-input-wrapper {
        position: relative;
        width: 100%;
      }

      .m-search-input {
        width: 100%;
        padding: 14px 50px 14px 48px;
        font-size: 15px;
        border: none;
        border-radius: 8px;
        background: hsl(var(--accent));
        color: hsl(var(--foreground));
        outline: none;
        transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
        box-shadow: none;
      }
      
      .m-search-input-icon {
        position: absolute;
        left: 14px;
        top: 50%;
        transform: translateY(-50%);
        width: 18px;
        height: 18px;
        color: hsl(var(--muted-foreground));
        pointer-events: none;
      }

      .m-search-input:focus {
        background: hsl(var(--accent));
        box-shadow: 0 0 0 2px hsl(var(--primary) / 0.3);
      }

      .m-search-input::placeholder {
        color: hsl(var(--muted-foreground));
      }

      .m-search-btn {
        position: absolute;
        right: 6px;
        top: 50%;
        transform: translateY(-50%);
        width: 36px;
        height: 36px;
        border-radius: 6px;
        background: transparent;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.15s ease;
        opacity: 0.6;
      }

      .m-search-btn:hover {
        opacity: 1;
        background: hsl(var(--primary) / 0.1);
      }

      .m-search-btn:active {
        transform: translateY(-50%) scale(0.95);
      }

      .m-search-btn svg {
        width: 18px;
        height: 18px;
        color: hsl(var(--foreground));
      }

      .m-search-suggestions {
        display: none;
      }

      .m-search-divider {
        display: none;
      }

      .m-search-section-title {
        font-size: 14px;
        font-weight: 600;
        color: hsl(var(--muted-foreground));
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 20px;
        text-align: center;
      }

      /* Search Results Page */
      .m-search-results {
        flex: 1;
        padding: 20px;
        overflow-y: auto;
        background: hsl(var(--background));
      }

      .m-search-results-header {
        display: flex;
        align-items: center;
        gap: 16px;
        padding: 16px 20px;
        border-bottom: 1px solid hsl(var(--border));
        background: hsl(var(--background));
      }

      .m-search-results-logo {
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
      }

      .m-search-results-logo-circle {
        width: 32px;
        height: 32px;
        border-radius: 8px;
        background: linear-gradient(135deg, hsl(var(--primary)), hsl(0 0% 40%));
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .m-search-results-logo-letter {
        font-size: 18px;
        font-weight: 700;
        color: white;
      }

      .m-search-results-input {
        flex: 1;
        max-width: 600px;
        padding: 12px 20px;
        font-size: 15px;
        border: 1px solid hsl(var(--border));
        border-radius: 24px;
        background: hsl(var(--accent) / 0.3);
        color: hsl(var(--foreground));
        outline: none;
        transition: all 0.2s;
      }

      .m-search-results-input:focus {
        border-color: hsl(var(--primary));
        background: hsl(var(--background));
      }

      .m-search-results-list {
        max-width: 700px;
        padding: 20px 0;
      }

      .m-search-result-item {
        padding: 16px 0;
        border-bottom: 1px solid hsl(var(--border) / 0.5);
      }

      .m-search-result-url {
        font-size: 12px;
        color: hsl(var(--muted-foreground));
        margin-bottom: 4px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .m-search-result-url img {
        width: 16px;
        height: 16px;
        border-radius: 2px;
      }

      .m-search-result-title {
        font-size: 18px;
        color: hsl(var(--foreground));
        margin-bottom: 6px;
        cursor: pointer;
        text-decoration: none;
        display: block;
      }

      .m-search-result-title:hover {
        text-decoration: underline;
      }

      .m-search-result-snippet {
        font-size: 14px;
        color: hsl(var(--foreground) / 0.8);
        line-height: 1.5;
      }

      .m-search-loading {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 60px 20px;
        gap: 16px;
      }

      .m-search-loading-spinner {
        width: 40px;
        height: 40px;
        border: 3px solid hsl(var(--border));
        border-top-color: hsl(var(--primary));
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
      }

      @keyframes spin {
        to { transform: rotate(360deg); }
      }

      .m-search-loading-text {
        font-size: 14px;
        color: hsl(var(--muted-foreground));
      }

      .m-search-error {
        padding: 40px 20px;
        text-align: center;
        color: hsl(var(--muted-foreground));
      }

      .m-search-powered {
        font-size: 11px;
        color: hsl(var(--muted-foreground));
        text-align: center;
        margin-top: 8px;
      }

      /* Firefox-style Favorites Grid */
      .browser-sites-grid {
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        max-width: 600px;
        justify-content: center;
        padding: 20px 0;
      }

      .browser-site-card {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        padding: 12px 8px;
        background: transparent;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.15s ease;
        width: 80px;
      }

      .browser-site-card:hover {
        background: hsl(var(--accent));
        transform: none;
        box-shadow: none;
      }

      .browser-site-card.show-actions .browser-site-remove {
        display: flex;
      }

      .browser-site-icon {
        width: 48px;
        height: 48px;
        background: hsl(var(--accent));
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        transition: all 0.15s ease;
      }

      .browser-site-card:hover .browser-site-icon {
        background: hsl(var(--accent-hover, var(--accent)));
        transform: none;
      }

      .browser-site-add {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        padding: 12px 8px;
        background: transparent;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.15s ease;
        width: 80px;
      }

      .browser-site-add:hover {
        background: hsl(var(--accent));
        transform: none;
      }

      .browser-site-add-icon {
        width: 48px;
        height: 48px;
        background: hsl(var(--accent));
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        color: hsl(var(--muted-foreground));
      }

      .browser-site-title {
        font-size: 11px;
        color: hsl(var(--foreground));
        text-align: center;
        transition: color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        max-width: 100%;
        overflow: hidden;
        text-overflow: ellipsis;
        line-height: 1.3;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        line-clamp: 2;
        -webkit-box-orient: vertical;
        word-break: break-word;
      }

      .browser-site-remove {
        position: absolute;
        top: 8px;
        right: 8px;
        width: 24px;
        height: 24px;
        background: hsl(var(--destructive));
        border-radius: 50%;
        display: none;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        color: white;
        font-size: 14px;
        z-index: 10;
      }

      /* Add Site Dialog */
      .add-site-dialog-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        backdrop-filter: blur(4px);
      }

      .add-site-dialog {
        background: hsl(var(--background));
        border: 1px solid hsl(var(--border));
        border-radius: 12px;
        padding: 24px;
        width: 400px;
        max-width: 90vw;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      }

      .add-site-dialog h3 {
        font-size: 18px;
        font-weight: 600;
        margin: 0 0 20px 0;
        color: hsl(var(--foreground));
      }

      .add-site-form {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .add-site-input-group {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .add-site-label {
        font-size: 13px;
        font-weight: 500;
        color: hsl(var(--foreground));
      }

      .add-site-input {
        padding: 10px 12px;
        background: hsl(var(--input));
        border: 1px solid hsl(var(--border));
        border-radius: 8px;
        font-size: 14px;
        color: hsl(var(--foreground));
        outline: none;
        transition: all 0.2s;
      }

      .add-site-input:focus {
        border-color: hsl(var(--primary));
        box-shadow: 0 0 0 3px hsl(var(--primary) / 0.1);
      }

      .add-site-buttons {
        display: flex;
        gap: 12px;
        justify-content: flex-end;
        margin-top: 8px;
      }

      .add-site-button {
        padding: 10px 20px;
        border: none;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
      }

      .add-site-button-cancel {
        background: hsl(var(--secondary));
        color: hsl(var(--secondary-foreground));
      }

      .add-site-button-cancel:hover {
        background: hsl(var(--secondary) / 0.8);
      }

      .add-site-button-submit {
        background: hsl(var(--primary));
        color: hsl(var(--primary-foreground));
      }

      .add-site-button-submit:hover {
        background: hsl(var(--primary) / 0.9);
      }

      /* Edit/Delete Icons on Bookmarks */
      .browser-bookmark {
        position: relative;
      }

      .browser-bookmark-actions {
        position: absolute;
        top: 50%;
        right: 8px;
        transform: translateY(-50%);
        display: none;
        gap: 4px;
        align-items: center;
      }

      .browser-bookmark.show-actions .browser-bookmark-actions {
        display: flex;
      }

      .browser-bookmark-action {
        width: 20px;
        height: 20px;
        border-radius: 4px;
        background: hsl(var(--background));
        border: 1px solid hsl(var(--border));
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.15s;
      }

      .browser-bookmark-action:hover {
        background: hsl(var(--primary));
        border-color: hsl(var(--primary));
        color: hsl(var(--primary-foreground));
      }

      .browser-bookmark-action svg {
        width: 12px;
        height: 12px;
      }

      /* Edit icons on saved sites */
      .browser-site-edit {
        position: absolute;
        top: 8px;
        right: 36px;
        width: 24px;
        height: 24px;
        background: hsl(var(--primary));
        border-radius: 50%;
        display: none;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        color: white;
        font-size: 12px;
        z-index: 10;
      }

      .browser-site-card.show-actions .browser-site-edit {
        display: flex;
      }

      .youtube-container {
        display: flex;
        flex-direction: column;
        flex: 1;
        background: #0f0f0f;
        overflow: hidden;
      }

      .youtube-header {
        display: flex;
        align-items: center;
        gap: 20px;
        padding: 12px 24px;
        background: #0f0f0f;
        border-bottom: 1px solid #272727;
      }

      .youtube-logo {
        display: flex;
        align-items: center;
        gap: 8px;
        color: #ff0000;
        font-size: 18px;
        font-weight: bold;
      }

      .youtube-logo span {
        color: white;
      }

      .youtube-search {
        flex: 1;
        max-width: 600px;
        display: flex;
        gap: 0;
      }

      .youtube-search input {
        flex: 1;
        padding: 10px 16px;
        background: #121212;
        border: 1px solid #303030;
        border-right: none;
        border-radius: 20px 0 0 20px;
        color: white;
        font-size: 14px;
        outline: none;
      }

      .youtube-search input:focus {
        border-color: #1c62b9;
      }

      .youtube-search button {
        width: 64px;
        background: #222;
        border: 1px solid #303030;
        border-left: none;
        border-radius: 0 20px 20px 0;
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .youtube-search button:hover {
        background: #303030;
      }

      .youtube-search button svg {
        width: 20px;
        height: 20px;
      }

      .youtube-content {
        display: flex;
        height: calc(100% - 60px);
        overflow: hidden;
      }

      .youtube-sidebar {
        width: 200px;
        background: #0f0f0f;
        padding: 12px 8px;
        overflow-y: auto;
        border-right: 1px solid #272727;
        scrollbar-width: thin;
        scrollbar-color: rgba(128, 128, 128, 0.5) transparent;
      }

      .youtube-sidebar::-webkit-scrollbar {
        width: 8px;
      }

      .youtube-sidebar::-webkit-scrollbar-track {
        background: transparent;
      }

      .youtube-sidebar::-webkit-scrollbar-thumb {
        background: rgba(128, 128, 128, 0.5);
        border-radius: 10px;
        border: 2px solid transparent;
        background-clip: padding-box;
      }

      .youtube-sidebar::-webkit-scrollbar-thumb:hover {
        background: rgba(128, 128, 128, 0.7);
        background-clip: padding-box;
      }

      .youtube-nav-item {
        display: flex;
        align-items: center;
        gap: 16px;
        padding: 12px 16px;
        color: white;
        cursor: pointer;
        border-radius: 8px;
        transition: background 0.2s;
        font-size: 14px;
      }

      .youtube-nav-item:hover {
        background: #272727;
      }

      .youtube-nav-item.active {
        background: #272727;
      }

      .youtube-nav-item svg {
        width: 20px;
        height: 20px;
      }

      .youtube-videos {
        flex: 1;
        padding: 24px;
        overflow-y: auto;
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        gap: 24px;
        align-content: start;
        scrollbar-width: thin;
        scrollbar-color: rgba(128, 128, 128, 0.5) transparent;
      }

      .youtube-videos::-webkit-scrollbar {
        width: 12px;
      }

      .youtube-videos::-webkit-scrollbar-track {
        background: transparent;
      }

      .youtube-videos::-webkit-scrollbar-thumb {
        background: rgba(128, 128, 128, 0.5);
        border-radius: 10px;
        border: 3px solid transparent;
        background-clip: padding-box;
      }

      .youtube-videos::-webkit-scrollbar-thumb:hover {
        background: rgba(128, 128, 128, 0.7);
        background-clip: padding-box;
      }

      .youtube-video-card {
        cursor: pointer;
        transition: transform 0.2s;
      }

      .youtube-video-card:hover {
        transform: scale(1.02);
      }

      .youtube-thumbnail {
        position: relative;
        width: 100%;
        aspect-ratio: 16/9;
        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        border-radius: 12px;
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }

      .youtube-play-icon {
        font-size: 48px;
        color: white;
        opacity: 0.9;
      }

      .youtube-duration {
        position: absolute;
        bottom: 8px;
        right: 8px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: 600;
      }

      .youtube-video-info h3 {
        color: white;
        font-size: 14px;
        font-weight: 500;
        margin-bottom: 8px;
        line-height: 1.4;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }

      .youtube-channel {
        color: #aaa;
        font-size: 13px;
        margin-bottom: 4px;
      }

      .youtube-stats {
        color: #aaa;
        font-size: 12px;
      }

      /* Window Snap Indicator */
      .snap-indicator {
        position: fixed;
        pointer-events: none;
        background: hsl(var(--primary) / 0.2);
        border: 2px solid hsl(var(--primary) / 0.6);
        border-radius: 8px;
        z-index: 50;
        opacity: 0;
        transition: opacity 0.2s cubic-bezier(0.4, 0, 0.2, 1),
                    left 0.15s cubic-bezier(0.4, 0, 0.2, 1),
                    top 0.15s cubic-bezier(0.4, 0, 0.2, 1),
                    width 0.15s cubic-bezier(0.4, 0, 0.2, 1),
                    height 0.15s cubic-bezier(0.4, 0, 0.2, 1),
                    border-radius 0.15s cubic-bezier(0.4, 0, 0.2, 1);
        will-change: opacity, left, top, width, height;
      }

      .snap-indicator.active {
        opacity: 1;
      }
      
      .snap-indicator.dragging {
        transition: opacity 0.2s cubic-bezier(0.4, 0, 0.2, 1),
                    left 0.08s cubic-bezier(0.4, 0, 0.2, 1),
                    top 0.08s cubic-bezier(0.4, 0, 0.2, 1),
                    width 0.08s cubic-bezier(0.4, 0, 0.2, 1),
                    height 0.08s cubic-bezier(0.4, 0, 0.2, 1),
                    border-radius 0.08s cubic-bezier(0.4, 0, 0.2, 1);
      }
      
      /* Window snap animation */
      .window.snapping {
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
      }
      
      /* Ensure snap/maximize animations still run even when global animations are disabled */
      body.no-animations .window.snapping,
      body.no-animations .window.maximizing,
      body.no-animations .window.restoring {
        transition-duration: 0.3s !important;
        transition-delay: 0s !important;
        animation-duration: 0.3s !important;
        animation-delay: 0s !important;
      }
      
      /* Disable transitions during drag */
      .window.dragging {
        transition: none !important;
      }
      
      /* Borderless fullscreen styles */
      .window.fullscreen {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        border-radius: 0 !important;
        z-index: 99999 !important;
        box-shadow: none !important;
      }
      
      .window.fullscreen .window-content {
        height: 100% !important;
        border-radius: 0 !important;
      }
      
      /* Fullscreen overlay UI - shows on hover */
      .fullscreen-overlay-ui {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        z-index: 100000;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      
      .window.fullscreen .fullscreen-overlay-ui.visible {
        opacity: 1;
      }
      
      /* Invisible hover zone at top to trigger UI */
      .fullscreen-hover-zone {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 60px;
        z-index: 99999;
        pointer-events: auto;
      }
      
      .fullscreen-exit-btn {
        position: absolute;
        top: 12px;
        right: 12px;
        display: flex;
        align-items: center;
        gap: 8px;
        background: rgba(0, 0, 0, 0.75);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 10px;
        padding: 10px 16px;
        color: white;
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
        pointer-events: auto;
        user-select: none;
        transition: all 0.2s ease;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
      }
      
      .fullscreen-exit-btn:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: scale(1.05);
      }
      
      .fullscreen-exit-btn:active {
        transform: scale(0.98);
      }
      
      .fullscreen-hint {
        position: absolute;
        top: 12px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border-radius: 8px;
        padding: 8px 16px;
        color: rgba(255, 255, 255, 0.7);
        font-size: 12px;
        white-space: nowrap;
        pointer-events: none;
      }
      
      /* Hide menubar and dock when any window is fullscreen */
      body:has(.window.fullscreen) .menubar,
      body:has(.window.fullscreen) .dock-container {
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease;
      }
      
      /* Custom Cursor Styles - Dynamically injected from localStorage */
      /* The actual cursor URLs will be injected via JavaScript using base64 data */
      
      /* ============= BOOT SCREEN STYLES - Pure Black with Emerging Logo ============= */
      .boot-screen {
        position: fixed;
        inset: 0;
        background: #000000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 999999;
        opacity: 1;
        transition: opacity 0.8s ease-out;
      }
      
      .boot-screen.fade-out {
        opacity: 0;
        pointer-events: none;
      }
      
      /* Pure black overlay that fades to reveal content */
      .boot-screen::before {
        content: '';
        position: absolute;
        inset: 0;
        background: #000000;
        z-index: 1;
        animation: bootBlackFade 1.2s ease-out 0.3s forwards;
        opacity: 1;
      }
      
      @keyframes bootBlackFade {
        0% {
          opacity: 1;
        }
        100% {
          opacity: 0;
          pointer-events: none;
        }
      }
      
      /* Logo emerges from pure black with dramatic immersion effect */
      .boot-logo {
        width: 100px;
        height: 100px;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        z-index: 2;
        opacity: 0;
        transform: scale(0) translateY(40px);
        animation: bootLogoEmerge 1.8s cubic-bezier(0.16, 1, 0.3, 1) 0.5s forwards;
      }
      
      /* Boot logo circle - matches menubar M logo */
      .boot-logo-circle {
        width: 80px;
        height: 80px;
        border-radius: 50%;
        background: white;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 0 30px rgba(255, 255, 255, 0.2);
        animation: bootLogoGlow 2s ease-in-out 1.8s infinite;
      }
      
      .boot-logo-letter {
        font-size: 44px;
        font-weight: 600;
        color: hsl(220 20% 10%);
        font-family: 'Space Grotesk', sans-serif;
        letter-spacing: 0.02em;
      }
      
      /* Subtle glow ring that expands from logo */
      .boot-logo::before {
        content: '';
        position: absolute;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        background: radial-gradient(circle, rgba(255, 255, 255, 0.15) 0%, transparent 70%);
        transform: scale(0);
        opacity: 0;
        animation: bootGlowRing 2s cubic-bezier(0.16, 1, 0.3, 1) 0.8s forwards;
      }
      
      /* Second expanding ring for depth */
      .boot-logo::after {
        content: '';
        position: absolute;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        border: 1px solid rgba(255, 255, 255, 0.1);
        transform: scale(0);
        opacity: 0;
        animation: bootOuterRing 2.5s cubic-bezier(0.16, 1, 0.3, 1) 1s forwards;
      }
      
      @keyframes bootLogoEmerge {
        0% {
          opacity: 0;
          transform: scale(0) translateY(40px);
          filter: blur(10px);
        }
        40% {
          opacity: 0.5;
          transform: scale(0.6) translateY(20px);
          filter: blur(5px);
        }
        70% {
          opacity: 0.9;
          transform: scale(1.05) translateY(-5px);
          filter: blur(0px);
        }
        85% {
          transform: scale(0.98) translateY(2px);
        }
        100% {
          opacity: 1;
          transform: scale(1) translateY(0);
          filter: blur(0px);
        }
      }
      
      @keyframes bootLogoGlow {
        0%, 100% {
          box-shadow: 0 0 30px rgba(255, 255, 255, 0.2);
        }
        50% {
          box-shadow: 0 0 60px rgba(255, 255, 255, 0.4);
        }
      }
      
      @keyframes bootGlowRing {
        0% {
          transform: scale(0);
          opacity: 0;
        }
        50% {
          opacity: 1;
        }
        100% {
          transform: scale(3);
          opacity: 0;
        }
      }
      
      @keyframes bootOuterRing {
        0% {
          transform: scale(0);
          opacity: 0;
        }
        30% {
          opacity: 0.5;
        }
        100% {
          transform: scale(5);
          opacity: 0;
        }
      }
      
      /* Hide old boot elements */
      .boot-title,
      .boot-loader,
      .boot-status,
      .boot-refresh-hint {
        display: none !important;
      }
      
      /* ============= POWER-OFF SCREEN STYLES ============= */
      .power-off-screen {
        position: fixed;
        inset: 0;
        background: #000000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 1000000;
        opacity: 1;
        transition: opacity 0.8s ease-out;
        pointer-events: auto;
      }
      
      .power-off-screen.hidden {
        opacity: 0;
        pointer-events: none;
        visibility: hidden;
      }
      
      .power-off-screen:not(.hidden) {
        visibility: visible;
        pointer-events: auto;
      }
      
      /* Cursor fix for power screens and dialogs */
      .custom-cursors-enabled .power-off-screen,
      .custom-cursors-enabled .power-off-screen *,
      .custom-cursors-enabled .sleep-screen,
      .custom-cursors-enabled .sleep-screen *,
      .custom-cursors-enabled .shutdown-dialog-overlay,
      .custom-cursors-enabled .shutdown-dialog-overlay *,
      .custom-cursors-enabled .shutdown-animation-screen,
      .custom-cursors-enabled .shutdown-animation-screen *,
      .custom-cursors-enabled .boot-up-animation,
      .custom-cursors-enabled .boot-up-animation *,
      .custom-cursors-enabled .boot-screen,
      .custom-cursors-enabled .boot-screen *,
      .custom-cursors-enabled .setup-screen,
      .custom-cursors-enabled .setup-screen *,
      .custom-cursors-enabled .lockscreen,
      .custom-cursors-enabled .lockscreen * {
        cursor: none !important;
      }
      
      /* Power-off monitor - white frame with rounded corners, black screen inside */
      .power-off-monitor {
        width: 320px;
        height: 200px;
        background: #000000;
        border: 8px solid #ffffff;
        border-radius: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        position: relative;
        box-shadow: 0 0 60px rgba(255, 255, 255, 0.1);
      }
      
      /* Disable expanding animation */
      .power-off-monitor.expanding {
        width: 320px;
        height: 200px;
        border-radius: 20px;
        border: 8px solid #ffffff;
      }
      
      .power-off-monitor::after {
        display: none;
      }
      
      /* Power button - simple white outline */
      .power-button {
        width: 56px;
        height: 56px;
        border-radius: 50%;
        background: transparent;
        border: 2px solid #ffffff;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
        pointer-events: auto;
        position: relative;
        z-index: 10;
      }
      
      .power-button::before {
        display: none;
      }
      
      .power-button:hover {
        background: rgba(255, 255, 255, 0.1);
      }
      
      .power-button:active {
        transform: scale(0.95);
      }
      
      .power-button svg {
        width: 24px;
        height: 24px;
        stroke: #ffffff;
      }
      
      .power-button:hover svg {
        stroke: #ffffff;
      }
      
      .power-off-hint {
        color: #666;
        font-size: 11px;
        margin-top: 40px;
        letter-spacing: 1px;
        text-transform: uppercase;
      }
      
      /* ============= SHUTDOWN DIALOG STYLES ============= */
      .shutdown-dialog-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 999999;
        opacity: 0;
        animation: shutdownDialogFadeIn 0.3s ease forwards;
      }
      
      @keyframes shutdownDialogFadeIn {
        to { opacity: 1; }
      }
      
      .shutdown-dialog {
        background: hsl(var(--window-bg));
        border: 1px solid hsl(var(--window-border));
        border-radius: 20px;
        padding: 32px;
        min-width: 320px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
        transform: scale(0.9) translateY(20px);
        animation: shutdownDialogSlideIn 0.3s ease forwards;
      }
      
      @keyframes shutdownDialogSlideIn {
        to { transform: scale(1) translateY(0); }
      }
      
      .shutdown-dialog-title {
        font-size: 18px;
        font-weight: 600;
        color: hsl(var(--foreground));
        text-align: center;
        margin-bottom: 24px;
      }
      
      .shutdown-dialog-options {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      
      .shutdown-option {
        display: flex;
        align-items: center;
        gap: 14px;
        padding: 14px 18px;
        background: hsl(var(--accent) / 0.5);
        border: 1px solid hsl(var(--window-border));
        border-radius: 12px;
        cursor: pointer;
        transition: all 0.2s ease;
        color: hsl(var(--foreground));
        font-size: 14px;
        font-weight: 500;
      }
      
      .shutdown-option:hover {
        background: hsl(var(--accent));
        border-color: hsl(var(--foreground) / 0.2);
        transform: translateX(4px);
      }
      
      .shutdown-option.destructive:hover {
        background: hsl(0 70% 50% / 0.15);
        border-color: hsl(0 70% 50% / 0.3);
      }
      
      .shutdown-option svg {
        width: 22px;
        height: 22px;
        stroke: currentColor;
        flex-shrink: 0;
      }
      
      .shutdown-dialog-cancel {
        margin-top: 16px;
        padding: 12px;
        background: transparent;
        border: 1px solid hsl(var(--window-border));
        border-radius: 10px;
        color: hsl(var(--muted-foreground));
        font-size: 13px;
        cursor: pointer;
        transition: all 0.2s ease;
        width: 100%;
      }
      
      .shutdown-dialog-cancel:hover {
        background: hsl(var(--accent) / 0.5);
        color: hsl(var(--foreground));
      }
      
      /* ============= SLEEP SCREEN STYLES ============= */
      .sleep-screen {
        position: fixed;
        inset: 0;
        background: #000000;
        z-index: 999998;
        opacity: 0;
        pointer-events: none;
        transition: opacity 1s ease;
      }
      
      .sleep-screen.active {
        opacity: 1;
        pointer-events: auto;
      }
      
      /* ============= SHUTDOWN/RESTART ANIMATION STYLES ============= */
      .shutdown-animation-screen {
        position: fixed;
        inset: 0;
        background: #000000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 1000001;
        opacity: 0;
        animation: shutdownFadeIn 0.5s ease forwards;
      }
      
      @keyframes shutdownFadeIn {
        to { opacity: 1; }
      }
      
      .shutdown-logo {
        width: 60px;
        height: 60px;
        animation: shutdownLogoFade 1.5s ease-in-out forwards;
      }
      
      @keyframes shutdownLogoFade {
        0% { opacity: 1; transform: scale(1); }
        100% { opacity: 0; transform: scale(0.8); }
      }
      
      .shutdown-text {
        color: #666;
        font-size: 13px;
        margin-top: 20px;
        letter-spacing: 1px;
        animation: shutdownTextFade 1.5s ease-in-out forwards;
      }
      
      @keyframes shutdownTextFade {
        0% { opacity: 1; }
        100% { opacity: 0; }
      }
      
      /* ============= BOOT-UP ANIMATION (from power-off) ============= */
      .boot-up-animation {
        position: fixed;
        inset: 0;
        background: #000000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 1000000;
      }
      
      .boot-up-logo {
        width: 80px;
        height: 80px;
        opacity: 0;
        animation: bootUpLogoAnim 2s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
      }
      
      @keyframes bootUpLogoAnim {
        0% { opacity: 0; transform: scale(0.3) rotate(-10deg); }
        40% { opacity: 1; transform: scale(1.15) rotate(3deg); }
        60% { transform: scale(0.95) rotate(-1deg); }
        80% { transform: scale(1.02) rotate(0.5deg); }
        100% { opacity: 1; transform: scale(1) rotate(0deg); }
      }
      
      .boot-up-glow {
        position: absolute;
        width: 120px;
        height: 120px;
        border-radius: 50%;
        background: radial-gradient(circle, rgba(255, 255, 255, 0.35) 0%, rgba(200, 200, 200, 0.15) 40%, transparent 70%);
        animation: bootUpGlow 2s cubic-bezier(0.16, 1, 0.3, 1) forwards;
      }
      
      @keyframes bootUpGlow {
        0% { opacity: 0; transform: scale(0.3) rotate(0deg); }
        30% { opacity: 1; transform: scale(1.2) rotate(45deg); }
        60% { opacity: 0.8; transform: scale(1.8) rotate(90deg); }
        100% { opacity: 0; transform: scale(2.5) rotate(180deg); }
      }
      
      /* Boot particles for playful effect - monochrome */
      .boot-particle {
        position: absolute;
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.8);
        animation: bootParticle 1.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
      }
      
      @keyframes bootParticle {
        0% { opacity: 0; transform: translate(0, 0) scale(0); }
        30% { opacity: 1; transform: scale(1); }
        100% { opacity: 0; transform: translate(var(--tx), var(--ty)) scale(0); }
      }
      
      /* ============= FIRST-BOOT SETUP STYLES ============= */
      .setup-screen {
        position: fixed;
        inset: 0;
        background: hsl(var(--background));
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 999998;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.5s ease, 
                    background-color 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      }
      
      .setup-screen.active {
        opacity: 1;
        pointer-events: auto;
      }
      
      /* Smooth theme transition for setup screen elements */
      .setup-screen,
      .setup-container,
      .setup-logo,
      .setup-title,
      .setup-subtitle,
      .setup-label,
      .setup-input,
      .setup-hint,
      .setup-option,
      .setup-option-label,
      .setup-cursor-option,
      .setup-cursor-name,
      .setup-btn,
      .setup-btn-primary,
      .setup-btn-secondary,
      .setup-progress-dot {
        transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      }
      
      .setup-container {
        width: 100%;
        max-width: 440px;
        padding: 40px;
        background: hsl(var(--window-bg));
        border: 1px solid hsl(var(--window-border));
        border-radius: 28px;
        box-shadow: 0 20px 60px hsl(var(--shadow-color) / 0.3);
        transition: background-color 0.6s cubic-bezier(0.4, 0, 0.2, 1),
                    border-color 0.6s cubic-bezier(0.4, 0, 0.2, 1),
                    box-shadow 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      }
      
      .setup-header {
        text-align: center;
        margin-bottom: 32px;
      }
      
      .setup-logo {
        width: 80px;
        height: 80px;
        background: hsl(var(--foreground));
        border-radius: 22px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 42px;
        font-weight: 700;
        color: hsl(var(--background));
        margin-bottom: 16px;
        box-shadow: 0 8px 24px hsl(var(--shadow-color) / 0.3);
      }
      
      .setup-title {
        font-size: 28px;
        font-weight: 600;
        color: hsl(var(--foreground));
        margin-bottom: 8px;
      }
      
      .setup-subtitle {
        font-size: 14px;
        color: hsl(var(--muted-foreground));
      }
      
      .setup-step {
        display: none;
      }
      
      .setup-step.active {
        display: block;
        animation: setupFadeIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      }
      
      @keyframes setupFadeIn {
        0% { opacity: 0; transform: translateY(20px) scale(0.95); }
        60% { opacity: 1; transform: translateY(-5px) scale(1.02); }
        100% { opacity: 1; transform: translateY(0) scale(1); }
      }
      
      .setup-field {
        margin-bottom: 20px;
      }
      
      .setup-label {
        display: block;
        font-size: 13px;
        font-weight: 500;
        color: hsl(var(--foreground) / 0.8);
        margin-bottom: 8px;
      }
      
      .setup-input {
        width: 100%;
        padding: 14px 16px;
        background: hsl(var(--accent) / 0.5);
        border: 1px solid hsl(var(--window-border));
        border-radius: 14px;
        font-size: 15px;
        color: hsl(var(--foreground));
        outline: none;
        transition: all 0.2s;
        font-family: 'Space Grotesk', sans-serif;
      }
      
      .setup-input:focus {
        border-color: hsl(var(--primary));
        background: hsl(var(--primary) / 0.05);
        box-shadow: 0 0 0 3px hsl(var(--primary) / 0.15);
      }
      
      .setup-input::placeholder {
        color: hsl(var(--muted-foreground) / 0.5);
      }
      
      .setup-hint {
        font-size: 12px;
        color: hsl(var(--muted-foreground));
        margin-top: 6px;
      }
      
      .setup-options {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
        margin-bottom: 20px;
      }
      
      .setup-option {
        padding: 16px;
        background: hsl(var(--accent) / 0.5);
        border: 2px solid hsl(var(--window-border));
        border-radius: 16px;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        text-align: center;
      }
      
      .setup-option:hover {
        background: hsl(var(--accent));
        border-color: hsl(var(--foreground) / 0.3);
        transform: translateY(-3px) scale(1.02);
      }
      
      .setup-option:active {
        transform: translateY(0) scale(0.98);
      }
      
      .setup-option.selected {
        background: hsl(var(--primary) / 0.15);
        border-color: hsl(var(--primary));
        animation: optionSelect 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      }
      
      @keyframes optionSelect {
        0% { transform: scale(1); }
        40% { transform: scale(1.08); }
        100% { transform: scale(1); }
      }
      
      .setup-option-icon {
        font-size: 32px;
        margin-bottom: 8px;
      }
      
      .setup-option-label {
        font-size: 13px;
        font-weight: 500;
        color: hsl(var(--foreground));
      }
      
      .setup-cursor-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
        margin-bottom: 20px;
      }
      
      .setup-cursor-option {
        aspect-ratio: 1.5;
        background: hsl(var(--accent) / 0.5);
        border: 2px solid hsl(var(--window-border));
        border-radius: 16px;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 8px;
        padding: 12px;
      }
      
      .setup-cursor-option:hover {
        background: hsl(var(--accent));
        border-color: hsl(var(--foreground) / 0.3);
      }
      
      .setup-cursor-option.selected {
        background: hsl(var(--primary) / 0.15);
        border-color: hsl(var(--primary));
      }
      
      .setup-cursor-preview {
        font-size: 28px;
      }
      
      .setup-cursor-name {
        font-size: 11px;
        color: hsl(var(--muted-foreground));
        text-align: center;
      }
      
      .setup-buttons {
        display: flex;
        gap: 12px;
        margin-top: 24px;
      }
      
      .setup-btn {
        flex: 1;
        padding: 14px 24px;
        border: none;
        border-radius: 14px;
        font-size: 15px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        font-family: 'Space Grotesk', sans-serif;
      }
      
      .setup-btn-secondary {
        background: hsl(var(--accent));
        color: hsl(var(--foreground));
      }
      
      .setup-btn-secondary:hover {
        background: hsl(var(--accent-hover));
        transform: translateY(-2px);
      }
      
      .setup-btn-secondary:active {
        transform: translateY(0) scale(0.97);
      }
      
      .setup-btn-primary {
        background: hsl(var(--foreground));
        color: hsl(var(--background));
      }
      
      .setup-btn-primary:hover {
        transform: translateY(-3px) scale(1.02);
        box-shadow: 0 10px 30px hsl(var(--shadow-color) / 0.5);
      }
      
      .setup-btn-primary:active {
        transform: translateY(0) scale(0.98);
      }
      
      .setup-progress {
        display: flex;
        justify-content: center;
        gap: 8px;
        margin-top: 24px;
      }
      
      .setup-progress-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: hsl(var(--foreground) / 0.2);
        transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      }
      
      .setup-progress-dot.active {
        background: hsl(var(--primary));
        width: 24px;
        border-radius: 4px;
        animation: dotPulse 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
      }
      
      @keyframes dotPulse {
        0% { transform: scale(0.8); }
        50% { transform: scale(1.2); }
        100% { transform: scale(1); }
      }
      
      .setup-progress-dot.completed {
        background: hsl(var(--primary) / 0.5);
      }
      
      /* ============= LOCKSCREEN STYLES ============= */
      .lockscreen {
        position: fixed;
        inset: 0;
        background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0f0f1a 100%);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 999997;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.4s ease;
        cursor: pointer;
      }
      
      .lockscreen.active {
        opacity: 1;
        pointer-events: auto;
      }
      
      /* Lockscreen background - NO blur by default */
      .lockscreen-bg {
        position: absolute;
        inset: 0;
        background-size: cover;
        background-position: center;
        transition: filter 0.4s ease, transform 0.4s ease;
      }
      
      /* Initial state - time only view (bright, no blur) */
      .lockscreen:not(.unlock-view) .lockscreen-bg {
        filter: brightness(1);
        transform: scale(1);
      }
      
      /* Unlock view state - blurred background */
      .lockscreen.unlock-view .lockscreen-bg {
        filter: blur(20px) brightness(0.7);
        transform: scale(1.1);
      }
      
      .lockscreen-content {
        position: relative;
        z-index: 1;
        text-align: center;
        transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1);
      }
      
      /* Time display - larger in initial view */
      .lockscreen-time {
        font-size: 120px;
        font-weight: 200;
        color: white;
        font-family: var(--lockscreen-clock-font, 'Space Grotesk'), sans-serif;
        letter-spacing: var(--lockscreen-clock-spacing, -3px);
        line-height: 1;
        text-shadow: 0 4px 40px rgba(0, 0, 0, 0.7), 0 2px 10px rgba(0, 0, 0, 0.5), 0 0 80px rgba(0, 0, 0, 0.4);
        transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1);
      }
      
      /* Use accent color for time if enabled */
      .lockscreen.use-accent-time .lockscreen-time {
        color: hsl(var(--primary));
        text-shadow: 0 4px 30px hsl(var(--primary) / 0.3);
      }
      
      .lockscreen-date {
        font-size: 24px;
        color: rgba(255, 255, 255, 0.7);
        margin-top: 12px;
        font-weight: 300;
        text-shadow: 0 2px 20px rgba(0, 0, 0, 0.6), 0 1px 5px rgba(0, 0, 0, 0.4);
        transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1);
      }
      
      /* Clock style variations */
      .lockscreen-time.style-minimal {
        font-weight: 100;
        letter-spacing: -5px;
      }
      .lockscreen-time.style-bold {
        font-weight: 700;
        letter-spacing: 0px;
      }
      .lockscreen-time.style-outlined {
        color: transparent;
        -webkit-text-stroke: 2px white;
      }
      .lockscreen-time.style-retro {
        font-family: 'JetBrains Mono', 'Courier New', monospace;
        letter-spacing: 5px;
        font-weight: 400;
      }
      .lockscreen-time.style-elegant {
        font-family: 'Georgia', 'Times New Roman', serif;
        font-weight: 300;
        font-style: italic;
        letter-spacing: 2px;
      }
      
      /* Swipe up indicator - shown in initial view */
      .lockscreen-swipe-indicator {
        position: absolute;
        bottom: 60px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        opacity: 0.6;
        transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1);
        animation: lockscreenBounce 2s ease-in-out infinite;
      }
      
      .lockscreen-swipe-indicator svg {
        width: 28px;
        height: 28px;
        color: white;
      }
      
      .lockscreen-swipe-indicator span {
        font-size: 13px;
        color: rgba(255, 255, 255, 0.6);
        font-weight: 400;
      }
      
      @keyframes lockscreenBounce {
        0%, 100% { transform: translateX(-50%) translateY(0); }
        50% { transform: translateX(-50%) translateY(-8px); }
      }
      
      /* User section - hidden in initial view with fade animation */
      .lockscreen-user-section {
        opacity: 0;
        transform: translateY(30px) scale(0.95);
        transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1);
        pointer-events: none;
      }
      
      /* Fade in user section when in unlock view */
      .lockscreen.unlock-view .lockscreen-user-section {
        opacity: 1;
        transform: translateY(0) scale(1);
        pointer-events: auto;
        animation: lockscreen-fade-in 0.5s cubic-bezier(0.16, 1, 0.3, 1) forwards;
      }
      
      /* Time/date sections fade up when entering unlock view */
      .lockscreen.unlock-view .lockscreen-time {
        animation: lockscreen-slide-up 0.5s cubic-bezier(0.16, 1, 0.3, 1) forwards;
      }
      
      .lockscreen.unlock-view .lockscreen-date {
        animation: lockscreen-slide-up 0.5s cubic-bezier(0.16, 1, 0.3, 1) 0.05s forwards;
      }
      
      /* Fade out animation for exiting unlock view */
      .lockscreen:not(.unlock-view) .lockscreen-user-section {
        animation: lockscreen-fade-out 0.4s cubic-bezier(0.16, 1, 0.3, 1) forwards;
      }
      
      @keyframes lockscreen-fade-in {
        0% {
          opacity: 0;
          transform: translateY(30px) scale(0.95);
        }
        100% {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
      }
      
      @keyframes lockscreen-fade-out {
        0% {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
        100% {
          opacity: 0;
          transform: translateY(30px) scale(0.95);
        }
      }
      
      @keyframes lockscreen-slide-up {
        0% {
          transform: translateY(0);
        }
        100% {
          transform: translateY(-40px);
        }
      }
      
      /* Hide swipe indicator when in unlock view */
      .lockscreen.unlock-view .lockscreen-swipe-indicator {
        opacity: 0;
        transform: translateX(-50%) translateY(20px);
        pointer-events: none;
      }
      
      .lockscreen-avatar {
        width: 96px;
        height: 96px;
        background: linear-gradient(135deg, hsl(var(--primary)), hsl(var(--primary-glow, var(--primary))));
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 42px;
        font-weight: 600;
        color: white;
        margin: 40px auto 16px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        transition: all 0.3s ease;
      }
      
      .lockscreen-username {
        font-size: 22px;
        font-weight: 500;
        color: white;
        margin-bottom: 24px;
      }
      
      .lockscreen-password-container {
        position: relative;
        width: 280px;
        margin: 0 auto;
      }
      
      .lockscreen-password {
        width: 100%;
        padding: 16px 48px 16px 20px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 28px;
        font-size: 16px;
        color: white;
        outline: none;
        transition: all 0.2s;
        font-family: 'Space Grotesk', sans-serif;
        text-align: center;
      }
      
      .lockscreen-password:focus {
        border-color: hsl(var(--primary));
        background: hsl(var(--primary) / 0.1);
        box-shadow: 0 0 0 3px hsl(var(--primary) / 0.2);
      }
      
      .lockscreen-password::placeholder {
        color: rgba(255, 255, 255, 0.4);
      }
      
      .lockscreen-submit {
        position: absolute;
        right: 6px;
        top: 50%;
        transform: translateY(-50%);
        width: 36px;
        height: 36px;
        background: linear-gradient(135deg, hsl(var(--primary)), hsl(var(--primary-glow, var(--primary))));
        border: none;
        border-radius: 50%;
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
      }
      
      .lockscreen-submit:hover {
        transform: translateY(-50%) scale(1.1);
      }
      
      .lockscreen-submit svg {
        width: 18px;
        height: 18px;
      }
      
      .lockscreen-error {
        margin-top: 16px;
        font-size: 14px;
        color: #ff6b6b;
        opacity: 0;
        transform: translateY(-10px);
        transition: all 0.3s ease;
        pointer-events: none;
      }
      
      .lockscreen-error.visible {
        opacity: 1;
        transform: translateY(0);
        animation: lockscreenShake 0.4s ease;
      }
      
      @keyframes lockscreenShake {
        0%, 100% { transform: translateX(0); }
        25% { transform: translateX(-8px); }
        50% { transform: translateX(8px); }
        75% { transform: translateX(-4px); }
      }
      
      /* No password lockscreen */
      .lockscreen-unlock-btn {
        margin-top: 24px;
        padding: 14px 32px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 28px;
        color: white;
        font-size: 15px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        font-family: 'Space Grotesk', sans-serif;
      }
      
      .lockscreen-unlock-btn:hover {
        background: hsl(var(--primary) / 0.2);
        border-color: hsl(var(--primary) / 0.4);
        transform: translateY(-2px);
      }
      
      /* UNLOCK VIEW STATE - show user section, hide swipe indicator */
      .lockscreen.unlock-view .lockscreen-content {
        transform: translateY(-20px);
      }
      
      .lockscreen.unlock-view .lockscreen-time {
        font-size: 72px;
      }
      
      .lockscreen.unlock-view .lockscreen-date {
        font-size: 18px;
      }
      
      .lockscreen.unlock-view .lockscreen-user-section {
        opacity: 1;
        transform: translateY(0);
        pointer-events: auto;
      }
      
      .lockscreen.unlock-view .lockscreen-swipe-indicator {
        opacity: 0;
        transform: translateX(-50%) translateY(20px);
        pointer-events: none;
      }
      
      /* Back button to return to time view */
      .lockscreen-back-btn {
        position: absolute;
        top: 24px;
        left: 24px;
        width: 40px;
        height: 40px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 50%;
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        transform: translateX(-20px);
        transition: all 0.3s ease;
        pointer-events: none;
        z-index: 10;
      }
      
      .lockscreen-back-btn svg {
        width: 20px;
        height: 20px;
      }
      
      .lockscreen.unlock-view .lockscreen-back-btn {
        opacity: 0.7;
        transform: translateX(0);
        pointer-events: auto;
      }
      
      .lockscreen.unlock-view .lockscreen-back-btn:hover {
        opacity: 1;
        background: rgba(255, 255, 255, 0.2);
      }
      
      /* ============= VERSION PICKER DIALOG STYLES ============= */
      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }
      
      @keyframes scaleIn {
        from { 
          opacity: 0;
          transform: scale(0.95);
        }
        to { 
          opacity: 1;
          transform: scale(1);
        }
      }
      
      .version-picker-overlay {
        animation: fadeIn 0.2s ease;
      }
    </style>
  </head>
  <body>
    <!-- Power-Off Screen (shown after shutdown) - visible by default, hidden by JS when appropriate -->
    <div id="power-off-screen" class="power-off-screen">
      <div class="power-off-monitor">
        <button class="power-button" onclick="window.powerOnOS()" title="Power On">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M18.36 6.64a9 9 0 1 1-12.73 0"/>
            <line x1="12" y1="2" x2="12" y2="12"/>
          </svg>
        </button>
      </div>
      <div class="power-off-hint">Press to power on</div>
    </div>
    
    <!-- Sleep Screen -->
    <div id="sleep-screen" class="sleep-screen" onclick="window.wakeFromSleep()" onkeydown="window.wakeFromSleep()"></div>
    
    <!-- Boot Screen - M Logo Circle Style -->
    <div id="boot-screen" class="boot-screen">
      <div class="boot-logo">
        <div class="boot-logo-circle">
          <span class="boot-logo-letter">M</span>
        </div>
      </div>
    </div>
    
    <!-- First-Boot Setup Screen -->
    <div id="setup-screen" class="setup-screen">
      <div class="setup-container">
        <div class="setup-header">
          <div class="setup-logo">M</div>
          <h1 class="setup-title">Welcome to M OS</h1>
          <p class="setup-subtitle">Let's set up your new desktop</p>
        </div>
        
        <!-- Step 1: Username -->
        <div class="setup-step active" data-step="1">
          <div class="setup-field">
            <label class="setup-label">What's your name?</label>
            <input type="text" class="setup-input" id="setup-username" placeholder="Enter your name" autocomplete="off" maxlength="32">
            <p class="setup-hint">This will be displayed on the lockscreen</p>
          </div>
        </div>
        
        <!-- Step 2: Password (optional) -->
        <div class="setup-step" data-step="2">
          <div class="setup-field">
            <label class="setup-label">Set a password (optional)</label>
            <input type="password" class="setup-input" id="setup-password" placeholder="Enter password" autocomplete="new-password">
            <p class="setup-hint">Leave empty to skip password protection</p>
          </div>
          <div class="setup-field">
            <label class="setup-label">Confirm password</label>
            <input type="password" class="setup-input" id="setup-password-confirm" placeholder="Confirm password" autocomplete="new-password">
          </div>
        </div>
        
        <!-- Step 3: Theme -->
        <div class="setup-step" data-step="3">
          <label class="setup-label">Choose your theme</label>
          <div class="setup-options">
            <div class="setup-option" data-theme="light" onclick="selectSetupTheme('light')">
              <div class="setup-option-icon"></div>
              <div class="setup-option-label">Light</div>
            </div>
            <div class="setup-option selected" data-theme="dark" onclick="selectSetupTheme('dark')">
              <div class="setup-option-icon"></div>
              <div class="setup-option-label">Dark</div>
            </div>
          </div>
        </div>
        
        <!-- Step 4: Sound -->
        <div class="setup-step" data-step="4">
          <label class="setup-label">Enable system sounds?</label>
          <div class="setup-options">
            <div class="setup-option selected" data-sound="true" onclick="selectSetupSound(true)">
              <div class="setup-option-icon"></div>
              <div class="setup-option-label">Sounds On</div>
            </div>
            <div class="setup-option" data-sound="false" onclick="selectSetupSound(false)">
              <div class="setup-option-icon"></div>
              <div class="setup-option-label">Sounds Off</div>
            </div>
          </div>
          <p class="setup-hint">LineageOS sounds will be downloaded</p>
        </div>
        
        <!-- Step 5: Cursor -->
        <div class="setup-step" data-step="5">
          <label class="setup-label">Choose your cursor style</label>
          <div class="setup-cursor-grid">
            <div class="setup-cursor-option selected" data-cursor="default" onclick="selectSetupCursor('default')">
              <div class="setup-cursor-preview"></div>
              <div class="setup-cursor-name">Default</div>
            </div>
            <div class="setup-cursor-option" data-cursor="custom" onclick="selectSetupCursor('custom')">
              <div class="setup-cursor-preview"></div>
              <div class="setup-cursor-name">M OS Custom</div>
            </div>
          </div>
          <p class="setup-hint" id="setup-cursor-hint">You can change this later in Settings</p>
        </div>
        
        <div class="setup-buttons">
          <button class="setup-btn setup-btn-secondary" id="setup-back-btn" onclick="setupPrevStep()" style="display: none;">Back</button>
          <button class="setup-btn setup-btn-primary" id="setup-next-btn" onclick="setupNextStep()">Continue</button>
        </div>
        
        <div class="setup-progress">
          <div class="setup-progress-dot active" data-dot="1"></div>
          <div class="setup-progress-dot" data-dot="2"></div>
          <div class="setup-progress-dot" data-dot="3"></div>
          <div class="setup-progress-dot" data-dot="4"></div>
          <div class="setup-progress-dot" data-dot="5"></div>
        </div>
      </div>
    </div>
    
    <!-- Lockscreen -->
    <div id="lockscreen" class="lockscreen" onclick="handleLockscreenClick(event)">
      <div class="lockscreen-bg" id="lockscreen-bg"></div>
      
      <!-- Back button (visible in unlock view) -->
      <button class="lockscreen-back-btn" id="lockscreen-back-btn" onclick="exitUnlockView(event)">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="15 18 9 12 15 6"></polyline>
        </svg>
      </button>
      
      <div class="lockscreen-content">
        <!-- Time/Date section (always visible) -->
        <div class="lockscreen-time" id="lockscreen-time">00:00</div>
        <div class="lockscreen-date" id="lockscreen-date">Monday, January 1</div>
        
        <!-- User section (revealed on click/swipe) -->
        <div class="lockscreen-user-section" id="lockscreen-user-section">
          <div class="lockscreen-avatar" id="lockscreen-avatar">U</div>
          <div class="lockscreen-username" id="lockscreen-username">User</div>
          <div class="lockscreen-password-container" id="lockscreen-password-container">
            <input type="password" class="lockscreen-password" id="lockscreen-password" placeholder="Enter password" onclick="event.stopPropagation()">
            <button class="lockscreen-submit" onclick="event.stopPropagation(); unlockScreen()">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="9 18 15 12 9 6"></polyline>
              </svg>
            </button>
          </div>
          <button class="lockscreen-unlock-btn" id="lockscreen-unlock-btn" onclick="event.stopPropagation(); unlockScreen()" style="display: none;">
            Click to unlock
          </button>
          <div class="lockscreen-error" id="lockscreen-error">Incorrect password</div>
        </div>
      </div>
      
      <!-- Swipe up indicator (initial view only) -->
      <div class="lockscreen-swipe-indicator" id="lockscreen-swipe-indicator">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="18 15 12 9 6 15"></polyline>
        </svg>
        <span>Click or swipe up to unlock</span>
      </div>
    </div>
    
    
    <div id="root"></div>

    <script>
      console.log('Script starting...');
      const state = {
        windows: [],
        nextId: 1,
        nextZIndex: 100,
        isDark: false,
        dragging: null,
        resizing: null,
        pinnedApps: [],
        contextMenu: null,
        menubarContextMenu: null, // Context menu right-click menu {x, y}
        contextMenuCustomizeMode: false, // Track if context menu customization mode is active
        contextMenuLayout: JSON.parse(localStorage.getItem('contextMenuLayout') || 'null') || {
          // Default layout - each element has id, position (left/center/right), order
          // Enhanced with more panel applets like Linux Mint/KDE
          elements: [
            { id: 'logo', position: 'left', order: 0, visible: true },
            { id: 'menus', position: 'left', order: 1, visible: true },
            { id: 'separator1', position: 'center', order: 0, visible: false },
            { id: 'workspaces', position: 'center', order: 1, visible: false },
            { id: 'clock', position: 'center', order: 2, visible: true },
            { id: 'separator2', position: 'right', order: 0, visible: false },
            { id: 'systray', position: 'right', order: 1, visible: true },
            { id: 'battery', position: 'right', order: 2, visible: false },
            { id: 'notifications', position: 'right', order: 3, visible: true },
            { id: 'quicksettings', position: 'right', order: 4, visible: false }
          ]
        },
        // Workspace state for virtual desktops
        currentWorkspace: 1,
        totalWorkspaces: 4,
        // Notification state
        notificationCount: 0,
        notifications: JSON.parse(localStorage.getItem('mosNotifications') || '[]'),
        showNotificationPanel: false,
        calendarExpanded: true,
        calendarMonth: new Date().getMonth(),
        calendarYear: new Date().getFullYear(),
        focusTimerMinutes: 30,
        contextMenuDragElement: null, // Currently dragged element id
        currentTime: new Date(),
        terminalHistory: JSON.parse(localStorage.getItem('terminalHistory') || '{}'), // Store terminal output history per window
        inputValues: {}, // Store input values per window
        commandHistory: JSON.parse(localStorage.getItem('commandHistory') || '[]'), // All commands typed
        commandHistoryIndex: -1, // Current position in command history navigation
        customWallpaper: localStorage.getItem('customWallpaper') || null, // Custom wallpaper URL
        customWallpapers: JSON.parse(localStorage.getItem('customWallpapers') || '[]'), // Array of {id, dark, light, name} objects
        activeCustomWallpaper: parseInt(localStorage.getItem('activeCustomWallpaper') || '-2'), // Index of active custom wallpaper (-2 for default Tahoe)
        customCursor: localStorage.getItem('customCursor') || null, // Custom cursor URL
        cursorPack: JSON.parse(localStorage.getItem('cursorPack') || 'null'), // Cursor pack with multiple cursors
        scrollPositions: {}, // Store scroll positions per window
        isScrolling: false, // Track if user is actively scrolling
        scrollTimeout: null, // Timeout for scroll debouncing
        dockPosition: localStorage.getItem('dockPosition') || 'bottom', // Dock position: bottom (macOS style)
        dockSize: 'small', // Dock icon size fixed to small
        dockScale: parseFloat(localStorage.getItem('dockScale') || '1.0'), // Dock scale multiplier (0.5 to 2.0)
        animationsEnabled: localStorage.getItem('animationsEnabled') !== 'false', // Enable/disable animations
        soundEnabled: localStorage.getItem('soundEnabled') !== 'false', // Enable/disable sound effects
        browserUrls: {}, // Store current URL for each browser window
        browserHistory: {}, // Store navigation history for each browser window
        browserHistoryIndex: {}, // Store current position in history for each browser window
        browserTabs: {}, // Store tabs for each browser window {windowId: [{id, title, url, active, loading}]}
        browserTabIframes: {}, // Store preserved iframes per tab {windowId: {tabId: iframeElement}}
        browserBookmarks: JSON.parse(localStorage.getItem('browserBookmarks') || '["https://google.com", "https://youtube.com", "https://github.com", "https://twitter.com"]'),
        browserSavedSites: JSON.parse(localStorage.getItem('browserSavedSites') || '[]'),
        browserSearchHistory: JSON.parse(localStorage.getItem('browserSearchHistory') || '[]'), // Search history
        browserVerticalTabs: localStorage.getItem('browserVerticalTabs') === 'true', // Vertical tabs toggle
        showBrowserHistory: false, // Show history panel
        showAddSiteDialog: false,
        showEditBookmarkDialog: false,
        editingBookmarkIndex: null,
        showEditSiteDialog: false,
        editingSiteIndex: null,
        activeBookmarkIndex: null, // Track which bookmark is showing actions
        activeSiteIndex: null, // Track which saved site is showing actions
        showLaunchpad: false, // Track if launchpad is visible
        accentColor: localStorage.getItem('accentColor') || '#007AFF', // macOS blue accent
        iconPack: localStorage.getItem('iconPack') || 'classic', // Icon pack: classic, accent, monochrome, glass
        launchpadSearch: '', // Search query for launchpad
        windowStates: JSON.parse(localStorage.getItem('windowStates') || '{}'), // Track maximize state per appId
        settingsTab: localStorage.getItem('settingsTab') || 'appearance', // Active settings tab
        settingsSearchQuery: '', // Search query for settings sidebar
        snapZone: null, // Track snap zone: 'left', 'right', 'top', 'top-left', 'top-right'
        isSnappingWindow: false, // Prevent re-renders from killing snap animations
        showQuickSettings: false, // Track if quick settings panel is visible
        themeTransitioning: false, // Track if theme icon is animating
        // Window customization - defaults: 35% transparency (0.65 opacity), 20px blur
        windowOpacity: parseFloat(localStorage.getItem('windowOpacity') || '0.65'), // 0.5 to 1.0
        windowBlur: parseInt(localStorage.getItem('windowBlur') || '20'), // 0 to 20
        systemFont: localStorage.getItem('systemFont') || 'SF Pro Display', // System font family
        // OS Theme - always macOS
        osTheme: 'macos',
        dockStyle: 'macos',
        menubarStyle: 'macos',
        windowStyle: 'macos',
        // App Store state
        installedApps: [], // Array of installed app IDs (detected at runtime from local files)
        minecraftSource: null, // 'local' if minecraft.html exists in same folder
        minecraftBlobUrl: null, // Blob URL for Minecraft iframe (fallback)
        minecraftHtmlContent: null, // Raw HTML content for Minecraft (for srcdoc usage)
        // Window controls layout
        mirroredControls: localStorage.getItem('mirroredControls') === 'true', // If true, window buttons on right, fullscreen on left
        activeWindowId: null, // Track currently active/focused window
        // Quick Settings toggles
        wifiEnabled: localStorage.getItem('wifiEnabled') !== 'false',
        bluetoothEnabled: localStorage.getItem('bluetoothEnabled') === 'true',
        shareEnabled: localStorage.getItem('shareEnabled') === 'true',
        focusEnabled: false, // Always default to off on restart
        // Volume level (0-100)
        volume: parseInt(localStorage.getItem('mosVolume') || '60'),
        // Task Manager refresh interval
        taskManagerInterval: null,
        taskManagerWindowId: null,
        // Background Processes System - apps running in background like real OS
        backgroundProcesses: JSON.parse(localStorage.getItem('backgroundProcesses') || '{}'), // {appId: {state, data, startTime}}
        processStartTimes: {}, // Track when each process started
        // Render throttling
        renderQueued: false,
        lastRenderTime: 0,
        // Boot/Setup/Lock state
        bootComplete: false,
        setupComplete: localStorage.getItem('mos_setup_complete') === 'true',
        isLocked: false,
        isSleeping: false, // Track if system is in sleep mode
        lockscreenInUnlockView: false, // Track if lockscreen is showing unlock view
        // Lockscreen appearance settings
        lockscreenSettings: JSON.parse(localStorage.getItem('mos_lockscreen_settings') || 'null') || {
          useDesktopWallpaper: true, // Use same wallpaper as desktop
          lockscreenEnabled: true, // Enable lockscreen on boot
          showSeconds: false, // Show seconds in time display
          clockStyle: 'default', // Clock style: 'default', 'minimal', 'bold', 'outlined', 'retro', 'elegant'
          clockFont: 'Space Grotesk', // Clock font family
        },
        // Notification toast position: 'top-center', 'top-left', 'top-right', 'bottom-center', 'bottom-left', 'bottom-right'
        notificationToastPosition: localStorage.getItem('notificationToastPosition') || 'top-center',
      };
      
      // ============= M OS VERSION SYSTEM =============
      const MOS_VERSION = 'MoS v1';
      const MOS_UPDATE_REPO = 'https://api.github.com/repos/Matko802/my-web-os-things/contents/Versions';
      const MOS_RAW_BASE = 'https://raw.githubusercontent.com/Matko802/my-web-os-things/main/Versions/';
      let availableVersions = [];
      let selectedVersionForDetails = null;
      
      function getInstalledVersion() {
        return localStorage.getItem('mos_version') || MOS_VERSION;
      }
      
      function setInstalledVersion(version) {
        localStorage.setItem('mos_version', version);
      }
      
      function parseVersionNumber(versionStr) {
        const match = versionStr.match(/MoS v(\d+)/i);
        return match ? parseInt(match[1], 10) : 0;
      }
      
      async function fetchAvailableVersions() {
        try {
          const response = await fetch(MOS_UPDATE_REPO);
          if (!response.ok) return [];
          const files = await response.json();
          const versions = [];
          for (const file of files) {
            if (file.type === 'file' && file.name.endsWith('.html')) {
              const versionNum = parseVersionNumber(file.name);
              if (versionNum > 0) {
                // Include file size from GitHub API response
                const fileSize = file.size || 0;
                versions.push({ 
                  version: 'MoS v' + versionNum, 
                  versionNum, 
                  file: file.name, 
                  downloadUrl: MOS_RAW_BASE + file.name,
                  size: fileSize
                });
              }
            }
          }
          versions.sort((a, b) => b.versionNum - a.versionNum);
          return versions;
        } catch (e) { return []; }
      }
      
      // Format file size for display
      function formatFileSize(bytes) {
        if (bytes === 0) return 'Unknown size';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
      }
      
      function getVersionChangelog(versionNum) {
        const changelogs = {
          1: ' Initial release of M OS\n Desktop environment with draggable windows\n Dock with app launcher\n Settings app with customization\n Terminal emulator\n File browser\n Browser app',
          2: ' Bug fixes and improvements\n Enhanced window management\n New customization options',
          3: ' Performance improvements\n UI refinements\n New features'
        };
        return changelogs[versionNum] || ' Version ' + versionNum + ' release\n Various improvements and fixes';
      }
      
      window.downloadVersion = function(downloadUrl, fileName) {
        fetch(downloadUrl).then(r => r.blob()).then(blob => {
          const url = window.URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url; link.download = fileName;
          document.body.appendChild(link); link.click();
          document.body.removeChild(link);
          window.URL.revokeObjectURL(url);
        }).catch(() => alert('Download failed. Try again.'));
      };
      
      window.openVersionManager = async function() {
        const existingWindow = state.windows.find(w => w.appId === 'versionmanager');
        if (existingWindow) { window.focusWindow(existingWindow.id); return; }
        state.isLoadingVersions = true;
        window.createWindow('versionmanager', 'Version Manager');
        availableVersions = await fetchAvailableVersions();
        state.isLoadingVersions = false;
        selectedVersionForDetails = null;
        
        // Directly update the version manager window content
        const vmWindow = state.windows.find(w => w.appId === 'versionmanager');
        if (vmWindow) {
          const windowEl = document.getElementById(`window-${vmWindow.id}`);
          if (windowEl) {
            const windowContent = windowEl.querySelector('.window-content');
            if (windowContent) {
              windowContent.innerHTML = getVersionManagerContent();
              return;
            }
          }
        }
        
        // Fallback to renderWindows
        renderWindows();
      };
      
      window.selectVersionForDetails = function(versionNum) {
        selectedVersionForDetails = versionNum;
        
        // Directly update the version manager window content instead of relying on renderWindows
        const vmWindow = state.windows.find(w => w.appId === 'versionmanager');
        if (vmWindow) {
          const windowEl = document.getElementById(`window-${vmWindow.id}`);
          if (windowEl) {
            const windowContent = windowEl.querySelector('.window-content');
            if (windowContent) {
              // Save scroll positions for both panes (list + details)
              const listEl = windowContent.querySelector('.versionmanager-list');
              const detailsEl = windowContent.querySelector('.versionmanager-details');
              const listScroll = listEl ? listEl.scrollTop : 0;
              const detailsScroll = detailsEl ? detailsEl.scrollTop : 0;
              
              // Update content
              windowContent.innerHTML = getVersionManagerContent();
              
              // Restore scroll positions
              const newListEl = windowContent.querySelector('.versionmanager-list');
              const newDetailsEl = windowContent.querySelector('.versionmanager-details');
              if (newListEl) newListEl.scrollTop = listScroll;
              if (newDetailsEl) newDetailsEl.scrollTop = detailsScroll;
              return;
            }
          }
        }
        
        // Fallback to renderWindows if direct update fails
        renderWindows();
      };
      
      function getVersionManagerContent() {
        const currentVersion = getInstalledVersion();
        const currentVersionNum = parseVersionNumber(currentVersion);
        
        if (state.isLoadingVersions) {
          return '<div style="width:100%;height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;color:hsl(var(--foreground));"><div style="font-size:32px;margin-bottom:16px;"></div><div style="font-size:14px;color:hsl(var(--muted-foreground));">Loading versions...</div></div>';
        }
        
        if (availableVersions.length === 0) {
          return '<div style="width:100%;height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;color:hsl(var(--foreground));"><div style="font-size:48px;margin-bottom:16px;"></div><div style="font-size:16px;font-weight:600;">No Versions Found</div><button onclick="window.openVersionManager()" style="margin-top:20px;padding:10px 20px;background:hsl(var(--primary));color:hsl(var(--primary-foreground));border:none;border-radius:8px;cursor:pointer;">Retry</button></div>';
        }
        
        const selectedVersion = selectedVersionForDetails ? availableVersions.find(v => v.versionNum === selectedVersionForDetails) : null;
        
        let listHTML = '';
        availableVersions.forEach(v => {
          const isCurrent = v.versionNum === currentVersionNum;
          const isNewer = v.versionNum > currentVersionNum;
          const isSelected = selectedVersionForDetails === v.versionNum;
          const sizeStr = formatFileSize(v.size);
          listHTML += '<div onclick="event.stopPropagation();window.selectVersionForDetails(' + v.versionNum + ')" style="padding:12px;margin:4px 0;border-radius:8px;cursor:pointer;background:' + (isSelected ? 'hsl(var(--primary)/0.15)' : 'transparent') + ';border:1px solid ' + (isSelected ? 'hsl(var(--primary)/0.3)' : 'transparent') + ';" onmouseover="if(!' + isSelected + ')this.style.background=\'hsl(var(--accent)/0.5)\'" onmouseout="if(!' + isSelected + ')this.style.background=\'transparent\'">';
          listHTML += '<div style="display:flex;align-items:center;justify-content:space-between;"><span style="font-size:14px;font-weight:600;color:hsl(var(--foreground));">' + v.version + '</span><span style="display:flex;gap:4px;">';
          if (isCurrent) listHTML += '<span style="font-size:10px;background:hsl(var(--primary));color:hsl(var(--primary-foreground));padding:2px 6px;border-radius:6px;">Current</span>';
          if (isNewer) listHTML += '<span style="font-size:10px;background:#10b981;color:white;padding:2px 6px;border-radius:6px;">New</span>';
          listHTML += '</span></div><div style="display:flex;justify-content:space-between;align-items:center;margin-top:4px;"><span style="font-size:11px;color:hsl(var(--muted-foreground));">' + v.file + '</span><span style="font-size:10px;color:hsl(var(--muted-foreground));background:hsl(var(--accent)/0.5);padding:2px 6px;border-radius:4px;"> ' + sizeStr + '</span></div></div>';
        });
        
        let detailsHTML = '';
        if (selectedVersion) {
          const changelog = getVersionChangelog(selectedVersion.versionNum);
          const isCurrent = selectedVersion.versionNum === currentVersionNum;
          const isNewer = selectedVersion.versionNum > currentVersionNum;
          
          detailsHTML = '<div style="padding:24px;border-bottom:1px solid hsl(var(--window-border));background:hsl(var(--accent)/0.1);"><div style="display:flex;align-items:center;justify-content:space-between;"><div><div style="display:flex;align-items:center;gap:12px;"><span style="font-size:24px;font-weight:700;color:hsl(var(--foreground));">' + selectedVersion.version + '</span>';
          if (isCurrent) detailsHTML += '<span style="font-size:12px;background:hsl(var(--primary));color:hsl(var(--primary-foreground));padding:4px 10px;border-radius:8px;">Installed</span>';
          else if (isNewer) detailsHTML += '<span style="font-size:12px;background:#10b981;color:white;padding:4px 10px;border-radius:8px;">Newer</span>';
          else detailsHTML += '<span style="font-size:12px;background:hsl(var(--muted-foreground));color:white;padding:4px 10px;border-radius:8px;">Older</span>';
          detailsHTML += '</div><div style="font-size:13px;color:hsl(var(--muted-foreground));margin-top:6px;">File: ' + selectedVersion.file + '  <span style="color:hsl(var(--primary));"> ' + formatFileSize(selectedVersion.size) + '</span></div></div>';
          detailsHTML += '<button onclick="event.stopPropagation();window.downloadVersion(\'' + selectedVersion.downloadUrl + '\',\'' + selectedVersion.file + '\')" style="padding:12px 24px;background:hsl(var(--primary));color:hsl(var(--primary-foreground));border:none;border-radius:10px;font-size:14px;font-weight:600;cursor:pointer;display:flex;align-items:center;gap:8px;" onmouseover="this.style.transform=\'scale(1.05)\'" onmouseout="this.style.transform=\'scale(1)\'"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:18px;height:18px;"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>Download (' + formatFileSize(selectedVersion.size) + ')</button></div></div>';
          detailsHTML += '<div class="versionmanager-details" style="flex:1;padding:24px;overflow-y:auto;"><div style="font-size:16px;font-weight:600;color:hsl(var(--foreground));margin-bottom:16px;"> What\'s New</div>';
          detailsHTML += '<div style="background:hsl(var(--accent)/0.3);border-radius:12px;padding:20px;font-size:14px;line-height:1.8;color:hsl(var(--foreground));white-space:pre-line;">' + changelog + '</div>';
          if (!isCurrent) {
            detailsHTML += '<div style="margin-top:24px;padding:16px;background:hsl(var(--accent)/0.2);border-radius:12px;border:1px solid hsl(var(--window-border));"><div style="font-size:14px;font-weight:600;color:hsl(var(--foreground));margin-bottom:8px;">How to Update</div><ol style="font-size:13px;color:hsl(var(--muted-foreground));margin:0;padding-left:20px;line-height:1.8;"><li>Click Download above</li><li>Replace your os.html file</li><li>Refresh the page</li></ol></div>';
          } else {
            detailsHTML += '<div style="margin-top:24px;padding:16px;background:hsl(var(--primary)/0.1);border-radius:12px;"><div style="font-size:14px;color:hsl(var(--foreground));display:flex;align-items:center;gap:8px;"> You are running this version.</div></div>';
          }
          detailsHTML += '</div>';
        } else {
          detailsHTML = '<div style="flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center;color:hsl(var(--muted-foreground));"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="width:64px;height:64px;margin-bottom:16px;opacity:0.5;"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg><div style="font-size:16px;font-weight:500;">Select a version</div><div style="font-size:13px;margin-top:4px;">Click on a version to see details</div></div>';
        }
        
        return '<div class="versionmanager-container" style="display:flex;height:100%;overflow:hidden;"><div class="versionmanager-sidebar" style="width:280px;border-right:1px solid hsl(var(--window-border) / 0.5);display:flex;flex-direction:column;flex-shrink:0;background:hsl(var(--accent) / 0.3);"><div style="padding:16px;border-bottom:1px solid hsl(var(--window-border) / 0.5);background:hsl(var(--accent)/0.3);"><div style="font-size:11px;text-transform:uppercase;letter-spacing:0.5px;color:hsl(var(--muted-foreground));margin-bottom:4px;">Current Version</div><div style="font-size:16px;font-weight:600;color:hsl(var(--foreground));">' + currentVersion + '</div></div><div class="versionmanager-list" style="flex:1;overflow-y:auto;padding:8px;">' + listHTML + '</div></div><div style="flex:1;display:flex;flex-direction:column;overflow:hidden;">' + detailsHTML + '</div></div>';
      }
      
      // Upload lockscreen wallpaper
      window.uploadLockscreenWallpaper = function() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*';
        input.onchange = function(e) {
          const file = e.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = function(event) {
              localStorage.setItem('mos_lockscreen_wallpaper', event.target.result);
              refreshSettingsContent();
              playSound('click');
            };
            reader.readAsDataURL(file);
          }
        };
        input.click();
      };
      
      // Clear lockscreen wallpaper
      window.clearLockscreenWallpaper = function() {
        localStorage.removeItem('mos_lockscreen_wallpaper');
        refreshSettingsContent();
        playSound('click');
      };
      
      // ============= LOCKSCREEN SETTINGS FUNCTIONS =============
      
      // IndexedDB helper for settings storage
      const settingsDB = {
        dbName: 'MOSSettings',
        storeName: 'settings',
        _db: null,
        
        async open() {
          if (this._db && this._db.objectStoreNames.contains(this.storeName)) {
            return this._db;
          }
          
          return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, 1);
            request.onerror = (e) => reject(e.target.error);
            request.onsuccess = (e) => {
              this._db = e.target.result;
              resolve(this._db);
            };
            request.onupgradeneeded = (e) => {
              const db = e.target.result;
              if (!db.objectStoreNames.contains(this.storeName)) {
                db.createObjectStore(this.storeName, { keyPath: 'key' });
              }
            };
          });
        },
        
        async save(key, value) {
          try {
            const db = await this.open();
            return new Promise((resolve, reject) => {
              const tx = db.transaction(this.storeName, 'readwrite');
              const store = tx.objectStore(this.storeName);
              store.put({ key, value, timestamp: Date.now() });
              tx.oncomplete = () => resolve();
              tx.onerror = (e) => reject(e.target.error);
            });
          } catch (e) {
            console.error('settingsDB save error:', e);
          }
        },
        
        async get(key) {
          try {
            const db = await this.open();
            return new Promise((resolve, reject) => {
              const tx = db.transaction(this.storeName, 'readonly');
              const store = tx.objectStore(this.storeName);
              const request = store.get(key);
              request.onerror = (e) => reject(e.target.error);
              request.onsuccess = () => resolve(request.result?.value || null);
            });
          } catch (e) {
            console.error('settingsDB get error:', e);
            return null;
          }
        }
      };
      
      // Save lockscreen settings to both localStorage and IndexedDB
      function saveLockscreenSettings() {
        const settingsJson = JSON.stringify(state.lockscreenSettings);
        localStorage.setItem('mos_lockscreen_settings', settingsJson);
        settingsDB.save('lockscreenSettings', state.lockscreenSettings);
      }
      
      // Load lockscreen settings from IndexedDB (with localStorage fallback)
      async function loadLockscreenSettingsFromDB() {
        try {
          const dbSettings = await settingsDB.get('lockscreenSettings');
          if (dbSettings) {
            state.lockscreenSettings = {
              useDesktopWallpaper: true,
              lockscreenEnabled: true,
              showSeconds: false,
              clockStyle: 'default',
              clockFont: 'Space Grotesk',
              ...dbSettings
            };
            // Sync to localStorage
            localStorage.setItem('mos_lockscreen_settings', JSON.stringify(state.lockscreenSettings));
            console.log('Lockscreen settings loaded from IndexedDB:', state.lockscreenSettings);
          }
          // Apply clock style immediately to any existing lockscreen
          applyLockscreenClockStyle();
        } catch (e) {
          console.error('Failed to load lockscreen settings from IndexedDB:', e);
        }
      }
      
      // Helper to refresh settings content in-place without full render
      function refreshSettingsContent() {
        const settingsContent = document.querySelector('.settings-content');
        if (settingsContent && state.settingsTab) {
          settingsContent.innerHTML = getSettingsContent(state.settingsTab);
        }
      }
      
      // Toggle lockscreen enabled on boot
      window.toggleLockscreenEnabled = function() {
        state.lockscreenSettings.lockscreenEnabled = !state.lockscreenSettings.lockscreenEnabled;
        saveLockscreenSettings();
        refreshSettingsContent();
        playSound('click');
      };
      
      // Toggle use desktop wallpaper for lockscreen
      window.toggleLockscreenUseDesktopWallpaper = function() {
        state.lockscreenSettings.useDesktopWallpaper = !state.lockscreenSettings.useDesktopWallpaper;
        saveLockscreenSettings();
        refreshSettingsContent();
        playSound('click');
      };
      
      // Toggle show seconds in lockscreen clock
      window.toggleLockscreenShowSeconds = function() {
        state.lockscreenSettings.showSeconds = !state.lockscreenSettings.showSeconds;
        saveLockscreenSettings();
        refreshSettingsContent();
        playSound('click');
      };
      
      // Set clock style for lockscreen
      window.setLockscreenClockStyle = function(style) {
        state.lockscreenSettings.clockStyle = style;
        saveLockscreenSettings();
        applyLockscreenClockStyle();
        refreshSettingsContent();
        playSound('click');
      };
      
      // Set clock font for lockscreen
      window.setLockscreenClockFont = function(font) {
        state.lockscreenSettings.clockFont = font;
        saveLockscreenSettings();
        applyLockscreenClockStyle();
        refreshSettingsContent();
        playSound('click');
      };
      
      // Apply clock style to lockscreen element
      function applyLockscreenClockStyle() {
        const timeEl = document.getElementById('lockscreen-time');
        if (!timeEl) return;
        
        // Remove all style classes
        timeEl.classList.remove('style-minimal', 'style-bold', 'style-outlined', 'style-retro', 'style-elegant');
        
        // Add current style class
        const style = state.lockscreenSettings?.clockStyle || 'default';
        if (style !== 'default') {
          timeEl.classList.add('style-' + style);
        }
        
        // Apply font
        const font = state.lockscreenSettings?.clockFont || 'Space Grotesk';
        timeEl.style.fontFamily = font + ', sans-serif';
      }
      
      // Show change password dialog
      window.showChangePasswordDialog = function() {
        const hasPassword = !!localStorage.getItem('mos_password_hash');
        
        const overlay = document.createElement('div');
        overlay.className = 'add-site-dialog-overlay';
        overlay.onclick = (e) => { if (e.target === overlay) overlay.remove(); };
        
        overlay.innerHTML = `
          <div class="add-site-dialog" onclick="event.stopPropagation()">
            <h3>${hasPassword ? 'Change Password' : 'Set Password'}</h3>
            <div class="add-site-form">
              ${hasPassword ? `
                <div class="add-site-input-group">
                  <label class="add-site-label">Current Password</label>
                  <input type="password" class="add-site-input" id="dialog-current-password" placeholder="Enter current password" autocomplete="current-password" />
                </div>
              ` : ''}
              <div class="add-site-input-group">
                <label class="add-site-label">New Password</label>
                <input type="password" class="add-site-input" id="dialog-new-password" placeholder="Enter new password" autocomplete="new-password" />
              </div>
              <div class="add-site-input-group">
                <label class="add-site-label">Confirm Password</label>
                <input type="password" class="add-site-input" id="dialog-confirm-password" placeholder="Confirm new password" autocomplete="new-password" />
              </div>
              <div id="dialog-password-error" style="color: #ff6b6b; font-size: 13px; display: none;"></div>
              <div class="add-site-buttons">
                <button class="add-site-button add-site-button-cancel" onclick="this.closest('.add-site-dialog-overlay').remove()">Cancel</button>
                <button class="add-site-button add-site-button-submit" onclick="window.submitPasswordChange()">Save</button>
              </div>
            </div>
          </div>
        `;
        
        document.body.appendChild(overlay);
        
        // Focus first input
        setTimeout(() => {
          const firstInput = overlay.querySelector('input');
          if (firstInput) firstInput.focus();
        }, 100);
        
        // Handle Enter key
        overlay.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            window.submitPasswordChange();
          } else if (e.key === 'Escape') {
            overlay.remove();
          }
        });
      };
      
      // Submit password change
      window.submitPasswordChange = function() {
        const hasPassword = !!localStorage.getItem('mos_password_hash');
        const currentPasswordInput = document.getElementById('dialog-current-password');
        const newPasswordInput = document.getElementById('dialog-new-password');
        const confirmPasswordInput = document.getElementById('dialog-confirm-password');
        const errorEl = document.getElementById('dialog-password-error');
        
        const newPassword = newPasswordInput?.value || '';
        const confirmPassword = confirmPasswordInput?.value || '';
        
        // Validate current password if exists
        if (hasPassword && currentPasswordInput) {
          const currentPasswordHash = localStorage.getItem('mos_password_hash');
          const enteredHash = simpleHash(currentPasswordInput.value);
          
          if (enteredHash !== currentPasswordHash) {
            errorEl.textContent = 'Current password is incorrect';
            errorEl.style.display = 'block';
            currentPasswordInput.focus();
            return;
          }
        }
        
        // Validate new password
        if (!newPassword) {
          errorEl.textContent = 'Please enter a new password';
          errorEl.style.display = 'block';
          newPasswordInput.focus();
          return;
        }
        
        if (newPassword !== confirmPassword) {
          errorEl.textContent = 'Passwords do not match';
          errorEl.style.display = 'block';
          confirmPasswordInput.focus();
          return;
        }
        
        // Save new password
        localStorage.setItem('mos_password_hash', simpleHash(newPassword));
        
        // Close dialog
        document.querySelector('.add-site-dialog-overlay')?.remove();
        
        // Refresh settings
        refreshSettingsContent();
        
        playSound('notification');
      };
      
      // Remove password
      window.removePassword = function() {
        if (!confirm('Are you sure you want to remove your password? Anyone will be able to unlock the screen.')) {
          return;
        }
        
        localStorage.removeItem('mos_password_hash');
        refreshSettingsContent();
        playSound('click');
      };
      
      // ============= SIMPLE PASSWORD HASHING =============
      function simpleHash(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash; // Convert to 32bit integer
        }
        // Add some salt and convert to hex
        const salt = 'mos_salt_2024';
        let saltedHash = hash;
        for (let i = 0; i < salt.length; i++) {
          saltedHash = ((saltedHash << 5) - saltedHash) + salt.charCodeAt(i);
          saltedHash = saltedHash & saltedHash;
        }
        return Math.abs(saltedHash).toString(16);
      }
      
      // ============= POWER SYSTEM =============
      
      // Ensure cursor follower stays visible during power dialogs and screens
      function ensureCursorVisibleInOverlay() {
        if (areCursorsEnabled() && cursorFollower) {
          cursorFollower.style.display = 'block';
          // Cursor z-index is already very high (999999999), no need to change
        }
      }
      
      // Show shutdown dialog with options
      window.showPowerDialog = function() {
        // Close quick settings first
        state.showQuickSettings = false;
        renderShell();
        
        // Ensure cursor stays visible
        ensureCursorVisibleInOverlay();
        
        const overlay = document.createElement('div');
        overlay.className = 'shutdown-dialog-overlay';
        overlay.innerHTML = `
          <div class="shutdown-dialog">
            <div class="shutdown-dialog-title">What would you like to do?</div>
            <div class="shutdown-dialog-options">
              <div class="shutdown-option destructive" onclick="window.handleShutdown()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M18.36 6.64a9 9 0 1 1-12.73 0"/>
                  <line x1="12" y1="2" x2="12" y2="12"/>
                </svg>
                <span>Shut Down</span>
              </div>
              <div class="shutdown-option" onclick="window.handleRestart()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M23 4v6h-6"/>
                  <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"/>
                </svg>
                <span>Restart</span>
              </div>
              <div class="shutdown-option" onclick="window.handleSleep()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                </svg>
                <span>Sleep</span>
              </div>
            </div>
            <button class="shutdown-dialog-cancel" onclick="window.closePowerDialog()">Cancel</button>
          </div>
        `;
        
        overlay.addEventListener('click', (e) => {
          if (e.target === overlay) window.closePowerDialog();
        });
        
        document.body.appendChild(overlay);
      };
      
      window.closePowerDialog = function() {
        const overlay = document.querySelector('.shutdown-dialog-overlay');
        if (overlay) {
          overlay.style.animation = 'shutdownDialogFadeIn 0.2s ease reverse forwards';
          setTimeout(() => overlay.remove(), 200);
        }
        // Cursor z-index is already high enough (999999999)
      };
      
      // Shutdown: play animation, set powered-off state, reload
      window.handleShutdown = function() {
        window.closePowerDialog();
        
        // Create shutdown animation screen
        const animScreen = document.createElement('div');
        animScreen.className = 'shutdown-animation-screen';
        animScreen.innerHTML = `
          <div class="shutdown-logo">
            <div class="boot-logo-circle" style="width: 80px; height: 80px; border-radius: 50%; background: white; display: flex; align-items: center; justify-content: center; box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);">
              <span style="font-size: 44px; font-weight: 600; color: hsl(220 20% 10%); font-family: 'Space Grotesk', sans-serif; letter-spacing: 0.02em;">M</span>
            </div>
          </div>
          <div class="shutdown-text">Shutting down...</div>
        `;
        document.body.appendChild(animScreen);
        
        // Set powered-off state in localStorage
        localStorage.setItem('mos_power_state', 'off');
        
        // Wait for animation then reload
        setTimeout(() => {
          location.reload();
        }, 1800);
      };
      
      // Restart: play animation, set restart flag, reload
      window.handleRestart = function() {
        window.closePowerDialog();
        
        // Create restart animation screen
        const animScreen = document.createElement('div');
        animScreen.className = 'shutdown-animation-screen';
        animScreen.innerHTML = `
          <div class="shutdown-logo">
            <div class="boot-logo-circle" style="width: 80px; height: 80px; border-radius: 50%; background: white; display: flex; align-items: center; justify-content: center; box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);">
              <span style="font-size: 44px; font-weight: 600; color: hsl(220 20% 10%); font-family: 'Space Grotesk', sans-serif; letter-spacing: 0.02em;">M</span>
            </div>
          </div>
          <div class="shutdown-text">Restarting...</div>
        `;
        document.body.appendChild(animScreen);
        
        // Set restart state (will boot normally)
        localStorage.setItem('mos_power_state', 'restart');
        
        // Wait for animation then reload
        setTimeout(() => {
          location.reload();
        }, 1800);
      };
      
      // Sleep: fade to black, wake on click/keypress
      window.handleSleep = function() {
        window.closePowerDialog();
        
        const sleepScreen = document.getElementById('sleep-screen');
        if (sleepScreen) {
          sleepScreen.classList.add('active');
          sleepScreen.tabIndex = 0;
          sleepScreen.focus();
          
          // Store sleep state
          state.isSleeping = true;
          
          // Ensure cursor stays visible on sleep screen
          ensureCursorVisibleInOverlay();
        }
      };
      
      // Wake from sleep
      window.wakeFromSleep = function() {
        if (!state.isSleeping) return;
        
        const sleepScreen = document.getElementById('sleep-screen');
        if (sleepScreen) {
          sleepScreen.classList.remove('active');
          state.isSleeping = false;
          
          // Show lockscreen if enabled, otherwise just return to desktop
          const lockscreenEnabled = state.lockscreenSettings?.lockscreenEnabled !== false;
          if (lockscreenEnabled) {
            showLockscreen();
          }
        }
      };
      
      // Power on from off state
      window.powerOnOS = function() {
        // Ensure cursor stays visible during boot
        ensureCursorVisibleInOverlay();
        
        // Play power on sound
        playPowerSound('powerOn');
        
        const powerOffScreen = document.getElementById('power-off-screen');
        const powerOffMonitor = powerOffScreen?.querySelector('.power-off-monitor');
        
        // Add expanding class to monitor for smooth screen expansion
        if (powerOffMonitor) {
          powerOffMonitor.classList.add('expanding');
        }
        
        // Wait for monitor expansion animation, then transition to boot screen
        setTimeout(() => {
          if (powerOffScreen) {
            powerOffScreen.classList.add('hidden');
          }
          
          // Create boot-up animation with playful particles (monochrome)
          const bootUpScreen = document.createElement('div');
          bootUpScreen.className = 'boot-up-animation';
          
          // Create particles for playful effect - MONOCHROME
          let particlesHtml = '';
          for (let i = 0; i < 12; i++) {
            const angle = (i / 12) * Math.PI * 2;
            const distance = 80 + Math.random() * 40;
            const tx = Math.cos(angle) * distance;
            const ty = Math.sin(angle) * distance;
            const delay = Math.random() * 0.3;
            const brightness = 70 + Math.random() * 30; // White to light gray
            particlesHtml += `<div class="boot-particle" style="--tx: ${tx}px; --ty: ${ty}px; animation-delay: ${delay}s; background: hsl(0 0% ${brightness}%);"></div>`;
          }
          
          bootUpScreen.innerHTML = `
            <div class="boot-up-glow"></div>
            ${particlesHtml}
            <div class="boot-up-logo">
              <div class="boot-logo-circle" style="width: 80px; height: 80px; border-radius: 50%; background: white; display: flex; align-items: center; justify-content: center; box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);">
                <span style="font-size: 44px; font-weight: 600; color: hsl(220 20% 10%); font-family: 'Space Grotesk', sans-serif; letter-spacing: 0.02em;">M</span>
              </div>
            </div>
          `;
          document.body.appendChild(bootUpScreen);
          
          // Play boot sound after a short delay
          setTimeout(() => {
            playPowerSound('boot');
          }, 300);
          
          // Clear power state and set to restart so boot proceeds normally
          localStorage.setItem('mos_power_state', 'restart');
          localStorage.removeItem('mos_power_state');
          
          // After boot animation, proceed to normal boot
          setTimeout(() => {
            bootUpScreen.style.opacity = '0';
            bootUpScreen.style.transition = 'opacity 0.5s cubic-bezier(0.4, 0, 0.2, 1)';
            setTimeout(() => {
              bootUpScreen.remove();
              // Reset monitor expansion state
              if (powerOffMonitor) {
                powerOffMonitor.classList.remove('expanding');
              }
              // Continue with normal boot sequence
              proceedWithBoot();
            }, 500);
          }, 2200);
        }, 800); // Wait for monitor expansion
      };
      
      // Proceed with normal boot after power-on
      async function proceedWithBoot() {
        const lockscreenEnabled = state.lockscreenSettings?.lockscreenEnabled !== false;
        const isFirstBoot = !state.setupComplete;
        
        // Prepare lockscreen during boot (hidden but ready)
        if (!isFirstBoot && lockscreenEnabled) {
          prepareLockscreenForBoot();
        }
        
        // Check if first boot (setup not complete)
        if (isFirstBoot) {
          console.log('[Boot] First boot - showing setup');
          showSetupScreen();
          return;
        }
        
        const hasPassword = !!localStorage.getItem('mos_password_hash');
        
        // Show lockscreen if enabled
        if (lockscreenEnabled) {
          console.log('[Boot] Showing lockscreen' + (hasPassword ? ' (password protected)' : ''));
          revealPreparedLockscreen();
          setupLockscreenIdleDetection();
        } else {
          console.log('[Boot] Lockscreen disabled, going straight to desktop');
        }
      }
      
      // ============= BOOT SCREEN SYSTEM =============
      let bootProgress = 0;
      let bootInterval = null;
      
      function updateBootProgress(progress, status) {
        const bar = document.getElementById('boot-loader-bar');
        const statusEl = document.getElementById('boot-status');
        const refreshHint = document.getElementById('boot-refresh-hint');
        if (bar) bar.style.width = progress + '%';
        if (statusEl) statusEl.textContent = status;
        // Show refresh hint when Initializing kernel... step
        if (refreshHint && status === 'Initializing kernel...') {
          refreshHint.style.display = 'block';
        }
      }
      
      function runBootSequence() {
        return new Promise((resolve) => {
          const bootScreen = document.getElementById('boot-screen');
          if (!bootScreen) {
            resolve();
            return;
          }
          
          // Pure black boot with emerging logo animation
          // Boot duration: 2.8 seconds (pure black + logo emergence + glow effect)
          setTimeout(() => {
            bootScreen.classList.add('fade-out');
            setTimeout(() => {
              bootScreen.style.display = 'none';
              state.bootComplete = true;
              resolve();
            }, 800);
          }, 2800);
        });
      }
      
      // ============= FIRST-BOOT SETUP SYSTEM =============
      let setupStep = 1;
      const SETUP_TOTAL_STEPS = 5;
      let setupData = {
        username: '',
        password: '',
        theme: 'dark',
        sound: true,
        cursor: 'default'
      };
      
      function showSetupScreen() {
        const setupScreen = document.getElementById('setup-screen');
        if (setupScreen) {
          setupScreen.style.display = 'flex'; // Restore display before showing
          setupScreen.classList.add('active');
          // Focus first input after animation
          setTimeout(() => {
            const input = document.getElementById('setup-username');
            if (input) input.focus();
          }, 300);
        }
      }
      
      function hideSetupScreen() {
        const setupScreen = document.getElementById('setup-screen');
        if (setupScreen) {
          setupScreen.classList.remove('active');
          // Completely remove from DOM flow to prevent invisible element blocking
          setTimeout(() => {
            if (!setupScreen.classList.contains('active')) {
              setupScreen.style.display = 'none';
            }
          }, 500); // Wait for fade out animation
        }
      }
      
      function updateSetupStep(step) {
        setupStep = step;
        
        // Update step visibility
        document.querySelectorAll('.setup-step').forEach(el => {
          el.classList.remove('active');
          if (parseInt(el.dataset.step) === step) {
            el.classList.add('active');
          }
        });
        
        // Update progress dots
        document.querySelectorAll('.setup-progress-dot').forEach(el => {
          const dotStep = parseInt(el.dataset.dot);
          el.classList.remove('active', 'completed');
          if (dotStep === step) {
            el.classList.add('active');
          } else if (dotStep < step) {
            el.classList.add('completed');
          }
        });
        
        // Update buttons
        const backBtn = document.getElementById('setup-back-btn');
        const nextBtn = document.getElementById('setup-next-btn');
        
        if (backBtn) {
          backBtn.style.display = step > 1 ? 'block' : 'none';
        }
        
        if (nextBtn) {
          nextBtn.textContent = step === SETUP_TOTAL_STEPS ? 'Get Started' : 'Continue';
        }
        
        // Focus appropriate input
        setTimeout(() => {
          if (step === 1) {
            const input = document.getElementById('setup-username');
            if (input) input.focus();
          } else if (step === 2) {
            const input = document.getElementById('setup-password');
            if (input) input.focus();
          }
        }, 100);
      }
      
      window.setupNextStep = function() {
        // Validate current step
        if (setupStep === 1) {
          const username = document.getElementById('setup-username').value.trim();
          if (!username) {
            document.getElementById('setup-username').focus();
            return;
          }
          setupData.username = username;
        } else if (setupStep === 2) {
          const password = document.getElementById('setup-password').value;
          const confirm = document.getElementById('setup-password-confirm').value;
          if (password && password !== confirm) {
            document.getElementById('setup-password-confirm').focus();
            return;
          }
          setupData.password = password;
        }
        
        if (setupStep < SETUP_TOTAL_STEPS) {
          updateSetupStep(setupStep + 1);
        } else {
          // Complete setup
          completeSetup();
        }
      };
      
      window.setupPrevStep = function() {
        if (setupStep > 1) {
          updateSetupStep(setupStep - 1);
        }
      };
      
      window.selectSetupTheme = function(theme) {
        setupData.theme = theme;
        document.querySelectorAll('.setup-option').forEach(el => {
          el.classList.toggle('selected', el.dataset.theme === theme);
        });
        
        // Apply theme immediately for smooth preview transition
        if (theme === 'dark') {
          document.documentElement.classList.add('dark');
        } else {
          document.documentElement.classList.remove('dark');
        }
        
        // Play a click sound for feedback
        playSound('click');
      };
      
      window.selectSetupSound = function(enabled) {
        setupData.sound = enabled;
        document.querySelectorAll('.setup-step[data-step="4"] .setup-option').forEach(el => {
          el.classList.toggle('selected', el.dataset.sound === enabled.toString());
        });
      };
      
      window.selectSetupCursor = function(cursor) {
        setupData.cursor = cursor;
        document.querySelectorAll('.setup-cursor-option').forEach(el => {
          el.classList.toggle('selected', el.dataset.cursor === cursor);
        });
      };
      
      async function completeSetup() {
        // Save user data
        localStorage.setItem('mos_username', setupData.username);
        if (setupData.password) {
          localStorage.setItem('mos_password_hash', simpleHash(setupData.password));
        } else {
          localStorage.removeItem('mos_password_hash');
        }
        
        // Apply theme
        if (setupData.theme === 'dark') {
          document.documentElement.classList.add('dark');
          localStorage.setItem('theme', 'dark');
          state.isDark = true;
        } else {
          document.documentElement.classList.remove('dark');
          localStorage.setItem('theme', 'light');
          state.isDark = false;
        }
        
        // Apply sound preference
        state.soundEnabled = setupData.sound;
        localStorage.setItem(SOUND_CONFIG.enabledKey, setupData.sound ? 'true' : 'false');
        
        // Apply cursor preference - download if custom selected
        if (setupData.cursor === 'custom') {
          localStorage.setItem(CURSOR_CONFIG.enabledKey, 'true');
          // Download cursors in background
          if (!areCursorsInstalled()) {
            installCursorsFromGitHub().then(() => {
              loadAniCursors();
              injectCursorStyles();
            }).catch(() => {
              installFallbackCursors();
              loadAniCursors();
              injectCursorStyles();
            });
          } else {
            loadAniCursors();
            injectCursorStyles();
          }
        } else {
          localStorage.setItem(CURSOR_CONFIG.enabledKey, 'false');
        }
        
        // Download sounds in background if enabled
        if (setupData.sound && !areSoundsInstalled()) {
          installSoundsFromGitHub().catch(e => {
            console.warn('[Setup] Sound download failed:', e);
          });
        }
        
        // Mark setup as complete
        localStorage.setItem('mos_setup_complete', 'true');
        state.setupComplete = true;
        
        // Set power state to off so next page load shows power button
        localStorage.setItem('mos_power_state', 'off');
        
        // Hide setup and show desktop
        hideSetupScreen();
        
        render();
      }
      
      // Handle Enter key in setup inputs
      document.addEventListener('keydown', function(e) {
        const setupScreen = document.getElementById('setup-screen');
        if (setupScreen && setupScreen.classList.contains('active')) {
          if (e.key === 'Enter') {
            e.preventDefault();
            setupNextStep();
          } else if (e.key === 'Escape' && setupStep > 1) {
            e.preventDefault();
            setupPrevStep();
          }
        }
      });
      
      // ============= LOCKSCREEN SYSTEM =============
      let lockscreenClockInterval = null;
      let lockscreenIdleTimeout = null;
      let lockscreenIdleTimer = null;
      const LOCKSCREEN_IDLE_TIMEOUT = 30000; // 30 seconds before returning to initial view
      
      function updateLockscreenClock() {
        const timeEl = document.getElementById('lockscreen-time');
        const dateEl = document.getElementById('lockscreen-date');
        
        if (timeEl && dateEl) {
          const now = new Date();
          const showSeconds = state.lockscreenSettings?.showSeconds;
          timeEl.textContent = now.toLocaleTimeString('en-US', {
            hour: '2-digit',
            minute: '2-digit',
            second: showSeconds ? '2-digit' : undefined,
            hour12: false
          });
          dateEl.textContent = now.toLocaleDateString('en-US', {
            weekday: 'long',
            month: 'long',
            day: 'numeric'
          });
        }
      }
      
      // Get lockscreen wallpaper based on settings
      function getLockscreenWallpaper() {
        const customLockscreenWallpaper = localStorage.getItem('mos_lockscreen_wallpaper');
        const useDesktopWallpaper = state.lockscreenSettings?.useDesktopWallpaper !== false;
        const desktopWallpaper = state.customWallpaper || localStorage.getItem('customWallpaper');
        
        // Priority: custom lockscreen wallpaper > desktop wallpaper (if enabled) > null (use gradient)
        if (customLockscreenWallpaper) {
          return customLockscreenWallpaper;
        } else if (useDesktopWallpaper && desktopWallpaper) {
          return desktopWallpaper;
        }
        return null;
      }
      
      // Handle click/tap on lockscreen to enter unlock view
      window.handleLockscreenClick = function(e) {
        const lockscreen = document.getElementById('lockscreen');
        if (!lockscreen) return;
        
        // If already in unlock view, don't do anything (let clicks pass through to children)
        if (lockscreen.classList.contains('unlock-view')) {
          return;
        }
        
        // Enter unlock view
        enterUnlockView();
      };
      
      // Enter the unlock view (show user/password section)
      function enterUnlockView() {
        const lockscreen = document.getElementById('lockscreen');
        if (!lockscreen) return;
        
        state.lockscreenInUnlockView = true;
        lockscreen.classList.add('unlock-view');
        
        // Focus password input if password is set
        const hasPassword = !!localStorage.getItem('mos_password_hash');
        if (hasPassword) {
          const input = document.getElementById('lockscreen-password');
          if (input) {
            setTimeout(() => input.focus(), 400);
          }
        }
        
        // Reset idle timer
        resetLockscreenIdleTimer();
        
        playSound('click');
      }
      
      // Exit unlock view and return to initial time display
      window.exitUnlockView = function(e) {
        if (e) e.stopPropagation();
        
        const lockscreen = document.getElementById('lockscreen');
        if (!lockscreen) return;
        
        state.lockscreenInUnlockView = false;
        lockscreen.classList.remove('unlock-view');
        
        // Clear password input
        const input = document.getElementById('lockscreen-password');
        if (input) input.value = '';
        
        // Clear any error
        const errorEl = document.getElementById('lockscreen-error');
        if (errorEl) errorEl.classList.remove('visible');
        
        playSound('click');
      };
      
      // Reset the idle timer - returns to initial view after timeout
      function resetLockscreenIdleTimer() {
        if (lockscreenIdleTimer) {
          clearTimeout(lockscreenIdleTimer);
        }
        const lockscreen = document.getElementById('lockscreen');
        if (lockscreen && lockscreen.classList.contains('active') && lockscreen.classList.contains('unlock-view')) {
          lockscreenIdleTimer = setTimeout(() => {
            // Return to initial time-only view after idle
            exitUnlockView();
          }, LOCKSCREEN_IDLE_TIMEOUT);
        }
      }
      
      // Setup lockscreen interaction detection
      function setupLockscreenIdleDetection() {
        const lockscreen = document.getElementById('lockscreen');
        if (lockscreen) {
          // Reset idle timer on any activity when in unlock view
          ['mousemove', 'mousedown', 'keydown', 'touchstart'].forEach(event => {
            lockscreen.addEventListener(event, () => {
              if (lockscreen.classList.contains('unlock-view')) {
                resetLockscreenIdleTimer();
              }
            });
          });
          
          // Handle swipe up gesture for touch devices
          let touchStartY = 0;
          lockscreen.addEventListener('touchstart', (e) => {
            touchStartY = e.touches[0].clientY;
          });
          
          lockscreen.addEventListener('touchend', (e) => {
            const touchEndY = e.changedTouches[0].clientY;
            const swipeDistance = touchStartY - touchEndY;
            
            // If swipe up more than 50px and not in unlock view, enter unlock view
            if (swipeDistance > 50 && !lockscreen.classList.contains('unlock-view')) {
              enterUnlockView();
            }
          });
        }
      }
      
      function showLockscreen() {
        const lockscreen = document.getElementById('lockscreen');
        const username = localStorage.getItem('mos_username') || 'User';
        const hasPassword = !!localStorage.getItem('mos_password_hash');
        
        if (lockscreen) {
          // Set username and avatar
          const usernameEl = document.getElementById('lockscreen-username');
          const avatarEl = document.getElementById('lockscreen-avatar');
          const passwordContainer = document.getElementById('lockscreen-password-container');
          const unlockBtn = document.getElementById('lockscreen-unlock-btn');
          
          if (usernameEl) usernameEl.textContent = username;
          if (avatarEl) avatarEl.textContent = username.charAt(0).toUpperCase();
          
          // Show password input or unlock button based on password existence
          if (hasPassword) {
            if (passwordContainer) passwordContainer.style.display = 'block';
            if (unlockBtn) unlockBtn.style.display = 'none';
          } else {
            if (passwordContainer) passwordContainer.style.display = 'none';
            if (unlockBtn) unlockBtn.style.display = 'inline-block';
          }
          
          // Set background - NO blur on lockscreen, clear wallpaper
          const bg = document.getElementById('lockscreen-bg');
          const wallpaperToUse = getLockscreenWallpaper();
          
          if (bg) {
            if (wallpaperToUse) {
              // Clear any previous background shorthand first
              bg.style.background = 'none';
              bg.style.backgroundImage = 'url("' + wallpaperToUse + '")';
              bg.style.backgroundSize = 'cover';
              bg.style.backgroundPosition = 'center';
              bg.style.backgroundRepeat = 'no-repeat';
              // NO blur - let CSS handle the filter based on state
              bg.style.filter = '';
              bg.style.transform = '';
            } else {
              // No wallpaper set, use dark gradient
              bg.style.backgroundImage = 'none';
              bg.style.background = 'linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0f0f1a 100%)';
              bg.style.filter = '';
              bg.style.transform = '';
            }
          }
          
          // Reset to initial time-only view (not unlock view)
          lockscreen.classList.remove('unlock-view');
          state.lockscreenInUnlockView = false;
          
          lockscreen.classList.add('active');
          state.isLocked = true;
          
          // Apply clock style and update clock
          applyLockscreenClockStyle();
          updateLockscreenClock();
          lockscreenClockInterval = setInterval(updateLockscreenClock, 1000);
          
          // Play lock sound
          playSound('lock');
        }
      }
      
      function hideLockscreen() {
        const lockscreen = document.getElementById('lockscreen');
        if (lockscreen) {
          lockscreen.classList.remove('active');
          lockscreen.classList.remove('unlock-view');
          lockscreen.classList.remove('screensaver');
          
          // Clear any boot-prep inline overrides so the lockscreen can fully disappear
          lockscreen.style.opacity = '';
          lockscreen.style.zIndex = '';
          lockscreen.style.transition = '';
          lockscreen.style.pointerEvents = '';
          
          state.isLocked = false;
          state.lockscreenInUnlockView = false;
          
          if (lockscreenClockInterval) {
            clearInterval(lockscreenClockInterval);
            lockscreenClockInterval = null;
          }
          
          if (lockscreenIdleTimer) {
            clearTimeout(lockscreenIdleTimer);
            lockscreenIdleTimer = null;
          }
          
          // Clear password input
          const input = document.getElementById('lockscreen-password');
          if (input) input.value = '';
          
          // Clear error
          const errorEl = document.getElementById('lockscreen-error');
          if (errorEl) errorEl.classList.remove('visible');
          
          // Play unlock sound
          playSound('unlock');
          
          // Force desktop to be interactive by triggering a re-render after unlock
          // This ensures all UI elements are properly responsive
          setTimeout(() => {
            // Blur any lingering focus from lockscreen
            if (document.activeElement && document.activeElement !== document.body) {
              document.activeElement.blur();
            }
            // Re-render to ensure desktop is fully interactive
            render();
          }, 50);
        }
      }
      
      window.unlockScreen = function() {
        const passwordHash = localStorage.getItem('mos_password_hash');
        
        if (!passwordHash) {
          // No password set, just unlock
          hideLockscreen();
          return;
        }
        
        const input = document.getElementById('lockscreen-password');
        const errorEl = document.getElementById('lockscreen-error');
        
        if (input && errorEl) {
          const enteredHash = simpleHash(input.value);
          
          if (enteredHash === passwordHash) {
            hideLockscreen();
          } else {
            // Show error with shake animation
            errorEl.classList.add('visible');
            input.value = '';
            input.focus();
            
            // Hide error after delay
            setTimeout(() => {
              errorEl.classList.remove('visible');
            }, 2000);
          }
        }
      };
      
      // Handle keyboard on lockscreen
      document.addEventListener('keydown', function(e) {
        const lockscreen = document.getElementById('lockscreen');
        if (!lockscreen || !lockscreen.classList.contains('active')) return;
        
        // Enter to unlock (only works when in unlock view or no password)
        if (e.key === 'Enter') {
          e.preventDefault();
          if (lockscreen.classList.contains('unlock-view')) {
            unlockScreen();
          } else {
            // Any key press enters unlock view first
            enterUnlockView();
          }
          return;
        }
        
        // Escape to go back to initial view (when in unlock view)
        if (e.key === 'Escape') {
          e.preventDefault();
          if (lockscreen.classList.contains('unlock-view')) {
            exitUnlockView();
          }
          return;
        }
        
        // Any other key (except modifiers) enters unlock view
        if (!lockscreen.classList.contains('unlock-view') && !e.ctrlKey && !e.altKey && !e.metaKey) {
          if (e.key.length === 1 || e.key === 'Backspace' || e.key === 'Delete') {
            // Prevent Space from causing scroll/button activation issues
            if (e.key === ' ') {
              e.preventDefault();
            }
            enterUnlockView();
          }
        }
        
        // When in unlock view, prevent Space from triggering back behavior
        if (lockscreen.classList.contains('unlock-view') && e.key === ' ') {
          e.preventDefault();
        }
      });
      
      // Lock screen function (can be called from UI)
      window.lockScreen = function() {
        // Don't lock if already locked
        if (state.isLocked) return;
        showLockscreen();
        setupLockscreenIdleDetection();
      };
      
      // ============= BOOT ORCHESTRATION =============
      async function startOS() {
        console.log('[Boot] Starting M OS...');
        
        // Check power state first
        const powerState = localStorage.getItem('mos_power_state');
        
        // Always show power-off screen on page load UNLESS it's a restart
        // This ensures the user must always press the power button to start
        if (powerState !== 'restart') {
          console.log('[Boot] Showing power-off screen - user must press power button to start');
          const bootScreen = document.getElementById('boot-screen');
          if (bootScreen) bootScreen.style.display = 'none';
          
          const powerOffScreen = document.getElementById('power-off-screen');
          if (powerOffScreen) {
            powerOffScreen.classList.remove('hidden');
            // Reapply cursor styles to power-off screen
            reapplyCursorToElement(powerOffScreen);
          }
          
          // Set power state to off so next reload also shows power screen
          localStorage.setItem('mos_power_state', 'off');
          return;
        }
        
        // If restart, clear the state and proceed normally
        if (powerState === 'restart') {
          localStorage.removeItem('mos_power_state');
          // Hide power-off screen since we're restarting
          const powerOffScreen = document.getElementById('power-off-screen');
          if (powerOffScreen) {
            powerOffScreen.classList.add('hidden');
          }
        }
        
        // Apply saved cursor preference immediately before boot screen shows
        const savedCursor = localStorage.getItem(CURSOR_CONFIG.enabledKey);
        if (savedCursor === 'true') {
          // Cursor will be applied by the cursor system
        }
        
        // Pre-check lockscreen settings BEFORE boot sequence
        const lockscreenEnabled = state.lockscreenSettings?.lockscreenEnabled !== false;
        const isFirstBoot = !state.setupComplete;
        
        // Prepare lockscreen during boot (hidden but ready)
        if (!isFirstBoot && lockscreenEnabled) {
          prepareLockscreenForBoot();
        }
        
        // Run boot animation
        await runBootSequence();
        
        // Check if first boot (setup not complete)
        if (isFirstBoot) {
          console.log('[Boot] First boot - showing setup');
          showSetupScreen();
          return;
        }
        
        const hasPassword = !!localStorage.getItem('mos_password_hash');
        
        // Show lockscreen if enabled (it's already prepared, just reveal it)
        if (lockscreenEnabled) {
          console.log('[Boot] Showing lockscreen' + (hasPassword ? ' (password protected)' : ''));
          revealPreparedLockscreen();
          setupLockscreenIdleDetection();
        } else {
          console.log('[Boot] Lockscreen disabled, going straight to desktop');
        }
      }
      
      // Helper function to reapply cursor to an element and its children
      function reapplyCursorToElement(element) {
        if (!areCursorsEnabled()) return;
        // The CSS already handles cursor: none, but we ensure the cursor follower is visible
        if (cursorFollower && cursorFollower.style.display === 'none') {
          cursorFollower.style.display = 'block';
        }
      }
      
      // Prepare lockscreen during boot (sets up content but doesn't show yet)
      function prepareLockscreenForBoot() {
        const lockscreen = document.getElementById('lockscreen');
        const username = localStorage.getItem('mos_username') || 'User';
        const hasPassword = !!localStorage.getItem('mos_password_hash');
        
        if (lockscreen) {
          // Set username and avatar
          const usernameEl = document.getElementById('lockscreen-username');
          const avatarEl = document.getElementById('lockscreen-avatar');
          const passwordContainer = document.getElementById('lockscreen-password-container');
          const unlockBtn = document.getElementById('lockscreen-unlock-btn');
          
          if (usernameEl) usernameEl.textContent = username;
          if (avatarEl) avatarEl.textContent = username.charAt(0).toUpperCase();
          
          // Show password input or unlock button based on password existence
          if (hasPassword) {
            if (passwordContainer) passwordContainer.style.display = 'block';
            if (unlockBtn) unlockBtn.style.display = 'none';
          } else {
            if (passwordContainer) passwordContainer.style.display = 'none';
            if (unlockBtn) unlockBtn.style.display = 'inline-block';
          }
          
          // Set background
          const bg = document.getElementById('lockscreen-bg');
          const wallpaperToUse = getLockscreenWallpaper();
          
          if (bg) {
            if (wallpaperToUse) {
              bg.style.background = 'none';
              bg.style.backgroundImage = 'url("' + wallpaperToUse + '")';
              bg.style.backgroundSize = 'cover';
              bg.style.backgroundPosition = 'center';
              bg.style.backgroundRepeat = 'no-repeat';
              bg.style.filter = '';
              bg.style.transform = '';
            } else {
              bg.style.backgroundImage = 'none';
              bg.style.background = 'linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0f0f1a 100%)';
              bg.style.filter = '';
              bg.style.transform = '';
            }
          }
          
          // Reset to initial time-only view
          lockscreen.classList.remove('unlock-view');
          state.lockscreenInUnlockView = false;
          
          // Prepare lockscreen during boot: keep it active behind the boot screen.
          // IMPORTANT: do not set inline opacity here, otherwise unlock may not hide it.
          lockscreen.style.opacity = '';
          lockscreen.style.zIndex = '';
          lockscreen.style.transition = '';
          lockscreen.classList.add('active');
          state.isLocked = true;
          
          // Apply clock style and update clock
          applyLockscreenClockStyle();
          updateLockscreenClock();
          lockscreenClockInterval = setInterval(updateLockscreenClock, 1000);
        }
      }
      
      // Reveal the prepared lockscreen (boot fades away to reveal it)
      function revealPreparedLockscreen() {
        const lockscreen = document.getElementById('lockscreen');
        if (lockscreen) {
          // Ensure any boot-prep inline styles are cleared so normal lock/unlock works
          lockscreen.style.opacity = '';
          lockscreen.style.zIndex = '';
          lockscreen.style.transition = '';
          
          // Lock sound on boot reveal
          playSound('lock');
        }
      }

      // Force-remove the Window List from the top bar (also clears any persisted layout overrides)
      (function sanitizeContextMenuLayout() {
        try {
          const layout = state.contextMenuLayout;
          if (!layout || !Array.isArray(layout.elements)) return;

          const before = layout.elements.length;
          layout.elements = layout.elements.filter(e => e?.id !== 'windowlist');

          if (layout.elements.length !== before) {
            localStorage.setItem('contextMenuLayout', JSON.stringify(layout));
          }
        } catch (e) {
          // no-op
        }
      })();

      // Store preserved iframes outside render to prevent recreating them on re-render
      // This MUST be declared before getWindowContent to be accessible from it
      const preservedIframes = new Map();
      
      // Store preserved Task Manager content to prevent refresh on window focus/render
      const preservedTaskManagerContent = new Map();

      // ============= Virtual DOM Batching Layer =============
      // Batches multiple state changes before committing to the real DOM
      // Uses requestAnimationFrame for optimal timing and prevents layout thrashing
      
      const vdom = {
        // Pending state changes queue
        pendingChanges: [],
        
        // Batch frame request ID
        batchFrameId: null,
        
        // Track what needs to be updated
        dirty: {
          windows: false,
          shell: false,
          full: false,
          // Granular window updates
          windowPatches: new Map(), // windowId -> {props to update}
        },
        
        // Batch timing
        lastCommitTime: 0,
        minBatchInterval: 16, // ~60fps
        
        // Queue a state change with optional render type
        // renderType: 'windows' | 'shell' | 'full' | 'none'
        queue(changes, renderType = 'windows') {
          // Apply changes to state immediately (for reads to work)
          if (typeof changes === 'function') {
            changes(state);
          } else if (typeof changes === 'object') {
            Object.assign(state, changes);
          }
          
          // Mark what's dirty
          if (renderType === 'full') {
            this.dirty.full = true;
          } else if (renderType === 'shell') {
            this.dirty.shell = true;
          } else if (renderType === 'windows') {
            this.dirty.windows = true;
          }
          // 'none' means no render needed
          
          // Schedule batch commit
          this.scheduleBatch();
        },
        
        // Queue a window-specific update (more granular)
        queueWindowUpdate(windowId, updates) {
          const existing = this.dirty.windowPatches.get(windowId) || {};
          this.dirty.windowPatches.set(windowId, { ...existing, ...updates });
          this.dirty.windows = true;
          this.scheduleBatch();
        },
        
        // Schedule the batch commit on next animation frame
        scheduleBatch() {
          if (this.batchFrameId !== null) return; // Already scheduled
          
          this.batchFrameId = requestAnimationFrame((timestamp) => {
            this.commit(timestamp);
          });
        },
        
        // Cancel pending batch (useful during drag operations)
        cancelBatch() {
          if (this.batchFrameId !== null) {
            cancelAnimationFrame(this.batchFrameId);
            this.batchFrameId = null;
          }
        },
        
        // Commit all pending changes to the real DOM
        commit(timestamp) {
          this.batchFrameId = null;
          
          // Skip if we're dragging/resizing (let dedicated handlers manage)
          // Note: dragState/resizeState are declared later, use typeof check
          if ((typeof dragState !== 'undefined' && dragState) || 
              (typeof resizeState !== 'undefined' && resizeState)) {
            // Still process dirty flags after drag ends
            return;
          }
          
          // Determine what to render
          if (this.dirty.full) {
            render();
          } else {
            // Apply granular window patches first
            if (this.dirty.windowPatches.size > 0) {
              this.applyWindowPatches();
            }
            
            // Then do broader updates if needed
            if (this.dirty.windows) {
              renderWindows();
            }
            if (this.dirty.shell) {
              renderShell();
            }
          }
          
          // Reset dirty flags
          this.resetDirty();
          this.lastCommitTime = timestamp;
        },
        
        // Apply granular window patches without full renderWindows
        applyWindowPatches() {
          this.dirty.windowPatches.forEach((updates, windowId) => {
            const windowEl = document.querySelector('.window[data-id="' + windowId + '"]');
            if (!windowEl) return;
            
            const win = state.windows.find(w => w.id === parseInt(windowId, 10));
            if (!win) return;
            
            // Apply position/size updates directly
            if (updates.x !== undefined || updates.y !== undefined) {
              windowEl.style.left = (updates.x ?? win.x) + 'px';
              windowEl.style.top = (updates.y ?? win.y) + 'px';
            }
            if (updates.width !== undefined || updates.height !== undefined) {
              windowEl.style.width = (updates.width ?? win.width) + 'px';
              windowEl.style.height = (updates.height ?? win.height) + 'px';
            }
            if (updates.zIndex !== undefined) {
              windowEl.style.zIndex = updates.zIndex;
            }
            
            // Apply class updates
            if (updates.isMaximized !== undefined) {
              if (updates.isMaximized) {
                windowEl.classList.add('maximized');
              } else {
                windowEl.classList.remove('maximized');
              }
            }
            if (updates.isMinimized !== undefined) {
              windowEl.style.display = updates.isMinimized ? 'none' : '';
            }
          });
        },
        
        // Reset all dirty flags
        resetDirty() {
          this.dirty.windows = false;
          this.dirty.shell = false;
          this.dirty.full = false;
          this.dirty.windowPatches.clear();
        },
        
        // Force immediate commit (bypasses batching)
        flush() {
          this.cancelBatch();
          this.commit(performance.now());
        },
        
        // Batch multiple operations together
        batch(callback) {
          // Temporarily disable auto-scheduling
          const wasScheduled = this.batchFrameId !== null;
          this.cancelBatch();
          
          // Run all operations
          callback();
          
          // Now schedule a single commit
          this.scheduleBatch();
        }
      };
      
      // Proxy wrapper for state to auto-queue updates
      // Usage: vdom.setState({ key: value }) or vdom.setState(s => s.key = value)
      vdom.setState = function(changes, renderType = 'windows') {
        this.queue(changes, renderType);
      };
      
      // Convenience methods for common operations
      vdom.updateWindow = function(windowId, updates) {
        const win = state.windows.find(w => w.id === windowId);
        if (win) {
          Object.assign(win, updates);
          this.queueWindowUpdate(windowId, updates);
        }
      };
      
      vdom.bringToFront = function(windowId) {
        const win = state.windows.find(w => w.id === windowId);
        if (win) {
          win.zIndex = ++state.nextZIndex;
          state.activeWindowId = windowId;
          this.queueWindowUpdate(windowId, { zIndex: win.zIndex });
        }
      };
      
      // Expose globally
      window.vdom = vdom;

      // ============= ICON PACKS SYSTEM =============
      // Classic pack - colorful macOS-style icons
      const iconsClassic = {
        Files: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="finderBgGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#5AC8FA"/><stop offset="100%" stop-color="#007AFF"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#finderBgGrad)"/><path d="M14 24 L14 46 Q14 48 16 48 L48 48 Q50 48 50 46 L50 24 Q50 22 48 22 L14 22 Q14 22 14 24 Z" fill="white" opacity="0.9"/><path d="M14 22 L14 20 Q14 18 16 18 L26 18 Q28 18 29 20 L31 22 L14 22 Z" fill="white" opacity="0.8"/><path d="M12 26 L12 48 Q12 50 14 50 L50 50 Q52 50 52 48 L52 26 Q52 24 50 24 L14 24 Q12 24 12 26 Z" fill="white"/></svg>`,
        Terminal: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="termGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#464646"/><stop offset="100%" stop-color="#1a1a1a"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#termGrad)"/><path d="M18 22 L28 32 L18 42" stroke="#4ADE80" stroke-width="3.5" stroke-linecap="round" stroke-linejoin="round" fill="none"/><line x1="32" y1="42" x2="46" y2="42" stroke="#4ADE80" stroke-width="3.5" stroke-linecap="round"/></svg>`,
        Browser: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="safariGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#5AC8FA"/><stop offset="100%" stop-color="#007AFF"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#safariGrad)"/><circle cx="32" cy="32" r="18" fill="white"/><polygon points="32,16 36,32 32,36 28,32" fill="#FF3B30"/><polygon points="32,48 28,32 32,28 36,32" fill="#FF3B30" opacity="0.4"/><circle cx="32" cy="32" r="3" fill="white" stroke="#ccc" stroke-width="0.5"/></svg>`,
        Mail: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="mailGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#5AC8FA"/><stop offset="100%" stop-color="#007AFF"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#mailGrad)"/><rect x="12" y="20" width="40" height="26" rx="3" fill="white"/><path d="M12 22 L32 36 L52 22" stroke="#007AFF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"/></svg>`,
        Music: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="musicGrad" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#FC3C44"/><stop offset="100%" stop-color="#FF2D55"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#musicGrad)"/><ellipse cx="24" cy="42" rx="7" ry="6" fill="white"/><ellipse cx="44" cy="38" rx="7" ry="6" fill="white"/><path d="M31 42 L31 18 L51 14 L51 38" stroke="white" stroke-width="4" fill="none"/></svg>`,
        Settings: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="settingsGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#8E8E93"/><stop offset="100%" stop-color="#636366"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#settingsGrad)"/><g fill="white"><circle cx="32" cy="32" r="10"/><rect x="29" y="10" width="6" height="10" rx="2"/><rect x="29" y="44" width="6" height="10" rx="2"/><rect x="10" y="29" width="10" height="6" rx="2"/><rect x="44" y="29" width="10" height="6" rx="2"/><rect x="29" y="10" width="6" height="10" rx="2" transform="rotate(45 32 32)"/><rect x="29" y="10" width="6" height="10" rx="2" transform="rotate(135 32 32)"/><rect x="29" y="10" width="6" height="10" rx="2" transform="rotate(225 32 32)"/><rect x="29" y="10" width="6" height="10" rx="2" transform="rotate(315 32 32)"/></g><circle cx="32" cy="32" r="5" fill="#636366"/></svg>`,
        Finder: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="launchGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#636366"/><stop offset="100%" stop-color="#3A3A3C"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#launchGrad)"/><g fill="white"><circle cx="20" cy="20" r="5"/><circle cx="32" cy="20" r="5"/><circle cx="44" cy="20" r="5"/><circle cx="20" cy="32" r="5"/><circle cx="32" cy="32" r="5"/><circle cx="44" cy="32" r="5"/><circle cx="20" cy="44" r="5"/><circle cx="32" cy="44" r="5"/><circle cx="44" cy="44" r="5"/></g></svg>`,
        Camera: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="photosGrad" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#FF6B6B"/><stop offset="25%" stop-color="#FF9500"/><stop offset="50%" stop-color="#FFD60A"/><stop offset="75%" stop-color="#30D158"/><stop offset="100%" stop-color="#5AC8FA"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="white"/><ellipse cx="32" cy="20" rx="8" ry="12" fill="#FF3B30"/><ellipse cx="42" cy="26" rx="8" ry="12" fill="#FF9500" transform="rotate(60 42 26)"/><ellipse cx="42" cy="38" rx="8" ry="12" fill="#FFCC00" transform="rotate(120 42 38)"/><ellipse cx="32" cy="44" rx="8" ry="12" fill="#34C759"/><ellipse cx="22" cy="38" rx="8" ry="12" fill="#5AC8FA" transform="rotate(60 22 38)"/><ellipse cx="22" cy="26" rx="8" ry="12" fill="#AF52DE" transform="rotate(120 22 26)"/><circle cx="32" cy="32" r="6" fill="white"/></svg>`,
        Video: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="facetimeGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#34C759"/><stop offset="100%" stop-color="#30B350"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#facetimeGrad)"/><rect x="12" y="22" width="28" height="20" rx="4" fill="white"/><path d="M42 26 L52 20 L52 44 L42 38 Z" fill="white"/></svg>`,
        Document: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="notesGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#FFD60A"/><stop offset="100%" stop-color="#FFCC00"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#notesGrad)"/><rect x="14" y="12" width="36" height="40" rx="3" fill="white"/><g stroke="#FFD60A" stroke-width="1.5"><line x1="20" y1="22" x2="44" y2="22"/><line x1="20" y1="28" x2="44" y2="28"/><line x1="20" y1="34" x2="44" y2="34"/><line x1="20" y1="40" x2="36" y2="40"/></g></svg>`,
        Download: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="downGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#5AC8FA"/><stop offset="100%" stop-color="#007AFF"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#downGrad)"/><path d="M32 14 L32 40" stroke="white" stroke-width="4" stroke-linecap="round"/><path d="M20 32 L32 44 L44 32" stroke="white" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" fill="none"/><line x1="16" y1="50" x2="48" y2="50" stroke="white" stroke-width="4" stroke-linecap="round"/></svg>`,
        Messages: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="messagesGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#65D36E"/><stop offset="100%" stop-color="#2DC84D"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#messagesGrad)"/><path d="M12 32 Q12 16 32 16 Q52 16 52 32 Q52 46 38 48 L32 54 L30 48 Q12 46 12 32 Z" fill="white"/></svg>`,
        Maps: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="mapsGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#4CD964"/><stop offset="50%" stop-color="#5AC8FA"/><stop offset="100%" stop-color="#007AFF"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#mapsGrad)"/><path d="M16 52 L16 16 L28 22 L40 14 L48 20 L48 52 L36 46 L24 54 Z" fill="white" opacity="0.9"/><path d="M24 22 L24 50" stroke="#34C759" stroke-width="2"/><path d="M36 18 L36 46" stroke="#FF3B30" stroke-width="2"/></svg>`,
        Calendar: `<svg viewBox="0 0 64 64" fill="none"><rect x="4" y="4" width="56" height="56" rx="14" fill="white"/><rect x="4" y="4" width="56" height="18" rx="14 14 0 0" fill="#FF3B30"/><text x="32" y="18" fill="white" font-size="10" font-weight="600" text-anchor="middle" font-family="SF Pro Display, sans-serif">WED</text><text x="32" y="46" fill="#1a1a1a" font-size="28" font-weight="300" text-anchor="middle" font-family="SF Pro Display, sans-serif">22</text></svg>`,
        AppStore: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="appstoreGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#1E90FF"/><stop offset="100%" stop-color="#0066CC"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#appstoreGrad)"/><path d="M16 24 L16 50 Q16 52 18 52 L46 52 Q48 52 48 50 L48 24 Z" fill="white"/><path d="M24 24 L24 18 Q24 12 32 12 Q40 12 40 18 L40 24" stroke="white" stroke-width="3" fill="none" stroke-linecap="round"/><path d="M24 44V32h3l5 8 5-8h3v12h-3V36l-5 8-5-8v8h-3z" fill="#0066CC"/></svg>`,
        Podcasts: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="podcastsGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#AF52DE"/><stop offset="100%" stop-color="#8944AB"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#podcastsGrad)"/><circle cx="32" cy="26" r="8" fill="white"/><path d="M28 34 L28 50 Q28 52 32 52 Q36 52 36 50 L36 34" fill="white"/><path d="M18 30 Q18 14 32 14 Q46 14 46 30" stroke="white" stroke-width="3" fill="none" stroke-linecap="round"/><path d="M22 32 Q22 20 32 20 Q42 20 42 32" stroke="white" stroke-width="3" fill="none" stroke-linecap="round"/></svg>`,
        Contacts: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="contactsGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#C9A77C"/><stop offset="100%" stop-color="#A67C52"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#contactsGrad)"/><circle cx="32" cy="26" r="10" fill="white"/><ellipse cx="32" cy="52" rx="16" ry="12" fill="white"/></svg>`,
        Trash: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="trashGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#8E8E93"/><stop offset="100%" stop-color="#636366"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#trashGrad)"/><path d="M20 22 L44 22 L42 50 L22 50 Z" fill="white"/><rect x="18" y="18" width="28" height="4" rx="2" fill="white"/><rect x="28" y="14" width="8" height="4" rx="1" fill="white"/><g stroke="#8E8E93" stroke-width="2"><line x1="27" y1="28" x2="27" y2="44"/><line x1="32" y1="28" x2="32" y2="44"/><line x1="37" y1="28" x2="37" y2="44"/></g></svg>`,
        TaskManager: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="taskGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#10B981"/><stop offset="100%" stop-color="#059669"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#taskGrad)"/><rect x="14" y="38" width="8" height="12" rx="2" fill="white" opacity="0.9"/><rect x="24" y="28" width="8" height="22" rx="2" fill="white" opacity="0.9"/><rect x="34" y="18" width="8" height="32" rx="2" fill="white" opacity="0.9"/><rect x="44" y="24" width="8" height="26" rx="2" fill="white" opacity="0.9"/><path d="M12 22 L22 18 L32 14 L42 16 L52 12" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" fill="none"/></svg>`,
        Minecraft: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="mcGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#7CB342"/><stop offset="100%" stop-color="#558B2F"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#mcGrad)"/><rect x="18" y="18" width="10" height="10" fill="#1a1a1a"/><rect x="36" y="18" width="10" height="10" fill="#1a1a1a"/><rect x="28" y="28" width="8" height="6" fill="#1a1a1a"/><rect x="24" y="34" width="16" height="4" fill="#1a1a1a"/><rect x="24" y="38" width="6" height="8" fill="#1a1a1a"/><rect x="34" y="38" width="6" height="8" fill="#1a1a1a"/></svg>`,
      };
      
      // Monochrome pack - dark gray backgrounds with white icons
      const iconsMonochrome = {
        Files: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoFilesGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#3a3a3e"/><stop offset="100%" stop-color="#1a1a1e"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoFilesGrad)"/><path d="M14 24 L14 46 Q14 48 16 48 L48 48 Q50 48 50 46 L50 24 Q50 22 48 22 L14 22 Q14 22 14 24 Z" fill="white" opacity="0.85"/><path d="M14 22 L14 20 Q14 18 16 18 L26 18 Q28 18 29 20 L31 22 L14 22 Z" fill="white" opacity="0.7"/><path d="M12 26 L12 48 Q12 50 14 50 L50 50 Q52 50 52 48 L52 26 Q52 24 50 24 L14 24 Q12 24 12 26 Z" fill="white"/></svg>`,
        Terminal: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoTermGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#2a2a2e"/><stop offset="100%" stop-color="#0a0a0e"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoTermGrad)"/><path d="M18 22 L28 32 L18 42" stroke="white" stroke-width="3.5" stroke-linecap="round" stroke-linejoin="round" fill="none"/><line x1="32" y1="42" x2="46" y2="42" stroke="white" stroke-width="3.5" stroke-linecap="round"/></svg>`,
        Browser: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoBrowserGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#4a4a4e"/><stop offset="100%" stop-color="#2a2a2e"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoBrowserGrad)"/><circle cx="32" cy="32" r="16" stroke="white" stroke-width="2.5" fill="none"/><ellipse cx="32" cy="32" rx="8" ry="16" stroke="white" stroke-width="2" fill="none"/><line x1="16" y1="32" x2="48" y2="32" stroke="white" stroke-width="2"/><line x1="32" y1="16" x2="32" y2="48" stroke="white" stroke-width="2"/></svg>`,
        Mail: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoMailGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#3a3a3e"/><stop offset="100%" stop-color="#1a1a1e"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoMailGrad)"/><rect x="12" y="20" width="40" height="26" rx="3" fill="white"/><path d="M12 22 L32 36 L52 22" stroke="#2a2a2e" stroke-width="2" fill="none"/></svg>`,
        Music: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoMusicGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#3a3a3e"/><stop offset="100%" stop-color="#1a1a1e"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoMusicGrad)"/><ellipse cx="24" cy="42" rx="7" ry="6" fill="white"/><ellipse cx="44" cy="38" rx="7" ry="6" fill="white"/><path d="M31 42 L31 18 L51 14 L51 38" stroke="white" stroke-width="4" fill="none"/></svg>`,
        Settings: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoSettingsGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#4a4a4e"/><stop offset="100%" stop-color="#2a2a2e"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoSettingsGrad)"/><g fill="white"><circle cx="32" cy="32" r="10"/><rect x="29" y="10" width="6" height="10" rx="2"/><rect x="29" y="44" width="6" height="10" rx="2"/><rect x="10" y="29" width="10" height="6" rx="2"/><rect x="44" y="29" width="10" height="6" rx="2"/><rect x="29" y="10" width="6" height="10" rx="2" transform="rotate(45 32 32)"/><rect x="29" y="10" width="6" height="10" rx="2" transform="rotate(135 32 32)"/><rect x="29" y="10" width="6" height="10" rx="2" transform="rotate(225 32 32)"/><rect x="29" y="10" width="6" height="10" rx="2" transform="rotate(315 32 32)"/></g><circle cx="32" cy="32" r="5" fill="#3a3a3e"/></svg>`,
        Finder: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoLaunchGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#3a3a3e"/><stop offset="100%" stop-color="#1a1a1e"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoLaunchGrad)"/><g fill="white"><circle cx="20" cy="20" r="5"/><circle cx="32" cy="20" r="5"/><circle cx="44" cy="20" r="5"/><circle cx="20" cy="32" r="5"/><circle cx="32" cy="32" r="5"/><circle cx="44" cy="32" r="5"/><circle cx="20" cy="44" r="5"/><circle cx="32" cy="44" r="5"/><circle cx="44" cy="44" r="5"/></g></svg>`,
        Camera: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoCameraGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#3a3a3e"/><stop offset="100%" stop-color="#1a1a1e"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoCameraGrad)"/><rect x="12" y="22" width="40" height="28" rx="4" fill="white"/><circle cx="32" cy="36" r="10" fill="#2a2a2e"/><circle cx="32" cy="36" r="6" fill="white"/><circle cx="32" cy="36" r="3" fill="#2a2a2e"/><rect x="24" y="14" width="16" height="8" rx="2" fill="white"/></svg>`,
        Video: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoVideoGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#3a3a3e"/><stop offset="100%" stop-color="#1a1a1e"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoVideoGrad)"/><rect x="12" y="22" width="28" height="20" rx="4" fill="white"/><path d="M42 26 L52 20 L52 44 L42 38 Z" fill="white"/></svg>`,
        Document: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoDocGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#3a3a3e"/><stop offset="100%" stop-color="#1a1a1e"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoDocGrad)"/><rect x="14" y="12" width="36" height="40" rx="3" fill="white"/><g stroke="#2a2a2e" stroke-width="1.5"><line x1="20" y1="22" x2="44" y2="22"/><line x1="20" y1="28" x2="44" y2="28"/><line x1="20" y1="34" x2="44" y2="34"/><line x1="20" y1="40" x2="36" y2="40"/></g></svg>`,
        Download: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoDownGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#3a3a3e"/><stop offset="100%" stop-color="#1a1a1e"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoDownGrad)"/><path d="M32 14 L32 40" stroke="white" stroke-width="4" stroke-linecap="round"/><path d="M20 32 L32 44 L44 32" stroke="white" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" fill="none"/><line x1="16" y1="50" x2="48" y2="50" stroke="white" stroke-width="4" stroke-linecap="round"/></svg>`,
        Messages: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoMsgGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#3a3a3e"/><stop offset="100%" stop-color="#1a1a1e"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoMsgGrad)"/><path d="M12 32 Q12 16 32 16 Q52 16 52 32 Q52 46 38 48 L32 54 L30 48 Q12 46 12 32 Z" fill="white"/></svg>`,
        Maps: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoMapsGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#3a3a3e"/><stop offset="100%" stop-color="#1a1a1e"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoMapsGrad)"/><path d="M32 52 L32 52 C32 52 16 36 16 26 C16 17 23 10 32 10 C41 10 48 17 48 26 C48 36 32 52 32 52 Z" fill="white"/><circle cx="32" cy="26" r="8" fill="#2a2a2e"/></svg>`,
        Calendar: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoCalGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#3a3a3e"/><stop offset="100%" stop-color="#1a1a1e"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoCalGrad)"/><rect x="10" y="16" width="44" height="38" rx="4" fill="white"/><rect x="10" y="16" width="44" height="12" rx="4" fill="#2a2a2e"/><text x="32" y="46" fill="#1a1a1a" font-size="22" font-weight="600" text-anchor="middle" font-family="Space Grotesk, sans-serif">22</text><rect x="20" y="10" width="4" height="10" rx="2" fill="white"/><rect x="40" y="10" width="4" height="10" rx="2" fill="white"/></svg>`,
        AppStore: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoStoreGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#2a2a2e"/><stop offset="100%" stop-color="#0f0f12"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoStoreGrad)"/><path d="M16 24 L16 50 Q16 52 18 52 L46 52 Q48 52 48 50 L48 24 Z" fill="white"/><path d="M24 24 L24 18 Q24 12 32 12 Q40 12 40 18 L40 24" stroke="white" stroke-width="3" fill="none" stroke-linecap="round"/><path d="M24 44V32h3l5 8 5-8h3v12h-3V36l-5 8-5-8v8h-3z" fill="#1a1a1e"/></svg>`,
        Podcasts: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoPodGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#3a3a3e"/><stop offset="100%" stop-color="#1a1a1e"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoPodGrad)"/><circle cx="32" cy="26" r="8" fill="white"/><path d="M28 34 L28 50 Q28 52 32 52 Q36 52 36 50 L36 34" fill="white"/><path d="M18 30 Q18 14 32 14 Q46 14 46 30" stroke="white" stroke-width="3" fill="none" stroke-linecap="round"/><path d="M22 32 Q22 20 32 20 Q42 20 42 32" stroke="white" stroke-width="3" fill="none" stroke-linecap="round"/></svg>`,
        Contacts: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoContactGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#3a3a3e"/><stop offset="100%" stop-color="#1a1a1e"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoContactGrad)"/><circle cx="32" cy="24" r="10" fill="white"/><ellipse cx="32" cy="52" rx="16" ry="12" fill="white"/></svg>`,
        Trash: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoTrashGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#4a4a4e"/><stop offset="100%" stop-color="#2a2a2e"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoTrashGrad)"/><path d="M20 22 L44 22 L42 50 L22 50 Z" fill="white"/><rect x="18" y="18" width="28" height="4" rx="2" fill="white"/><rect x="28" y="14" width="8" height="4" rx="1" fill="white"/><g stroke="#3a3a3e" stroke-width="2"><line x1="27" y1="28" x2="27" y2="44"/><line x1="32" y1="28" x2="32" y2="44"/><line x1="37" y1="28" x2="37" y2="44"/></g></svg>`,
        TaskManager: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoTaskGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#3a3a3e"/><stop offset="100%" stop-color="#1a1a1e"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoTaskGrad)"/><rect x="14" y="38" width="8" height="12" rx="2" fill="white" opacity="0.9"/><rect x="24" y="28" width="8" height="22" rx="2" fill="white" opacity="0.9"/><rect x="34" y="18" width="8" height="32" rx="2" fill="white" opacity="0.9"/><rect x="44" y="24" width="8" height="26" rx="2" fill="white" opacity="0.9"/><path d="M12 22 L22 18 L32 14 L42 16 L52 12" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" fill="none"/></svg>`,
        Minecraft: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoMcGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#3a3a3e"/><stop offset="100%" stop-color="#1a1a1e"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoMcGrad)"/><rect x="18" y="18" width="10" height="10" fill="white"/><rect x="36" y="18" width="10" height="10" fill="white"/><rect x="28" y="28" width="8" height="6" fill="white"/><rect x="24" y="34" width="16" height="4" fill="white"/><rect x="24" y="38" width="6" height="8" fill="white"/><rect x="34" y="38" width="6" height="8" fill="white"/></svg>`,
      };
      
      // Monochrome pack for light mode - light gray backgrounds with dark icons
      const iconsMonochromeLight = {
        Files: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoLightFilesGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#f5f5f5"/><stop offset="100%" stop-color="#e0e0e0"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoLightFilesGrad)"/><path d="M14 24 L14 46 Q14 48 16 48 L48 48 Q50 48 50 46 L50 24 Q50 22 48 22 L14 22 Q14 22 14 24 Z" fill="#1a1a1e" opacity="0.85"/><path d="M14 22 L14 20 Q14 18 16 18 L26 18 Q28 18 29 20 L31 22 L14 22 Z" fill="#1a1a1e" opacity="0.7"/><path d="M12 26 L12 48 Q12 50 14 50 L50 50 Q52 50 52 48 L52 26 Q52 24 50 24 L14 24 Q12 24 12 26 Z" fill="#1a1a1e"/></svg>`,
        Terminal: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoLightTermGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#e8e8e8"/><stop offset="100%" stop-color="#d0d0d0"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoLightTermGrad)"/><path d="M18 22 L28 32 L18 42" stroke="#1a1a1e" stroke-width="3.5" stroke-linecap="round" stroke-linejoin="round" fill="none"/><line x1="32" y1="42" x2="46" y2="42" stroke="#1a1a1e" stroke-width="3.5" stroke-linecap="round"/></svg>`,
        Browser: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoLightBrowserGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#f0f0f0"/><stop offset="100%" stop-color="#dcdcdc"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoLightBrowserGrad)"/><circle cx="32" cy="32" r="16" stroke="#1a1a1e" stroke-width="2.5" fill="none"/><ellipse cx="32" cy="32" rx="8" ry="16" stroke="#1a1a1e" stroke-width="2" fill="none"/><line x1="16" y1="32" x2="48" y2="32" stroke="#1a1a1e" stroke-width="2"/><line x1="32" y1="16" x2="32" y2="48" stroke="#1a1a1e" stroke-width="2"/></svg>`,
        Mail: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoLightMailGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#f5f5f5"/><stop offset="100%" stop-color="#e0e0e0"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoLightMailGrad)"/><rect x="12" y="20" width="40" height="26" rx="3" fill="#1a1a1e"/><path d="M12 22 L32 36 L52 22" stroke="#e0e0e0" stroke-width="2" fill="none"/></svg>`,
        Music: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoLightMusicGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#f5f5f5"/><stop offset="100%" stop-color="#e0e0e0"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoLightMusicGrad)"/><ellipse cx="24" cy="42" rx="7" ry="6" fill="#1a1a1e"/><ellipse cx="44" cy="38" rx="7" ry="6" fill="#1a1a1e"/><path d="M31 42 L31 18 L51 14 L51 38" stroke="#1a1a1e" stroke-width="4" fill="none"/></svg>`,
        Settings: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoLightSettingsGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#f0f0f0"/><stop offset="100%" stop-color="#dcdcdc"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoLightSettingsGrad)"/><g fill="#1a1a1e"><circle cx="32" cy="32" r="10"/><rect x="29" y="10" width="6" height="10" rx="2"/><rect x="29" y="44" width="6" height="10" rx="2"/><rect x="10" y="29" width="10" height="6" rx="2"/><rect x="44" y="29" width="10" height="6" rx="2"/><rect x="29" y="10" width="6" height="10" rx="2" transform="rotate(45 32 32)"/><rect x="29" y="10" width="6" height="10" rx="2" transform="rotate(135 32 32)"/><rect x="29" y="10" width="6" height="10" rx="2" transform="rotate(225 32 32)"/><rect x="29" y="10" width="6" height="10" rx="2" transform="rotate(315 32 32)"/></g><circle cx="32" cy="32" r="5" fill="#e0e0e0"/></svg>`,
        Finder: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoLightLaunchGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#f5f5f5"/><stop offset="100%" stop-color="#e0e0e0"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoLightLaunchGrad)"/><g fill="#1a1a1e"><circle cx="20" cy="20" r="5"/><circle cx="32" cy="20" r="5"/><circle cx="44" cy="20" r="5"/><circle cx="20" cy="32" r="5"/><circle cx="32" cy="32" r="5"/><circle cx="44" cy="32" r="5"/><circle cx="20" cy="44" r="5"/><circle cx="32" cy="44" r="5"/><circle cx="44" cy="44" r="5"/></g></svg>`,
        Camera: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoLightCameraGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#f5f5f5"/><stop offset="100%" stop-color="#e0e0e0"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoLightCameraGrad)"/><rect x="12" y="22" width="40" height="28" rx="4" fill="#1a1a1e"/><circle cx="32" cy="36" r="10" fill="#e0e0e0"/><circle cx="32" cy="36" r="6" fill="#1a1a1e"/><circle cx="32" cy="36" r="3" fill="#e0e0e0"/><rect x="24" y="14" width="16" height="8" rx="2" fill="#1a1a1e"/></svg>`,
        Video: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoLightVideoGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#f5f5f5"/><stop offset="100%" stop-color="#e0e0e0"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoLightVideoGrad)"/><rect x="12" y="22" width="28" height="20" rx="4" fill="#1a1a1e"/><path d="M42 26 L52 20 L52 44 L42 38 Z" fill="#1a1a1e"/></svg>`,
        Document: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoLightDocGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#f5f5f5"/><stop offset="100%" stop-color="#e0e0e0"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoLightDocGrad)"/><rect x="14" y="12" width="36" height="40" rx="3" fill="#1a1a1e"/><g stroke="#e0e0e0" stroke-width="1.5"><line x1="20" y1="22" x2="44" y2="22"/><line x1="20" y1="28" x2="44" y2="28"/><line x1="20" y1="34" x2="44" y2="34"/><line x1="20" y1="40" x2="36" y2="40"/></g></svg>`,
        Download: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoLightDownGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#f5f5f5"/><stop offset="100%" stop-color="#e0e0e0"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoLightDownGrad)"/><path d="M32 14 L32 40" stroke="#1a1a1e" stroke-width="4" stroke-linecap="round"/><path d="M20 32 L32 44 L44 32" stroke="#1a1a1e" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" fill="none"/><line x1="16" y1="50" x2="48" y2="50" stroke="#1a1a1e" stroke-width="4" stroke-linecap="round"/></svg>`,
        Messages: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoLightMsgGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#f5f5f5"/><stop offset="100%" stop-color="#e0e0e0"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoLightMsgGrad)"/><path d="M12 32 Q12 16 32 16 Q52 16 52 32 Q52 46 38 48 L32 54 L30 48 Q12 46 12 32 Z" fill="#1a1a1e"/></svg>`,
        Maps: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoLightMapsGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#f5f5f5"/><stop offset="100%" stop-color="#e0e0e0"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoLightMapsGrad)"/><path d="M32 52 L32 52 C32 52 16 36 16 26 C16 17 23 10 32 10 C41 10 48 17 48 26 C48 36 32 52 32 52 Z" fill="#1a1a1e"/><circle cx="32" cy="26" r="8" fill="#e0e0e0"/></svg>`,
        Calendar: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoLightCalGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#f5f5f5"/><stop offset="100%" stop-color="#e0e0e0"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoLightCalGrad)"/><rect x="10" y="16" width="44" height="38" rx="4" fill="#1a1a1e"/><rect x="10" y="16" width="44" height="12" rx="4" fill="#e0e0e0"/><text x="32" y="46" fill="#e8e8e8" font-size="22" font-weight="600" text-anchor="middle" font-family="Space Grotesk, sans-serif">22</text><rect x="20" y="10" width="4" height="10" rx="2" fill="#1a1a1e"/><rect x="40" y="10" width="4" height="10" rx="2" fill="#1a1a1e"/></svg>`,
        AppStore: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoLightStoreGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#e8e8e8"/><stop offset="100%" stop-color="#d0d0d0"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoLightStoreGrad)"/><path d="M16 24 L16 50 Q16 52 18 52 L46 52 Q48 52 48 50 L48 24 Z" fill="#1a1a1e"/><path d="M24 24 L24 18 Q24 12 32 12 Q40 12 40 18 L40 24" stroke="#1a1a1e" stroke-width="3" fill="none" stroke-linecap="round"/><path d="M24 44V32h3l5 8 5-8h3v12h-3V36l-5 8-5-8v8h-3z" fill="#e0e0e0"/></svg>`,
        Podcasts: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoLightPodGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#f5f5f5"/><stop offset="100%" stop-color="#e0e0e0"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoLightPodGrad)"/><circle cx="32" cy="26" r="8" fill="#1a1a1e"/><path d="M28 34 L28 50 Q28 52 32 52 Q36 52 36 50 L36 34" fill="#1a1a1e"/><path d="M18 30 Q18 14 32 14 Q46 14 46 30" stroke="#1a1a1e" stroke-width="3" fill="none" stroke-linecap="round"/><path d="M22 32 Q22 20 32 20 Q42 20 42 32" stroke="#1a1a1e" stroke-width="3" fill="none" stroke-linecap="round"/></svg>`,
        Contacts: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoLightContactGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#f5f5f5"/><stop offset="100%" stop-color="#e0e0e0"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoLightContactGrad)"/><circle cx="32" cy="24" r="10" fill="#1a1a1e"/><ellipse cx="32" cy="52" rx="16" ry="12" fill="#1a1a1e"/></svg>`,
        Trash: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoLightTrashGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#f0f0f0"/><stop offset="100%" stop-color="#dcdcdc"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoLightTrashGrad)"/><path d="M20 22 L44 22 L42 50 L22 50 Z" fill="#1a1a1e"/><rect x="18" y="18" width="28" height="4" rx="2" fill="#1a1a1e"/><rect x="28" y="14" width="8" height="4" rx="1" fill="#1a1a1e"/><g stroke="#e0e0e0" stroke-width="2"><line x1="27" y1="28" x2="27" y2="44"/><line x1="32" y1="28" x2="32" y2="44"/><line x1="37" y1="28" x2="37" y2="44"/></g></svg>`,
        TaskManager: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoLightTaskGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#f5f5f5"/><stop offset="100%" stop-color="#e0e0e0"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoLightTaskGrad)"/><rect x="14" y="38" width="8" height="12" rx="2" fill="#1a1a1e" opacity="0.9"/><rect x="24" y="28" width="8" height="22" rx="2" fill="#1a1a1e" opacity="0.9"/><rect x="34" y="18" width="8" height="32" rx="2" fill="#1a1a1e" opacity="0.9"/><rect x="44" y="24" width="8" height="26" rx="2" fill="#1a1a1e" opacity="0.9"/><path d="M12 22 L22 18 L32 14 L42 16 L52 12" stroke="#1a1a1e" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" fill="none"/></svg>`,
        Minecraft: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="monoLightMcGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#f5f5f5"/><stop offset="100%" stop-color="#e0e0e0"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#monoLightMcGrad)"/><rect x="18" y="18" width="10" height="10" fill="#1a1a1e"/><rect x="36" y="18" width="10" height="10" fill="#1a1a1e"/><rect x="28" y="28" width="8" height="6" fill="#1a1a1e"/><rect x="24" y="34" width="16" height="4" fill="#1a1a1e"/><rect x="24" y="38" width="6" height="8" fill="#1a1a1e"/><rect x="34" y="38" width="6" height="8" fill="#1a1a1e"/></svg>`,
      };
      
      const iconsGlass = {
        Files: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="glassFilesGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="rgba(255,255,255,0.3)"/><stop offset="100%" stop-color="rgba(255,255,255,0.1)"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#glassFilesGrad)" stroke="rgba(255,255,255,0.4)" stroke-width="1"/><path d="M14 24 L14 46 Q14 48 16 48 L48 48 Q50 48 50 46 L50 24 Q50 22 48 22 L14 22 Q14 22 14 24 Z" fill="rgba(255,255,255,0.5)"/><path d="M14 22 L14 20 Q14 18 16 18 L26 18 Q28 18 29 20 L31 22 L14 22 Z" fill="rgba(255,255,255,0.4)"/><path d="M12 26 L12 48 Q12 50 14 50 L50 50 Q52 50 52 48 L52 26 Q52 24 50 24 L14 24 Q12 24 12 26 Z" fill="rgba(255,255,255,0.7)"/></svg>`,
        Terminal: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="glassTermGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="rgba(0,0,0,0.5)"/><stop offset="100%" stop-color="rgba(0,0,0,0.7)"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#glassTermGrad)" stroke="rgba(255,255,255,0.2)" stroke-width="1"/><path d="M18 22 L28 32 L18 42" stroke="rgba(255,255,255,0.9)" stroke-width="3.5" stroke-linecap="round" stroke-linejoin="round" fill="none"/><line x1="32" y1="42" x2="46" y2="42" stroke="rgba(255,255,255,0.9)" stroke-width="3.5" stroke-linecap="round"/></svg>`,
        Browser: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="glassBrowserGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="rgba(255,255,255,0.3)"/><stop offset="100%" stop-color="rgba(255,255,255,0.1)"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#glassBrowserGrad)" stroke="rgba(255,255,255,0.4)" stroke-width="1"/><circle cx="32" cy="32" r="16" stroke="rgba(255,255,255,0.9)" stroke-width="2.5" fill="none"/><ellipse cx="32" cy="32" rx="8" ry="16" stroke="rgba(255,255,255,0.7)" stroke-width="2" fill="none"/><line x1="16" y1="32" x2="48" y2="32" stroke="rgba(255,255,255,0.7)" stroke-width="2"/></svg>`,
        Mail: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="glassMailGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="rgba(255,255,255,0.3)"/><stop offset="100%" stop-color="rgba(255,255,255,0.1)"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#glassMailGrad)" stroke="rgba(255,255,255,0.4)" stroke-width="1"/><rect x="12" y="20" width="40" height="26" rx="3" fill="rgba(255,255,255,0.7)"/><path d="M12 22 L32 36 L52 22" stroke="rgba(0,0,0,0.3)" stroke-width="2" fill="none"/></svg>`,
        Music: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="glassMusicGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="rgba(255,255,255,0.3)"/><stop offset="100%" stop-color="rgba(255,255,255,0.1)"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#glassMusicGrad)" stroke="rgba(255,255,255,0.4)" stroke-width="1"/><ellipse cx="24" cy="42" rx="7" ry="6" fill="rgba(255,255,255,0.8)"/><ellipse cx="44" cy="38" rx="7" ry="6" fill="rgba(255,255,255,0.8)"/><path d="M31 42 L31 18 L51 14 L51 38" stroke="rgba(255,255,255,0.9)" stroke-width="4" fill="none"/></svg>`,
        Settings: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="glassSettingsGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="rgba(255,255,255,0.3)"/><stop offset="100%" stop-color="rgba(255,255,255,0.1)"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#glassSettingsGrad)" stroke="rgba(255,255,255,0.4)" stroke-width="1"/><g fill="rgba(255,255,255,0.8)"><circle cx="32" cy="32" r="10"/><rect x="29" y="10" width="6" height="10" rx="2"/><rect x="29" y="44" width="6" height="10" rx="2"/><rect x="10" y="29" width="10" height="6" rx="2"/><rect x="44" y="29" width="10" height="6" rx="2"/><rect x="29" y="10" width="6" height="10" rx="2" transform="rotate(45 32 32)"/><rect x="29" y="10" width="6" height="10" rx="2" transform="rotate(135 32 32)"/><rect x="29" y="10" width="6" height="10" rx="2" transform="rotate(225 32 32)"/><rect x="29" y="10" width="6" height="10" rx="2" transform="rotate(315 32 32)"/></g><circle cx="32" cy="32" r="5" fill="rgba(0,0,0,0.3)"/></svg>`,
        Finder: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="glassLaunchGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="rgba(255,255,255,0.3)"/><stop offset="100%" stop-color="rgba(255,255,255,0.1)"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#glassLaunchGrad)" stroke="rgba(255,255,255,0.4)" stroke-width="1"/><g fill="rgba(255,255,255,0.8)"><circle cx="20" cy="20" r="5"/><circle cx="32" cy="20" r="5"/><circle cx="44" cy="20" r="5"/><circle cx="20" cy="32" r="5"/><circle cx="32" cy="32" r="5"/><circle cx="44" cy="32" r="5"/><circle cx="20" cy="44" r="5"/><circle cx="32" cy="44" r="5"/><circle cx="44" cy="44" r="5"/></g></svg>`,
        Camera: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="glassCameraGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="rgba(255,255,255,0.3)"/><stop offset="100%" stop-color="rgba(255,255,255,0.1)"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#glassCameraGrad)" stroke="rgba(255,255,255,0.4)" stroke-width="1"/><rect x="12" y="22" width="40" height="28" rx="4" fill="rgba(255,255,255,0.7)"/><circle cx="32" cy="36" r="10" fill="rgba(0,0,0,0.2)"/><circle cx="32" cy="36" r="6" fill="rgba(255,255,255,0.8)"/><rect x="24" y="14" width="16" height="8" rx="2" fill="rgba(255,255,255,0.7)"/></svg>`,
        Video: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="glassVideoGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="rgba(255,255,255,0.3)"/><stop offset="100%" stop-color="rgba(255,255,255,0.1)"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#glassVideoGrad)" stroke="rgba(255,255,255,0.4)" stroke-width="1"/><rect x="12" y="22" width="28" height="20" rx="4" fill="rgba(255,255,255,0.8)"/><path d="M42 26 L52 20 L52 44 L42 38 Z" fill="rgba(255,255,255,0.8)"/></svg>`,
        Document: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="glassDocGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="rgba(255,255,255,0.3)"/><stop offset="100%" stop-color="rgba(255,255,255,0.1)"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#glassDocGrad)" stroke="rgba(255,255,255,0.4)" stroke-width="1"/><rect x="14" y="12" width="36" height="40" rx="3" fill="rgba(255,255,255,0.8)"/><g stroke="rgba(0,0,0,0.2)" stroke-width="1.5"><line x1="20" y1="22" x2="44" y2="22"/><line x1="20" y1="28" x2="44" y2="28"/><line x1="20" y1="34" x2="44" y2="34"/><line x1="20" y1="40" x2="36" y2="40"/></g></svg>`,
        Download: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="glassDownGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="rgba(255,255,255,0.3)"/><stop offset="100%" stop-color="rgba(255,255,255,0.1)"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#glassDownGrad)" stroke="rgba(255,255,255,0.4)" stroke-width="1"/><path d="M32 14 L32 40" stroke="rgba(255,255,255,0.9)" stroke-width="4" stroke-linecap="round"/><path d="M20 32 L32 44 L44 32" stroke="rgba(255,255,255,0.9)" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" fill="none"/><line x1="16" y1="50" x2="48" y2="50" stroke="rgba(255,255,255,0.9)" stroke-width="4" stroke-linecap="round"/></svg>`,
        Messages: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="glassMsgGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="rgba(255,255,255,0.3)"/><stop offset="100%" stop-color="rgba(255,255,255,0.1)"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#glassMsgGrad)" stroke="rgba(255,255,255,0.4)" stroke-width="1"/><path d="M12 32 Q12 16 32 16 Q52 16 52 32 Q52 46 38 48 L32 54 L30 48 Q12 46 12 32 Z" fill="rgba(255,255,255,0.8)"/></svg>`,
        Maps: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="glassMapsGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="rgba(255,255,255,0.3)"/><stop offset="100%" stop-color="rgba(255,255,255,0.1)"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#glassMapsGrad)" stroke="rgba(255,255,255,0.4)" stroke-width="1"/><path d="M32 52 L32 52 C32 52 16 36 16 26 C16 17 23 10 32 10 C41 10 48 17 48 26 C48 36 32 52 32 52 Z" fill="rgba(255,255,255,0.8)"/><circle cx="32" cy="26" r="8" fill="rgba(0,0,0,0.2)"/></svg>`,
        Calendar: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="glassCalGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="rgba(255,255,255,0.3)"/><stop offset="100%" stop-color="rgba(255,255,255,0.1)"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#glassCalGrad)" stroke="rgba(255,255,255,0.4)" stroke-width="1"/><rect x="10" y="16" width="44" height="38" rx="4" fill="rgba(255,255,255,0.8)"/><rect x="10" y="16" width="44" height="12" rx="4" fill="rgba(0,0,0,0.2)"/><text x="32" y="46" fill="rgba(0,0,0,0.6)" font-size="22" font-weight="600" text-anchor="middle" font-family="Space Grotesk, sans-serif">22</text><rect x="20" y="10" width="4" height="10" rx="2" fill="rgba(255,255,255,0.9)"/><rect x="40" y="10" width="4" height="10" rx="2" fill="rgba(255,255,255,0.9)"/></svg>`,
        AppStore: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="glassStoreGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="rgba(255,255,255,0.3)"/><stop offset="100%" stop-color="rgba(255,255,255,0.1)"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#glassStoreGrad)" stroke="rgba(255,255,255,0.4)" stroke-width="1"/><path d="M16 24 L16 50 Q16 52 18 52 L46 52 Q48 52 48 50 L48 24 Z" fill="rgba(255,255,255,0.8)"/><path d="M24 24 L24 18 Q24 12 32 12 Q40 12 40 18 L40 24" stroke="rgba(255,255,255,0.9)" stroke-width="3" fill="none" stroke-linecap="round"/><path d="M24 44V32h3l5 8 5-8h3v12h-3V36l-5 8-5-8v8h-3z" fill="rgba(0,0,0,0.3)"/></svg>`,
        Podcasts: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="glassPodGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="rgba(255,255,255,0.3)"/><stop offset="100%" stop-color="rgba(255,255,255,0.1)"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#glassPodGrad)" stroke="rgba(255,255,255,0.4)" stroke-width="1"/><circle cx="32" cy="26" r="8" fill="rgba(255,255,255,0.8)"/><path d="M28 34 L28 50 Q28 52 32 52 Q36 52 36 50 L36 34" fill="rgba(255,255,255,0.8)"/><path d="M18 30 Q18 14 32 14 Q46 14 46 30" stroke="rgba(255,255,255,0.9)" stroke-width="3" fill="none" stroke-linecap="round"/><path d="M22 32 Q22 20 32 20 Q42 20 42 32" stroke="rgba(255,255,255,0.9)" stroke-width="3" fill="none" stroke-linecap="round"/></svg>`,
        Contacts: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="glassContactGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="rgba(255,255,255,0.3)"/><stop offset="100%" stop-color="rgba(255,255,255,0.1)"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#glassContactGrad)" stroke="rgba(255,255,255,0.4)" stroke-width="1"/><circle cx="32" cy="24" r="10" fill="rgba(255,255,255,0.8)"/><ellipse cx="32" cy="52" rx="16" ry="12" fill="rgba(255,255,255,0.8)"/></svg>`,
        Trash: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="glassTrashGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="rgba(255,255,255,0.3)"/><stop offset="100%" stop-color="rgba(255,255,255,0.1)"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#glassTrashGrad)" stroke="rgba(255,255,255,0.4)" stroke-width="1"/><path d="M20 22 L44 22 L42 50 L22 50 Z" fill="rgba(255,255,255,0.8)"/><rect x="18" y="18" width="28" height="4" rx="2" fill="rgba(255,255,255,0.8)"/><rect x="28" y="14" width="8" height="4" rx="1" fill="rgba(255,255,255,0.8)"/><g stroke="rgba(0,0,0,0.2)" stroke-width="2"><line x1="27" y1="28" x2="27" y2="44"/><line x1="32" y1="28" x2="32" y2="44"/><line x1="37" y1="28" x2="37" y2="44"/></g></svg>`,
        TaskManager: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="glassTaskGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="rgba(255,255,255,0.3)"/><stop offset="100%" stop-color="rgba(255,255,255,0.1)"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#glassTaskGrad)" stroke="rgba(255,255,255,0.4)" stroke-width="1"/><rect x="14" y="38" width="8" height="12" rx="2" fill="rgba(255,255,255,0.8)"/><rect x="24" y="28" width="8" height="22" rx="2" fill="rgba(255,255,255,0.8)"/><rect x="34" y="18" width="8" height="32" rx="2" fill="rgba(255,255,255,0.8)"/><rect x="44" y="24" width="8" height="26" rx="2" fill="rgba(255,255,255,0.8)"/><path d="M12 22 L22 18 L32 14 L42 16 L52 12" stroke="rgba(255,255,255,0.9)" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" fill="none"/></svg>`,
        Minecraft: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="glassMcGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="rgba(255,255,255,0.3)"/><stop offset="100%" stop-color="rgba(255,255,255,0.1)"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#glassMcGrad)" stroke="rgba(255,255,255,0.4)" stroke-width="1"/><rect x="18" y="18" width="10" height="10" fill="rgba(255,255,255,0.8)"/><rect x="36" y="18" width="10" height="10" fill="rgba(255,255,255,0.8)"/><rect x="28" y="28" width="8" height="6" fill="rgba(255,255,255,0.8)"/><rect x="24" y="34" width="16" height="4" fill="rgba(255,255,255,0.8)"/><rect x="24" y="38" width="6" height="8" fill="rgba(255,255,255,0.8)"/><rect x="34" y="38" width="6" height="8" fill="rgba(255,255,255,0.8)"/></svg>`,
      };
      
      // Helper to check if accent color is bright (for contrast)
      function isAccentBright(hex) {
        const r = parseInt(hex.slice(1, 3), 16) / 255;
        const g = parseInt(hex.slice(3, 5), 16) / 255;
        const b = parseInt(hex.slice(5, 7), 16) / 255;
        const toLinear = (c) => c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
        const luminance = 0.2126 * toLinear(r) + 0.7152 * toLinear(g) + 0.0722 * toLinear(b);
        return luminance > 0.45;
      }
      
      // Function to generate accent-colored icons dynamically
      function getAccentIcons(accentColor) {
        const fg = isAccentBright(accentColor) ? '#1a1a1e' : 'white';
        const fgOp85 = isAccentBright(accentColor) ? 'rgba(26,26,30,0.85)' : 'rgba(255,255,255,0.85)';
        const fgOp70 = isAccentBright(accentColor) ? 'rgba(26,26,30,0.7)' : 'rgba(255,255,255,0.7)';
        const fgOp90 = isAccentBright(accentColor) ? 'rgba(26,26,30,0.9)' : 'rgba(255,255,255,0.9)';
        return {
          Files: `<svg viewBox="0 0 64 64" fill="none"><rect x="4" y="4" width="56" height="56" rx="14" fill="${accentColor}"/><path d="M14 24 L14 46 Q14 48 16 48 L48 48 Q50 48 50 46 L50 24 Q50 22 48 22 L14 22 Q14 22 14 24 Z" fill="${fgOp85}"/><path d="M14 22 L14 20 Q14 18 16 18 L26 18 Q28 18 29 20 L31 22 L14 22 Z" fill="${fgOp70}"/><path d="M12 26 L12 48 Q12 50 14 50 L50 50 Q52 50 52 48 L52 26 Q52 24 50 24 L14 24 Q12 24 12 26 Z" fill="${fg}"/></svg>`,
          Terminal: `<svg viewBox="0 0 64 64" fill="none"><rect x="4" y="4" width="56" height="56" rx="14" fill="${accentColor}"/><path d="M18 22 L28 32 L18 42" stroke="${fg}" stroke-width="3.5" stroke-linecap="round" stroke-linejoin="round" fill="none"/><line x1="32" y1="42" x2="46" y2="42" stroke="${fg}" stroke-width="3.5" stroke-linecap="round"/></svg>`,
          Browser: `<svg viewBox="0 0 64 64" fill="none"><rect x="4" y="4" width="56" height="56" rx="14" fill="${accentColor}"/><circle cx="32" cy="32" r="16" stroke="${fg}" stroke-width="2.5" fill="none"/><ellipse cx="32" cy="32" rx="8" ry="16" stroke="${fg}" stroke-width="2" fill="none"/><line x1="16" y1="32" x2="48" y2="32" stroke="${fg}" stroke-width="2"/><line x1="32" y1="16" x2="32" y2="48" stroke="${fg}" stroke-width="2"/></svg>`,
          Mail: `<svg viewBox="0 0 64 64" fill="none"><rect x="4" y="4" width="56" height="56" rx="14" fill="${accentColor}"/><rect x="12" y="20" width="40" height="26" rx="3" fill="${fg}"/><path d="M12 22 L32 36 L52 22" stroke="${accentColor}" stroke-width="2" fill="none"/></svg>`,
          Music: `<svg viewBox="0 0 64 64" fill="none"><rect x="4" y="4" width="56" height="56" rx="14" fill="${accentColor}"/><ellipse cx="24" cy="42" rx="7" ry="6" fill="${fg}"/><ellipse cx="44" cy="38" rx="7" ry="6" fill="${fg}"/><path d="M31 42 L31 18 L51 14 L51 38" stroke="${fg}" stroke-width="4" fill="none"/></svg>`,
          Settings: `<svg viewBox="0 0 64 64" fill="none"><rect x="4" y="4" width="56" height="56" rx="14" fill="${accentColor}"/><g fill="${fg}"><circle cx="32" cy="32" r="10"/><rect x="29" y="10" width="6" height="10" rx="2"/><rect x="29" y="44" width="6" height="10" rx="2"/><rect x="10" y="29" width="10" height="6" rx="2"/><rect x="44" y="29" width="10" height="6" rx="2"/><rect x="29" y="10" width="6" height="10" rx="2" transform="rotate(45 32 32)"/><rect x="29" y="10" width="6" height="10" rx="2" transform="rotate(135 32 32)"/><rect x="29" y="10" width="6" height="10" rx="2" transform="rotate(225 32 32)"/><rect x="29" y="10" width="6" height="10" rx="2" transform="rotate(315 32 32)"/></g><circle cx="32" cy="32" r="5" fill="${accentColor}"/></svg>`,
          Finder: `<svg viewBox="0 0 64 64" fill="none"><rect x="4" y="4" width="56" height="56" rx="14" fill="${accentColor}"/><g fill="${fg}"><circle cx="20" cy="20" r="5"/><circle cx="32" cy="20" r="5"/><circle cx="44" cy="20" r="5"/><circle cx="20" cy="32" r="5"/><circle cx="32" cy="32" r="5"/><circle cx="44" cy="32" r="5"/><circle cx="20" cy="44" r="5"/><circle cx="32" cy="44" r="5"/><circle cx="44" cy="44" r="5"/></g></svg>`,
          Camera: `<svg viewBox="0 0 64 64" fill="none"><rect x="4" y="4" width="56" height="56" rx="14" fill="${accentColor}"/><rect x="12" y="22" width="40" height="28" rx="4" fill="${fg}"/><circle cx="32" cy="36" r="10" fill="${accentColor}"/><circle cx="32" cy="36" r="6" fill="${fg}"/><circle cx="32" cy="36" r="3" fill="${accentColor}"/><rect x="24" y="14" width="16" height="8" rx="2" fill="${fg}"/></svg>`,
          Video: `<svg viewBox="0 0 64 64" fill="none"><rect x="4" y="4" width="56" height="56" rx="14" fill="${accentColor}"/><rect x="12" y="22" width="28" height="20" rx="4" fill="${fg}"/><path d="M42 26 L52 20 L52 44 L42 38 Z" fill="${fg}"/></svg>`,
          Document: `<svg viewBox="0 0 64 64" fill="none"><rect x="4" y="4" width="56" height="56" rx="14" fill="${accentColor}"/><rect x="14" y="12" width="36" height="40" rx="3" fill="${fg}"/><g stroke="${accentColor}" stroke-width="1.5"><line x1="20" y1="22" x2="44" y2="22"/><line x1="20" y1="28" x2="44" y2="28"/><line x1="20" y1="34" x2="44" y2="34"/><line x1="20" y1="40" x2="36" y2="40"/></g></svg>`,
          Download: `<svg viewBox="0 0 64 64" fill="none"><rect x="4" y="4" width="56" height="56" rx="14" fill="${accentColor}"/><path d="M32 14 L32 40" stroke="${fg}" stroke-width="4" stroke-linecap="round"/><path d="M20 32 L32 44 L44 32" stroke="${fg}" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" fill="none"/><line x1="16" y1="50" x2="48" y2="50" stroke="${fg}" stroke-width="4" stroke-linecap="round"/></svg>`,
          Messages: `<svg viewBox="0 0 64 64" fill="none"><rect x="4" y="4" width="56" height="56" rx="14" fill="${accentColor}"/><path d="M12 32 Q12 16 32 16 Q52 16 52 32 Q52 46 38 48 L32 54 L30 48 Q12 46 12 32 Z" fill="${fg}"/></svg>`,
          Maps: `<svg viewBox="0 0 64 64" fill="none"><rect x="4" y="4" width="56" height="56" rx="14" fill="${accentColor}"/><path d="M32 52 L32 52 C32 52 16 36 16 26 C16 17 23 10 32 10 C41 10 48 17 48 26 C48 36 32 52 32 52 Z" fill="${fg}"/><circle cx="32" cy="26" r="8" fill="${accentColor}"/></svg>`,
          Calendar: `<svg viewBox="0 0 64 64" fill="none"><rect x="4" y="4" width="56" height="56" rx="14" fill="${accentColor}"/><rect x="10" y="16" width="44" height="38" rx="4" fill="${fg}"/><rect x="10" y="16" width="44" height="12" rx="4" fill="${accentColor}" opacity="0.5"/><text x="32" y="46" fill="${accentColor}" font-size="22" font-weight="600" text-anchor="middle" font-family="Space Grotesk, sans-serif">22</text><rect x="20" y="10" width="4" height="10" rx="2" fill="${fg}"/><rect x="40" y="10" width="4" height="10" rx="2" fill="${fg}"/></svg>`,
          AppStore: `<svg viewBox="0 0 64 64" fill="none"><rect x="4" y="4" width="56" height="56" rx="14" fill="${accentColor}"/><path d="M16 24 L16 50 Q16 52 18 52 L46 52 Q48 52 48 50 L48 24 Z" fill="${fg}"/><path d="M24 24 L24 18 Q24 12 32 12 Q40 12 40 18 L40 24" stroke="${fg}" stroke-width="3" fill="none" stroke-linecap="round"/><path d="M24 44V32h3l5 8 5-8h3v12h-3V36l-5 8-5-8v8h-3z" fill="${accentColor}"/></svg>`,
          Podcasts: `<svg viewBox="0 0 64 64" fill="none"><rect x="4" y="4" width="56" height="56" rx="14" fill="${accentColor}"/><circle cx="32" cy="26" r="8" fill="${fg}"/><path d="M28 34 L28 50 Q28 52 32 52 Q36 52 36 50 L36 34" fill="${fg}"/><path d="M18 30 Q18 14 32 14 Q46 14 46 30" stroke="${fg}" stroke-width="3" fill="none" stroke-linecap="round"/><path d="M22 32 Q22 20 32 20 Q42 20 42 32" stroke="${fg}" stroke-width="3" fill="none" stroke-linecap="round"/></svg>`,
          Contacts: `<svg viewBox="0 0 64 64" fill="none"><rect x="4" y="4" width="56" height="56" rx="14" fill="${accentColor}"/><circle cx="32" cy="24" r="10" fill="${fg}"/><ellipse cx="32" cy="52" rx="16" ry="12" fill="${fg}"/></svg>`,
          Trash: `<svg viewBox="0 0 64 64" fill="none"><rect x="4" y="4" width="56" height="56" rx="14" fill="${accentColor}"/><path d="M20 22 L44 22 L42 50 L22 50 Z" fill="${fg}"/><rect x="18" y="18" width="28" height="4" rx="2" fill="${fg}"/><rect x="28" y="14" width="8" height="4" rx="1" fill="${fg}"/><g stroke="${accentColor}" stroke-width="2"><line x1="27" y1="28" x2="27" y2="44"/><line x1="32" y1="28" x2="32" y2="44"/><line x1="37" y1="28" x2="37" y2="44"/></g></svg>`,
          TaskManager: `<svg viewBox="0 0 64 64" fill="none"><rect x="4" y="4" width="56" height="56" rx="14" fill="${accentColor}"/><rect x="14" y="38" width="8" height="12" rx="2" fill="${fgOp90}"/><rect x="24" y="28" width="8" height="22" rx="2" fill="${fgOp90}"/><rect x="34" y="18" width="8" height="32" rx="2" fill="${fgOp90}"/><rect x="44" y="24" width="8" height="26" rx="2" fill="${fgOp90}"/><path d="M12 22 L22 18 L32 14 L42 16 L52 12" stroke="${fg}" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" fill="none"/></svg>`,
          Minecraft: `<svg viewBox="0 0 64 64" fill="none"><rect x="4" y="4" width="56" height="56" rx="14" fill="${accentColor}"/><rect x="18" y="18" width="10" height="10" fill="${fg}"/><rect x="36" y="18" width="10" height="10" fill="${fg}"/><rect x="28" y="28" width="8" height="6" fill="${fg}"/><rect x="24" y="34" width="16" height="4" fill="${fg}"/><rect x="24" y="38" width="6" height="8" fill="${fg}"/><rect x="34" y="38" width="6" height="8" fill="${fg}"/></svg>`,
        };
      }
      
      // Get icons based on current icon pack setting
      function getIcons() {
        const pack = state.iconPack || 'classic';
        const isDarkMode = document.documentElement.classList.contains('dark');
        
        switch(pack) {
          case 'monochrome':
            // Use light version in light mode, dark version in dark mode
            return isDarkMode ? iconsMonochrome : iconsMonochromeLight;
          case 'glass':
            return iconsGlass;
          case 'accent':
            return getAccentIcons(state.accentColor);
          case 'classic':
          default:
            return iconsClassic;
        }
      }
      
      // Icons object that dynamically returns based on pack
      const icons = new Proxy({}, {
        get: function(target, prop) {
          const currentIcons = getIcons();
          // Add utility icons that don't change
          if (prop === 'Sun') return `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="5"/><path d="M12 1v2m0 18v2M4.22 4.22l1.42 1.42m12.72 12.72l1.42 1.42M1 12h2m18 0h2M4.22 19.78l1.42-1.42m12.72-12.72l1.42-1.42" stroke-linecap="round"/></svg>`;
          if (prop === 'Moon') return `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>`;
          if (prop === 'WiFi') return `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 12.55a11 11 0 0 1 14.08 0"/><path d="M1.42 9a16 16 0 0 1 21.16 0"/><path d="M8.53 16.11a6 6 0 0 1 6.95 0"/><circle cx="12" cy="20" r="1" fill="currentColor"/></svg>`;
          if (prop === 'Battery') return `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="1" y="6" width="18" height="12" rx="2" ry="2"/><path d="M23 10v4"/><rect x="3" y="8" width="14" height="8" fill="currentColor"/></svg>`;
          if (prop === 'Volume') return `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></svg>`;
          if (prop === 'MLogo') {
            const p = state.iconPack || 'classic';
            if (p === 'monochrome') return `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="mGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#3a3a3e"/><stop offset="100%" stop-color="#1a1a1e"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#mGrad)"/><path d="M20 42V22h4l8 12 8-12h4v20h-4V28l-8 12-8-12v14h-4z" fill="white"/></svg>`;
            if (p === 'glass') return `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="mGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="rgba(255,255,255,0.3)"/><stop offset="100%" stop-color="rgba(255,255,255,0.1)"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#mGrad)" stroke="rgba(255,255,255,0.4)" stroke-width="1"/><path d="M20 42V22h4l8 12 8-12h4v20h-4V28l-8 12-8-12v14h-4z" fill="rgba(255,255,255,0.9)"/></svg>`;
            if (p === 'accent') return `<svg viewBox="0 0 64 64" fill="none"><rect x="4" y="4" width="56" height="56" rx="14" fill="${state.accentColor}"/><path d="M20 42V22h4l8 12 8-12h4v20h-4V28l-8 12-8-12v14h-4z" fill="white"/></svg>`;
            return `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="mGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#8B5CF6"/><stop offset="100%" stop-color="#6D28D9"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#mGrad)"/><path d="M20 42V22h4l8 12 8-12h4v20h-4V28l-8 12-8-12v14h-4z" fill="white"/></svg>`;
          }
          if (prop === 'UbuntuLogo') {
            const p = state.iconPack || 'classic';
            if (p === 'monochrome') return `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="ubuntuGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#3a3a3e"/><stop offset="100%" stop-color="#1a1a1e"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#ubuntuGrad)"/><g transform="translate(32,32)"><circle cx="0" cy="0" r="6" fill="white"/><circle cx="-13" cy="0" r="5" fill="white"/><circle cx="7" cy="-11" r="5" fill="white"/><circle cx="7" cy="11" r="5" fill="white"/></g></svg>`;
            return `<svg viewBox="0 0 64 64" fill="none"><rect x="4" y="4" width="56" height="56" rx="14" fill="#E95420"/><g transform="translate(32,32)"><circle cx="0" cy="0" r="6" fill="white"/><circle cx="-13" cy="0" r="5" fill="white"/><circle cx="7" cy="-11" r="5" fill="white"/><circle cx="7" cy="11" r="5" fill="white"/></g></svg>`;
          }
          return currentIcons[prop] || '';
        }
      });

      // Base apps (always available)
      const baseApps = [
        { id: 'files', name: 'Files', icon: 'Files' },
        { id: 'terminal', name: 'Terminal', icon: 'Terminal' },
        { id: 'browser', name: 'Browser', icon: 'Browser', supportsFullscreen: true },
        { id: 'mail', name: 'Mail', icon: 'Mail' },
        { id: 'music', name: 'Music', icon: 'Music' },
        { id: 'settings', name: 'Settings', icon: 'Settings' },
        { id: 'photos', name: 'Photos', icon: 'Camera' },
        { id: 'videos', name: 'Videos', icon: 'Video' },
        { id: 'documents', name: 'Documents', icon: 'Document' },
        { id: 'downloads', name: 'Downloads', icon: 'Download' },
        { id: 'appstore', name: 'M Store', icon: 'AppStore' },
        { id: 'taskmanager', name: 'Task Manager', icon: 'TaskManager' },
        { id: 'finder', name: 'Launchpad', icon: 'Finder', isPermanent: true },
      ];
      
      // Installable apps (only show after installation)
      const installableApps = {
        minecraft: { id: 'minecraft', name: 'Minecraft', icon: 'Minecraft', supportsFullscreen: true }
      };
      
      // Function to get all available apps (base + installed)
      function getApps() {
        const installedAppsList = state.installedApps.map(id => installableApps[id]).filter(Boolean);
        return [...baseApps.slice(0, -1), ...installedAppsList, baseApps[baseApps.length - 1]]; // Keep finder at end
      }
      
      // For backwards compatibility, create a getter
      let apps = getApps();

      // ============= Context Menu (Top Bar) Customization Functions =============
      
      // Render individual context menu elements
      function renderContextMenuElement(elementId, isCustomizeMode) {
        const elementLabels = {
          logo: 'Logo',
          menus: 'Menu Items',
          quicksettings: 'Quick Settings',
          clock: 'Clock',
          windowlist: 'Window List',
          workspaces: 'Workspaces',
          separator1: 'Separator',
          separator2: 'Separator',
          systray: 'System Tray',
          battery: 'Battery',
          notifications: 'Notifications'
        };
        
        const dragAttrs = isCustomizeMode ? `
          draggable="true"
          ondragstart="window.handleContextMenuDragStart(event, '${elementId}')"
          ondragend="window.handleContextMenuDragEnd(event)"
          ondragover="window.handleContextMenuDragOver(event, '${elementId}')"
          ondrop="window.handleContextMenuDrop(event, '${elementId}')"
          onclick="event.stopPropagation(); window.showElementPositionMenu(event, '${elementId}')"
        ` : '';
        
        const wrapperClass = isCustomizeMode ? 'context-menu-element' : '';
        const labelHTML = isCustomizeMode ? `<span class="context-menu-element-label">${elementLabels[elementId] || elementId}</span>` : '';
        
        switch(elementId) {
          case 'logo':
            return `
              <div class="${wrapperClass}" data-element-id="logo" ${dragAttrs} style="display: flex; align-items: center; position: relative;">
                ${labelHTML}
                <div class="m-logo-circle" style="display: flex; align-items: center; justify-content: center; width: 18px; height: 18px; border-radius: 50%; margin-right: 10px;">
                  <span class="m-logo-letter" style="font-size: 11px; font-weight: 600; letter-spacing: 0.02em; font-family: 'Space Grotesk', sans-serif;">M</span>
                </div>
              </div>
            `;
          case 'menus':
            return `
              <div class="${wrapperClass}" data-element-id="menus" ${dragAttrs} style="display: flex; align-items: center; gap: 2px; position: relative;">
                ${labelHTML}
                <button style="font-weight: 600;">Files</button>
                <button>Edit</button>
                <button>View</button>
                <button>Tools</button>
                <button>Help</button>
              </div>
            `;
          case 'windowlist':
            // Window list showing open windows like KDE/GNOME taskbar - same behavior as dock
            const openWindows = state.windows.filter(w => !w.isMinimized);
            const minimizedWindows = state.windows.filter(w => w.isMinimized);
            const maxZIndex = state.windows.length > 0 ? Math.max(...state.windows.map(w => w.zIndex || 0)) : 0;
            return `
              <div class="${wrapperClass}" data-element-id="windowlist" ${dragAttrs} style="display: flex; align-items: center; gap: 4px; position: relative; margin-left: 8px;">
                ${labelHTML}
                ${openWindows.length === 0 && minimizedWindows.length === 0 ? '' : openWindows.map(w => {
                  const app = apps.find(a => a.id === w.appId);
                  const isTopWindow = w.zIndex === maxZIndex;
                  const isActive = state.activeWindowId === w.id;
                  return `
                    <button onclick="window.handleWindowListClick(${w.id})" 
                            style="padding: 4px 10px; display: flex; align-items: center; gap: 6px; border-radius: 6px; font-size: 11px; ${isActive ? 'background: hsl(var(--primary) / 0.2); border: 1px solid hsl(var(--primary) / 0.3);' : ''}"
                            title="${w.title}${isTopWindow ? ' (click to minimize)' : ' (click to focus)'}">
                      <span style="width: 14px; height: 14px; display: flex; align-items: center; justify-content: center;">
                        ${app && icons[app.icon] ? icons[app.icon].replace(/width="[^"]*"/g, 'width="14"').replace(/height="[^"]*"/g, 'height="14"') : ''}
                      </span>
                      <span style="max-width: 80px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${w.title}</span>
                    </button>
                  `;
                }).join('')}
                ${minimizedWindows.map(w => {
                  const app = apps.find(a => a.id === w.appId);
                  return `
                    <button onclick="window.restoreWindowById(${w.id})" 
                            style="padding: 4px 10px; display: flex; align-items: center; gap: 6px; border-radius: 6px; font-size: 11px; opacity: 0.6;"
                            title="${w.title} (minimized - click to restore)">
                      <span style="width: 14px; height: 14px; display: flex; align-items: center; justify-content: center;">
                        ${app && icons[app.icon] ? icons[app.icon].replace(/width="[^"]*"/g, 'width="14"').replace(/height="[^"]*"/g, 'height="14"') : ''}
                      </span>
                      <span style="max-width: 80px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${w.title}</span>
                    </button>
                  `;
                }).join('')}
              </div>
            `;
          case 'workspaces':
            // Virtual desktop/workspace switcher like KDE
            return `
              <div class="${wrapperClass}" data-element-id="workspaces" ${dragAttrs} style="display: flex; align-items: center; gap: 4px; position: relative;">
                ${labelHTML}
                ${[1, 2, 3, 4].map(ws => `
                  <button onclick="window.switchWorkspace(${ws})" 
                          style="padding: 2px 8px; min-width: 24px; font-size: 11px; font-weight: ${state.currentWorkspace === ws ? '700' : '500'}; ${state.currentWorkspace === ws ? 'background: hsl(var(--primary)); color: hsl(var(--primary-foreground));' : ''} border-radius: 4px;">
                    ${ws}
                  </button>
                `).join('')}
              </div>
            `;
          case 'separator1':
          case 'separator2':
            // Separator/spacer
            return `
              <div class="${wrapperClass}" data-element-id="${elementId}" ${dragAttrs} style="display: flex; align-items: center; position: relative; padding: 0 4px;">
                ${labelHTML}
                <div style="width: 1px; height: 16px; background: hsl(var(--foreground) / 0.2);"></div>
              </div>
            `;
          case 'systray':
            // System tray - combined WiFi, Power, Volume button
            return `
              <div class="${wrapperClass}" data-element-id="systray" ${dragAttrs} style="display: flex; align-items: center; position: relative;">
                ${labelHTML}
                <button onclick="${isCustomizeMode ? '' : 'window.toggleQuickSettings(event)'}" style="padding: 6px 10px; display: flex; align-items: center; gap: 8px; border-radius: 8px;" title="Quick Settings">
                  <span class="menubar-icon">${icons.WiFi}</span>
                  <span class="menubar-icon">${icons.Volume}</span>
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                    <path d="M18.36 6.64a9 9 0 1 1-12.73 0"/>
                    <line x1="12" y1="2" x2="12" y2="12"/>
                  </svg>
                </button>
              </div>
            `;
          case 'battery':
            // Battery indicator
            const batteryLevel = 85; // Mock battery level
            return `
              <div class="${wrapperClass}" data-element-id="battery" ${dragAttrs} style="display: flex; align-items: center; gap: 4px; position: relative;">
                ${labelHTML}
                <button style="padding: 4px 6px; display: flex; align-items: center; gap: 4px; font-size: 11px;" title="Battery ${batteryLevel}%">
                  <span class="menubar-icon">${icons.Battery}</span>
                  <span style="font-weight: 500;">${batteryLevel}%</span>
                </button>
              </div>
            `;
          case 'notifications':
            // Notification indicator
            const hasNotifications = state.notificationCount > 0;
            return `
              <div class="${wrapperClass}" data-element-id="notifications" ${dragAttrs} style="display: flex; align-items: center; position: relative;">
                ${labelHTML}
                <button onclick="${isCustomizeMode ? '' : 'window.toggleNotifications(event)'}" style="padding: 4px; position: relative;" title="Notifications">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                    <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"/>
                    <path d="M13.73 21a2 2 0 0 1-3.46 0"/>
                  </svg>
                  ${hasNotifications ? `<span style="position: absolute; top: 0; right: 0; width: 8px; height: 8px; background: hsl(var(--primary)); border-radius: 50%; border: 2px solid hsl(var(--menubar-bg));"></span>` : ''}
                </button>
              </div>
            `;
          case 'quicksettings':
            return `
              <div class="${wrapperClass}" data-element-id="quicksettings" ${dragAttrs} style="position: relative;">
                ${labelHTML}
                <button onclick="${isCustomizeMode ? '' : 'window.toggleQuickSettings(event)'}" style="padding: 6px 10px; display: flex; align-items: center; gap: 6px; border-radius: 8px;" title="Quick Settings">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                    <path d="M18.36 6.64a9 9 0 1 1-12.73 0"/>
                    <line x1="12" y1="2" x2="12" y2="12"/>
                  </svg>
                </button>
              </div>
            `;
          case 'clock':
            return `
              <div class="${wrapperClass}" data-element-id="clock" ${dragAttrs} style="position: relative;">
                ${labelHTML}
                <button style="padding: 6px 14px; font-weight: 600; font-size: 12px; letter-spacing: 0.02em;">
                  ${state.currentTime.toLocaleString('en-US', {
                    weekday: 'short',
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false
                  }).replace(',', '')}
                </button>
              </div>
            `;
          default:
            return '';
        }
      }
      
      // Render the full context menu bar
      function renderContextMenuBar() {
        const layout = state.contextMenuLayout;
        const isCustomizeMode = state.contextMenuCustomizeMode;
        
        // Group elements by position
        const leftElements = layout.elements
          .filter(e => e.position === 'left' && e.visible)
          .sort((a, b) => a.order - b.order);
        const centerElements = layout.elements
          .filter(e => e.position === 'center' && e.visible)
          .sort((a, b) => a.order - b.order);
        const rightElements = layout.elements
          .filter(e => e.position === 'right' && e.visible)
          .sort((a, b) => a.order - b.order);
        
        const dropZoneAttrs = isCustomizeMode ? `
          ondragover="event.preventDefault(); event.currentTarget.classList.add('drag-over');"
          ondragleave="event.currentTarget.classList.remove('drag-over');"
        ` : '';
        
        return `
          <div class="menubar-left context-menu-drop-zone ${isCustomizeMode && leftElements.length === 0 ? 'empty' : ''}" 
               data-position="left" 
               ondrop="window.handleContextMenuDropZone(event, 'left')" ${dropZoneAttrs}>
            ${isCustomizeMode && leftElements.length === 0 ? '<span class="drop-zone-label">Left</span>' : ''}
            ${leftElements.map(e => renderContextMenuElement(e.id, isCustomizeMode)).join('')}
          </div>
          
          <div class="menubar-center context-menu-drop-zone ${isCustomizeMode && centerElements.length === 0 ? 'empty' : ''}" 
               data-position="center" 
               ondrop="window.handleContextMenuDropZone(event, 'center')" ${dropZoneAttrs}
               style="${centerElements.length === 0 && !isCustomizeMode ? 'display: none;' : ''}">
            ${isCustomizeMode && centerElements.length === 0 ? '<span class="drop-zone-label">Center</span>' : ''}
            ${centerElements.map(e => renderContextMenuElement(e.id, isCustomizeMode)).join('')}
          </div>
          
          <div class="menubar-right context-menu-drop-zone ${isCustomizeMode && rightElements.length === 0 ? 'empty' : ''}" 
               data-position="right" 
               ondrop="window.handleContextMenuDropZone(event, 'right')" ${dropZoneAttrs}>
            ${isCustomizeMode && rightElements.length === 0 ? '<span class="drop-zone-label">Right</span>' : ''}
            ${rightElements.map(e => renderContextMenuElement(e.id, isCustomizeMode)).join('')}
          </div>
        `;
      }
      
      // Context menu drag and drop handlers
      window.handleContextMenuDragStart = function(event, elementId) {
        state.contextMenuDragElement = elementId;
        event.currentTarget.classList.add('dragging');
        event.dataTransfer.effectAllowed = 'move';
        event.dataTransfer.setData('text/plain', elementId);
      };
      
      window.handleContextMenuDragEnd = function(event) {
        state.contextMenuDragElement = null;
        event.currentTarget.classList.remove('dragging');
        document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
      };
      
      window.handleContextMenuDragOver = function(event, targetElementId) {
        event.preventDefault();
        if (state.contextMenuDragElement && state.contextMenuDragElement !== targetElementId) {
          event.currentTarget.classList.add('drag-over');
        }
      };
      
      window.handleContextMenuDrop = function(event, targetElementId) {
        event.preventDefault();
        event.currentTarget.classList.remove('drag-over');
        
        if (!state.contextMenuDragElement || state.contextMenuDragElement === targetElementId) return;
        
        const layout = state.contextMenuLayout;
        const draggedElement = layout.elements.find(e => e.id === state.contextMenuDragElement);
        const targetElement = layout.elements.find(e => e.id === targetElementId);
        
        if (draggedElement && targetElement && draggedElement.position === targetElement.position) {
          // Swap orders within same position
          const tempOrder = draggedElement.order;
          draggedElement.order = targetElement.order;
          targetElement.order = tempOrder;
          
          localStorage.setItem('contextMenuLayout', JSON.stringify(layout));
          render();
        }
        
        state.contextMenuDragElement = null;
      };
      
      window.handleContextMenuDropZone = function(event, position) {
        event.preventDefault();
        event.currentTarget.classList.remove('drag-over');
        
        if (!state.contextMenuDragElement) return;
        
        const layout = state.contextMenuLayout;
        const draggedElement = layout.elements.find(e => e.id === state.contextMenuDragElement);
        
        if (draggedElement) {
          // Move element to new position
          const elementsInPosition = layout.elements.filter(e => e.position === position);
          const maxOrder = elementsInPosition.length > 0 ? Math.max(...elementsInPosition.map(e => e.order)) : -1;
          
          draggedElement.position = position;
          draggedElement.order = maxOrder + 1;
          
          // Recalculate orders to remove gaps
          ['left', 'center', 'right'].forEach(pos => {
            const elements = layout.elements.filter(e => e.position === pos).sort((a, b) => a.order - b.order);
            elements.forEach((e, i) => e.order = i);
          });
          
          localStorage.setItem('contextMenuLayout', JSON.stringify(layout));
          render();
        }
        
        state.contextMenuDragElement = null;
      };
      
      // Show position selector menu for an element
      window.showElementPositionMenu = function(event, elementId) {
        event.preventDefault();
        event.stopPropagation();
        
        const element = state.contextMenuLayout.elements.find(e => e.id === elementId);
        if (!element) return;
        
        const menuHTML = `
          <div class="menubar-context-menu" style="left: ${event.clientX}px; top: ${event.clientY}px; z-index: 100001;" onclick="event.stopPropagation()">
            <div class="menubar-context-menu-header">Move "${elementId}" to:</div>
            <div class="context-menu-item ${element.position === 'left' ? 'active' : ''}" onclick="window.moveContextMenuElement('${elementId}', 'left')">
               Left
            </div>
            <div class="context-menu-item ${element.position === 'center' ? 'active' : ''}" onclick="window.moveContextMenuElement('${elementId}', 'center')">
               Center
            </div>
            <div class="context-menu-item ${element.position === 'right' ? 'active' : ''}" onclick="window.moveContextMenuElement('${elementId}', 'right')">
               Right
            </div>
            <div class="context-menu-separator"></div>
            <div class="context-menu-item destructive" onclick="window.removeContextMenuElement('${elementId}')">
               Remove
            </div>
          </div>
        `;
        
        // Remove existing menus
        document.querySelectorAll('.menubar-context-menu').forEach(el => el.remove());
        
        // Add new menu
        document.body.insertAdjacentHTML('beforeend', menuHTML);
        
        // Auto-close on outside click
        setTimeout(() => {
          const handler = (e) => {
            if (!e.target.closest('.menubar-context-menu')) {
              document.querySelectorAll('.menubar-context-menu').forEach(el => el.remove());
              document.removeEventListener('click', handler);
            }
          };
          document.addEventListener('click', handler);
        }, 10);
      };
      
      window.moveContextMenuElement = function(elementId, newPosition) {
        const layout = state.contextMenuLayout;
        const element = layout.elements.find(e => e.id === elementId);
        
        if (element) {
          const elementsInPosition = layout.elements.filter(e => e.position === newPosition);
          const maxOrder = elementsInPosition.length > 0 ? Math.max(...elementsInPosition.map(e => e.order)) : -1;
          
          element.position = newPosition;
          element.order = maxOrder + 1;
          
          // Recalculate orders
          ['left', 'center', 'right'].forEach(pos => {
            const elements = layout.elements.filter(e => e.position === pos).sort((a, b) => a.order - b.order);
            elements.forEach((e, i) => e.order = i);
          });
          
          localStorage.setItem('contextMenuLayout', JSON.stringify(layout));
        }
        
        document.querySelectorAll('.menubar-context-menu').forEach(el => el.remove());
        render();
      };
      
      // Enter/exit customize mode
      window.enterContextMenuCustomizeMode = function() {
        state.contextMenuCustomizeMode = true;
        render();
      };
      
      window.exitContextMenuCustomizeMode = function() {
        state.contextMenuCustomizeMode = false;
        render();
      };
      
      window.resetContextMenuLayout = function() {
        state.contextMenuLayout = {
          elements: [
            { id: 'logo', position: 'left', order: 0, visible: true },
            { id: 'menus', position: 'left', order: 1, visible: true },
            { id: 'windowlist', position: 'left', order: 2, visible: false },
            { id: 'separator1', position: 'center', order: 0, visible: false },
            { id: 'workspaces', position: 'center', order: 1, visible: false },
            { id: 'clock', position: 'center', order: 2, visible: true },
            { id: 'separator2', position: 'right', order: 0, visible: false },
            { id: 'systray', position: 'right', order: 1, visible: true },
            { id: 'battery', position: 'right', order: 2, visible: false },
            { id: 'notifications', position: 'right', order: 3, visible: true },
            { id: 'quicksettings', position: 'right', order: 4, visible: false }
          ]
        };
        localStorage.setItem('contextMenuLayout', JSON.stringify(state.contextMenuLayout));
        render();
      };
      
      // Remove element from context menu bar (hide it)
      window.removeContextMenuElement = function(elementId) {
        const layout = state.contextMenuLayout;
        const element = layout.elements.find(e => e.id === elementId);
        if (element) {
          element.visible = false;
          localStorage.setItem('contextMenuLayout', JSON.stringify(layout));
          render();
        }
      };
      
      // Add element back to context menu bar
      window.addContextMenuElement = function(elementId, position = 'left') {
        const layout = state.contextMenuLayout;
        let element = layout.elements.find(e => e.id === elementId);
        if (!element) {
          // Element doesn't exist yet, add it
          element = { id: elementId, position: position, order: 0, visible: true };
          layout.elements.push(element);
        }
        element.visible = true;
        element.position = position;
        const elementsInPosition = layout.elements.filter(e => e.position === position && e.visible);
        element.order = elementsInPosition.length > 0 ? Math.max(...elementsInPosition.map(e => e.order)) + 1 : 0;
        localStorage.setItem('contextMenuLayout', JSON.stringify(layout));
        render();
      };
      
      // Widget drag from panel to menubar
      window.handleWidgetDragStart = function(event, elementId) {
        state.contextMenuDragElement = elementId;
        event.currentTarget.classList.add('dragging');
        event.dataTransfer.effectAllowed = 'copy';
        event.dataTransfer.setData('text/plain', elementId);
      };
      
      window.handleWidgetDragEnd = function(event) {
        state.contextMenuDragElement = null;
        event.currentTarget.classList.remove('dragging');
        document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
      };
      
      // Widget search filter
      window.filterWidgets = function(searchTerm) {
        const grid = document.getElementById('widgets-grid');
        if (!grid) return;
        
        const cards = grid.querySelectorAll('.widget-card');
        const term = searchTerm.toLowerCase().trim();
        
        cards.forEach(card => {
          const name = card.querySelector('.widget-name')?.textContent?.toLowerCase() || '';
          const desc = card.querySelector('.widget-desc')?.textContent?.toLowerCase() || '';
          
          if (term === '' || name.includes(term) || desc.includes(term)) {
            card.style.display = '';
          } else {
            card.style.display = 'none';
          }
        });
      };
      
      // Show right-click context menu on the menubar
      window.showContextMenuRightClick = function(event) {
        event.preventDefault();
        state.menubarContextMenu = { x: event.clientX, y: event.clientY };
        render();
      };
      
      // ============= Workspace Functions =============
      window.switchWorkspace = function(workspaceNumber) {
        state.currentWorkspace = workspaceNumber;
        localStorage.setItem('currentWorkspace', workspaceNumber);
        render();
      };
      
      // ============= Notification Functions =============
      let notificationClockInterval = null;
      
      function updateNotificationClock() {
        const clockEl = document.getElementById('notification-clock-time');
        if (clockEl) {
          const now = new Date();
          clockEl.textContent = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false });
        }
      }
      
      // ============= Centralized Panel State Management =============
      // Track animation states to prevent conflicting animations
      let notificationPanelAnimating = false;
      let quickSettingsAnimating = false;
      let notificationPanelAnimationTimer = null;
      let quickSettingsAnimationTimer = null;
      
      // Helper to close both panels instantly (no animation) - used when interacting with other UI
      function closePanelsInstantly() {
        // Clear any pending animations
        if (notificationPanelAnimationTimer) {
          clearTimeout(notificationPanelAnimationTimer);
          notificationPanelAnimationTimer = null;
        }
        if (quickSettingsAnimationTimer) {
          clearTimeout(quickSettingsAnimationTimer);
          quickSettingsAnimationTimer = null;
        }
        if (notificationClockInterval) {
          clearInterval(notificationClockInterval);
          notificationClockInterval = null;
        }
        
        // Reset animation flags
        notificationPanelAnimating = false;
        quickSettingsAnimating = false;
        
        // Update state
        const wasOpen = state.showNotificationPanel || state.showQuickSettings;
        state.showNotificationPanel = false;
        state.showQuickSettings = false;
        
        // If panels were open, we need to re-render to remove them
        if (wasOpen) {
          render();
        }
      }
      
      // Expose globally for use in window interactions
      window.closePanelsInstantly = closePanelsInstantly;
      
      // Helper to safely close notification panel with animation
      function closeNotificationPanel(callback, skipRender) {
        // Cancel any pending animation timer
        if (notificationPanelAnimationTimer) {
          clearTimeout(notificationPanelAnimationTimer);
          notificationPanelAnimationTimer = null;
        }
        
        if (notificationClockInterval) {
          clearInterval(notificationClockInterval);
          notificationClockInterval = null;
        }
        
        // If not open, just reset state
        if (!state.showNotificationPanel) {
          notificationPanelAnimating = false;
          if (callback) callback();
          return;
        }
        
        const notifPanel = document.querySelector('.notification-panel');
        if (notifPanel) {
          // If already closing, don't restart animation
          if (notificationPanelAnimating) {
            return;
          }
          notificationPanelAnimating = true;
          notifPanel.classList.add('closing');
          notifPanel.classList.remove('active');
          // Match .notification-panel.closing transition duration (~250ms) so the animation can finish
          notificationPanelAnimationTimer = setTimeout(() => {
            state.showNotificationPanel = false;
            notificationPanelAnimating = false;
            notificationPanelAnimationTimer = null;
            if (callback) callback();
            else if (!skipRender) render();
          }, 260);
        } else {
          state.showNotificationPanel = false;
          notificationPanelAnimating = false;
          if (callback) callback();
        }
      }
      
      // Helper to safely close quick settings with animation
      function closeQuickSettings(callback, skipRender) {
        // Cancel any pending animation timer
        if (quickSettingsAnimationTimer) {
          clearTimeout(quickSettingsAnimationTimer);
          quickSettingsAnimationTimer = null;
        }
        
        // If not open, just reset state
        if (!state.showQuickSettings) {
          quickSettingsAnimating = false;
          if (callback) callback();
          return;
        }
        
        const quickSettingsEl = document.querySelector('.quick-settings');
        if (quickSettingsEl) {
          // If already closing, don't restart animation
          if (quickSettingsAnimating) {
            return;
          }
          quickSettingsAnimating = true;
          quickSettingsEl.classList.add('closing');
          quickSettingsEl.classList.remove('active');
          quickSettingsAnimationTimer = setTimeout(() => {
            state.showQuickSettings = false;
            quickSettingsAnimating = false;
            quickSettingsAnimationTimer = null;
            if (callback) callback();
            else if (!skipRender) render();
          }, 200);
        } else {
          state.showQuickSettings = false;
          quickSettingsAnimating = false;
          if (callback) callback();
        }
      }
      
      // Track the last pointer target so inline onclick handlers (that don't pass an event)
      // still resolve the correct trigger element after layout customization.
      let __lastPointerDownTarget = null;
      document.addEventListener(
        'pointerdown',
        (e) => {
          __lastPointerDownTarget = e.target;
        },
        { capture: true }
      );

      function __isProbablyVisible(el) {
        if (!(el instanceof Element)) return false;
        const r = el.getBoundingClientRect();
        return r.width > 0 && r.height > 0;
      }

      function __clamp(n, min, max) {
        return Math.max(min, Math.min(max, n));
      }

      // Helper to find the trigger element for panel anchoring.
      // Prefers the actual clicked element (or last pointer target) so it works after layout customization.
      function findPanelTriggerButton(event, elementIds) {
        const candidate =
          event?.currentTarget ||
          event?.target ||
          __lastPointerDownTarget ||
          document.activeElement;

        if (candidate && candidate instanceof Element) {
          const el = candidate.closest('button,[role="button"],[onclick]');
          if (el) return el;
        }

        // Then try to find by data-element-id (works with customized layout)
        for (const id of elementIds) {
          const wrapper = document.querySelector(`[data-element-id="${id}"]`);
          if (wrapper) {
            const el = wrapper.querySelector('button,[role="button"],[onclick]');
            if (el) return el;
          }
        }

        // Fallback to onclick selector (pick a visible one if there are multiples)
        const selector = elementIds.includes('notifications')
          ? '[onclick*="toggleNotifications"]'
          : '[onclick*="toggleQuickSettings"]';

        const matches = Array.from(document.querySelectorAll(selector));
        const visible = matches.find(__isProbablyVisible);
        return (visible || matches[0]) ?? null;
      }

      // Compute BOTH: panel horizontal position (left/right) and the transform-origin inside the panel.
      // We store results on :root so they survive the app's render() which replaces innerHTML.
      function calculatePanelAnchor(triggerEl, panelWidth, edgePadding = 12) {
        if (!triggerEl) return null;

        const rect = triggerEl.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;

        const left = __clamp(
          centerX - panelWidth / 2,
          edgePadding,
          window.innerWidth - panelWidth - edgePadding
        );

        const originX = centerX - left;
        return { left, originX };
      }

      function applyPanelVars(kind, anchor, defaults) {
        const root = document.documentElement;

        if (anchor) {
          root.style.setProperty(`--${kind}-left`, `${anchor.left}px`);
          root.style.setProperty(`--${kind}-right`, 'auto');
          root.style.setProperty(`--${kind}-origin-x`, `${anchor.originX}px`);
        } else {
          root.style.setProperty(`--${kind}-left`, 'auto');
          root.style.setProperty(`--${kind}-right`, defaults.right);
          root.style.setProperty(`--${kind}-origin-x`, defaults.origin);
        }
      }

      // Helper to open notification panel
      function openNotificationPanel(event) {
        // Cancel any pending close animation
        if (notificationPanelAnimationTimer) {
          clearTimeout(notificationPanelAnimationTimer);
          notificationPanelAnimationTimer = null;
        }
        notificationPanelAnimating = false;

        // Close quick settings immediately (no animation) to prevent conflict
        if (quickSettingsAnimationTimer) {
          clearTimeout(quickSettingsAnimationTimer);
          quickSettingsAnimationTimer = null;
        }
        state.showQuickSettings = false;
        quickSettingsAnimating = false;

        // Persist anchor/origin across render() (render replaces the DOM)
        const trigger = findPanelTriggerButton(event, ['notifications']);
        const anchor = calculatePanelAnchor(trigger, 380, 12);
        applyPanelVars('notif', anchor, {
          right: '12px',
          origin: 'calc(100% - 120px)'
        });

        state.showNotificationPanel = true;
        render();
        // Start clock update interval
        notificationClockInterval = setInterval(updateNotificationClock, 1000);
      }

      // Helper to open quick settings
      function openQuickSettings(event) {
        // Cancel any pending close animation
        if (quickSettingsAnimationTimer) {
          clearTimeout(quickSettingsAnimationTimer);
          quickSettingsAnimationTimer = null;
        }
        quickSettingsAnimating = false;

        // Close notification panel immediately (no animation) to prevent conflict
        if (notificationPanelAnimationTimer) {
          clearTimeout(notificationPanelAnimationTimer);
          notificationPanelAnimationTimer = null;
        }
        if (notificationClockInterval) {
          clearInterval(notificationClockInterval);
          notificationClockInterval = null;
        }
        state.showNotificationPanel = false;
        notificationPanelAnimating = false;

        // Persist anchor/origin across render() (render replaces the DOM)
        const trigger = findPanelTriggerButton(event, ['systray', 'quicksettings']);
        const anchor = calculatePanelAnchor(trigger, 320, 12);
        applyPanelVars('qs', anchor, {
          right: '12px',
          origin: 'calc(100% - 60px)'
        });

        state.showQuickSettings = true;
        render();
      }
      
      window.toggleNotifications = function(event) {
        if (state.showNotificationPanel) {
          // Already animating close? Just let it finish
          if (notificationPanelAnimating) return;
          closeNotificationPanel();
        } else {
          // Cancel any pending close animation
          if (notificationPanelAnimationTimer) {
            clearTimeout(notificationPanelAnimationTimer);
            notificationPanelAnimationTimer = null;
          }
          notificationPanelAnimating = false;
          openNotificationPanel(event);
        }
      };
      
      window.addNotification = function(appName, title, message, icon = null, showToast = true) {
        const notification = {
          id: Date.now(),
          app: appName,
          title: title,
          message: message,
          icon: icon,
          time: new Date().toISOString()
        };
        state.notifications.unshift(notification);
        state.notificationCount = state.notifications.length;
        localStorage.setItem('mosNotifications', JSON.stringify(state.notifications));
        playSound('notification');
        
        // Show notification toast
        if (showToast) {
          window.showNotificationToast(notification);
        }
        
        // Update notification panel if open - update DOM directly instead of full render to prevent animation replay
        const notifList = document.querySelector('.notification-list');
        if (notifList && state.showNotificationPanel) {
          // Update notification list directly without full render
          const notificationHTML = notification.icon 
            ? `<div class="notification-item" onclick="window.removeNotification(${notification.id})">
                <div class="notification-icon"><img src="${notification.icon}" alt="" /></div>
                <div class="notification-content">
                  <div class="notification-app">${notification.app} <span class="notification-time">Just now</span></div>
                  <div class="notification-title">${notification.title}</div>
                  <div class="notification-body">${notification.message}</div>
                </div>
              </div>`
            : `<div class="notification-item" onclick="window.removeNotification(${notification.id})">
                <div class="notification-icon">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"/>
                    <path d="M13.73 21a2 2 0 0 1-3.46 0"/>
                  </svg>
                </div>
                <div class="notification-content">
                  <div class="notification-app">${notification.app} <span class="notification-time">Just now</span></div>
                  <div class="notification-title">${notification.title}</div>
                  <div class="notification-body">${notification.message}</div>
                </div>
              </div>`;
          notifList.insertAdjacentHTML('afterbegin', notificationHTML);
        }
        
        return notification.id;
      };
      
      // Notification toast system
      let notificationToastContainer = null;
      const activeToasts = new Map();
      
      window.showNotificationToast = function(notification) {
        // Dismiss any existing toasts first - only 1 notification at a time
        activeToasts.forEach((toast, id) => {
          if (toast.parentNode) {
            toast.parentNode.removeChild(toast);
          }
          activeToasts.delete(id);
        });
        
        // Create container if doesn't exist
        if (!notificationToastContainer) {
          notificationToastContainer = document.createElement('div');
          notificationToastContainer.className = 'notification-toast-container ' + state.notificationToastPosition;
          document.body.appendChild(notificationToastContainer);
        }
        
        // Update container position class
        notificationToastContainer.className = 'notification-toast-container ' + state.notificationToastPosition;
        
        // Create toast element
        const toast = document.createElement('div');
        toast.className = 'notification-toast';
        toast.dataset.notificationId = notification.id;
        toast.innerHTML = `
          <div class="notification-toast-icon">
            ${notification.icon ? `<img src="${notification.icon}" alt="">` : `
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"/>
                <path d="M13.73 21a2 2 0 0 1-3.46 0"/>
              </svg>
            `}
          </div>
          <div class="notification-toast-content">
            <div class="notification-toast-app">${notification.app}</div>
            <div class="notification-toast-title">${notification.title}</div>
            <div class="notification-toast-message">${notification.message}</div>
          </div>
          <button class="notification-toast-close" onclick="event.stopPropagation(); window.dismissNotificationToast(${notification.id});">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M18 6L6 18M6 6l12 12"/>
            </svg>
          </button>
        `;
        
        // Click to open notifications panel
        toast.onclick = function(e) {
          if (e.target.closest('.notification-toast-close')) return;
          e.stopPropagation(); // Prevent click-outside handler from firing
          window.dismissNotificationToast(notification.id);
          // Use a slight delay to let the toast dismiss animation start
          setTimeout(() => {
            if (!state.showNotificationPanel) {
              openNotificationPanel();
            }
          }, 50);
        };
        
        notificationToastContainer.appendChild(toast);
        activeToasts.set(notification.id, toast);
        
        // Auto dismiss after 5 seconds
        setTimeout(() => {
          window.dismissNotificationToast(notification.id);
        }, 5000);
      };
      
      window.dismissNotificationToast = function(notificationId) {
        const toast = activeToasts.get(notificationId);
        if (toast) {
          toast.classList.add('toast-out');
          setTimeout(() => {
            if (toast.parentNode) {
              toast.parentNode.removeChild(toast);
            }
            activeToasts.delete(notificationId);
            
            // Remove container if empty
            if (notificationToastContainer && notificationToastContainer.children.length === 0) {
              notificationToastContainer.remove();
              notificationToastContainer = null;
            }
          }, 300);
        }
      };
      
      window.updateNotificationToastPosition = function(position) {
        state.notificationToastPosition = position;
        localStorage.setItem('notificationToastPosition', position);
        
        // Update container if exists
        if (notificationToastContainer) {
          notificationToastContainer.className = 'notification-toast-container ' + position;
        }
      };
      
      window.removeNotification = function(id) {
        state.notifications = state.notifications.filter(n => n.id !== id);
        state.notificationCount = state.notifications.length;
        localStorage.setItem('mosNotifications', JSON.stringify(state.notifications));
        render();
      };
      
      window.clearNotifications = function() {
        state.notifications = [];
        state.notificationCount = 0;
        localStorage.setItem('mosNotifications', JSON.stringify([]));
        
        // Update notification list directly without full render (like focus button)
        const notificationList = document.querySelector('.notification-list');
        if (notificationList) {
          // Add fade-out animation to existing notifications
          const existingItems = notificationList.querySelectorAll('.notification-item');
          existingItems.forEach((item, index) => {
            item.style.transition = 'opacity 0.2s ease, transform 0.2s ease';
            item.style.transitionDelay = `${index * 0.03}s`;
            item.style.opacity = '0';
            item.style.transform = 'translateX(20px)';
          });
          
          // After animation, show empty state
          setTimeout(() => {
            notificationList.innerHTML = `
              <div class="notification-empty">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                  <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"/>
                  <path d="M13.73 21a2 2 0 0 1-3.46 0"/>
                </svg>
                <span>No notifications</span>
              </div>
            `;
          }, existingItems.length > 0 ? 200 + (existingItems.length * 30) : 0);
        }
        
        // Update notification badge in menubar
        const notifBadge = document.querySelector('.menubar-notif-badge');
        if (notifBadge) {
          notifBadge.style.display = 'none';
        }
      };
      
      window.changeCalendarMonth = function(delta) {
        state.calendarMonth += delta;
        if (state.calendarMonth > 11) {
          state.calendarMonth = 0;
          state.calendarYear++;
        } else if (state.calendarMonth < 0) {
          state.calendarMonth = 11;
          state.calendarYear--;
        }
        // Update calendar display directly instead of full render
        window.updateCalendarDisplay();
      };
      
      // Direct DOM update for calendar without full render
      window.updateCalendarDisplay = function() {
        const calendarSection = document.querySelector('.notification-calendar-section');
        if (!calendarSection) {
          render();
          return;
        }
        
        const monthLabel = calendarSection.querySelector('.notification-calendar-month');
        const daysContainer = calendarSection.querySelector('.notification-calendar-days');
        
        if (monthLabel && daysContainer) {
          const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
          monthLabel.textContent = monthNames[state.calendarMonth] + ' ' + state.calendarYear;
          
          // Regenerate days
          const year = state.calendarYear;
          const month = state.calendarMonth;
          const firstDay = new Date(year, month, 1);
          const lastDay = new Date(year, month + 1, 0);
          const startPad = (firstDay.getDay() + 6) % 7;
          const today = new Date();
          const isCurrentMonth = today.getMonth() === month && today.getFullYear() === year;
          
          let daysHTML = '';
          const prevMonthLastDay = new Date(year, month, 0).getDate();
          for (let i = startPad - 1; i >= 0; i--) {
            daysHTML += '<span class="notification-calendar-day other-month">' + (prevMonthLastDay - i) + '</span>';
          }
          for (let d = 1; d <= lastDay.getDate(); d++) {
            const isToday = isCurrentMonth && d === today.getDate();
            daysHTML += '<span class="notification-calendar-day' + (isToday ? ' today' : '') + '">' + d + '</span>';
          }
          const totalCells = startPad + lastDay.getDate();
          const remaining = totalCells % 7 === 0 ? 0 : 7 - (totalCells % 7);
          for (let i = 1; i <= remaining; i++) {
            daysHTML += '<span class="notification-calendar-day other-month">' + i + '</span>';
          }
          
          daysContainer.innerHTML = daysHTML;
        }
      };
      
      window.toggleCalendar = function() {
        state.calendarExpanded = !state.calendarExpanded;
        render();
      };
      
      window.adjustFocusTimer = function(delta) {
        state.focusTimerMinutes = Math.max(5, Math.min(120, state.focusTimerMinutes + delta));
        // Update timer display directly
        const timerValue = document.querySelector('.notification-footer-timer-value');
        if (timerValue) {
          timerValue.textContent = state.focusTimerMinutes + ' min';
        }
      };
      
      window.toggleFocusMode = function() {
        state.focusEnabled = !state.focusEnabled;
        localStorage.setItem('focusEnabled', state.focusEnabled);
        
        // Update notification panel focus button directly
        const focusBtn = document.querySelector('.notification-footer-focus');
        if (focusBtn) {
          if (state.focusEnabled) {
            focusBtn.classList.add('active');
            focusBtn.innerHTML = `
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/>
              </svg>
              Stop Focus
            `;
          } else {
            focusBtn.classList.remove('active');
            focusBtn.innerHTML = `
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polygon points="5 3 19 12 5 21 5 3"/>
              </svg>
              Focus
            `;
          }
        }
        
        // Also update quick settings focus button if visible
        const qsFocusBtn = document.querySelector('.quick-settings-icon-btn[onclick*="toggleFocus"]');
        if (qsFocusBtn) {
          if (state.focusEnabled) {
            qsFocusBtn.classList.add('active');
          } else {
            qsFocusBtn.classList.remove('active');
          }
        }
        
        // Add notification about focus mode change (with showToast=true for toast, but skip render)
        if (state.focusEnabled) {
          window.addNotification('System', 'Focus Mode', 'Focus mode enabled for ' + state.focusTimerMinutes + ' minutes');
        } else {
          window.addNotification('System', 'Focus Mode', 'Focus mode disabled');
        }
      };
      
      // Load notification count on startup
      state.notificationCount = state.notifications.length;
      
      // ============= Quick Settings Toggle Functions =============
      // These functions update DOM directly to avoid animation refresh on full render
      
      function updateQuickSettingsButtonState(buttonClass, isActive) {
        const button = document.querySelector(`.quick-settings-icon-btn.${buttonClass}`);
        if (button) {
          if (isActive) {
            button.classList.add('active');
          } else {
            button.classList.remove('active');
          }
        }
      }
      
      window.toggleWifi = function() {
        state.wifiEnabled = !state.wifiEnabled;
        localStorage.setItem('wifiEnabled', state.wifiEnabled);
        // Update button state directly instead of full render
        const wifiBtn = document.querySelector('.quick-settings-icon-btn[onclick*="toggleWifi"]');
        if (wifiBtn) {
          if (state.wifiEnabled) {
            wifiBtn.classList.add('active');
          } else {
            wifiBtn.classList.remove('active');
          }
        }
      };
      
      window.toggleBluetooth = function() {
        state.bluetoothEnabled = !state.bluetoothEnabled;
        localStorage.setItem('bluetoothEnabled', state.bluetoothEnabled);
        const btBtn = document.querySelector('.quick-settings-icon-btn[onclick*="toggleBluetooth"]');
        if (btBtn) {
          if (state.bluetoothEnabled) {
            btBtn.classList.add('active');
          } else {
            btBtn.classList.remove('active');
          }
        }
      };
      
      window.toggleShare = function() {
        state.shareEnabled = !state.shareEnabled;
        localStorage.setItem('shareEnabled', state.shareEnabled);
        const shareBtn = document.querySelector('.quick-settings-icon-btn[onclick*="toggleShare"]');
        if (shareBtn) {
          if (state.shareEnabled) {
            shareBtn.classList.add('active');
          } else {
            shareBtn.classList.remove('active');
          }
        }
      };
      
      window.toggleFocus = function() {
        state.focusEnabled = !state.focusEnabled;
        localStorage.setItem('focusEnabled', state.focusEnabled);
        
        // Update quick settings focus button directly
        const focusBtn = document.querySelector('.quick-settings-icon-btn[onclick*="toggleFocus"]');
        if (focusBtn) {
          if (state.focusEnabled) {
            focusBtn.classList.add('active');
          } else {
            focusBtn.classList.remove('active');
          }
        }
        
        // Also update notification panel focus button if visible
        const notifFocusBtn = document.querySelector('.notification-footer-focus');
        if (notifFocusBtn) {
          if (state.focusEnabled) {
            notifFocusBtn.classList.add('active');
            notifFocusBtn.innerHTML = `
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/>
              </svg>
              Stop Focus
            `;
          } else {
            notifFocusBtn.classList.remove('active');
            notifFocusBtn.innerHTML = `
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polygon points="5 3 19 12 5 21 5 3"/>
              </svg>
              Focus
            `;
          }
        }
      };
      
      // ============= Volume Slider Functions =============
      
      window.setVolume = function(value) {
        state.volume = Math.max(0, Math.min(100, Math.round(value)));
        localStorage.setItem('mosVolume', state.volume);
        updateVolumeSliderUI();
      };
      
      function updateVolumeSliderUI() {
        const slider = document.querySelector('.quick-settings .volume-slider');
        if (!slider) return;
        
        const fill = slider.querySelector('.volume-slider-fill');
        const thumb = slider.querySelector('.volume-slider-thumb');
        const percentLabel = slider.parentElement.querySelector('span');
        
        if (fill) fill.style.width = state.volume + '%';
        if (thumb) thumb.style.left = state.volume + '%';
        if (percentLabel) percentLabel.textContent = state.volume + '%';
        
        // Update the volume icon
        const volumeIcon = slider.parentElement.querySelector('svg');
        if (volumeIcon) {
          if (state.volume === 0) {
            volumeIcon.innerHTML = '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><line x1="23" y1="9" x2="17" y2="15"/><line x1="17" y1="9" x2="23" y2="15"/>';
          } else if (state.volume <= 50) {
            volumeIcon.innerHTML = '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/>';
          } else {
            volumeIcon.innerHTML = '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/>';
          }
        }
      }
      
      window.startVolumeSlide = function(event) {
        event.preventDefault();
        event.stopPropagation();
        
        const slider = event.currentTarget;
        const rect = slider.getBoundingClientRect();
        
        function updateVolume(clientX) {
          const x = clientX - rect.left;
          const percent = Math.max(0, Math.min(100, (x / rect.width) * 100));
          window.setVolume(percent);
        }
        
        // Initial update
        const clientX = event.touches ? event.touches[0].clientX : event.clientX;
        updateVolume(clientX);
        
        function onMove(e) {
          const cx = e.touches ? e.touches[0].clientX : e.clientX;
          updateVolume(cx);
        }
        
        function onEnd() {
          document.removeEventListener('mousemove', onMove);
          document.removeEventListener('mouseup', onEnd);
          document.removeEventListener('touchmove', onMove);
          document.removeEventListener('touchend', onEnd);
        }
        
        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onEnd);
        document.addEventListener('touchmove', onMove, { passive: false });
        document.addEventListener('touchend', onEnd);
      };
      
      // ============= End Panel Functions =============

      // Helper function to calculate dock dimensions based on scale
      function getDockDimensions() {
        const scale = state.dockScale || 1.0;
        const baseIconSize = 48;
        const basePadding = 6;
        const baseGap = 4; // Gap between icons
        const sidePadding = 10; // Left/right padding in dock
        
        // Calculate total number of dock icons
        const pinnedCount = state.pinnedApps.length;
        const unpinnedOpenApps = apps.filter(app => 
          !state.pinnedApps.includes(app.id) && 
          state.windows.some(w => w.appId === app.id)
        );
        const unpinnedCount = unpinnedOpenApps.length;
        const finderCount = 1; // Always present
        
        // Number of dividers (one before unpinned section if exists, one before finder)
        const dividerCount = (unpinnedCount > 0 ? 1 : 0) + 1;
        
        const totalIcons = pinnedCount + unpinnedCount + finderCount;
        
        return {
          iconSize: Math.round(baseIconSize * scale),
          padding: Math.round(basePadding * scale),
          gap: Math.round(baseGap * scale),
          // Calculate dock space for different positions
          // Bottom: padding-top + icon-height + padding-bottom + spacing + border
          getBottomSpace: () => {
            return 4 + // bottom spacing from edge
                   Math.round(basePadding * scale) + // top padding
                   Math.round(baseIconSize * scale) + // icon height
                   Math.round(basePadding * scale) + // bottom padding
                   8; // extra spacing
          },
          // Side: left/right spacing + padding + icon width + padding + border-radius
          getSideSpace: () => {
            return 8 + // left/right spacing from edge
                   Math.round(sidePadding * scale) + // side padding
                   Math.round(baseIconSize * scale) + // icon width
                   Math.round(sidePadding * scale) + // side padding
                   8; // extra spacing
          }
        };
      }


      function init() {
        localStorage.removeItem('windows');
        localStorage.removeItem('openWindows');

        // Debug: log loaded window states
        console.log('Loaded windowStates from localStorage:', state.windowStates);

        // Apply custom cursor if set
        if (state.customCursor) {
          document.body.style.cursor = `url('${state.customCursor}') 0 0, auto`;
        }

        // Load pinned apps from localStorage with proper validation
        const savedPinned = localStorage.getItem('pinnedApps');
        if (savedPinned) {
          try {
            const parsed = JSON.parse(savedPinned);
            // Validate that all saved apps still exist in the apps array
            const validPinned = parsed.filter(id => apps.find(app => app.id === id));
            state.pinnedApps = validPinned.length > 0 ? validPinned : ['finder', 'files', 'terminal', 'browser', 'mail', 'music'];
            // Save cleaned up version
            localStorage.setItem('pinnedApps', JSON.stringify(state.pinnedApps));
          } catch (e) {
            state.pinnedApps = ['finder', 'files', 'terminal', 'browser', 'mail', 'music'];
            localStorage.setItem('pinnedApps', JSON.stringify(state.pinnedApps));
          }
        } else {
          state.pinnedApps = ['finder', 'files', 'terminal', 'browser', 'mail', 'music'];
          localStorage.setItem('pinnedApps', JSON.stringify(state.pinnedApps));
        }

        const theme = localStorage.getItem('theme');
        if (theme === 'dark' || !theme) {
          // Default to dark mode like Ubuntu
          state.isDark = true;
          document.documentElement.classList.add('dark');
          if (!theme) localStorage.setItem('theme', 'dark');
        } else {
          state.isDark = false;
          document.documentElement.classList.remove('dark');
        }

        // Apply OS theme class - always macOS
        document.documentElement.classList.add('macos');

        // Define built-in wallpapers with external URLs (macOS only)
        const builtInWallpapers = {
          '-2': { // Tahoe
            light: 'https://raw.githubusercontent.com/Matko802/my-web-os-things/refs/heads/main/26-Tahoe-Light-1080x1920.png',
            dark: 'https://raw.githubusercontent.com/Matko802/my-web-os-things/refs/heads/main/26-Tahoe-Dark-1080x1920.png',
            name: 'Tahoe'
          },
          '-3': { // macOS Sonoma (default)
            light: 'https://512pixels.net/downloads/macos-wallpapers-thumbs/14-0-Sonoma-L.jpg',
            dark: 'https://512pixels.net/downloads/macos-wallpapers-thumbs/14-0-Sonoma-D.jpg',
            name: 'Sonoma'
          }
        };
        
        // Set initial wallpaper based on theme
        const savedWallpaper = localStorage.getItem('customWallpaper');
        const activeCustomIdx = parseInt(localStorage.getItem('activeCustomWallpaper') || '-2');
        
        if (activeCustomIdx >= 0 && state.customWallpapers[activeCustomIdx]) {
          // Use active custom wallpaper
          const customWallpaper = state.customWallpapers[activeCustomIdx];
          const wallpaperURL = state.isDark ? customWallpaper.dark : customWallpaper.light;
          state.customWallpaper = wallpaperURL;
        } else if (activeCustomIdx < 0 && builtInWallpapers[activeCustomIdx]) {
          // Use built-in wallpaper from localStorage or URL
          const wallpaper = builtInWallpapers[activeCustomIdx];
          const wallpaperURL = state.isDark ? wallpaper.dark : wallpaper.light;
          state.customWallpaper = savedWallpaper || wallpaperURL;
          if (!savedWallpaper) {
            localStorage.setItem('customWallpaper', wallpaperURL);
          }
        } else {
          // Default to Tahoe
          const defaultIdx = '-2';
          const wallpaperURL = state.isDark ? builtInWallpapers[defaultIdx].dark : builtInWallpapers[defaultIdx].light;
          state.customWallpaper = savedWallpaper || wallpaperURL;
          if (!savedWallpaper) {
            localStorage.setItem('customWallpaper', wallpaperURL);
            localStorage.setItem('activeCustomWallpaper', defaultIdx);
          }
        }

        // Apply no-animations class if animations are disabled
        if (!state.animationsEnabled) {
          document.body.classList.add('no-animations');
        }

        // Note: Minecraft installation is detected at runtime, not persisted

        // Initialize accent color
        const savedAccentColor = localStorage.getItem('accentColor');
        const getContrastFg = (hex) => {
          const r = parseInt(hex.slice(1, 3), 16) / 255;
          const g = parseInt(hex.slice(3, 5), 16) / 255;
          const b = parseInt(hex.slice(5, 7), 16) / 255;
          const toLinear = (c) => c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
          const luminance = 0.2126 * toLinear(r) + 0.7152 * toLinear(g) + 0.0722 * toLinear(b);
          return luminance > 0.45 ? '0 0% 10%' : '0 0% 100%';
        };
        
        if (savedAccentColor) {
          const hexToHSL = (hex) => {
            const r = parseInt(hex.slice(1, 3), 16) / 255;
            const g = parseInt(hex.slice(3, 5), 16) / 255;
            const b = parseInt(hex.slice(5, 7), 16) / 255;
            
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
              h = s = 0;
            } else {
              const d = max - min;
              s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
              
              switch (max) {
                case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                case g: h = ((b - r) / d + 2) / 6; break;
                case b: h = ((r - g) / d + 4) / 6; break;
              }
            }
            
            h = Math.round(h * 360);
            s = Math.round(s * 100);
            l = Math.round(l * 100);
            
            return `${h} ${s}% ${l}%`;
          };
          
          const hslColor = hexToHSL(savedAccentColor);
          const fgColor = getContrastFg(savedAccentColor);
          const thumbColor = getContrastFg(savedAccentColor) === '0 0% 10%' ? '#1a1a1e' : 'white';
          document.documentElement.style.setProperty('--primary', hslColor);
          document.documentElement.style.setProperty('--primary-foreground', fgColor);
          document.documentElement.style.setProperty('--ubuntu-orange', hslColor);
          document.documentElement.style.setProperty('--toggle-thumb-color', thumbColor);
        } else {
          // Set default accent color - macOS blue
          const defaultAccent = '#007AFF';
          state.accentColor = defaultAccent;
          localStorage.setItem('accentColor', defaultAccent);
          const hexToHSLDefault = (hex) => {
            const r = parseInt(hex.slice(1, 3), 16) / 255;
            const g = parseInt(hex.slice(3, 5), 16) / 255;
            const b = parseInt(hex.slice(5, 7), 16) / 255;
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            if (max === min) { h = s = 0; }
            else {
              const d = max - min;
              s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
              switch (max) {
                case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                case g: h = ((b - r) / d + 2) / 6; break;
                case b: h = ((r - g) / d + 4) / 6; break;
              }
            }
            return `${Math.round(h * 360)} ${Math.round(s * 100)}% ${Math.round(l * 100)}%`;
          };
          const hslDefault = hexToHSLDefault(defaultAccent);
          const fgDefault = getContrastFg(defaultAccent);
          const thumbDefault = fgDefault === '0 0% 10%' ? '#1a1a1e' : 'white';
          document.documentElement.style.setProperty('--primary', hslDefault);
          document.documentElement.style.setProperty('--primary-foreground', fgDefault);
          document.documentElement.style.setProperty('--ubuntu-orange', hslDefault);
          document.documentElement.style.setProperty('--toggle-thumb-color', thumbDefault);
        }
        
        // Initialize component style classes
        if (typeof updateComponentClasses === 'function') {
          updateComponentClasses();
        } else {
          // Fallback: apply default classes
          const root = document.documentElement;
          root.classList.add('macos-dock');
          root.classList.add('macos-menubar');
          root.classList.add('macos-windows');
        }
        
        // Apply window effects
        document.documentElement.style.setProperty('--window-opacity', state.windowOpacity);
        document.documentElement.style.setProperty('--window-blur', state.windowBlur + 'px');
        
        // Apply system font
        if (state.systemFont && state.systemFont !== 'Ubuntu') {
          document.body.style.fontFamily = `'${state.systemFont}', 'Segoe UI', Roboto, sans-serif`;
        }


        // Handle window resize for borderless fullscreen windows
        window.addEventListener('resize', function() {
          // Update fullscreen windows to match new screen size
          state.windows.forEach(win => {
            if (win.isFullscreen) {
              const windowEl = document.getElementById(`window-${win.id}`);
              if (windowEl) {
                windowEl.style.width = '100vw';
                windowEl.style.height = '100vh';
                windowEl.style.top = '0';
                windowEl.style.left = '0';
              }
            }
          });
          // Also update maximized windows
          state.windows.forEach(win => {
            if (win.isMaximized) {
              const windowEl = document.getElementById(`window-${win.id}`);
              if (windowEl) {
                const dockPosition = state.dockPosition || 'bottom';
                const menubarHeight = 28;
                const dockDims = getDockDimensions();
                const dockSpaceBottom = dockPosition === 'bottom' ? dockDims.getBottomSpace() : 0;
                const dockSpaceSide = (dockPosition === 'left' || dockPosition === 'right') ? dockDims.getSideSpace() : 0;
                const targetWidth = window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0);
                const targetHeight = window.innerHeight - menubarHeight - dockSpaceBottom;
                const targetLeft = dockPosition === 'left' ? dockSpaceSide : 0;
                windowEl.style.width = `${targetWidth}px`;
                windowEl.style.height = `${targetHeight}px`;
                windowEl.style.top = `${menubarHeight}px`;
                windowEl.style.left = `${targetLeft}px`;
              }
            }
          });
        });

        setInterval(() => {
          state.currentTime = new Date();
          updateTime();
        }, 1000);
        
        // ============= SCROLL TRACKING =============
        // Track scroll events to prevent render during scrollbar interaction
        // and maintain cursor visibility during scroll
        let scrollTimeout = null;
        document.addEventListener('scroll', (e) => {
          // Set scrolling flag
          state.isScrolling = true;
          
          // Save scroll position of the scrolled element
          const windowEl = e.target.closest('.window');
          if (windowEl) {
            const windowId = windowEl.dataset.id;
            if (windowId) {
              state.scrollPositions[windowId] = e.target.scrollTop;
            }
          }
          
          // Clear previous timeout
          if (scrollTimeout) {
            clearTimeout(scrollTimeout);
          }
          
          // Set timeout to reset scrolling flag after scrolling stops
          scrollTimeout = setTimeout(() => {
            state.isScrolling = false;
          }, 150);
        }, true); // Use capture to catch all scroll events
        
        // Track mousedown on scrollbars to prevent cursor glitches
        // AND save all scroll positions before any interaction
        document.addEventListener('mousedown', (e) => {
          // ALWAYS save scroll positions on mousedown - this prevents scroll resets
          // when clicking anywhere in the OS
          const saveAllScrollPositions = () => {
            // Save settings content scroll position
            const settingsContent = document.querySelector('.settings-content');
            if (settingsContent) {
              state.scrollPositions['settings-content'] = settingsContent.scrollTop;
            }
            
            // Save settings sidebar scroll position
            const settingsSidebar = document.querySelector('.settings-sidebar');
            if (settingsSidebar) {
              state.scrollPositions['settings-sidebar'] = settingsSidebar.scrollTop;
            }
            
            // Save all window-content scroll positions
            document.querySelectorAll('.window-content').forEach(content => {
              const windowEl = content.closest('.window');
              if (windowEl) {
                const windowId = windowEl.dataset.id;
                if (windowId) {
                  state.scrollPositions[windowId] = content.scrollTop;
                }
              }
            });
            
            // Save launchpad scroll
            const launchpad = document.querySelector('.launchpad-grid');
            if (launchpad) {
              state.scrollPositions['launchpad'] = launchpad.scrollTop;
            }
            
             // Save version manager scroll (list + details panes)
             document.querySelectorAll('.window').forEach(windowEl => {
               const windowId = windowEl.dataset.id;
               if (!windowId) return;
               const win = state.windows.find(w => w.id === parseInt(windowId));
               if (!win || win.appId !== 'versionmanager') return;

               const listEl = windowEl.querySelector('.versionmanager-list');
               if (listEl) state.scrollPositions[`${windowId}-versionmanager-list`] = listEl.scrollTop;

               const detailsEl = windowEl.querySelector('.versionmanager-details');
               if (detailsEl) state.scrollPositions[`${windowId}-versionmanager-details`] = detailsEl.scrollTop;
             });
          };
          
          // Save scroll positions on every mousedown
          saveAllScrollPositions();
          
          // Check if clicking on a scrollbar area (right edge of scrollable content)
          const target = e.target;
          if (target.scrollHeight > target.clientHeight || target.scrollWidth > target.clientWidth) {
            const rect = target.getBoundingClientRect();
            const scrollbarWidth = target.offsetWidth - target.clientWidth;
            const scrollbarHeight = target.offsetHeight - target.clientHeight;
            
            // Check if click is in scrollbar area (right 20px for vertical, bottom 20px for horizontal)
            const inVerticalScrollbar = e.clientX > rect.right - Math.max(scrollbarWidth, 20);
            const inHorizontalScrollbar = e.clientY > rect.bottom - Math.max(scrollbarHeight, 20);
            
            if (inVerticalScrollbar || inHorizontalScrollbar) {
              state.isScrolling = true;
              // Reset after mouseup
              const resetScrolling = () => {
                setTimeout(() => {
                  state.isScrolling = false;
                }, 100);
                document.removeEventListener('mouseup', resetScrolling);
              };
              document.addEventListener('mouseup', resetScrolling);
            }
          }
        }, true);

        document.addEventListener('contextmenu', (e) => {
          // Allow menubar context menu
          if (e.target.closest('.menubar')) {
            e.preventDefault();
            const menubar = e.target.closest('.menubar');
            const menubarRect = menubar.getBoundingClientRect();
            // Position the context menu at click position, but ensure it stays on screen
            let x = e.clientX;
            let y = e.clientY;
            // Prevent menu from going off-screen (menu is ~180px wide, ~120px tall)
            if (x + 180 > window.innerWidth) x = window.innerWidth - 190;
            if (y + 120 > window.innerHeight) y = window.innerHeight - 130;
            if (x < 10) x = 10;
            if (y < 10) y = 10;
            state.menubarContextMenu = { x, y };
            state.contextMenu = null; // Close any dock context menu
            render();
            return;
          }
          e.preventDefault();
        });
        document.addEventListener('click', (e) => {
          // If a window snap animation is in progress, skip this click's re-render
          // so the animation isn't killed by a full DOM rebuild.
          if (state.isSnappingWindow) return;

          // If a panel close animation was just triggered (e.g. by clicking its toggle),
          // do NOT re-render on this same click event or it will cancel the CSS transition.
          if (quickSettingsAnimating || notificationPanelAnimating) return;
          
          // Skip render() during active window/dock dragging to eliminate flicker
          if (dragState || dockDragState || resizeState) return;
          
          // Skip render if user is interacting with scrollable content
          if (state.isScrolling) return;
          
          // Don't re-render if clicking inside a window - window content handles its own updates
          // EXCEPT: save scroll positions before any action
          const clickedWindow = e.target.closest('.window');
          if (clickedWindow) {
            // Save scroll positions immediately when clicking inside a window
            const windowId = clickedWindow.dataset.id;
            
            // Save settings content scroll position
            const settingsContent = clickedWindow.querySelector('.settings-content');
            if (settingsContent) {
              state.scrollPositions['settings-content'] = settingsContent.scrollTop;
            }
            
            // Save settings sidebar scroll position
            const settingsSidebar = clickedWindow.querySelector('.settings-sidebar');
            if (settingsSidebar) {
              state.scrollPositions['settings-sidebar'] = settingsSidebar.scrollTop;
            }
            
            // Save general window content scroll
            const windowContent = clickedWindow.querySelector('.window-content');
            if (windowContent && windowId) {
              state.scrollPositions[windowId] = windowContent.scrollTop;
            }
            
            // Only close context menus, don't trigger full render
            if (state.contextMenu || state.menubarContextMenu) {
              state.contextMenu = null;
              state.menubarContextMenu = null;
            }
            return; // Don't render - window content updates itself
          }
          
          // Don't clear context menu or re-render if user has text selected
          const selection = window.getSelection();
          const hasSelection = selection && selection.toString().length > 0;
          
          if (!hasSelection && !e.target.closest('.context-menu') && !e.target.closest('.dock-icon') && !e.target.closest('.menubar-context-menu')) {
            state.contextMenu = null;
            state.menubarContextMenu = null;
            
            // Don't render when clicking inside quick-settings or notification-panel
            // This prevents button clicks inside these panels from triggering animations
            if (e.target.closest('.quick-settings') || e.target.closest('.notification-panel')) {
              return;
            }
            
            // Close quick settings if clicking outside (with animation)
            if (!e.target.closest('[onclick*="toggleQuickSettings"]') && !e.target.closest('.notification-toast')) {
              if (state.showQuickSettings && !quickSettingsAnimating) {
                closeQuickSettings();
                return; // Don't render immediately
              }
            }
            // Close notification panel if clicking outside (with animation)
            if (!e.target.closest('[onclick*="toggleNotifications"]') && !e.target.closest('.notification-toast')) {
              if (state.showNotificationPanel && !notificationPanelAnimating) {
                closeNotificationPanel();
                return;
              }
            }
            // Clear active bookmark/site actions when clicking elsewhere
            if (!e.target.closest('.browser-bookmark') && !e.target.closest('.browser-site-card')) {
              state.activeBookmarkIndex = null;
              state.activeSiteIndex = null;
            }
            render();
          }
        });

        // Listen for fullscreen changes to update maximized windows
        document.addEventListener('fullscreenchange', () => {
          // When entering/exiting fullscreen, update all maximized windows
          const maximizedWindows = state.windows.filter(w => w.isMaximized && !w.isMinimized);
          maximizedWindows.forEach(win => {
            const windowEl = document.getElementById(`window-${win.id}`);
            if (windowEl) {
              const dockPosition = state.dockPosition || 'bottom';
              const menubarHeight = 28;
              const dockDims = getDockDimensions();
              
              const dockSpaceBottom = dockPosition === 'bottom' ? dockDims.getBottomSpace() : 0;
              const dockSpaceSide = (dockPosition === 'left' || dockPosition === 'right') ? dockDims.getSideSpace() : 0;
              const targetWidth = window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0);
              const targetHeight = window.innerHeight - menubarHeight - dockSpaceBottom;
              const targetLeft = dockPosition === 'left' ? dockSpaceSide : 0;
              const targetTop = menubarHeight;
              
              windowEl.style.top = `${targetTop}px`;
              windowEl.style.left = `${targetLeft}px`;
              windowEl.style.width = `${targetWidth}px`;
              windowEl.style.height = `${targetHeight}px`;
            }
          });
        });

        // Global F11 handler - use capture phase to intercept before iframes
        // This will work even when focus is inside an iframe
        document.addEventListener('keydown', (e) => {
          if (e.key === 'F11') {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            
            // Toggle browser fullscreen for the entire desktop OS
            if (!document.fullscreenElement) {
              document.documentElement.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
              });
            } else {
              document.exitFullscreen().catch(err => {
                console.error(`Error attempting to exit fullscreen: ${err.message}`);
              });
            }
            return false;
          }
        }, true); // capture: true to intercept before iframes
        
        window.addEventListener('keydown', (e) => {
          
          // Block common browser keybinds when in fullscreen mode to make OS usable
          if (document.fullscreenElement) {
            const key = e.key.toLowerCase();
            const isCtrl = e.ctrlKey || e.metaKey;
            const isAlt = e.altKey;
            const isShift = e.shiftKey;
            
            // Block Ctrl+key combinations that browsers use
            if (isCtrl && !isAlt) {
              const blockedCtrlKeys = [
                't', // new tab
                'w', // close tab
                'n', // new window
                'r', // reload
                'p', // print
                's', // save
                'f', // find
                'g', // find next
                'h', // history
                'j', // downloads
                'k', // search (some browsers)
                'l', // address bar
                'd', // bookmark
                'b', // bookmarks bar
                'o', // open file
                'u', // view source
                'q', // quit
                '+', // zoom in
                '-', // zoom out
                '=', // zoom in (alternative)
                '0', // reset zoom
                'tab', // switch tabs
              ];
              
              // Ctrl+Shift combinations
              const blockedCtrlShiftKeys = [
                't', // reopen closed tab
                'n', // incognito window
                'w', // close window
                'j', // downloads
                'i', // developer tools
                'c', // developer tools
                'delete', // clear browsing data
                'tab', // switch tabs reverse
                'b', // bookmarks manager
                'o', // bookmarks manager
                'm', // user profiles
                'p', // print preview
              ];
              
              if (isShift) {
                if (blockedCtrlShiftKeys.includes(key)) {
                  e.preventDefault();
                  e.stopPropagation();
                  return;
                }
              } else {
                if (blockedCtrlKeys.includes(key)) {
                  // Allow Ctrl+C, Ctrl+V, Ctrl+X, Ctrl+A, Ctrl+Z for normal text operations in input fields
                  const isInputField = e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable;
                  const allowedInInputs = ['c', 'v', 'x', 'a', 'z', 'y'];
                  if (isInputField && allowedInInputs.includes(key)) {
                    return; // Allow these in input fields
                  }
                  e.preventDefault();
                  e.stopPropagation();
                  return;
                }
              }
            }
            
            // Block Alt+key combinations
            if (isAlt && !isCtrl) {
              const blockedAltKeys = [
                'home', // home page
                'arrowleft', // back
                'arrowright', // forward
                'd', // address bar
                'f4', // close window
                'f', // file menu
                'e', // edit menu
                'v', // view menu
                'h', // help menu
                't', // tools menu
              ];
              
              if (blockedAltKeys.includes(key)) {
                e.preventDefault();
                e.stopPropagation();
                return;
              }
            }
            
            // Block function keys that browsers use
            const blockedFunctionKeys = [
              'f1', // help
              'f3', // find
              'f5', // reload
              'f6', // address bar
              'f7', // caret browsing
              'f10', // menu bar
              'f12', // developer tools
            ];
            
            if (blockedFunctionKeys.includes(key)) {
              e.preventDefault();
              e.stopPropagation();
              return;
            }
          }
          
          // Track Ctrl+Alt key state for launchpad (only opens on release)
          if (!state.ctrlAltState) {
            state.ctrlAltState = { ctrlDown: false, altDown: false, usedForShortcut: false };
          }
          
          // Track key presses
          if (e.key === 'Control') state.ctrlAltState.ctrlDown = true;
          if (e.key === 'Alt') state.ctrlAltState.altDown = true;
          
          // Handle Ctrl+Alt+; or Ctrl+Alt+` to open Task Manager (bypasses launchpad)
          // Use e.code for international keyboard compatibility
          if (e.ctrlKey && e.altKey && (e.code === 'Semicolon' || e.code === 'Backquote' || e.key === ';' || e.key === '`')) {
            // Don't trigger if user is typing in an input field
            if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
              e.preventDefault();
              state.ctrlAltState.usedForShortcut = true; // Mark that we used this combo for a shortcut
              // Open Task Manager
              window.toggleWindow('taskmanager');
            }
            return;
          }
          
          // Handle Ctrl+Alt+L to lock screen (bypasses launchpad)
          // Use e.code for international keyboard compatibility (KeyL is the physical L key regardless of layout)
          if (e.ctrlKey && e.altKey && (e.code === 'KeyL' || e.key === 'l' || e.key === 'L')) {
            // Don't trigger if user is typing in an input field or already locked
            if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA' && !state.isLocked) {
              e.preventDefault();
              state.ctrlAltState.usedForShortcut = true; // Mark that we used this combo for a shortcut
              window.lockScreen();
            }
            return;
          }
          
          // Don't interfere with input fields (except for launchpad search Escape)
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            // Handle Escape for launchpad search or fullscreen exit
            if (e.key === 'Escape') {
              if (state.showLaunchpad) {
                window.closeLaunchpad();
                return;
              }
              const fullscreenWindow = state.windows.find((w) => w.isFullscreen);
              if (fullscreenWindow) {
                toggleFullscreen(fullscreenWindow.id);
              }
            }
            return;
          }
          
          if (e.key === 'Escape') {
            // Close launchpad first if open
            if (state.showLaunchpad) {
              window.closeLaunchpad();
              return;
            }
            // Otherwise check for fullscreen window
            const fullscreenWindow = state.windows.find((w) => w.isFullscreen);
            if (fullscreenWindow) {
              toggleFullscreen(fullscreenWindow.id);
            }
          }
        }, true);
        
        // Handle keyup for Ctrl+Alt release to open launchpad
        window.addEventListener('keyup', (e) => {
          if (!state.ctrlAltState) {
            state.ctrlAltState = { ctrlDown: false, altDown: false, usedForShortcut: false };
          }
          
          const wasCtrlAltHeld = state.ctrlAltState.ctrlDown && state.ctrlAltState.altDown;
          const usedForShortcut = state.ctrlAltState.usedForShortcut;
          
          // Track key releases
          if (e.key === 'Control') state.ctrlAltState.ctrlDown = false;
          if (e.key === 'Alt') state.ctrlAltState.altDown = false;
          
          // If both Ctrl and Alt were held and now one is released, and wasn't used for a shortcut
          if (wasCtrlAltHeld && !usedForShortcut && (e.key === 'Control' || e.key === 'Alt')) {
            // Don't trigger if user is typing in an input field
            if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
              e.preventDefault();
              state.showLaunchpad = !state.showLaunchpad;
              render();
              // Focus the search input after render when opening
              if (state.showLaunchpad) {
                setTimeout(() => {
                  const searchInput = document.querySelector('.launchpad-search');
                  if (searchInput) {
                    searchInput.focus();
                  }
                }, 50);
              }
            }
          }
          
          // Reset shortcut flag when both keys are released
          if (!state.ctrlAltState.ctrlDown && !state.ctrlAltState.altDown) {
            state.ctrlAltState.usedForShortcut = false;
          }
        }, true);

        render();
      }

      window.toggleTheme = function toggleTheme() {
        console.log('Theme toggle clicked! Current state:', state.isDark);
        state.isDark = !state.isDark;
        console.log('New theme state:', state.isDark ? 'dark' : 'light');
        
        // Create and trigger the pulse/glow overlay animation
        let overlay = document.querySelector('.theme-transition-overlay');
        if (!overlay) {
          overlay = document.createElement('div');
          overlay.className = 'theme-transition-overlay';
          document.body.appendChild(overlay);
        }
        overlay.style.setProperty('--pulse-color', state.accentColor + '40');
        overlay.classList.remove('active');
        void overlay.offsetWidth; // Force reflow
        overlay.classList.add('active');
        setTimeout(() => overlay.classList.remove('active'), 500);
        
        // Apply theme change immediately
        if (state.isDark) {
          document.documentElement.classList.add('dark');
          localStorage.setItem('theme', 'dark');
          // Set wallpaper based on active custom or default
          const builtInWallpapers = {
            '-2': { 
              light: 'https://raw.githubusercontent.com/Matko802/my-web-os-things/refs/heads/main/26-Tahoe-Light-1080x1920.png',
              dark: 'https://raw.githubusercontent.com/Matko802/my-web-os-things/refs/heads/main/26-Tahoe-Dark-1080x1920.png'
            },
            '-3': { 
              light: 'https://512pixels.net/downloads/macos-wallpapers-thumbs/14-0-Sonoma-L.jpg',
              dark: 'https://512pixels.net/downloads/macos-wallpapers-thumbs/14-0-Sonoma-D.jpg'
            },
          };
          
          if (state.activeCustomWallpaper >= 0 && state.customWallpapers[state.activeCustomWallpaper]) {
            const customWallpaper = state.customWallpapers[state.activeCustomWallpaper];
            window.setWallpaperFromURL(customWallpaper.dark);
          } else if (state.activeCustomWallpaper < 0 && builtInWallpapers[state.activeCustomWallpaper]) {
            window.setWallpaperFromURL(builtInWallpapers[state.activeCustomWallpaper].dark);
          } else {
            window.setWallpaperFromURL(builtInWallpapers['-2'].dark);
          }
        } else {
          document.documentElement.classList.remove('dark');
          localStorage.setItem('theme', 'light');
          // Set wallpaper based on active custom or default
          const builtInWallpapers = {
            '-2': { 
              light: 'https://raw.githubusercontent.com/Matko802/my-web-os-things/refs/heads/main/26-Tahoe-Light-1080x1920.png',
              dark: 'https://raw.githubusercontent.com/Matko802/my-web-os-things/refs/heads/main/26-Tahoe-Dark-1080x1920.png'
            },
            '-3': { 
              light: 'https://512pixels.net/downloads/macos-wallpapers-thumbs/14-0-Sonoma-L.jpg',
              dark: 'https://512pixels.net/downloads/macos-wallpapers-thumbs/14-0-Sonoma-D.jpg'
            },
          };
          
          if (state.activeCustomWallpaper >= 0 && state.customWallpapers[state.activeCustomWallpaper]) {
            const customWallpaper = state.customWallpapers[state.activeCustomWallpaper];
            window.setWallpaperFromURL(customWallpaper.light);
          } else if (state.activeCustomWallpaper < 0 && builtInWallpapers[state.activeCustomWallpaper]) {
            window.setWallpaperFromURL(builtInWallpapers[state.activeCustomWallpaper].light);
          } else {
            window.setWallpaperFromURL(builtInWallpapers['-2'].light);
          }
        }
        
        // Update ALL theme icons with spinning animation (menubar + Quick Settings)
        const themeIcons = document.querySelectorAll('.theme-toggle-icon');
        themeIcons.forEach(themeIcon => {
          themeIcon.classList.add('transitioning');
          
          // Switch icon halfway through the rotation for smooth transition
          setTimeout(() => {
            themeIcon.innerHTML = state.isDark ? icons.Moon : icons.Sun;
          }, 300); // Halfway through the 600ms spinning animation
          
          // Remove transitioning class after animation completes
          setTimeout(() => {
            themeIcon.classList.remove('transitioning');
          }, 600);
        });
        
        // Update Quick Settings button active state, icon and label
        const qsThemeBtn = document.querySelector('.quick-settings-icon-btn .qs-theme-icon');
        if (qsThemeBtn) {
          const btn = qsThemeBtn.closest('.quick-settings-icon-btn');
          if (btn) {
            if (state.isDark) {
              btn.classList.add('active');
            } else {
              btn.classList.remove('active');
            }
            // Update the icon inside qs-theme-icon (already handled by themeIcons loop above via .theme-toggle-icon)
            // Update the label text
            const labelSpan = btn.querySelector('span:not(.qs-theme-icon)');
            if (labelSpan) {
              labelSpan.textContent = state.isDark ? 'Dark' : 'Light';
            }
          }
        }
        
        // Update all toggle switches in settings to match new state
        const toggleSwitches = document.querySelectorAll('.toggle-switch');
        toggleSwitches.forEach(toggle => {
          const onclickStr = toggle.getAttribute('onclick');
          if (onclickStr && onclickStr.includes('toggleTheme')) {
            if (state.isDark) {
              toggle.classList.add('active');
            } else {
              toggle.classList.remove('active');
            }
          }
        });

        // Skip full render if quick settings or notification panel is open to prevent animation replay
        // The DOM was already updated directly above, so we just need to update settings content if visible
        if (state.showQuickSettings || state.showNotificationPanel) {
          // Only refresh settings content if settings window is open
          const settingsContent = document.querySelector('.settings-content');
          if (settingsContent && state.settingsTab === 'appearance') {
            setTimeout(() => {
              refreshSettingsContent();
            }, 350);
          }
        } else {
          // Delay render to allow smooth CSS color transitions to complete first
          setTimeout(() => {
            render();
          }, 350);
        }
      };
      
      window.toggleQuickSettings = function toggleQuickSettings(event) {
        if (state.showQuickSettings) {
          // Already animating close? Just let it finish
          if (quickSettingsAnimating) return;
          closeQuickSettings();
        } else {
          // Cancel any pending close animation
          if (quickSettingsAnimationTimer) {
            clearTimeout(quickSettingsAnimationTimer);
            quickSettingsAnimationTimer = null;
          }
          quickSettingsAnimating = false;
          openQuickSettings(event);
        }
      };

      // Helper functions to get effective style for each component - always macOS
      window.getEffectiveDockStyle = function() {
        return 'macos';
      };
      
      window.getEffectiveMenubarStyle = function() {
        return 'macos';
      };
      
      window.getEffectiveWindowStyle = function() {
        return 'macos';
      };
      
      // Functions to set component styles
      window.setComponentStyle = function(component, style) {
        if (component === 'dock') {
          state.dockStyle = style;
          localStorage.setItem('dockStyle', style);
        } else if (component === 'menubar') {
          state.menubarStyle = style;
          localStorage.setItem('menubarStyle', style);
        } else if (component === 'window') {
          state.windowStyle = style;
          localStorage.setItem('windowStyle', style);
        }
        
        // Update CSS classes
        updateComponentClasses();
        render();
      };
      
      function updateComponentClasses() {
        const root = document.documentElement;
        
        // Remove all component-specific classes
        root.classList.remove('macos-dock', 'macos-menubar', 'macos-windows', 'window-transparent');
        
        // Add macOS classes
        root.classList.add('macos-dock');
        root.classList.add('macos-menubar');
        root.classList.add('macos-windows');
        
        // Add transparency class if enabled
        if (state.windowOpacity < 1 || state.windowBlur > 0) {
          root.classList.add('window-transparent');
        }
        
        // Apply CSS custom properties
        root.style.setProperty('--window-opacity', state.windowOpacity);
        root.style.setProperty('--window-blur', state.windowBlur + 'px');
      }
      
      // Window customization functions
      window.setWindowOpacity = function(opacity) {
        state.windowOpacity = parseFloat(opacity);
        localStorage.setItem('windowOpacity', opacity);
        document.documentElement.style.setProperty('--window-opacity', opacity);
        updateComponentClasses();
        // CSS properties are updated directly, no need for full render
      };
      
      window.setWindowBlur = function(blur) {
        state.windowBlur = parseInt(blur);
        localStorage.setItem('windowBlur', blur);
        document.documentElement.style.setProperty('--window-blur', blur + 'px');
        updateComponentClasses();
        // CSS properties are updated directly, no need for full render
      };
      
      window.resetWindowEffects = function() {
        // Reset to defaults: 35% transparency (0.65 opacity), 20px blur
        state.windowOpacity = 0.65;
        state.windowBlur = 20;
        localStorage.setItem('windowOpacity', '0.65');
        localStorage.setItem('windowBlur', '20');
        document.documentElement.style.setProperty('--window-opacity', '0.65');
        document.documentElement.style.setProperty('--window-blur', '20px');
        updateComponentClasses();
        refreshSettingsContent();
      };
      
      window.setSystemFont = function(font) {
        state.systemFont = font;
        localStorage.setItem('systemFont', font);
        document.body.style.fontFamily = `'${font}', 'Segoe UI', Roboto, sans-serif`;
        render();
      };

      window.switchSettingsTab = function switchSettingsTab(tab) {
        // Save settings sidebar scroll position before switching tabs
        const settingsSidebar = document.querySelector('.settings-sidebar');
        if (settingsSidebar) {
          state.scrollPositions['settings-sidebar'] = settingsSidebar.scrollTop;
        }
        
        state.settingsTab = tab;
        localStorage.setItem('settingsTab', tab);
        
        // Instead of full render, try to update settings content directly
        const settingsContent = document.querySelector('.settings-content');
        if (settingsContent) {
          // Save current tab scroll before switching
          state.scrollPositions['settings-content'] = 0; // Reset content scroll for new tab
          
          // Update the active state on sidebar items
          document.querySelectorAll('.settings-nav-item').forEach(item => {
            const itemTab = item.getAttribute('onclick')?.match(/switchSettingsTab\('([^']+)'\)/)?.[1];
            if (itemTab === tab) {
              item.classList.add('active');
            } else {
              item.classList.remove('active');
            }
          });
          
          // Update content
          settingsContent.innerHTML = getSettingsContent(tab);
          settingsContent.scrollTop = 0; // Scroll to top for new tab
          
          // Restore sidebar scroll
          if (settingsSidebar && state.scrollPositions['settings-sidebar'] !== undefined) {
            settingsSidebar.scrollTop = state.scrollPositions['settings-sidebar'];
          }
          return;
        }
        
        render();
      };

      // ============= Real-Time Appearance Update Functions =============
      
      // Helper function to convert hex to HSL
      function hexToHSL(hex) {
        const r = parseInt(hex.slice(1, 3), 16) / 255;
        const g = parseInt(hex.slice(3, 5), 16) / 255;
        const b = parseInt(hex.slice(5, 7), 16) / 255;
        
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        
        if (max === min) {
          h = s = 0;
        } else {
          const d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          
          switch (max) {
            case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
            case g: h = ((b - r) / d + 2) / 6; break;
            case b: h = ((r - g) / d + 4) / 6; break;
          }
        }
        
        h = Math.round(h * 360);
        s = Math.round(s * 100);
        l = Math.round(l * 100);
        
        return `${h} ${s}% ${l}%`;
      }
      
      // Calculate relative luminance and determine if text should be dark or light
      function getContrastForeground(hex) {
        const r = parseInt(hex.slice(1, 3), 16) / 255;
        const g = parseInt(hex.slice(3, 5), 16) / 255;
        const b = parseInt(hex.slice(5, 7), 16) / 255;
        
        // Convert to sRGB
        const toLinear = (c) => c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
        const luminance = 0.2126 * toLinear(r) + 0.7152 * toLinear(g) + 0.0722 * toLinear(b);
        
        // Return dark text for bright backgrounds, white text for dark backgrounds
        // Threshold of 0.45 works well for most colors
        return luminance > 0.45 ? '0 0% 10%' : '0 0% 100%';
      }
      
      // Update all dock indicators with current accent color (real-time)
      function updateDockIndicators() {
        const dock = document.querySelector('.dock');
        if (!dock) return;
        
        dock.querySelectorAll('.dock-icon').forEach(iconEl => {
          const appId = iconEl.id.replace('dock-', '');
          const openWindows = state.windows.filter(w => w.appId === appId && !w.isMinimized);
          const minimizedWindows = state.windows.filter(w => w.appId === appId && w.isMinimized);
          const windowCount = openWindows.length;
          const hasMinimized = minimizedWindows.length > 0;
          
          // Check for launchpad active state
          const isLaunchpadActive = appId === 'finder' && state.showLaunchpad;
          
          // Find or create indicator container
          let indicatorContainer = iconEl.querySelector('[data-indicator]');
          
          if (windowCount > 0 || isLaunchpadActive) {
            const dotCount = isLaunchpadActive ? 1 : Math.min(windowCount, 3);
            const dots = Array.from({ length: dotCount })
              .map(() => `<div style="width: 5px; height: 5px; border-radius: 50%; background: ${state.accentColor};"></div>`)
              .join('');
            
            if (indicatorContainer) {
              indicatorContainer.innerHTML = dots;
              indicatorContainer.style.opacity = '1';
            } else {
              const newIndicator = document.createElement('div');
              newIndicator.setAttribute('data-indicator', 'true');
              newIndicator.style.cssText = 'position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%); display: flex; gap: 3px;';
              newIndicator.innerHTML = dots;
              iconEl.appendChild(newIndicator);
            }
          } else if (hasMinimized) {
            if (indicatorContainer) {
              indicatorContainer.innerHTML = `<div style="width: 5px; height: 5px; border-radius: 50%; background: ${state.accentColor}; opacity: 0.6;"></div>`;
              indicatorContainer.style.opacity = '1';
            } else {
              const newIndicator = document.createElement('div');
              newIndicator.setAttribute('data-indicator', 'true');
              newIndicator.style.cssText = 'position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%);';
              newIndicator.innerHTML = `<div style="width: 5px; height: 5px; border-radius: 50%; background: ${state.accentColor}; opacity: 0.6;"></div>`;
              iconEl.appendChild(newIndicator);
            }
          } else if (indicatorContainer) {
            indicatorContainer.remove();
          }
        });
      }
      
      // Update all icons (dock, launchpad, menubar window list) with current icon pack
      function updateAllIcons() {
        // Update dock icons
        const dock = document.querySelector('.dock');
        if (dock) {
          dock.querySelectorAll('.dock-icon').forEach(iconEl => {
            const appId = iconEl.id.replace('dock-', '');
            const app = apps.find(a => a.id === appId);
            if (app) {
              const svg = iconEl.querySelector('svg');
              if (svg) {
                // Create a temp container to parse the new icon
                const temp = document.createElement('div');
                temp.innerHTML = icons[app.icon];
                const newSvg = temp.querySelector('svg');
                if (newSvg) {
                  // Preserve transform if present (for magnification)
                  const existingTransform = svg.style.transform;
                  svg.outerHTML = newSvg.outerHTML;
                  // Re-apply transform to new svg
                  const replacedSvg = iconEl.querySelector('svg');
                  if (replacedSvg && existingTransform) {
                    replacedSvg.style.transform = existingTransform;
                  }
                }
              }
            }
          });
        }
        
        // Update launchpad icons if visible
        const launchpadGrid = document.querySelector('.launchpad-grid');
        if (launchpadGrid && state.showLaunchpad) {
          launchpadGrid.querySelectorAll('.launchpad-item').forEach(item => {
            const onclick = item.getAttribute('onclick');
            if (onclick) {
              const match = onclick.match(/toggleWindow\('([^']+)'\)/);
              if (match) {
                const appId = match[1];
                const app = apps.find(a => a.id === appId);
                if (app) {
                  const svg = item.querySelector('svg');
                  if (svg) {
                    const temp = document.createElement('div');
                    temp.innerHTML = icons[app.icon];
                    const newSvg = temp.querySelector('svg');
                    if (newSvg) {
                      svg.outerHTML = newSvg.outerHTML;
                    }
                  }
                }
              }
            }
          });
        }
        
        // Update menubar window list icons if visible
        const windowList = document.querySelector('[data-element-id="windowlist"]');
        if (windowList) {
          windowList.querySelectorAll('button').forEach(btn => {
            const spanWithIcon = btn.querySelector('span > svg')?.parentElement || btn.querySelector('svg')?.parentElement;
            if (spanWithIcon) {
              const onclick = btn.getAttribute('onclick');
              if (onclick) {
                const match = onclick.match(/handleWindowListClick\((\d+)\)|restoreWindowById\((\d+)\)/);
                if (match) {
                  const winId = parseInt(match[1] || match[2], 10);
                  const win = state.windows.find(w => w.id === winId);
                  if (win) {
                    const app = apps.find(a => a.id === win.appId);
                    if (app) {
                      const iconHtml = icons[app.icon].replace(/width="[^"]*"/g, 'width="14"').replace(/height="[^"]*"/g, 'height="14"');
                      spanWithIcon.innerHTML = iconHtml;
                    }
                  }
                }
              }
            }
          });
        }
        
        // Update dock indicators as well
        updateDockIndicators();
      }
      
      // Refresh settings content in-place without full render
      function refreshSettingsContent() {
        const settingsContent = document.querySelector('.settings-content');
        if (settingsContent) {
          // Save scroll position
          const scrollTop = settingsContent.scrollTop;
          
          // Update content
          settingsContent.innerHTML = getSettingsContent(state.settingsTab || 'appearance');
          
          // Restore scroll position
          settingsContent.scrollTop = scrollTop;
        }
      }
      
      // Apply all appearance changes in real-time (accent color, icons, indicators)
      function applyAppearanceChanges() {
        // Update icons if using accent pack
        if (state.iconPack === 'accent') {
          updateAllIcons();
        }
        
        // Always update dock indicators (they use accent color)
        updateDockIndicators();
        
        // Refresh settings content to show selected state
        refreshSettingsContent();
      }

      window.setAccentColor = function setAccentColor(color) {
        state.accentColor = color;
        localStorage.setItem('accentColor', color);
        
        // Update CSS variables immediately
        const root = document.documentElement;
        const hslColor = hexToHSL(color);
        const fgColor = getContrastForeground(color);
        root.style.setProperty('--primary', hslColor);
        root.style.setProperty('--primary-foreground', fgColor);
        root.style.setProperty('--ubuntu-orange', hslColor);
        
        // Set toggle thumb color based on accent brightness (for light mode)
        const thumbColor = isAccentBright(color) ? '#1a1a1e' : 'white';
        root.style.setProperty('--toggle-thumb-color', thumbColor);
        
        // Apply all appearance changes in real-time
        applyAppearanceChanges();
        
        // Play click sound for feedback
        playSound('click');
      };

      window.showCustomColorPicker = function showCustomColorPicker() {
        const input = document.createElement('input');
        input.type = 'color';
        input.value = state.accentColor;
        input.style.position = 'absolute';
        input.style.opacity = '0';
        input.style.pointerEvents = 'none';
        document.body.appendChild(input);
        
        input.addEventListener('change', (e) => {
          window.setAccentColor(e.target.value);
          document.body.removeChild(input);
        });
        
        input.click();
      };

      window.setIconPack = function setIconPack(pack) {
        state.iconPack = pack;
        localStorage.setItem('iconPack', pack);
        
        // Update icon pack class on document for CSS-based icon adjustments
        const root = document.documentElement;
        root.classList.remove('icon-pack-classic', 'icon-pack-monochrome', 'icon-pack-accent', 'icon-pack-glass');
        root.classList.add('icon-pack-' + pack);
        
        // Update all icons in real-time without full render
        updateAllIcons();
        
        // Refresh settings content to show selected state
        refreshSettingsContent();
        
        // Play click sound for feedback
        playSound('click');
      };

      window.filterSettingsItems = function filterSettingsItems(query) {
        state.settingsSearchQuery = query;
        
        // Update only the settings sidebar content instead of full re-render
        const settingsSidebar = document.querySelector('.settings-sidebar > div:last-child');
        if (settingsSidebar) {
          const activeTab = state.settingsTab || 'appearance';
          
          const settingsItems = [
            { id: 'general', label: 'General', icon: '<circle cx="12" cy="12" r="3"/><path d="M12 1v6m0 6v6m9-9h-6m-6 0H3"/>' },
            { id: 'appearance', label: 'Appearance', icon: '<circle cx="12" cy="12" r="10"/><path d="M12 2a10 10 0 0 1 0 20"/>' },
            { id: 'control-centre', label: 'Control Centre', icon: '<circle cx="12" cy="12" r="3"/><circle cx="19" cy="5" r="2"/><circle cx="5" cy="19" r="2"/><path d="M10.4 10.4 7 7m7.6 7.6 3.4 3.4"/>' },
            { id: 'desktop-dock', label: 'Desktop & Dock', icon: '<rect x="2" y="3" width="20" height="14" rx="2"/><path d="M8 21h8M12 17v4"/>' },
            { id: 'notifications', label: 'Notifications', icon: '<path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9M13.73 21a2 2 0 0 1-3.46 0"/>' },
            { id: 'sound', label: 'Sound', icon: '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/>' },
            { id: 'mouse', label: 'Mouse & Cursor', icon: '<path d="M12 2v6m-2-2 2-2 2 2M12 22v-6m-2 2 2 2 2-2"/><path d="M6 12H2m4-2-2 2 2 2M22 12h-4m2-2-2 2 2 2"/>' },
            { id: 'system', label: 'System', icon: '<rect x="4" y="4" width="16" height="16" rx="2"/><rect x="9" y="9" width="6" height="6"/><path d="M9 1v2M15 1v2M9 21v2M15 21v2M1 9h2M1 15h2M21 9h2M21 15h2"/>' }
          ];
          
          const filteredItems = settingsItems.filter(item => 
            item.label.toLowerCase().includes(query.toLowerCase())
          );
          
          settingsSidebar.innerHTML = `
            ${filteredItems.map(item => `
              <div class="settings-nav-item ${activeTab === item.id ? 'active' : ''}" onclick="event.stopPropagation(); window.switchSettingsTab('${item.id}')">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  ${item.icon}
                </svg>
                <span>${item.label}</span>
              </div>
            `).join('')}
            ${filteredItems.length === 0 ? '<div style="padding: 12px; text-align: center; color: rgba(255,255,255,0.5); font-size: 13px;">No results found</div>' : ''}
          `;
        }
      };

      function getSettingsContent(activeTab) {
        switch (activeTab) {
          case 'general':
            return `
              <div class="settings-section">
                <h2 style="font-size: 28px; font-weight: 700; margin-bottom: 24px; color: hsl(var(--foreground));">General</h2>
                <div class="settings-item">
                  <div>
                    <div class="settings-label">About This Computer</div>
                    <div class="settings-description">MOS Web Desktop v1.0.0</div>
                  </div>
                </div>
              </div>
            `;
            
          case 'appearance':
            return `
              <div class="settings-section" style="max-width: 700px; margin: 0 auto;">
                <h2 style="font-size: 20px; font-weight: 600; margin-bottom: 16px; color: hsl(var(--foreground));">Style</h2>
                <div style="background: hsl(var(--accent) / 0.4); border-radius: 16px; padding: 24px; margin-bottom: 32px;">
                  <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px; max-width: 450px; margin: 0 auto;">
                    <div 
                      onclick="event.stopPropagation(); if (state.isDark) window.toggleTheme();"
                      style="position: relative; aspect-ratio: 16/10; border-radius: 12px; overflow: hidden; cursor: pointer; border: 3px solid ${!state.isDark ? state.accentColor : 'hsl(var(--foreground) / 0.2)'}; background: linear-gradient(135deg, #5AC8FA 0%, #007AFF 100%); display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; box-shadow: ${!state.isDark ? '0 0 20px ' + state.accentColor + '40' : 'none'};"
                      onmouseover="if (state.isDark) this.style.borderColor='hsl(var(--foreground) / 0.4)';"
                      onmouseout="if (state.isDark) this.style.borderColor='hsl(var(--foreground) / 0.2)';"
                    >
                      <div style="width: 60%; height: 70%; background: white; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15);"></div>
                      ${!state.isDark ? '<div style="position: absolute; top: 8px; right: 8px; background: ' + state.accentColor + '; color: ' + (isAccentBright(state.accentColor) ? '#1a1a1e' : 'white') + '; width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: bold; box-shadow: 0 2px 8px rgba(0,0,0,0.3);"></div>' : ''}
                      <div style="position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%); font-size: 14px; font-weight: 600; color: white; text-shadow: 0 1px 3px rgba(0,0,0,0.3);">Light</div>
                    </div>
                    <div 
                      onclick="event.stopPropagation(); if (!state.isDark) window.toggleTheme();"
                      style="position: relative; aspect-ratio: 16/10; border-radius: 12px; overflow: hidden; cursor: pointer; border: 3px solid ${state.isDark ? state.accentColor : 'hsl(var(--foreground) / 0.2)'}; background: #2d2d2d; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; box-shadow: ${state.isDark ? '0 0 20px ' + state.accentColor + '40' : 'none'};"
                      onmouseover="if (!state.isDark) this.style.borderColor='hsl(var(--foreground) / 0.4)';"
                      onmouseout="if (!state.isDark) this.style.borderColor='hsl(var(--foreground) / 0.2)';"
                    >
                      <div style="width: 60%; height: 70%; background: #1a1a1a; border-radius: 8px; border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 4px 12px rgba(0,0,0,0.3);"></div>
                      ${state.isDark ? '<div style="position: absolute; top: 8px; right: 8px; background: ' + state.accentColor + '; color: ' + (isAccentBright(state.accentColor) ? '#1a1a1e' : 'white') + '; width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: bold; box-shadow: 0 2px 8px rgba(0,0,0,0.3);"></div>' : ''}
                      <div style="position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%); font-size: 14px; font-weight: 600; color: rgba(255,255,255,0.9); text-shadow: 0 1px 3px rgba(0,0,0,0.3);">Dark</div>
                    </div>
                  </div>
                </div>
                
                <h2 style="font-size: 20px; font-weight: 600; margin-bottom: 16px; color: hsl(var(--foreground));">Accent Color</h2>
                <div style="background: hsl(var(--accent) / 0.4); border-radius: 16px; padding: 24px; margin-bottom: 32px;">
                  <div style="display: flex; flex-wrap: wrap; gap: 16px; justify-content: center; max-width: 500px; margin: 0 auto; align-items: center;">
                    ${['#007AFF', '#3584E4', '#26A269', '#33D17A', '#F6D32D', '#E95420', '#E01B24', '#9141AC', '#613583', '#5E5C64'].map(color => `
                      <div 
                        onclick="event.stopPropagation(); window.setAccentColor('${color}');"
                        style="width: 36px; height: 36px; border-radius: 50%; background: ${color}; cursor: pointer; transition: all 0.2s ease; border: 3px solid ${color === state.accentColor ? 'white' : 'transparent'}; box-shadow: ${color === state.accentColor ? '0 0 0 2px ' + color : 'none'};"
                        onmouseover="this.style.transform='scale(1.15)';"
                        onmouseout="this.style.transform='scale(1)';"
                      ></div>
                    `).join('')}
                    <div 
                      onclick="event.stopPropagation(); window.showCustomColorPicker();"
                      style="width: 36px; height: 36px; border-radius: 50%; background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%); cursor: pointer; transition: all 0.2s ease; border: 3px solid ${!['#007AFF', '#3584E4', '#26A269', '#33D17A', '#F6D32D', '#E95420', '#E01B24', '#9141AC', '#613583', '#5E5C64'].includes(state.accentColor) ? 'white' : 'transparent'}; box-shadow: ${!['#007AFF', '#3584E4', '#26A269', '#33D17A', '#F6D32D', '#E95420', '#E01B24', '#9141AC', '#613583', '#5E5C64'].includes(state.accentColor) ? '0 0 0 2px ' + state.accentColor : 'none'}; position: relative;"
                      onmouseover="this.style.transform='scale(1.15)';"
                      onmouseout="this.style.transform='scale(1)';"
                      title="Custom Color"
                    >
                      <div style="position: absolute; inset: 4px; border-radius: 50%; background: ${state.accentColor}; display: ${!['#007AFF', '#3584E4', '#26A269', '#33D17A', '#F6D32D', '#E95420', '#E01B24', '#9141AC', '#613583', '#5E5C64'].includes(state.accentColor) ? 'block' : 'none'};"></div>
                      <div style="position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 18px; text-shadow: 0 1px 2px rgba(0,0,0,0.5);">+</div>
                    </div>
                  </div>
                </div>
                
                <h2 style="font-size: 20px; font-weight: 600; margin-bottom: 16px; color: hsl(var(--foreground));">Icon Pack</h2>
                <div style="background: hsl(var(--accent) / 0.4); border-radius: 16px; padding: 24px; margin-bottom: 32px;">
                  <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px;">
                    ${(() => {
                      const packs = [
                        { id: 'classic', name: 'Classic', desc: 'Original colorful icons', preview: ['#007AFF', '#34C759', '#FF3B30', '#FF9500'] },
                        { id: 'accent', name: 'Accent', desc: 'Icons match accent color', preview: [state.accentColor, state.accentColor, state.accentColor, state.accentColor] },
                        { id: 'monochrome', name: 'Monochrome', desc: 'Sleek dark icons', preview: ['#3a3a3e', '#3a3a3e', '#3a3a3e', '#3a3a3e'] },
                        { id: 'glass', name: 'Glass', desc: 'Frosted glass effect', preview: ['rgba(255,255,255,0.3)', 'rgba(255,255,255,0.25)', 'rgba(255,255,255,0.2)', 'rgba(255,255,255,0.15)'] }
                      ];
                      const currentPack = state.iconPack || 'classic';
                      return packs.map(pack => {
                        const isSelected = currentPack === pack.id;
                        const bgColor = isSelected ? 'hsl(var(--primary) / 0.2)' : 'hsl(var(--background) / 0.5)';
                        const borderColor = isSelected ? 'hsl(var(--primary))' : 'transparent';
                        const hoverBg = isSelected ? 'hsl(var(--primary) / 0.25)' : 'hsl(var(--background) / 0.7)';
                        const previewDivs = pack.preview.map((color, i) => {
                          const glassStyle = pack.id === 'glass' ? 'backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.3);' : '';
                          return '<div style="width: 28px; height: 28px; border-radius: 6px; background: ' + color + '; ' + glassStyle + '"></div>';
                        }).join('');
                        return '<div onclick="event.stopPropagation(); window.setIconPack(\'' + pack.id + '\');" style="background: ' + bgColor + '; border: 2px solid ' + borderColor + '; border-radius: 12px; padding: 16px; cursor: pointer; transition: all 0.2s ease;" onmouseover="this.style.background=\'' + hoverBg + '\';" onmouseout="this.style.background=\'' + bgColor + '\';"><div style="display: flex; gap: 6px; margin-bottom: 12px;">' + previewDivs + '</div><div style="font-size: 14px; font-weight: 600; color: hsl(var(--foreground)); margin-bottom: 4px;">' + pack.name + '</div><div style="font-size: 12px; color: hsl(var(--muted-foreground));">' + pack.desc + '</div></div>';
                      }).join('');
                    })()}
                  </div>
                </div>
                
                <h2 style="font-size: 20px; font-weight: 600; margin-bottom: 16px; color: hsl(var(--foreground)); display: flex; justify-content: space-between; align-items: center;">
                  <span>Window Effects</span>
                  <button 
                    onclick="event.stopPropagation(); window.resetWindowEffects()"
                    style="background: hsl(var(--accent)); border: none; color: hsl(var(--foreground)); font-size: 13px; font-weight: 500; cursor: pointer; padding: 6px 14px; border-radius: 6px; transition: all 0.2s ease;"
                    onmouseover="this.style.background='hsl(var(--accent) / 0.7)';"
                    onmouseout="this.style.background='hsl(var(--accent))';"
                  >Reset</button>
                </h2>
                <div style="background: hsl(var(--accent) / 0.4); border-radius: 16px; padding: 24px; margin-bottom: 32px;">
                  <div style="display: flex; flex-direction: column; gap: 24px;">
                    <!-- Window Transparency -->
                    <div style="display: flex; align-items: center; gap: 16px;">
                      <span style="font-size: 14px; font-weight: 500; color: hsl(var(--foreground)); min-width: 140px;">Transparency</span>
                      <div style="flex: 1; position: relative; height: 28px; display: flex; align-items: center;">
                        <div style="position: absolute; left: 0; right: 0; height: 4px; background: hsl(var(--foreground) / 0.15); border-radius: 2px;"></div>
                        <div class="slider-fill-transparency" style="position: absolute; left: 0; height: 4px; background: ${state.accentColor}; border-radius: 2px; width: ${(1 - state.windowOpacity) * 200}%;"></div>
                        <input type="range" min="0.5" max="1" step="0.05" value="${state.windowOpacity}"
                          oninput="event.stopPropagation(); 
                            var fill = this.parentElement.querySelector('.slider-fill-transparency');
                            var label = this.parentElement.parentElement.querySelector('span:last-child');
                            fill.style.width = ((1 - this.value) * 200) + '%';
                            label.textContent = Math.round((1 - this.value) * 100) + '%';
                            window.setWindowOpacity(this.value);"
                          style="position: absolute; left: 0; right: 0; width: 100%; height: 28px; -webkit-appearance: none; background: transparent; cursor: pointer; margin: 0; direction: rtl;"
                        />
                      </div>
                      <span style="font-size: 13px; color: hsl(var(--muted-foreground)); min-width: 45px; text-align: right;">${Math.round((1 - state.windowOpacity) * 100)}%</span>
                    </div>
                    
                    <!-- Background Blur -->
                    <div style="display: flex; align-items: center; gap: 16px;">
                      <span style="font-size: 14px; font-weight: 500; color: hsl(var(--foreground)); min-width: 140px;">Background Blur</span>
                      <div style="flex: 1; position: relative; height: 28px; display: flex; align-items: center;">
                        <div style="position: absolute; left: 0; right: 0; height: 4px; background: hsl(var(--foreground) / 0.15); border-radius: 2px;"></div>
                        <div class="slider-fill-blur" style="position: absolute; left: 0; height: 4px; background: ${state.accentColor}; border-radius: 2px; width: ${state.windowBlur * 5}%;"></div>
                        <input type="range" min="0" max="20" step="1" value="${state.windowBlur}"
                          oninput="event.stopPropagation();
                            var fill = this.parentElement.querySelector('.slider-fill-blur');
                            var label = this.parentElement.parentElement.querySelector('span:last-child');
                            fill.style.width = (this.value * 5) + '%';
                            label.textContent = this.value + 'px';
                            window.setWindowBlur(this.value);"
                          style="position: absolute; left: 0; right: 0; width: 100%; height: 28px; -webkit-appearance: none; background: transparent; cursor: pointer; margin: 0;"
                        />
                      </div>
                      <span style="font-size: 13px; color: hsl(var(--muted-foreground)); min-width: 45px; text-align: right;">${state.windowBlur}px</span>
                    </div>
                  </div>
                </div>
                
                
                <h2 style="font-size: 20px; font-weight: 600; margin-bottom: 8px; color: hsl(var(--foreground)); display: flex; justify-content: space-between; align-items: center;">
                  <span>Background</span>
                  ${state.customWallpapers.length < 50 ? `
                    <button 
                      onclick="event.stopPropagation(); window.showAddWallpaperDialog()"
                      style="background: none; border: none; color: hsl(var(--primary)); font-size: 14px; font-weight: 500; cursor: pointer; padding: 6px 12px; border-radius: 6px; transition: all 0.2s ease;"
                      onmouseover="this.style.background='hsl(var(--accent))';"
                      onmouseout="this.style.background='none';"
                    >+ Add Picture...</button>
                  ` : ''}
                </h2>
                <div style="background: hsl(var(--accent) / 0.4); border-radius: 16px; padding: 24px;">
                  <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px;">
                    ${state.customWallpapers.map((wallpaper, index) => {
                      const isActive = state.activeCustomWallpaper === index;
                      return `
                        <div 
                          class="wallpaper-thumbnail ${isActive ? 'active' : ''}"
                          style="position: relative; aspect-ratio: 16/10; border-radius: 12px; overflow: hidden; cursor: pointer; border: 3px solid ${isActive ? '#E95420' : 'transparent'}; transition: all 0.2s ease;"
                          onclick="event.stopPropagation(); window.setActiveWallpaper(${index})"
                        >
                          <div style="position: absolute; inset: 0; display: flex;">
                            <div style="width: 50%; height: 100%; position: relative; overflow: hidden;">
                              <img src="${wallpaper.light}" style="position: absolute; left: 0; top: 0; width: 200%; height: 100%; object-fit: cover;" />
                            </div>
                            <div style="width: 50%; height: 100%; position: relative; overflow: hidden;">
                              <img src="${wallpaper.dark}" style="position: absolute; left: -100%; top: 0; width: 200%; height: 100%; object-fit: cover;" />
                            </div>
                          </div>
                          ${isActive ? `
                            <div style="position: absolute; bottom: 6px; right: 6px; background: ${state.accentColor}; color: hsl(var(--primary-foreground)); padding: 4px 8px; border-radius: 6px; font-size: 16px; font-weight: 600; z-index: 1;"></div>
                          ` : ''}
                          <button 
                            class="wallpaper-delete-btn"
                            onclick="event.stopPropagation(); window.deleteWallpaperPair(${index})"
                            style="position: absolute; top: 6px; right: 6px; background: rgba(0,0,0,0.6); backdrop-filter: blur(4px); color: white; border: none; border-radius: 6px; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; cursor: pointer; opacity: 0; transition: opacity 0.2s; font-size: 14px; z-index: 1;"
                            onmouseover="this.style.opacity='1'; this.style.background='rgba(220,38,38,0.9)';"
                            onmouseout="this.style.opacity='0'; this.style.background='rgba(0,0,0,0.6)';"
                          ></button>
                        </div>
                      `;
                    }).join('')}
                    
                    
                    <!-- Tahoe wallpaper -->
                    <div 
                      class="wallpaper-thumbnail ${state.activeCustomWallpaper === -2 ? 'active' : ''}"
                      style="position: relative; aspect-ratio: 16/10; border-radius: 12px; overflow: hidden; cursor: pointer; border: 3px solid ${state.activeCustomWallpaper === -2 ? state.accentColor : 'transparent'}; transition: all 0.2s ease;"
                      onclick="event.stopPropagation(); window.setActiveWallpaper(-2)"
                    >
                      <div style="position: absolute; inset: 0; display: flex;">
                        <div style="width: 50%; height: 100%; position: relative; overflow: hidden;">
                          <img src="https://raw.githubusercontent.com/Matko802/my-web-os-things/refs/heads/main/26-Tahoe-Light-1080x1920.png" style="position: absolute; left: 0; top: 0; width: 200%; height: 100%; object-fit: cover;" />
                        </div>
                        <div style="width: 50%; height: 100%; position: relative; overflow: hidden;">
                          <img src="https://raw.githubusercontent.com/Matko802/my-web-os-things/refs/heads/main/26-Tahoe-Dark-1080x1920.png" style="position: absolute; left: -100%; top: 0; width: 200%; height: 100%; object-fit: cover;" />
                        </div>
                      </div>
                      ${state.activeCustomWallpaper === -2 ? `
                        <div style="position: absolute; bottom: 6px; right: 6px; background: ${state.accentColor}; color: hsl(var(--primary-foreground)); padding: 4px 8px; border-radius: 6px; font-size: 16px; font-weight: 600; z-index: 1;"></div>
                      ` : ''}
                    </div>
                  </div>
                  
                  ${state.customWallpapers.length > 0 ? `
                    <div style="margin-top: 16px; padding: 10px 12px; background: hsl(var(--background) / 0.3); border-radius: 8px; font-size: 12px; color: hsl(var(--muted-foreground));">
                       Custom wallpapers adapt to dark/light mode. Toggle styles to see both versions.
                    </div>
                  ` : ''}
                </div>
              </div>
              
              <style>
                .wallpaper-thumbnail:hover {
                  transform: translateY(-2px);
                }
                .wallpaper-thumbnail:hover .wallpaper-delete-btn {
                  opacity: 1 !important;
                }
              </style>
            `;
            
          case 'lockscreen':
            const lockscreenWallpaper = localStorage.getItem('mos_lockscreen_wallpaper');
            const useDesktopWp = state.lockscreenSettings?.useDesktopWallpaper !== false;
            const lockEnabled = state.lockscreenSettings?.lockscreenEnabled !== false;
            const showSecs = state.lockscreenSettings?.showSeconds || false;
            const hasPass = !!localStorage.getItem('mos_password_hash');
            const currentClockStyle = state.lockscreenSettings?.clockStyle || 'default';
            const currentClockFont = state.lockscreenSettings?.clockFont || 'Space Grotesk';
            
            const clockStyles = [
              { id: 'default', name: 'Default', desc: 'Clean and modern' },
              { id: 'minimal', name: 'Minimal', desc: 'Ultra-thin weight' },
              { id: 'bold', name: 'Bold', desc: 'Heavy and impactful' },
              { id: 'outlined', name: 'Outlined', desc: 'Stroke only' },
              { id: 'retro', name: 'Retro', desc: 'Monospace style' },
              { id: 'elegant', name: 'Elegant', desc: 'Serif italic' },
            ];
            
            const clockFonts = [
              'Space Grotesk',
              'JetBrains Mono',
              'Georgia',
              'Courier New',
              'Arial',
              'Helvetica',
              'Times New Roman',
              'Verdana',
            ];
            
            // Get preview font and style classes for the preview
            const previewFontFamily = currentClockFont + ', sans-serif';
            const previewStyle = currentClockStyle === 'minimal' ? 'font-weight: 100; letter-spacing: -5px;' :
                                 currentClockStyle === 'bold' ? 'font-weight: 700; letter-spacing: 0;' :
                                 currentClockStyle === 'outlined' ? 'color: transparent; -webkit-text-stroke: 2px white;' :
                                 currentClockStyle === 'retro' ? 'font-family: JetBrains Mono, Courier New, monospace; letter-spacing: 5px; font-weight: 400;' :
                                 currentClockStyle === 'elegant' ? 'font-family: Georgia, Times New Roman, serif; font-weight: 300; font-style: italic; letter-spacing: 2px;' :
                                 'font-weight: 200; letter-spacing: -3px;';
            
            return `
              <div class="settings-section" style="max-width: 700px; margin: 0 auto;">
                <h2 style="font-size: 28px; font-weight: 700; margin-bottom: 24px; color: hsl(var(--foreground));">Lock Screen</h2>
                
                <!-- Lock Screen Preview -->
                <div style="background: hsl(var(--accent) / 0.4); border-radius: 16px; padding: 24px; margin-bottom: 32px;">
                  <div style="position: relative; aspect-ratio: 16/9; border-radius: 12px; overflow: hidden; background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0f0f1a 100%); display: flex; flex-direction: column; align-items: center; justify-content: center;">
                    ${(lockscreenWallpaper || (useDesktopWp && state.customWallpaper)) ? `
                      <div style="position: absolute; inset: 0; background-image: url('${lockscreenWallpaper || state.customWallpaper}'); background-size: cover; background-position: center; filter: brightness(0.6);"></div>
                    ` : ''}
                    <div style="position: relative; z-index: 1; text-align: center;">
                      <div style="font-size: 48px; color: white; font-family: ${previewFontFamily}; text-shadow: 0 4px 40px rgba(0,0,0,0.7), 0 2px 10px rgba(0,0,0,0.5); ${previewStyle}">
                        ${new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false })}
                      </div>
                      <div style="font-size: 14px; color: rgba(255,255,255,0.7); margin-top: 4px; text-shadow: 0 2px 10px rgba(0,0,0,0.5);">
                        ${new Date().toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' })}
                      </div>
                    </div>
                    <div style="position: absolute; bottom: 16px; left: 50%; transform: translateX(-50); display: flex; flex-direction: column; align-items: center; gap: 4px; opacity: 0.5;">
                      <svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" style="width: 16px; height: 16px;">
                        <polyline points="18 15 12 9 6 15"></polyline>
                      </svg>
                      <span style="font-size: 10px; color: white;">Swipe up</span>
                    </div>
                  </div>
                  <div style="margin-top: 12px; text-align: center; font-size: 12px; color: hsl(var(--muted-foreground));">
                    Click the lock screen or swipe up to reveal unlock options
                  </div>
                </div>
                
                <!-- Lock Screen Settings -->
                <h3 style="font-size: 18px; font-weight: 600; margin-bottom: 16px; color: hsl(var(--foreground));">Settings</h3>
                <div style="background: hsl(var(--accent) / 0.4); border-radius: 16px; padding: 20px; margin-bottom: 32px;">
                  
                  <!-- Enable Lock Screen on Boot -->
                  <div class="settings-item" style="padding: 16px 0; border-bottom: 1px solid hsl(var(--window-border) / 0.5);">
                    <div>
                      <div class="settings-label">Show Lock Screen on Boot</div>
                      <div class="settings-description">Display lock screen after starting M OS</div>
                    </div>
                    <div class="toggle-switch ${lockEnabled ? 'active' : ''}" onclick="event.stopPropagation(); window.toggleLockscreenEnabled();">
                      <div class="toggle-switch-thumb"></div>
                    </div>
                  </div>
                  
                  <!-- Use Desktop Wallpaper -->
                  <div class="settings-item" style="padding: 16px 0; border-bottom: 1px solid hsl(var(--window-border) / 0.5);">
                    <div>
                      <div class="settings-label">Use Desktop Wallpaper</div>
                      <div class="settings-description">Use the same wallpaper as your desktop background</div>
                    </div>
                    <div class="toggle-switch ${useDesktopWp ? 'active' : ''}" onclick="event.stopPropagation(); window.toggleLockscreenUseDesktopWallpaper();">
                      <div class="toggle-switch-thumb"></div>
                    </div>
                  </div>
                  
                  <!-- Show Seconds -->
                  <div class="settings-item" style="padding: 16px 0;">
                    <div>
                      <div class="settings-label">Show Seconds in Clock</div>
                      <div class="settings-description">Display seconds in the lock screen time</div>
                    </div>
                    <div class="toggle-switch ${showSecs ? 'active' : ''}" onclick="event.stopPropagation(); window.toggleLockscreenShowSeconds();">
                      <div class="toggle-switch-thumb"></div>
                    </div>
                  </div>
                </div>
                
                <!-- Clock Style Settings -->
                <h3 style="font-size: 18px; font-weight: 600; margin-bottom: 16px; color: hsl(var(--foreground));">Clock Style</h3>
                <div style="background: hsl(var(--accent) / 0.4); border-radius: 16px; padding: 20px; margin-bottom: 32px;">
                  
                  <!-- Clock Style Grid -->
                  <div style="margin-bottom: 20px;">
                    <div class="settings-label" style="margin-bottom: 12px;">Style</div>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
                      ${clockStyles.map(style => `
                        <button
                          onclick="event.stopPropagation(); window.setLockscreenClockStyle('${style.id}')"
                          style="
                            padding: 12px 8px;
                            background: ${currentClockStyle === style.id ? 'hsl(var(--primary))' : 'hsl(var(--accent))'};
                            color: ${currentClockStyle === style.id ? 'hsl(var(--primary-foreground))' : 'hsl(var(--foreground))'};
                            border: 2px solid ${currentClockStyle === style.id ? 'hsl(var(--primary))' : 'hsl(var(--border))'};
                            border-radius: 10px;
                            cursor: pointer;
                            transition: all 0.2s ease;
                            text-align: center;
                          "
                          onmouseover="if('${currentClockStyle}' !== '${style.id}') this.style.borderColor='hsl(var(--primary) / 0.5)';"
                          onmouseout="if('${currentClockStyle}' !== '${style.id}') this.style.borderColor='hsl(var(--border))';"
                        >
                          <div style="font-size: 13px; font-weight: 600;">${style.name}</div>
                          <div style="font-size: 10px; opacity: 0.7; margin-top: 2px;">${style.desc}</div>
                        </button>
                      `).join('')}
                    </div>
                  </div>
                  
                  <!-- Clock Font Dropdown -->
                  <div class="settings-item" style="padding: 16px 0; border-top: 1px solid hsl(var(--window-border) / 0.5);">
                    <div>
                      <div class="settings-label">Font Family</div>
                      <div class="settings-description">Choose a font for the clock display</div>
                    </div>
                    <select 
                      onchange="event.stopPropagation(); window.setLockscreenClockFont(this.value)"
                      style="
                        padding: 8px 12px;
                        background: hsl(var(--accent));
                        color: hsl(var(--foreground));
                        border: 1px solid hsl(var(--border));
                        border-radius: 8px;
                        font-size: 13px;
                        cursor: pointer;
                        min-width: 150px;
                      "
                    >
                      ${clockFonts.map(font => `
                        <option value="${font}" ${currentClockFont === font ? 'selected' : ''} style="font-family: ${font}, sans-serif;">${font}</option>
                      `).join('')}
                    </select>
                  </div>
                </div>
                
                <h3 style="font-size: 18px; font-weight: 600; margin-bottom: 16px; color: hsl(var(--foreground)); display: flex; justify-content: space-between; align-items: center;">
                  <span>Custom Lock Screen Wallpaper</span>
                  ${lockscreenWallpaper ? `
                    <button 
                      onclick="event.stopPropagation(); window.clearLockscreenWallpaper()"
                      style="background: hsl(var(--destructive)); border: none; color: hsl(var(--destructive-foreground)); font-size: 12px; font-weight: 500; cursor: pointer; padding: 6px 12px; border-radius: 6px; transition: all 0.2s ease;"
                      onmouseover="this.style.opacity='0.9';"
                      onmouseout="this.style.opacity='1';"
                    >Remove</button>
                  ` : ''}
                </h3>
                <div style="background: hsl(var(--accent) / 0.4); border-radius: 16px; padding: 20px;">
                  ${lockscreenWallpaper ? `
                    <div style="aspect-ratio: 16/9; border-radius: 12px; overflow: hidden; margin-bottom: 16px; border: 2px solid hsl(var(--primary));">
                      <img src="${lockscreenWallpaper}" style="width: 100%; height: 100%; object-fit: cover;" />
                    </div>
                  ` : `
                    <div style="text-align: center; padding: 32px 20px; border: 2px dashed hsl(var(--border)); border-radius: 12px; margin-bottom: 16px;">
                      <div style="font-size: 14px; color: hsl(var(--muted-foreground)); margin-bottom: 8px;">
                        ${useDesktopWp ? 'Using desktop wallpaper' : 'No custom wallpaper set'}
                      </div>
                      <div style="font-size: 12px; color: hsl(var(--muted-foreground) / 0.7);">
                        Upload an image to use a different wallpaper on the lock screen
                      </div>
                    </div>
                  `}
                  <button 
                    onclick="event.stopPropagation(); window.uploadLockscreenWallpaper()"
                    class="wallpaper-upload-btn"
                    style="width: 100%;"
                  >
                    ${lockscreenWallpaper ? 'Change Wallpaper' : 'Upload Wallpaper'}
                  </button>
                </div>
                
                <!-- Password Section -->
                <h3 style="font-size: 18px; font-weight: 600; margin: 32px 0 16px; color: hsl(var(--foreground));">Security</h3>
                <div style="background: hsl(var(--accent) / 0.4); border-radius: 16px; padding: 20px;">
                  <div class="settings-item" style="padding: 16px 0;">
                    <div>
                      <div class="settings-label">Password Protection</div>
                      <div class="settings-description">${hasPass ? 'Password is set - lock screen requires password to unlock' : 'No password set - anyone can unlock'}</div>
                    </div>
                    <button 
                      onclick="event.stopPropagation(); window.showChangePasswordDialog()"
                      style="background: hsl(var(--primary)); border: none; color: hsl(var(--primary-foreground)); font-size: 13px; font-weight: 500; cursor: pointer; padding: 8px 16px; border-radius: 8px; transition: all 0.2s ease;"
                      onmouseover="this.style.opacity='0.9';"
                      onmouseout="this.style.opacity='1';"
                    >${hasPass ? 'Change Password' : 'Set Password'}</button>
                  </div>
                  ${hasPass ? `
                    <div style="border-top: 1px solid hsl(var(--window-border) / 0.5); padding-top: 16px; margin-top: 8px;">
                      <button 
                        onclick="event.stopPropagation(); window.removePassword()"
                        style="background: none; border: 1px solid hsl(var(--destructive)); color: hsl(var(--destructive)); font-size: 13px; font-weight: 500; cursor: pointer; padding: 8px 16px; border-radius: 8px; transition: all 0.2s ease;"
                        onmouseover="this.style.background='hsl(var(--destructive) / 0.1)';"
                        onmouseout="this.style.background='none';"
                      >Remove Password</button>
                    </div>
                  ` : ''}
                </div>
              </div>
            `;
            
          case 'control-centre':
            const currentToastPos = state.notificationToastPosition || 'top-center';
            const positions = [
              { value: 'top-left', label: 'Top Left' },
              { value: 'top-center', label: 'Top Center' },
              { value: 'top-right', label: 'Top Right' },
              { value: 'bottom-left', label: 'Bottom Left' },
              { value: 'bottom-center', label: 'Bottom Center' },
              { value: 'bottom-right', label: 'Bottom Right' }
            ];
            return `
              <div class="settings-section">
                <h2 style="font-size: 28px; font-weight: 700; margin-bottom: 24px; color: hsl(var(--foreground));">Control Centre</h2>
                
                <div class="settings-item">
                  <div>
                    <div class="settings-label">Quick Settings</div>
                    <div class="settings-description">Access frequently used settings from the menu bar</div>
                  </div>
                </div>
                
                <div style="margin-top: 24px; padding-top: 24px; border-top: 1px solid hsl(var(--window-border));">
                  <h3 style="font-size: 18px; font-weight: 600; margin-bottom: 16px; color: hsl(var(--foreground));">Notifications</h3>
                  
                  <div class="settings-item" style="flex-direction: column; align-items: flex-start; gap: 16px;">
                    <div>
                      <div class="settings-label">Toast Position</div>
                      <div class="settings-description">Choose where notification toasts appear on screen</div>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; width: 100%;">
                      ${positions.map(pos => `
                        <button 
                          onclick="event.stopPropagation(); window.updateNotificationToastPosition('${pos.value}'); this.closest('.settings-item').querySelectorAll('.toast-pos-btn').forEach(b => b.classList.remove('active')); this.classList.add('active');"
                          class="toast-pos-btn ${currentToastPos === pos.value ? 'active' : ''}"
                        >${pos.label}</button>
                      `).join('')}
                    </div>
                  </div>
                  
                  <div class="settings-item" style="margin-top: 16px;">
                    <div>
                      <div class="settings-label">Test Notification</div>
                      <div class="settings-description">Send a test notification toast</div>
                    </div>
                    <button 
                      onclick="event.stopPropagation(); window.addNotification('System', 'Test Notification', 'This is a test notification toast to preview the position.');"
                      style="padding: 8px 16px; background: hsl(var(--primary)); color: hsl(var(--primary-foreground)); border: none; border-radius: 8px; font-size: 13px; font-weight: 500; cursor: pointer; transition: all 0.2s ease;"
                      onmouseover="this.style.opacity='0.9';"
                      onmouseout="this.style.opacity='1';"
                    >Send Test</button>
                  </div>
                </div>
              </div>
            `;
            
          case 'desktop-dock':
            return `
              <div class="settings-section">
                <h2 style="font-size: 28px; font-weight: 700; margin-bottom: 24px; color: hsl(var(--foreground));">Desktop & Dock</h2>
                <div class="settings-item">
                  <div>
                    <div class="settings-label">Dock Position</div>
                    <div class="settings-description">Choose where the dock appears</div>
                  </div>
                  <select class="settings-select" onchange="event.stopPropagation(); window.handleDockPosition(this.value)" style="padding: 8px 12px; background: hsl(var(--accent)); border: 1px solid hsl(var(--border)); border-radius: 6px; color: hsl(var(--foreground)); font-size: 14px;">
                    <option value="bottom" ${state.dockPosition === 'bottom' ? 'selected' : ''}>Bottom</option>
                    <option value="left" ${state.dockPosition === 'left' ? 'selected' : ''}>Left</option>
                    <option value="right" ${state.dockPosition === 'right' ? 'selected' : ''}>Right</option>
                  </select>
                </div>
                <div class="settings-item">
                  <div>
                    <div class="settings-label">Mirror Window Controls</div>
                    <div class="settings-description">Place window buttons on right, fullscreen button on left</div>
                  </div>
                  <div class="toggle-switch ${state.mirroredControls ? 'active' : ''}" onclick="event.stopPropagation(); window.toggleMirroredControls()">
                    <div class="toggle-switch-thumb"></div>
                  </div>
                </div>
              </div>
            `;
            
          case 'wallpaper':
            return `
              <div class="settings-section">
                <h2 style="font-size: 24px; font-weight: 600; margin-bottom: 20px; color: hsl(var(--foreground));">Background</h2>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 12px; margin-bottom: 24px;">
                  ${state.customWallpapers.map((wallpaper, index) => {
                    const isActive = state.activeCustomWallpaper === index;
                    return `
                      <div 
                        class="wallpaper-thumbnail ${isActive ? 'active' : ''}"
                        style="position: relative; aspect-ratio: 16/10; border-radius: 12px; overflow: hidden; cursor: pointer; border: 3px solid ${isActive ? 'hsl(var(--primary))' : 'transparent'}; transition: all 0.2s ease;"
                        onclick="event.stopPropagation(); window.setActiveWallpaper(${index})"
                      >
                        <div style="position: absolute; inset: 0; display: flex;">
                          <div style="width: 50%; height: 100%; position: relative; overflow: hidden;">
                            <img src="${wallpaper.light}" style="position: absolute; left: 0; top: 0; width: 200%; height: 100%; object-fit: cover;" />
                          </div>
                          <div style="width: 50%; height: 100%; position: relative; overflow: hidden;">
                            <img src="${wallpaper.dark}" style="position: absolute; left: -100%; top: 0; width: 200%; height: 100%; object-fit: cover;" />
                          </div>
                        </div>
                        ${isActive ? `
                          <div style="position: absolute; bottom: 6px; left: 6px; background: hsl(var(--primary)); color: hsl(var(--primary-foreground)); padding: 3px 8px; border-radius: 6px; font-size: 11px; font-weight: 500; z-index: 1;">
                            
                          </div>
                        ` : ''}
                        <button 
                          class="wallpaper-delete-btn"
                          onclick="event.stopPropagation(); window.deleteWallpaperPair(${index})"
                          style="position: absolute; top: 6px; right: 6px; background: rgba(0,0,0,0.6); backdrop-filter: blur(4px); color: white; border: none; border-radius: 6px; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; cursor: pointer; opacity: 0; transition: opacity 0.2s; font-size: 14px; z-index: 1;"
                          onmouseover="this.style.opacity='1'; this.style.background='rgba(220,38,38,0.9)';"
                          onmouseout="this.style.opacity='0'; this.style.background='rgba(0,0,0,0.6)';"
                        ></button>
                      </div>
                    `;
                  }).join('')}
                  
                  <!-- Tahoe wallpaper -->
                  <div style="display: flex; flex-direction: column; gap: 6px;">
                    <div 
                      class="wallpaper-thumbnail ${state.activeCustomWallpaper === -2 ? 'active' : ''}"
                      style="position: relative; aspect-ratio: 16/10; border-radius: 12px; overflow: hidden; cursor: pointer; border: 3px solid ${state.activeCustomWallpaper === -2 ? 'hsl(var(--primary))' : 'transparent'}; transition: all 0.2s ease;"
                      onclick="event.stopPropagation(); window.setActiveWallpaper(-2)"
                    >
                      <div style="position: absolute; inset: 0; display: flex;">
                        <div style="width: 50%; height: 100%; position: relative; overflow: hidden;">
                          <img src="https://raw.githubusercontent.com/Matko802/my-web-os-things/refs/heads/main/26-Tahoe-Light-1080x1920.png" style="position: absolute; left: 0; top: 0; width: 200%; height: 100%; object-fit: cover;" />
                        </div>
                        <div style="width: 50%; height: 100%; position: relative; overflow: hidden;">
                          <img src="https://raw.githubusercontent.com/Matko802/my-web-os-things/refs/heads/main/26-Tahoe-Dark-1080x1920.png" style="position: absolute; left: -100%; top: 0; width: 200%; height: 100%; object-fit: cover;" />
                        </div>
                      </div>
                      ${state.activeCustomWallpaper === -2 ? `
                        <div style="position: absolute; bottom: 6px; left: 6px; background: hsl(var(--primary)); color: hsl(var(--primary-foreground)); padding: 3px 8px; border-radius: 6px; font-size: 11px; font-weight: 500; z-index: 1;">
                          
                        </div>
                      ` : ''}
                    </div>
                    <div style="text-align: center; font-size: 11px; color: hsl(var(--muted-foreground)); font-weight: 500;">Tahoe</div>
                  </div>
                  
                  <div style="display: flex; flex-direction: column; gap: 6px;">
                    <div 
                      class="wallpaper-thumbnail ${state.activeCustomWallpaper === -3 ? 'active' : ''}"
                      style="position: relative; aspect-ratio: 16/10; border-radius: 12px; overflow: hidden; cursor: pointer; border: 3px solid ${state.activeCustomWallpaper === -3 ? 'hsl(var(--primary))' : 'transparent'}; transition: all 0.2s ease;"
                      onclick="event.stopPropagation(); window.setActiveWallpaper(-3)"
                    >
                      <div style="position: absolute; inset: 0; display: flex;">
                        <div style="width: 50%; height: 100%; position: relative; overflow: hidden;">
                          <img src="https://512pixels.net/downloads/macos-wallpapers-thumbs/14-0-Sonoma-L.jpg" style="position: absolute; left: 0; top: 0; width: 200%; height: 100%; object-fit: cover;" />
                        </div>
                        <div style="width: 50%; height: 100%; position: relative; overflow: hidden;">
                          <img src="https://512pixels.net/downloads/macos-wallpapers-thumbs/14-0-Sonoma-D.jpg" style="position: absolute; left: -100%; top: 0; width: 200%; height: 100%; object-fit: cover;" />
                        </div>
                      </div>
                      ${state.activeCustomWallpaper === -3 ? `
                        <div style="position: absolute; bottom: 6px; left: 6px; background: hsl(var(--primary)); color: hsl(var(--primary-foreground)); padding: 3px 8px; border-radius: 6px; font-size: 11px; font-weight: 500; z-index: 1;">
                          
                        </div>
                      ` : ''}
                    </div>
                    <div style="text-align: center; font-size: 11px; color: hsl(var(--muted-foreground)); font-weight: 500;">Sonoma</div>
                  </div>
                  
                  ${state.customWallpapers.length < 50 ? `
                    <div 
                      class="wallpaper-add-btn"
                      style="aspect-ratio: 16/10; border-radius: 12px; border: 2px dashed hsl(var(--border)); display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s ease; background: hsl(var(--accent) / 0.3);"
                      onclick="event.stopPropagation(); window.showAddWallpaperDialog()"
                      onmouseover="this.style.background='hsl(var(--accent) / 0.5)'; this.style.borderColor='hsl(var(--primary))';"
                      onmouseout="this.style.background='hsl(var(--accent) / 0.3)'; this.style.borderColor='hsl(var(--border))';"
                    >
                      <div style="font-size: 24px; margin-bottom: 4px; color: hsl(var(--muted-foreground));">+</div>
                      <div style="font-size: 11px; color: hsl(var(--muted-foreground)); font-weight: 500;">Add Picture...</div>
                    </div>
                  ` : ''}
                </div>
                
                ${state.customWallpapers.length > 0 ? `
                  <div style="margin-top: 16px; padding: 10px 12px; background: hsl(var(--accent) / 0.5); border-radius: 8px; font-size: 12px; color: hsl(var(--muted-foreground));">
                     Custom wallpapers adapt to dark/light mode. Toggle in Appearance to see both versions.
                  </div>
                ` : ''}
              </div>
              
              <style>
                .wallpaper-thumbnail:hover {
                  transform: translateY(-2px);
                }
                .wallpaper-thumbnail:hover .wallpaper-delete-btn {
                  opacity: 1 !important;
                }
              </style>
            `;
            
          case 'notifications':
            return `
              <div class="settings-section">
                <h2 style="font-size: 28px; font-weight: 700; margin-bottom: 24px; color: hsl(var(--foreground));">Notifications</h2>
                <div class="settings-item">
                  <div>
                    <div class="settings-label">Notification Centre</div>
                    <div class="settings-description">Shows your notifications in the top-right corner</div>
                  </div>
                </div>
              </div>
            `;
            
          case 'sound':
            const soundsInstalled = localStorage.getItem('lineageSoundsInstalled') === 'true';
            const soundsEnabled = state.soundEnabled;
            const totalSounds = SOUND_CONFIG.files.length;
            const installedSounds = SOUND_CONFIG.files.filter(f => localStorage.getItem(`sound_${f}`)).length;
            
            return `
              <div class="settings-section">
                <h2 style="font-size: 28px; font-weight: 700; margin-bottom: 24px; color: hsl(var(--foreground));">Sound</h2>
                <div class="settings-item">
                  <div>
                    <div class="settings-label">Sound Effects</div>
                    <div class="settings-description">Play system sounds</div>
                  </div>
                  <div class="toggle-switch ${soundsEnabled ? 'active' : ''}" onclick="event.stopPropagation(); window.toggleSound()">
                    <div class="toggle-switch-thumb"></div>
                  </div>
                </div>
                
                <!-- Lineage OS Sound Theme -->
                <div class="settings-item" style="flex-direction: column; align-items: flex-start; margin-top: 20px;">
                  <div style="width: 100%;">
                    <div class="settings-label" style="font-size: 16px; font-weight: 600;">Lineage OS Sound Theme</div>
                    <div class="settings-description">High-quality system sounds cached locally for offline use</div>
                    
                    ${soundsInstalled ? `
                      <div style="margin-top: 12px; padding: 12px; background: hsl(175 80% 45% / 0.15); border: 1px solid hsl(175 80% 45% / 0.3); border-radius: 10px;">
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                          <span style="font-size: 18px;"></span>
                          <span style="font-weight: 600; color: hsl(175 80% 45%);">Sound Pack Installed</span>
                        </div>
                        <div style="font-size: 12px; color: hsl(var(--muted-foreground));">
                          ${installedSounds}/${totalSounds} sounds cached in localStorage
                        </div>
                        <div style="display: flex; gap: 8px; margin-top: 12px; flex-wrap: wrap;">
                          <button onclick="event.stopPropagation(); window.testSound()" style="padding: 8px 14px; background: hsl(var(--primary)); color: hsl(var(--primary-foreground)); border: none; border-radius: 6px; font-size: 12px; cursor: pointer; font-family: inherit;">
                             Test Sound
                          </button>
                          <button onclick="event.stopPropagation(); window.reinstallSoundsUI()" style="padding: 8px 14px; background: hsl(var(--accent)); color: hsl(var(--foreground)); border: none; border-radius: 6px; font-size: 12px; cursor: pointer; font-family: inherit;">
                             Reinstall
                          </button>
                          <button onclick="event.stopPropagation(); window.clearSoundsUI()" style="padding: 8px 14px; background: transparent; color: hsl(var(--muted-foreground)); border: 1px solid hsl(var(--border)); border-radius: 6px; font-size: 12px; cursor: pointer; font-family: inherit;">
                             Remove
                          </button>
                        </div>
                      </div>
                    ` : `
                      <div style="margin-top: 12px; padding: 12px; background: hsl(var(--accent) / 0.5); border: 1px solid hsl(var(--border)); border-radius: 10px;">
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                          <span style="font-size: 18px;"></span>
                          <span style="font-weight: 500;">Lineage OS Sounds</span>
                        </div>
                        <div style="font-size: 12px; color: hsl(var(--muted-foreground)); margin-bottom: 12px;">
                          Download premium sound effects from Lineage OS for a richer experience. Sounds will be cached locally.
                        </div>
                        <button onclick="event.stopPropagation(); window.installSoundsUI()" style="padding: 10px 16px; background: hsl(var(--primary)); color: hsl(var(--primary-foreground)); border: none; border-radius: 8px; font-size: 13px; cursor: pointer; font-family: inherit; font-weight: 500;">
                           Download Sound Pack
                        </button>
                      </div>
                    `}
                  </div>
                </div>
                
                <!-- Sound Preview -->
                <div class="settings-item" style="flex-direction: column; align-items: flex-start; margin-top: 20px; padding-top: 20px; border-top: 1px solid hsl(var(--border));">
                  <div style="width: 100%;">
                    <div class="settings-label" style="font-size: 14px; font-weight: 500; margin-bottom: 12px;">Test Individual Sounds</div>
                    <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                      ${['click', 'open', 'close', 'minimize', 'notification', 'lock', 'unlock', 'trash'].map(sound => `
                        <button onclick="event.stopPropagation(); window.playSound('${sound}')" style="padding: 6px 12px; background: hsl(var(--accent)); color: hsl(var(--foreground)); border: 1px solid hsl(var(--border)); border-radius: 6px; font-size: 11px; cursor: pointer; font-family: inherit; text-transform: capitalize;">
                          ${sound}
                        </button>
                      `).join('')}
                    </div>
                  </div>
                </div>
              </div>
            `;
            
          case 'mouse':
            const cursorsInstalled = localStorage.getItem('customCursorsInstalled') === 'true';
            const cursorsEnabled = localStorage.getItem('customCursorsEnabled') === 'true';
            const cursorCount = CURSOR_CONFIG.files.length;
            const installedCount = CURSOR_CONFIG.files.filter(f => localStorage.getItem(`cursor_${f}`)).length;
            
            return `
              <div class="settings-section">
                <h2 style="font-size: 28px; font-weight: 700; margin-bottom: 24px; color: hsl(var(--foreground));">Mouse & Cursor</h2>
                
                <!-- M OS Cursor Theme -->
                <div class="settings-item" style="flex-direction: column; align-items: flex-start; margin-bottom: 20px;">
                  <div style="width: 100%;">
                    <div class="settings-label" style="font-size: 16px; font-weight: 600;">M OS Cursor Theme</div>
                    <div class="settings-description">Custom animated cursors - toggle will download if not installed</div>
                    
                    <div style="margin-top: 12px; padding: 12px; background: hsl(var(--accent) / 0.5); border-radius: 8px;">
                      <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                        <span style="font-size: 13px; color: hsl(var(--foreground));" id="cursor-status-text">
                          ${cursorsEnabled 
                            ? (cursorsInstalled ? ` ${installedCount}/${cursorCount} cursors active` : ' Installing...')
                            : (cursorsInstalled ? ' Custom cursors disabled (using default)' : ' Using default cursor')}
                        </span>
                        <div class="toggle-switch ${cursorsEnabled ? 'active' : ''}" id="cursor-toggle" onclick="event.stopPropagation(); window.toggleCustomCursorsUI(this);">
                          <div class="toggle-switch-thumb"></div>
                        </div>
                      </div>
                      
                      ${cursorsInstalled ? `
                        <div style="display: flex; gap: 8px; margin-top: 10px;">
                          <button class="wallpaper-reset-btn" onclick="event.stopPropagation(); window.reinstallCursorsUI();" style="font-size: 12px;">
                             Reinstall
                          </button>
                          <button class="wallpaper-reset-btn" onclick="event.stopPropagation(); window.clearCursorsUI();" style="font-size: 12px;">
                             Remove
                          </button>
                        </div>
                      ` : ''}
                      
                      ${cursorsInstalled && cursorsEnabled ? `
                        <div style="margin-top: 12px; display: flex; flex-wrap: wrap; gap: 8px;">
                          ${CURSOR_CONFIG.files.map(f => {
                            const previewUrl = getCursorPreviewUrl(f);
                            const isAnimated = f.endsWith('.ani');
                            return previewUrl ? `<div style="width: 36px; height: 36px; background: hsl(var(--background)); border-radius: 6px; display: flex; align-items: center; justify-content: center; border: 1px solid hsl(var(--border)); position: relative;" title="${f.replace(/\.(cur|ani)$/, '')}${isAnimated ? ' (animated)' : ''}">
                              <img src="${previewUrl}" style="width: 28px; height: 28px; object-fit: contain; image-rendering: auto; image-rendering: smooth;" onerror="this.style.display='none'; this.parentElement.innerHTML='?';" />
                              ${isAnimated ? '<div style="position: absolute; bottom: 1px; right: 1px; width: 8px; height: 8px; background: hsl(var(--primary)); border-radius: 50%; font-size: 5px; display: flex; align-items: center; justify-content: center; color: hsl(var(--primary-foreground));"></div>' : ''}
                            </div>` : '';
                          }).join('')}
                        </div>
                      ` : ''}
                    </div>
                  </div>
                </div>
                
              </div>
            `;
            
          case 'system':
            const currentVersion = getInstalledVersion();
            
            return `
              <div class="settings-section">
                <h2 style="font-size: 28px; font-weight: 700; margin-bottom: 24px; color: hsl(var(--foreground));">System</h2>
                <div class="settings-item">
                  <div>
                    <div class="settings-label">Animations</div>
                    <div class="settings-description">Enable smooth window animations</div>
                  </div>
                  <div class="toggle-switch ${state.animationsEnabled ? 'active' : ''}" onclick="event.stopPropagation(); window.toggleAnimations()">
                    <div class="toggle-switch-thumb"></div>
                  </div>
                </div>
                <div class="settings-item">
                  <div>
                    <div class="settings-label">MOS Version</div>
                    <div class="settings-description">${currentVersion}</div>
                  </div>
                </div>
              </div>
              
              <div class="settings-section">
                <h2 style="font-size: 28px; font-weight: 700; margin-bottom: 24px; color: hsl(var(--foreground));">Version Management</h2>
                <div class="settings-item">
                  <div>
                    <div class="settings-label">Current Version</div>
                    <div class="settings-description">${currentVersion}</div>
                  </div>
                </div>
                <div class="settings-item" style="flex-direction: column; align-items: flex-start;">
                  <div style="width: 100%;">
                    <div class="settings-label">Change Version</div>
                    <div class="settings-description">Download a different version of M OS from GitHub. After downloading, replace your os.html file and refresh.</div>
                    <button 
                      class="wallpaper-upload-btn" 
                      onclick="event.stopPropagation(); window.openVersionManager()"
                      style="margin-top: 12px;"
                    >
                      Change Version
                    </button>
                  </div>
                </div>
              </div>
              
              <div class="settings-section">
                <h2 style="font-size: 28px; font-weight: 700; margin-bottom: 24px; color: hsl(var(--foreground));">Data Management</h2>
                <div class="settings-item" style="flex-direction: column; align-items: flex-start;">
                  <div style="width: 100%;">
                    <div class="settings-label">Reset All Data</div>
                    <div class="settings-description">Clear all saved data including window states, settings, history, and custom wallpapers. This action cannot be undone.</div>
                    <button class="wallpaper-reset-btn destructive" onclick="event.stopPropagation(); window.clearAllData()" style="margin-top: 12px;">
                       Clear All Data
                    </button>
                  </div>
                </div>
              </div>
            `;
            
          default:
            return `
              <div class="settings-section">
                <h2 style="font-size: 28px; font-weight: 700; margin-bottom: 24px; color: hsl(var(--foreground));">Settings</h2>
                <p>Select a category from the sidebar</p>
              </div>
            `;
        }
      }

      window.createWindow = function createWindow(appId, appName) {
        playSound('open');
        
        // Load saved window size from localStorage
        const savedSizes = JSON.parse(localStorage.getItem('windowSizes') || '{}');
        const savedSize = savedSizes[appId] || { width: 600, height: 400 };
        
        // Load saved window state from localStorage (position, maximize, snap, etc.)
        const savedWindowState = state.windowStates[appId];
        console.log('Loading window state for', appId, ':', savedWindowState);
        const savedMaximizeState = savedWindowState && typeof savedWindowState === 'object' ? savedWindowState.isMaximized : savedWindowState || false;
        console.log('Resolved maximized state for', appId, ':', savedMaximizeState);
        
        const win = {
          id: state.nextId++,
          appId,
          title: appName,
          x: (savedWindowState && savedWindowState.x !== undefined) ? savedWindowState.x : 100 + ((state.nextId * 30) % 200),
          y: (savedWindowState && savedWindowState.y !== undefined) ? savedWindowState.y : 100 + ((state.nextId * 30) % 200),
          width: (savedWindowState && savedWindowState.width !== undefined) ? savedWindowState.width : savedSize.width,
          height: (savedWindowState && savedWindowState.height !== undefined) ? savedWindowState.height : savedSize.height,
          zIndex: state.nextZIndex++,
          isMinimized: false,
          isMaximized: savedMaximizeState,
          isFullscreen: false,
          isOpening: true, // Flag to trigger opening animation
          isSnapped: (savedWindowState && savedWindowState.isSnapped) || false,
          snapRestorePos: (savedWindowState && savedWindowState.snapRestorePos) || null,
        };
        // Initialize terminal history for this window if it's a terminal
        if (appId === 'terminal') {
          state.terminalHistory[win.id] = [
            `<div style="margin-top: 10px;">Type 'help' for available commands</div>`
          ];
        }
        // Initialize input values for this window
        if (appId === 'browser') {
          state.inputValues[win.id] = '';
        }
        // Start Task Manager refresh interval
        if (appId === 'taskmanager') {
          window.startTaskManagerRefresh(win.id);
        }
        // Start background process for this app
        window.startBackgroundProcess(appId, {
          windowId: win.id,
          windowTitle: appName,
          startedAt: Date.now()
        });
        state.windows.push(win);
        state.activeWindowId = win.id; // Set new window as active
        render();
        
        // Trigger opening animation after render
        requestAnimationFrame(() => {
          const windowEl = document.getElementById(`window-${win.id}`);
          if (windowEl && !win.isMaximized) {
            // Enable hardware acceleration
            windowEl.style.willChange = 'transform, opacity';
            
            // Set initial state (small and semi-transparent)
            windowEl.style.transform = 'scale3d(0.9, 0.9, 1)';
            windowEl.style.opacity = '0';
            windowEl.style.transition = 'none';
            
            // Force layout recalculation
            void windowEl.offsetHeight;
            
            // Animate to final state
            windowEl.style.transition = 'all 0.25s cubic-bezier(0.16, 1, 0.3, 1)';
            windowEl.style.transform = 'scale3d(1, 1, 1)';
            windowEl.style.opacity = '1';
            
            setTimeout(() => {
              windowEl.style.transition = '';
              windowEl.style.transform = '';
              windowEl.style.willChange = 'auto';
              win.isOpening = false;
            }, 250);
          } else if (windowEl && win.isMaximized) {
            // For maximized windows, fade in from center
            windowEl.style.willChange = 'transform, opacity';
            windowEl.style.transform = 'scale3d(0.95, 0.95, 1)';
            windowEl.style.opacity = '0';
            windowEl.style.transition = 'none';
            
            void windowEl.offsetHeight;
            
            windowEl.style.transition = 'all 0.25s cubic-bezier(0.16, 1, 0.3, 1)';
            windowEl.style.transform = 'scale3d(1, 1, 1)';
            windowEl.style.opacity = '1';
            
            setTimeout(() => {
              windowEl.style.transition = '';
              windowEl.style.transform = '';
              windowEl.style.willChange = 'auto';
              win.isOpening = false;
            }, 250);
          }
        });
      };

      window.closeWindow = function closeWindow(id) {
        playSound('close');
        
        // Stop Task Manager refresh if this is a task manager window
        const win = state.windows.find((w) => w.id === id);
        if (win && win.appId === 'taskmanager') {
          window.stopTaskManagerRefresh();
        }
        
        const windowEl = document.getElementById(`window-${id}`);
        
        if (windowEl) {
          // Enable hardware acceleration
          windowEl.style.willChange = 'transform, opacity';
          windowEl.style.pointerEvents = 'none'; // Prevent interaction during close
          
          // Animate to small and transparent
          windowEl.style.transition = 'all 0.2s cubic-bezier(0.16, 1, 0.3, 1)';
          windowEl.style.transform = 'scale3d(0.9, 0.9, 1)';
          windowEl.style.opacity = '0';
          
          setTimeout(() => {
            // Save terminal history to localStorage before closing
            if (state.terminalHistory[id]) {
              localStorage.setItem('terminalHistory', JSON.stringify(state.terminalHistory));
            }
            
            const closedWin = state.windows.find((w) => w.id === id);
            const appId = closedWin ? closedWin.appId : null;
            
            state.windows = state.windows.filter((w) => w.id !== id);
            // Clean up terminal history and input values
            delete state.terminalHistory[id];
            delete state.inputValues[id];
            
            // Stop background process if no more windows for this app
            if (appId && !state.windows.some(w => w.appId === appId)) {
              window.stopBackgroundProcess(appId);
            }
            
            // Dispatch windowClosed event for cleanup handlers
            window.dispatchEvent(new CustomEvent('windowClosed', { detail: { id } }));
            
            render();
          }, 200);
        } else {
          // Fallback if window element not found
          if (state.terminalHistory[id]) {
            localStorage.setItem('terminalHistory', JSON.stringify(state.terminalHistory));
          }
          
          const closedWin = state.windows.find((w) => w.id === id);
          const appId = closedWin ? closedWin.appId : null;
          
          state.windows = state.windows.filter((w) => w.id !== id);
          delete state.terminalHistory[id];
          delete state.inputValues[id];
          
          // Stop background process if no more windows for this app
          if (appId && !state.windows.some(w => w.appId === appId)) {
            window.stopBackgroundProcess(appId);
          }
          
          // Dispatch windowClosed event for cleanup handlers
          window.dispatchEvent(new CustomEvent('windowClosed', { detail: { id } }));
          
          render();
        }
      };

      window.minimizeWindow = function minimizeWindow(id) {
        playSound('minimize');
        const win = state.windows.find((w) => w.id === id);
        if (!win) return;
        
        // Prevent double minimize
        if (win.isMinimizing) return;
        win.isMinimizing = true;

        // Stop Task Manager refresh when minimizing
        if (win.appId === 'taskmanager') {
          window.stopTaskManagerRefresh();
        }

        const windowEl = document.getElementById(`window-${id}`);
        const dockIcon = document.getElementById(`dock-${win.appId}`);

        if (windowEl && dockIcon) {
          // Enable hardware acceleration and prevent pointer events during animation
          windowEl.style.willChange = 'transform, opacity';
          windowEl.style.pointerEvents = 'none';
          
          const windowRect = windowEl.getBoundingClientRect();
          const dockRect = dockIcon.getBoundingClientRect();

          const scaleX = 56 / windowRect.width;
          const scaleY = 56 / windowRect.height;
          const translateX = dockRect.left + 28 - windowRect.left - windowRect.width / 2;
          const translateY = dockRect.top + 28 - windowRect.top - windowRect.height / 2;

          // Use requestAnimationFrame for smoother animation start
          requestAnimationFrame(() => {
            windowEl.style.transition = 'transform 0.3s cubic-bezier(0.16, 1, 0.3, 1), opacity 0.25s ease-out';
            windowEl.style.transform = `translate3d(${translateX}px, ${translateY}px, 0) scale3d(${scaleX}, ${scaleY}, 1)`;
            windowEl.style.opacity = '0';
          });

          setTimeout(() => {
            win.isMinimized = true;
            win.isMinimizing = false;
            windowEl.style.willChange = 'auto';
            windowEl.style.pointerEvents = '';
            // Hide the element immediately to prevent flash
            windowEl.style.display = 'none';
            // Use updateDockOnly instead of full render when possible
            renderDockOnly();
            // Schedule full render after dock update
            requestAnimationFrame(() => render());
          }, 300);
        } else {
          win.isMinimized = true;
          win.isMinimizing = false;
          render();
        }
      };

      window.restoreWindow = function restoreWindow(appId) {
        const win = state.windows.find((w) => w.appId === appId && w.isMinimized);
        if (!win) {
          const app = apps.find((a) => a.id === appId);
          if (app) createWindow(app.id, app.name);
          return;
        }
        
        playSound('open');
        
        // Restart Task Manager refresh if restoring task manager
        if (appId === 'taskmanager') {
          window.startTaskManagerRefresh(win.id);
        }
        
        const dockIcon = document.getElementById(`dock-${appId}`);
        if (!dockIcon) {
          win.isMinimized = false;
          win.zIndex = state.nextZIndex++;
          state.activeWindowId = win.id; // Set as active
          render();
          return;
        }
        
        // Store dock position before changing state
        const dockRect = dockIcon.getBoundingClientRect();
        
        win.isMinimized = false;
        win.zIndex = state.nextZIndex++;
        state.activeWindowId = win.id; // Set as active
        
        // Add a flag to indicate we're animating
        win.isRestoring = true;
        render();

        requestAnimationFrame(() => {
          const windowEl = document.getElementById(`window-${win.id}`);
          
          if (windowEl) {
            // Enable hardware acceleration
            windowEl.style.willChange = 'transform, opacity';
            
            const finalRect = windowEl.getBoundingClientRect();
            
            const scaleX = 56 / finalRect.width;
            const scaleY = 56 / finalRect.height;
            const translateX = dockRect.left + 28 - finalRect.left - finalRect.width / 2;
            const translateY = dockRect.top + 28 - finalRect.top - finalRect.height / 2;
            
            // Set initial state at dock position with 3D transforms
            windowEl.style.transform = `translate3d(${translateX}px, ${translateY}px, 0) scale3d(${scaleX}, ${scaleY}, 1)`;
            windowEl.style.opacity = '0';
            
            // Force layout recalculation
            void windowEl.offsetHeight;
            
            // Start animation to final position
            windowEl.style.transition = 'all 0.3s cubic-bezier(0.16, 1, 0.3, 1)';
            windowEl.style.transform = 'translate3d(0, 0, 0) scale3d(1, 1, 1)';
            windowEl.style.opacity = '1';
            
            setTimeout(() => {
              windowEl.style.transition = '';
              windowEl.style.transform = '';
              windowEl.style.willChange = 'auto';
              win.isRestoring = false;
            }, 300);
          } else {
            win.isRestoring = false;
          }
        });
      };

      window.toggleWindow = function toggleWindow(appId) {
        // Special handling for app launcher (finder)
        if (appId === 'finder') {
          state.showLaunchpad = !state.showLaunchpad;
          state.launchpadSearch = '';
          render();
          if (state.showLaunchpad) {
            // Focus search input after render
            setTimeout(() => {
              const searchInput = document.getElementById('launchpad-search');
              if (searchInput) searchInput.focus();
            }, 50);
          }
          return;
        }
        
        // Check for open (not minimized) windows
        const openWindow = state.windows.find((w) => w.appId === appId && !w.isMinimized);
        
        if (openWindow) {
          // Check if this window is already the focused window (highest z-index)
          const maxZIndex = Math.max(...state.windows.map(w => w.zIndex || 0));
          const isAlreadyFocused = openWindow.zIndex === maxZIndex;
          
          if (isAlreadyFocused) {
            // If already focused, minimize it
            minimizeWindow(openWindow.id);
          } else {
            // If not focused, just bring it to front
            focusWindow(openWindow.id);
          }
        } else {
          // Otherwise restore or create new window
          restoreWindow(appId);
        }
      };

      window.handleDockClick = function handleDockClick(e, appId) {
        // Only handle left click for toggle
        if (e.button === 0) {
          e.preventDefault();
          e.stopPropagation();
          // Close panels when clicking dock icons
          closePanelsInstantly();
          toggleWindow(appId);
        }
      };

      window.handleDockMouseDown = function handleDockMouseDown(e, appId) {
        // Store click start position to detect drag vs click
        if (e.button === 0) {
          e._clickStartX = e.clientX;
          e._clickStartY = e.clientY;
          e._clickStartTime = Date.now();
          return;
        }
        
        // Middle click (button 1) opens new window
        if (e.button === 1) {
          e.preventDefault();
          const app = apps.find((a) => a.id === appId);
          if (app) {
            createWindow(app.id, app.name);
          }
        }
      };
      
      window.initDockDrag = function initDockDrag(e, appId) {
        // Only handle left click for drag reordering
        if (e.button !== 0) return;
        
        // Don't start drag on right click (for context menu)
        if (e.button === 2) return;
        
        const dockIcon = e.currentTarget;
        const rect = dockIcon.getBoundingClientRect();
        
        // Check if this is a pinned app
        const isPinned = state.pinnedApps.includes(appId);
        const currentIndex = isPinned ? state.pinnedApps.indexOf(appId) : -1;
        
        // Calculate offset between mouse position and icon's left edge
        const offsetX = e.clientX - rect.left;
        
        // Set up drag state for all apps including finder, but we'll prevent dragging finder later
        const isFinderIcon = appId === 'finder';
        
        dockDragState = {
          appId: appId,
          startX: e.clientX,
          currentX: e.clientX,
          deltaX: 0,
          iconWidth: rect.width,
          isDragging: false,
          dragThreshold: isFinderIcon ? 999999 : 6, // Set very high threshold for finder to prevent dragging
          originalIndex: currentIndex,
          currentIndex: currentIndex,
          draggedElement: dockIcon,
          isPinned: isPinned,
          lastSwapTime: 0,
          initialIconLeft: rect.left, // Store initial icon position
          offsetX: offsetX, // Store where on the icon the user clicked
          isFinderIcon: isFinderIcon, // Flag to identify finder icon
        };
        window.dockDragState = dockDragState;
        
        e.preventDefault();
        e.stopPropagation();
      };
      
      window.updateDockOrder = function updateDockOrder(fromIndex, toIndex) {
        if (fromIndex === toIndex) return;
        
        const newPinnedApps = [...state.pinnedApps];
        const [movedApp] = newPinnedApps.splice(fromIndex, 1);
        newPinnedApps.splice(toIndex, 0, movedApp);
        
        state.pinnedApps = newPinnedApps;
        // Persist to localStorage immediately for real-time saving
        localStorage.setItem('pinnedApps', JSON.stringify(state.pinnedApps));
      };

      window.maximizeWindow = function maximizeWindow(id) {
        const win = state.windows.find((w) => w.id === id);
        if (!win) {
          console.warn('maximizeWindow: no window found for id', id);
          return;
        }

        console.log('maximizeWindow: start', { id, isMaximized: win.isMaximized, isFullscreen: win.isFullscreen });

        const windowEl = document.getElementById(`window-${id}`);
        if (!windowEl) {
          console.warn('maximizeWindow: no DOM element for id', id);
          win.isMaximized = !win.isMaximized;
          win.isFullscreen = false;
          render();
          return;
        }

        // Calculate dock space based on current dock position and scale
        const dockPosition = state.dockPosition || 'bottom';
        const menubarHeight = 28;
        const dockDims = getDockDimensions();
        
        const dockSpaceBottom = dockPosition === 'bottom' ? dockDims.getBottomSpace() : 0;
        const dockSpaceSide = (dockPosition === 'left' || dockPosition === 'right') ? dockDims.getSideSpace() : 0;

        if (win.isMaximized) {
          // Restoring from maximized state
          const currentRect = windowEl.getBoundingClientRect();
          
          // Store values to restore to
          const restoreX = win.x;
          const restoreY = win.y;
          const restoreWidth = win.width;
          const restoreHeight = win.height;
          
          // Update window state IMMEDIATELY before animation
          win.isMaximized = false;
          win.isFullscreen = false;
          win.isSnapped = false;
          win.snapRestorePos = null;
          
          // Save to localStorage IMMEDIATELY so refresh works correctly
          const windowState = state.windowStates[win.appId] || {};
          windowState.x = restoreX;
          windowState.y = restoreY;
          windowState.width = restoreWidth;
          windowState.height = restoreHeight;
          windowState.isMaximized = false;
          windowState.isSnapped = false;
          windowState.snapRestorePos = null;
          state.windowStates[win.appId] = windowState;
          localStorage.setItem('windowStates', JSON.stringify(state.windowStates));
          
          // Enable hardware acceleration
          windowEl.style.willChange = 'transform, top, left, width, height, border-radius';
          windowEl.classList.add('restoring');
          
          // First, set the window to maximized state explicitly (respecting dock position)
          const targetWidth = window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0);
          const targetHeight = window.innerHeight - menubarHeight - dockSpaceBottom;
          const targetLeft = dockPosition === 'left' ? dockSpaceSide : 0;
          const targetTop = menubarHeight;
          
          windowEl.style.top = `${targetTop}px`;
          windowEl.style.left = `${targetLeft}px`;
          windowEl.style.width = `${targetWidth}px`;
          windowEl.style.height = `${targetHeight}px`;
          windowEl.style.borderRadius = '0px';
          windowEl.style.transform = 'none';
          windowEl.style.transition = 'none';
          
          // Force layout recalculation
          void windowEl.offsetHeight;
          
          // Use double requestAnimationFrame to GUARANTEE animation plays
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              // Now animate to restored position
              windowEl.style.transition = 'all 0.3s cubic-bezier(0.16, 1, 0.3, 1)';
              windowEl.style.top = `${restoreY}px`;
              windowEl.style.left = `${restoreX}px`;
              windowEl.style.width = `${restoreWidth}px`;
              windowEl.style.height = `${restoreHeight}px`;
              windowEl.style.borderRadius = '12px';
              windowEl.style.transform = 'scale3d(1, 1, 1)';
            });
          });
          
          setTimeout(() => {
            windowEl.classList.remove('restoring');
            windowEl.classList.remove('maximized');
            windowEl.style.willChange = 'auto';
            windowEl.style.transition = '';
            windowEl.style.transform = '';
            // Restore rounded corners for non-maximized state
            windowEl.style.borderRadius = '10px';
            
            render();
          }, 300);
          
        } else {
          // Maximizing
          const startRect = windowEl.getBoundingClientRect();
          
          // Store current position for restoration (prioritize snap restore position if available)
          if (!win.isMaximized) {
            if (win.isSnapped && win.snapRestorePos) {
              // Restore to pre-snap position when unmaximizing
              win.restoreX = win.snapRestorePos.x;
              win.restoreY = win.snapRestorePos.y;
              win.restoreWidth = win.snapRestorePos.width;
              win.restoreHeight = win.snapRestorePos.height;
            } else {
              win.restoreX = win.x;
              win.restoreY = win.y;
              win.restoreWidth = win.width;
              win.restoreHeight = win.height;
            }
          }
          
          // Clear snap state when maximizing
          win.isSnapped = false;
          win.snapRestorePos = null;
          
          // Update window state IMMEDIATELY before animation
          win.isMaximized = true;
          win.isFullscreen = false;
          // Store restore position for next time
          const tempX = win.restoreX || win.x;
          const tempY = win.restoreY || win.y;
          const tempWidth = win.restoreWidth || win.width;
          const tempHeight = win.restoreHeight || win.height;
          
          // Save to localStorage IMMEDIATELY so refresh works correctly
          const windowState = state.windowStates[win.appId] || {};
          windowState.x = tempX;
          windowState.y = tempY;
          windowState.width = tempWidth;
          windowState.height = tempHeight;
          windowState.isMaximized = true;
          state.windowStates[win.appId] = windowState;
          localStorage.setItem('windowStates', JSON.stringify(state.windowStates));
          
          // Enable hardware acceleration
          windowEl.style.willChange = 'transform, top, left, width, height, border-radius';
          windowEl.classList.add('maximizing');
          
          // Calculate target dimensions (accounting for menubar and dock)
          const targetWidth = window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0);
          const targetHeight = window.innerHeight - menubarHeight - dockSpaceBottom;
          const targetLeft = dockPosition === 'left' ? dockSpaceSide : 0;
          const targetTop = menubarHeight;
          
          // Set initial position explicitly
          windowEl.style.top = `${startRect.top}px`;
          windowEl.style.left = `${startRect.left}px`;
          windowEl.style.width = `${startRect.width}px`;
          windowEl.style.height = `${startRect.height}px`;
          windowEl.style.borderRadius = '12px';
          windowEl.style.transform = 'scale3d(1, 1, 1)';
          windowEl.style.transition = 'none';
          
          // Force layout recalculation
          void windowEl.offsetHeight;
          
          // Use double requestAnimationFrame to GUARANTEE animation plays
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              // Animate to maximized position (avoiding dock)
              windowEl.style.transition = 'all 0.3s cubic-bezier(0.16, 1, 0.3, 1)';
              windowEl.style.top = `${targetTop}px`;
              windowEl.style.left = `${targetLeft}px`;
              windowEl.style.width = `${targetWidth}px`;
              windowEl.style.height = `${targetHeight}px`;
              windowEl.style.borderRadius = '0px';
            });
          });
          
          setTimeout(() => {
            // Update position for next time
            win.x = tempX;
            win.y = tempY;
            win.width = tempWidth;
            win.height = tempHeight;
            windowEl.classList.remove('maximizing');
            windowEl.classList.add('maximized');
            windowEl.style.willChange = 'auto';
            windowEl.style.transition = '';
            // Keep border-radius: 0 for maximized state (don't clear it)
            windowEl.style.borderRadius = '0';
            
            render();
          }, 300);
        }
      };

      window.toggleFullscreen = function toggleFullscreen(id) {
        const win = state.windows.find((w) => w.id === id);
        if (!win) {
          console.warn('toggleFullscreen: no window found for id', id);
          return;
        }

        console.log('toggleFullscreen: start', { id, isFullscreen: win.isFullscreen });

        const windowEl = document.getElementById(`window-${id}`);
        if (!windowEl) {
          console.warn('toggleFullscreen: no DOM element for id', id);
          win.isFullscreen = !win.isFullscreen;
          win.isMaximized = false;
          render();
          return;
        }

        if (win.isFullscreen) {
          // EXITING borderless fullscreen - restore to previous state
          const currentRect = windowEl.getBoundingClientRect();
          
          // Get restore position
          const restoreX = win.fullscreenRestoreX || win.x || 100;
          const restoreY = win.fullscreenRestoreY || win.y || 100;
          const restoreWidth = win.fullscreenRestoreWidth || win.width || 800;
          const restoreHeight = win.fullscreenRestoreHeight || win.height || 600;
          const wasMaximized = win.fullscreenWasMaximized || false;
          
          // Update window state IMMEDIATELY
          win.isFullscreen = false;
          win.isMaximized = wasMaximized;
          
          // Clear fullscreen restore data
          delete win.fullscreenRestoreX;
          delete win.fullscreenRestoreY;
          delete win.fullscreenRestoreWidth;
          delete win.fullscreenRestoreHeight;
          delete win.fullscreenWasMaximized;
          
          // Enable hardware acceleration
          windowEl.style.willChange = 'transform, top, left, width, height, border-radius';
          windowEl.classList.add('restoring');
          windowEl.classList.remove('fullscreen');
          
          // Set starting position (fullscreen)
          windowEl.style.top = '0px';
          windowEl.style.left = '0px';
          windowEl.style.width = '100vw';
          windowEl.style.height = '100vh';
          windowEl.style.borderRadius = '0px';
          windowEl.style.transform = 'none';
          windowEl.style.transition = 'none';
          
          // Force layout
          void windowEl.offsetHeight;
          
          // Calculate target position
          let targetX, targetY, targetWidth, targetHeight, targetRadius;
          
          if (wasMaximized) {
            // Restore to maximized state
            const dockPosition = state.dockPosition || 'bottom';
            const menubarHeight = 28;
            const dockDims = getDockDimensions();
            const dockSpaceBottom = dockPosition === 'bottom' ? dockDims.getBottomSpace() : 0;
            const dockSpaceSide = (dockPosition === 'left' || dockPosition === 'right') ? dockDims.getSideSpace() : 0;
            
            targetWidth = window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0);
            targetHeight = window.innerHeight - menubarHeight - dockSpaceBottom;
            targetX = dockPosition === 'left' ? dockSpaceSide : 0;
            targetY = menubarHeight;
            targetRadius = '0px';
          } else {
            // Restore to windowed state
            targetX = restoreX;
            targetY = restoreY;
            targetWidth = restoreWidth;
            targetHeight = restoreHeight;
            targetRadius = '12px';
          }
          
          // Animate
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              windowEl.style.transition = 'all 0.3s cubic-bezier(0.16, 1, 0.3, 1)';
              windowEl.style.top = `${targetY}px`;
              windowEl.style.left = `${targetX}px`;
              windowEl.style.width = `${targetWidth}px`;
              windowEl.style.height = `${targetHeight}px`;
              windowEl.style.borderRadius = targetRadius;
              windowEl.style.transform = 'scale3d(1, 1, 1)';
            });
          });
          
          setTimeout(() => {
            windowEl.classList.remove('restoring');
            if (wasMaximized) {
              windowEl.classList.add('maximized');
            }
            windowEl.style.willChange = 'auto';
            windowEl.style.transition = '';
            windowEl.style.transform = '';
            windowEl.style.borderRadius = wasMaximized ? '0px' : '10px';
            
            render();
          }, 300);
          
        } else {
          // ENTERING borderless fullscreen
          const startRect = windowEl.getBoundingClientRect();
          
          // Store current position for restoration
          win.fullscreenRestoreX = win.x;
          win.fullscreenRestoreY = win.y;
          win.fullscreenRestoreWidth = win.width;
          win.fullscreenRestoreHeight = win.height;
          win.fullscreenWasMaximized = win.isMaximized;
          
          // Update window state IMMEDIATELY
          win.isFullscreen = true;
          win.isMaximized = false;
          
          // Enable hardware acceleration
          windowEl.style.willChange = 'transform, top, left, width, height, border-radius';
          windowEl.classList.add('maximizing'); // Use maximizing animation
          
          // Set initial position explicitly
          windowEl.style.top = `${startRect.top}px`;
          windowEl.style.left = `${startRect.left}px`;
          windowEl.style.width = `${startRect.width}px`;
          windowEl.style.height = `${startRect.height}px`;
          windowEl.style.borderRadius = win.fullscreenWasMaximized ? '0px' : '12px';
          windowEl.style.transform = 'scale3d(1, 1, 1)';
          windowEl.style.transition = 'none';
          
          // Force layout
          void windowEl.offsetHeight;
          
          // Animate to borderless fullscreen (entire screen, no corners)
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              windowEl.style.transition = 'all 0.3s cubic-bezier(0.16, 1, 0.3, 1)';
              windowEl.style.top = '0px';
              windowEl.style.left = '0px';
              windowEl.style.width = '100vw';
              windowEl.style.height = '100vh';
              windowEl.style.borderRadius = '0px';
            });
          });
          
          setTimeout(() => {
            windowEl.classList.remove('maximizing');
            windowEl.classList.add('fullscreen');
            windowEl.style.willChange = 'auto';
            windowEl.style.transition = '';
            windowEl.style.borderRadius = '0';
            
            render();
            
            // Focus iframe after fullscreen for keyboard events
            requestAnimationFrame(() => {
              const iframe = windowEl.querySelector('iframe');
              if (iframe) {
                try {
                  iframe.focus();
                  if (iframe.contentWindow) {
                    iframe.contentWindow.focus();
                    // Request pointer lock for games like Minecraft
                    if (win.appId === 'minecraft') {
                      try {
                        const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                        const canvas = iframeDoc.querySelector('canvas');
                        if (canvas && canvas.requestPointerLock) {
                          canvas.addEventListener('click', function() {
                            canvas.requestPointerLock();
                          }, { once: false });
                        }
                      } catch (e) {
                        console.log('Could not set up pointer lock for Minecraft');
                      }
                    }
                  }
                } catch (e) {
                  iframe.focus();
                }
              }
            });
          }, 300);
        }
      };
      
      // Fullscreen UI visibility helpers
      window.showFullscreenUI = function(winId) {
        const windowEl = document.getElementById(`window-${winId}`);
        if (windowEl) {
          const overlayUI = windowEl.querySelector('.fullscreen-overlay-ui');
          if (overlayUI) {
            overlayUI.classList.add('visible');
          }
        }
      };
      
      window.hideFullscreenUI = function(winId) {
        const windowEl = document.getElementById(`window-${winId}`);
        if (windowEl) {
          const overlayUI = windowEl.querySelector('.fullscreen-overlay-ui');
          if (overlayUI) {
            overlayUI.classList.remove('visible');
          }
        }
      };
      
      // Track when iframes steal focus and handle OS-level keybinds
      let lastFocusedIframe = null;
      
      window.addEventListener('blur', function() {
        // When main window loses focus (likely to an iframe), store which one
        const activeWin = state.windows.find(w => w.id === state.activeWindowId);
        if (activeWin) {
          const windowEl = document.getElementById(`window-${activeWin.id}`);
          if (windowEl) {
            const iframe = windowEl.querySelector('iframe');
            if (iframe && document.activeElement === iframe) {
              lastFocusedIframe = iframe;
            }
          }
        }
      });
      
      // Use capture phase to intercept keyboard events before iframes
      window.addEventListener('keydown', function(e) {
        // Handle OS-level keybinds even when iframe has focus
        if (e.key === 'Escape') {
          const fullscreenWin = state.windows.find(w => w.isFullscreen);
          if (fullscreenWin) {
            window.toggleFullscreen(fullscreenWin.id);
            e.preventDefault();
            e.stopPropagation();
            return;
          }
        }
        
        if (e.ctrlKey && e.shiftKey && (e.key === 'f' || e.key === 'F')) {
          e.preventDefault();
          e.stopPropagation();
          
          const activeWin = state.windows.find(w => w.id === state.activeWindowId);
          if (activeWin) {
            const app = apps.find(a => a.id === activeWin.appId);
            if ((app && app.supportsFullscreen) || activeWin.isFullscreen) {
              window.toggleFullscreen(activeWin.id);
            }
          }
          return;
        }
      }, true); // Use capture phase
      
      // Global mousedown handler in capture phase to ensure OS UI elements
      // (dock, menubar, desktop shortcuts) work even when an iframe has focus.
      // This fires BEFORE the iframe can capture the event.
      document.addEventListener('mousedown', (e) => {
        const target = e.target;
        
        // Check if click is on dock, menubar, or desktop (not inside a window)
        const isOnDock = target.closest('.dock-container');
        const isOnMenubar = target.closest('.menubar');
        const isOnDesktop = target.closest('.desktop-bg') && !target.closest('.window');
        const isOnDesktopShortcut = target.closest('.desktop-shortcut');
        const isOnLaunchpad = target.closest('.launchpad-overlay');
        const isOnQuickSettings = target.closest('.quick-settings');
        const isOnContextMenu = target.closest('.context-menu');
        
        if (isOnDock || isOnMenubar || isOnDesktop || isOnDesktopShortcut || isOnLaunchpad || isOnQuickSettings || isOnContextMenu) {
          // Blur any focused iframe to ensure OS UI can receive focus
          const focusedIframe = document.activeElement;
          if (focusedIframe && focusedIframe.tagName === 'IFRAME') {
            focusedIframe.blur();
          }
          
          // Deactivate all windows ONLY when clicking on the desktop background itself
          // NOT on dock, menubar, or other UI elements - those should not affect window focus
          if (isOnDesktop) {
            window.deactivateAllWindows();
          }
        }
      }, true); // Use capture phase to fire before bubbling
      
      window.handleLaunchpadSearch = function handleLaunchpadSearch(e) {
        state.launchpadSearch = e.target.value;
        
        // Update only the grid instead of full re-render
        const launchpadGrid = document.querySelector('.launchpad-grid');
        if (launchpadGrid) {
          const searchLower = state.launchpadSearch.toLowerCase();
          const filteredApps = apps.filter(app => {
            if (!state.launchpadSearch) return true;
            return app.name.toLowerCase().includes(searchLower);
          });
          
          launchpadGrid.innerHTML = filteredApps.map(app => `
            <div class="launchpad-item" onclick="window.toggleWindow('${app.id}'); window.closeLaunchpad();">
              ${icons[app.icon]}
              <span style="color: white; font-size: 13px; text-align: center; font-weight: 500;">${app.name}</span>
            </div>
          `).join('');
        }
      };

      window.closeLaunchpad = function closeLaunchpad() {
        if (state.showLaunchpad) {
          state.showLaunchpad = false;
          state.launchpadSearch = '';
          render();
        }
      };

      window.focusWindow = function focusWindow(id) {
        const win = state.windows.find((w) => w.id === id);
        if (win) {
          // Close notification panel and control center when focusing a window
          closePanelsInstantly();
          
          // Only play sound if this is a new window focus
          if (state.activeWindowId !== id) {
            playSound('focus');
          }
          win.zIndex = state.nextZIndex++;
          state.activeWindowId = id;
          
          // Update z-index and active state directly without re-rendering to preserve input state
          document.querySelectorAll('.window').forEach(windowEl => {
            const winId = parseInt(windowEl.dataset.id, 10);
            if (winId === id) {
              windowEl.style.zIndex = win.zIndex;
              windowEl.classList.remove('inactive');
              
              // If this window has an iframe (browser/game), focus it for keyboard controls.
              // BUT: don't steal focus from editable UI like the browser address bar.
              if (win.isFullscreen || win.appId === 'minecraft' || win.appId === 'browser') {
                const iframe = windowEl.querySelector('iframe');
                if (iframe) {
                  setTimeout(() => {
                    // If user is editing an input inside the browser chrome, keep focus there.
                    if (win.appId === 'browser') {
                      const ae = document.activeElement;
                      const isEditing = !!(
                        ae &&
                        (ae.tagName === 'INPUT' || ae.tagName === 'TEXTAREA' || ae.isContentEditable) &&
                        ae.closest('.browser-header')
                      );
                      if (isEditing) return;
                    }

                    try {
                      iframe.focus();
                      if (iframe.contentWindow) {
                        iframe.contentWindow.focus();
                      }
                    } catch (e) {
                      iframe.focus();
                    }
                  }, 50);
                }
              }
            } else {
              windowEl.classList.add('inactive');
            }
          });
          
          // Update window list buttons in the menubar to show active state
          const windowListWrapper = document.querySelector('[data-element-id="windowlist"]');
          if (windowListWrapper) {
            windowListWrapper.querySelectorAll('button').forEach(btn => {
              const onclick = btn.getAttribute('onclick');
              if (onclick) {
                const match = onclick.match(/handleWindowListClick\((\d+)\)|restoreWindowById\((\d+)\)/);
                if (match) {
                  const btnWindowId = parseInt(match[1] || match[2], 10);
                  if (btnWindowId === id) {
                    btn.style.background = 'hsl(var(--primary) / 0.2)';
                    btn.style.border = '1px solid hsl(var(--primary) / 0.3)';
                  } else {
                    btn.style.background = '';
                    btn.style.border = '';
                  }
                }
              }
            });
          }
          
          // Update dock indicators in real-time
          updateDockIndicators();
          
          // Don't call render() here to avoid input field refresh
        }
      };
      
      // Handle window list button click - same behavior as dock
      window.handleWindowListClick = function(windowId) {
        const win = state.windows.find(w => w.id === windowId);
        if (!win) return;
        
        // Check if this window is already the top window (highest z-index)
        const maxZIndex = Math.max(...state.windows.map(w => w.zIndex || 0));
        const isTopWindow = win.zIndex === maxZIndex;
        
        if (isTopWindow) {
          // If already on top, minimize it
          minimizeWindow(windowId);
        } else {
          // If not on top, bring it to front
          focusWindow(windowId);
        }
      };
      
      // Restore a minimized window by its ID
      window.restoreWindowById = function(windowId) {
        const win = state.windows.find(w => w.id === windowId);
        if (win && win.isMinimized) {
          win.isMinimized = false;
          win.zIndex = state.nextZIndex++;
          state.activeWindowId = windowId;
          playSound('focus');
          render();
        }
      };
      
      // Deactivate all windows (when clicking outside of windows)
      window.deactivateAllWindows = function deactivateAllWindows() {
        state.activeWindowId = null;

        // Mark all windows as inactive
        document.querySelectorAll('.window').forEach(windowEl => {
          windowEl.classList.add('inactive');
        });
        
        // Update dock indicators in real-time
        updateDockIndicators();
      };

      window.togglePinApp = function togglePinApp(appId) {
        const app = apps.find((a) => a.id === appId);
        if (app?.isPermanent) return;

        if (state.pinnedApps.includes(appId)) {
          state.pinnedApps = state.pinnedApps.filter((id) => id !== appId);
        } else {
          state.pinnedApps.push(appId);
        }
        localStorage.setItem('pinnedApps', JSON.stringify(state.pinnedApps));
        state.contextMenu = null;
        render();
      };

      window.showContextMenu = function showContextMenu(e, appId) {
        e.preventDefault();
        e.stopPropagation();
        const iconRect = e.currentTarget.getBoundingClientRect();
        state.contextMenu = {
          x: iconRect.left + iconRect.width / 2 - 90,
          y: iconRect.top - 88,
          appId,
        };
        render();
      };

      function updateTime() {
        const timeEl = document.querySelector('.current-time');
        if (timeEl) {
          timeEl.textContent = state.currentTime.toLocaleTimeString('en-US', {
            hour: 'numeric',
            minute: '2-digit',
          });
        }
      }

      function getWindowContent(appId) {
        if (appId === 'finder') {
          return `
            <div class="launchpad-grid">
              ${apps
                .map(
                  (app) => `
                    <div class="launchpad-item" onclick="window.toggleWindow('${app.id}')">
                      ${icons[app.icon]}
                      <span>${app.name}</span>
                    </div>
                  `,
                )
                .join('')}
            </div>
          `;
        }
        if (appId === 'cursor-calibration') {
          // Return the full calibration content directly for persistence across renders
          return getCalibrationContent();
        }
        if (appId === 'terminal') {
          // Get the window ID from the current windows array
          const win = state.windows.find(w => w.appId === 'terminal');
          const terminalId = win ? win.id : 'new';
          const history = state.terminalHistory[terminalId] || [];
          
          const savedValue = state.inputValues[`terminal-${terminalId}`] || '';
          return `
            <div class="terminal-content" data-terminal-id="${terminalId}">
              ${history.join('')}
              <div class="terminal-input-line" style="margin-top: 10px;">
                <span>user@mos ~ %</span>
                <input class="terminal-input" data-terminal-id="${terminalId}" type="text" value="${savedValue}" autofocus onkeydown="handleTerminalKeydown(event, ${terminalId})" onclick="event.stopPropagation()" />
              </div>
            </div>
          `;
        }
        if (appId === 'browser') {
          const win = state.windows.find(w => w.appId === 'browser');
          const windowId = win ? win.id : 'new';
          const savedValue = state.inputValues[windowId] || '';
          
          // Initialize tabs if needed
          initBrowserTabs(windowId);
          const tabs = state.browserTabs[windowId] || [];
          const activeTab = tabs.find(t => t.active);
          const currentUrl = activeTab?.url || '';
          
          // Update state to match active tab - but don't override inputValues if user might be editing
          state.browserUrls[windowId] = currentUrl;
          
          // Only sync inputValues to currentUrl on initial load (when inputValues is empty or matches browser URL)
          // This prevents overwriting what the user is typing
          if (!state.inputValues[windowId] || state.inputValues[windowId] === state.browserUrls[windowId]) {
            // Don't update inputValues here - let it be set only on navigation
          }
          
          // Update current tab info
          updateCurrentTabInfo(windowId);
          
          const isVerticalTabs = state.browserVerticalTabs;
          
          // Generate tabs HTML
          const generateTabs = () => tabs.map(tab => `
            <div class="browser-tab ${tab.active ? 'active' : ''}" data-tab-id="${tab.id}" onclick="window.switchBrowserTab(${windowId}, ${tab.id})">
              ${tab.loading ? '<div class="browser-tab-loading"></div>' : (tab.favicon ? `<img class="browser-tab-favicon" src="${tab.favicon}" alt="" onerror="this.style.display='none'" />` : '')}
              <span class="browser-tab-title">${tab.title}</span>
              <div class="browser-tab-close" onclick="window.closeBrowserTab(event, ${windowId}, ${tab.id})">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 12px; height: 12px;">
                  <path d="M18 6L6 18M6 6l12 12" stroke-linecap="round"/>
                </svg>
              </div>
            </div>
          `).join('');
          
          // Generate bookmarks bar
          const generateBookmarksBar = () => `
            <div class="browser-bookmarks-bar">
              ${state.browserBookmarks.map((bookmark, idx) => {
                let domain = bookmark;
                try { domain = new URL(bookmark).hostname.replace('www.', ''); } catch(e) {}
                return `
                  <div class="browser-bookmark ${state.activeBookmarkIndex === idx ? 'show-actions' : ''}" 
                       onclick="if(!event.target.closest('.browser-bookmark-action')){window.navigateCurrentTab(${windowId}, '${bookmark}')}" 
                       oncontextmenu="event.preventDefault(); window.toggleBookmarkActions(${idx})"
                       title="${bookmark}">
                    ${domain}
                    <div class="browser-bookmark-actions">
                      <div class="browser-bookmark-action" onclick="event.stopPropagation(); window.openEditBookmarkDialog(${idx})" title="Edit">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                          <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                          <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                        </svg>
                      </div>
                      <div class="browser-bookmark-action" onclick="event.stopPropagation(); window.removeBookmark(${idx})" title="Delete">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                          <path d="M18 6L6 18M6 6l12 12"/>
                        </svg>
                      </div>
                    </div>
                  </div>
                `;
              }).join('')}
              <div class="browser-bookmark" onclick="window.openAddBookmarkDialog()" title="Add Bookmark" style="opacity: 0.5;">+</div>
            </div>
          `;
          
          // Generate toolbar
          const generateToolbar = (addressValue, placeholder) => `
            <div class="browser-toolbar">
              <div class="browser-nav-buttons">
                <button class="browser-nav-button" title="Back" onclick="window.browserBack(${windowId})">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M19 12H5M12 19l-7-7 7-7" stroke-linecap="round" stroke-linejoin="round"/>
                  </svg>
                </button>
                <button class="browser-nav-button" title="Forward" onclick="window.browserForward(${windowId})">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M5 12h14M12 5l7 7-7 7" stroke-linecap="round" stroke-linejoin="round"/>
                  </svg>
                </button>
                <button class="browser-nav-button" title="Refresh" onclick="window.browserRefresh(${windowId})">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2" stroke-linecap="round" stroke-linejoin="round"/>
                  </svg>
                </button>
              </div>
              <div class="browser-address-bar">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <circle cx="11" cy="11" r="8"/>
                  <path d="m21 21-4.35-4.35"/>
                </svg>
                <input type="text" class="browser-address-input" data-window-id="${windowId}" value="${addressValue}" placeholder="${placeholder}" onclick="event.stopPropagation()" oninput="window.updateInputValue(${windowId}, this.value)" onkeydown="window.handleBrowserAddressKeydown(event, ${windowId})" />
              </div>
              <div class="browser-nav-buttons" style="margin-left: 8px;">
                <button class="browser-nav-button ${isVerticalTabs ? 'active' : ''}" title="Toggle Vertical Tabs" onclick="window.toggleBrowserVerticalTabs()" style="${isVerticalTabs ? 'background: hsl(var(--primary) / 0.2);' : ''}">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="3" width="18" height="18" rx="2"/>
                    <path d="M9 3v18"/>
                  </svg>
                </button>
                <button class="browser-nav-button ${state.showBrowserHistory ? 'active' : ''}" title="Search History" onclick="window.toggleBrowserHistory()" style="${state.showBrowserHistory ? 'background: hsl(var(--primary) / 0.2);' : ''}">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <polyline points="12 6 12 12 16 14"/>
                  </svg>
                </button>
              </div>
            </div>
          `;
          
          // Generate history panel
          const generateHistoryPanel = () => {
            if (!state.showBrowserHistory) return '';
            
            const formatTime = (timestamp) => {
              const date = new Date(timestamp);
              const now = new Date();
              const diffMs = now - date;
              const diffMins = Math.floor(diffMs / 60000);
              const diffHours = Math.floor(diffMs / 3600000);
              const diffDays = Math.floor(diffMs / 86400000);
              
              if (diffMins < 1) return 'Just now';
              if (diffMins < 60) return diffMins + 'm ago';
              if (diffHours < 24) return diffHours + 'h ago';
              if (diffDays < 7) return diffDays + 'd ago';
              return date.toLocaleDateString();
            };
            
            return `
              <div class="browser-history-panel">
                <div class="browser-history-header">
                  <h3>Search History</h3>
                  <div style="display: flex; gap: 8px;">
                    <button onclick="window.clearBrowserSearchHistory()" style="padding: 4px 8px; background: hsl(var(--destructive)); color: hsl(var(--destructive-foreground)); border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Clear All</button>
                    <button onclick="window.toggleBrowserHistory()" style="padding: 4px 8px; background: hsl(var(--accent)); color: hsl(var(--foreground)); border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Close</button>
                  </div>
                </div>
                <div class="browser-history-list">
                  ${state.browserSearchHistory.length === 0 ? `
                    <div class="browser-history-empty">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 48px; height: 48px; margin: 0 auto 16px; opacity: 0.3;">
                        <circle cx="11" cy="11" r="8"/>
                        <path d="m21 21-4.35-4.35"/>
                      </svg>
                      <p>No search history yet</p>
                      <p style="font-size: 12px; opacity: 0.7; margin-top: 8px;">Type something in the address bar to search</p>
                    </div>
                  ` : state.browserSearchHistory.map(item => `
                    <div class="browser-history-item" onclick="window.searchFromHistory(${windowId}, '${item.query.replace(/'/g, "\\'")}')">
                      <div class="browser-history-item-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                          <circle cx="11" cy="11" r="8"/>
                          <path d="m21 21-4.35-4.35"/>
                        </svg>
                      </div>
                      <div class="browser-history-item-text">${item.query}</div>
                      <div class="browser-history-item-time">${formatTime(item.timestamp)}</div>
                    </div>
                  `).join('')}
                </div>
              </div>
            `;
          };
          
          // Generate per-tab content wrappers
          const generateTabContent = () => {
            return tabs.map(tab => {
              const isActive = tab.active;
              if (tab.url) {
                // Tab has URL - show iframe
                return `
                  <div class="browser-tab-iframe-wrapper ${isActive ? 'active' : ''}" data-tab-id="${tab.id}">
                    <div class="iframe-click-interceptor" onclick="event.stopPropagation(); window.focusWindow(${windowId}); const browserWin = state.windows.find(w => w.id === ${windowId}); if(browserWin) { const iframe = this.parentElement.querySelector('iframe'); if(iframe) { iframe.focus(); if(iframe.contentWindow) iframe.contentWindow.focus(); } }"></div>
                    <div class="browser-iframe-blocker" onclick="window.browserBlockerClick(this)"></div>
                    <iframe class="browser-iframe" id="browser-iframe-${windowId}-${tab.id}" src="${tab.url}" 
                      sandbox="allow-same-origin allow-scripts allow-popups allow-forms allow-top-navigation allow-pointer-lock" 
                      allow="fullscreen; gamepad" tabindex="0"
                      onload="window.onBrowserTabLoad(${windowId}, ${tab.id})"></iframe>
                  </div>
                `;
              } else {
                // Tab is home page - use M Search home
                return `
                  <div class="browser-tab-iframe-wrapper ${isActive ? 'active' : ''}" data-tab-id="${tab.id}">
                    ${getBrowserHomeContent(windowId)}
                  </div>
                `;
              }
            }).join('');
          };
          
          // Return layout based on vertical tabs setting
          if (isVerticalTabs) {
            return `
              <div class="browser-container vertical-tabs" data-window-id="${windowId}">
                <div class="browser-sidebar">
                  <div class="browser-tabs-container">
                    ${generateTabs()}
                    <button class="browser-new-tab-btn" onclick="window.createBrowserTab(${windowId})" title="New Tab">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 18px; height: 18px;">
                        <path d="M12 5v14M5 12h14" stroke-linecap="round"/>
                      </svg>
                      <span style="margin-left: 8px; font-size: 13px;">New Tab</span>
                    </button>
                  </div>
                </div>
                <div class="browser-main">
                  <div class="browser-header" onmouseenter="window.browserHeaderEnter(this)" onmouseleave="window.browserHeaderLeave(this)">
                    ${generateBookmarksBar()}
                    ${generateToolbar(savedValue || currentUrl, 'Search with M Search or enter URL')}
                  </div>
                  <div class="browser-content-wrapper" style="position: relative;">
                    <div class="browser-tab-iframes">
                      ${generateTabContent()}
                    </div>
                    ${generateHistoryPanel()}
                  </div>
                </div>
              </div>
            `;
          } else {
            return `
              <div class="browser-container" data-window-id="${windowId}">
                <div class="browser-header" onmouseenter="window.browserHeaderEnter(this)" onmouseleave="window.browserHeaderLeave(this)">
                  <div class="browser-tabs-container">
                    ${generateTabs()}
                    <button class="browser-new-tab-btn" onclick="window.createBrowserTab(${windowId})" title="New Tab">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 18px; height: 18px;">
                        <path d="M12 5v14M5 12h14" stroke-linecap="round"/>
                      </svg>
                    </button>
                  </div>
                  ${generateBookmarksBar()}
                  ${generateToolbar(savedValue || currentUrl, 'Search with M Search or enter URL')}
                </div>
                <div class="browser-content-wrapper" style="position: relative;">
                  <div class="browser-tab-iframes">
                    ${generateTabContent()}
                  </div>
                  ${generateHistoryPanel()}
                </div>
              </div>
            `;
          }
        }
        if (appId === 'settings') {
          const activeTab = state.settingsTab || 'appearance';
          const searchQuery = state.settingsSearchQuery || '';
          
          const settingsItems = [
            { id: 'general', label: 'General', icon: '<circle cx="12" cy="12" r="3"/><path d="M12 1v6m0 6v6m9-9h-6m-6 0H3"/>' },
            { id: 'appearance', label: 'Appearance', icon: '<circle cx="12" cy="12" r="10"/><path d="M12 2a10 10 0 0 1 0 20"/>' },
            { id: 'lockscreen', label: 'Lock Screen', icon: '<rect x="3" y="11" width="18" height="11" rx="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/>' },
            { id: 'control-centre', label: 'Control Centre', icon: '<circle cx="12" cy="12" r="3"/><circle cx="19" cy="5" r="2"/><circle cx="5" cy="19" r="2"/><path d="M10.4 10.4 7 7m7.6 7.6 3.4 3.4"/>' },
            { id: 'desktop-dock', label: 'Desktop & Dock', icon: '<rect x="2" y="3" width="20" height="14" rx="2"/><path d="M8 21h8M12 17v4"/>' },
            { id: 'notifications', label: 'Notifications', icon: '<path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9M13.73 21a2 2 0 0 1-3.46 0"/>' },
            { id: 'sound', label: 'Sound', icon: '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/>' },
            { id: 'mouse', label: 'Mouse & Cursor', icon: '<path d="M12 2v6m-2-2 2-2 2 2M12 22v-6m-2 2 2 2 2-2"/><path d="M6 12H2m4-2-2 2 2 2M22 12h-4m2-2-2 2 2 2"/>' },
            { id: 'system', label: 'System', icon: '<rect x="4" y="4" width="16" height="16" rx="2"/><rect x="9" y="9" width="6" height="6"/><path d="M9 1v2M15 1v2M9 21v2M15 21v2M1 9h2M1 15h2M21 9h2M21 15h2"/>' }
          ];
          
          const filteredItems = settingsItems.filter(item => 
            item.label.toLowerCase().includes(searchQuery.toLowerCase())
          );
          
          return `
            <div class="settings-container">
              <div class="settings-sidebar">
                <div class="settings-search">
                  <input 
                    type="text" 
                    placeholder="Search" 
                    value="${searchQuery}"
                    oninput="event.stopPropagation(); window.filterSettingsItems(this.value)"
                    onclick="event.stopPropagation()" 
                  />
                </div>
                <div style="padding: 8px 0;">
                  ${filteredItems.map(item => `
                    <div class="settings-nav-item ${activeTab === item.id ? 'active' : ''}" onclick="event.stopPropagation(); window.switchSettingsTab('${item.id}')">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        ${item.icon}
                      </svg>
                      <span>${item.label}</span>
                    </div>
                  `).join('')}
                  ${filteredItems.length === 0 ? '<div style="padding: 12px; text-align: center; color: rgba(255,255,255,0.5); font-size: 13px;">No results found</div>' : ''}
                </div>
              </div>
              
              <div class="settings-content">
                ${getSettingsContent(activeTab)}
              </div>
            </div>
          `;
        }
        if (appId === 'versionmanager') {
          return getVersionManagerContent();
        }
        if (appId === 'taskmanager') {
          // Return initial structure immediately to prevent blank window
          // The actual content will be managed by updateTaskManagerContent which updates values
          return `<div data-task-manager-container style="width: 100%; height: 100%; display: flex; flex-direction: column; background: hsl(var(--window-bg)); color: hsl(var(--foreground)); font-family: 'JetBrains Mono', monospace; overflow: hidden;">
            <!-- Header with stats -->
            <div style="padding: 16px 20px; border-bottom: 1px solid hsl(var(--window-border)); display: flex; gap: 24px; align-items: center; background: hsl(var(--titlebar-bg));">
              <div style="display: flex; align-items: center; gap: 8px;">
                <div style="width: 12px; height: 12px; border-radius: 50%; background: #10B981;"></div>
                <span data-stat-cpu style="font-size: 12px; font-weight: 600;">CPU: 0.0%</span>
              </div>
              <div style="display: flex; align-items: center; gap: 8px;">
                <div style="width: 12px; height: 12px; border-radius: 50%; background: #3B82F6;"></div>
                <span data-stat-memory style="font-size: 12px; font-weight: 600;">Memory: 0 MB</span>
              </div>
              <div style="display: flex; align-items: center; gap: 8px;">
                <div style="width: 12px; height: 12px; border-radius: 50%; background: #F59E0B;"></div>
                <span data-stat-processes style="font-size: 12px; font-weight: 600;">Processes: 0</span>
              </div>
              <div style="flex: 1;"></div>
              <div style="font-size: 10px; color: hsl(var(--muted-foreground));">Auto-refresh: 1s</div>
            </div>
            
            <!-- Process table header -->
            <div style="display: grid; grid-template-columns: 80px 1fr 80px 100px 100px 100px; padding: 10px 20px; border-bottom: 1px solid hsl(var(--window-border)); font-size: 11px; font-weight: 600; color: hsl(var(--muted-foreground)); text-transform: uppercase; letter-spacing: 0.05em; background: hsl(var(--accent) / 0.3);">
              <span>PID</span>
              <span>Process Name</span>
              <span>CPU %</span>
              <span>Memory</span>
              <span>Status</span>
              <span>Actions</span>
            </div>
            
            <!-- Process list -->
            <div data-process-list style="flex: 1; overflow-y: auto; scrollbar-width: thin;">
              <div style="padding: 40px; text-align: center; color: hsl(var(--muted-foreground));">Loading processes...</div>
            </div>
            
            <!-- Footer -->
            <div style="padding: 12px 20px; border-top: 1px solid hsl(var(--window-border)); display: flex; justify-content: space-between; align-items: center; background: hsl(var(--titlebar-bg)); font-size: 11px; color: hsl(var(--muted-foreground));">
              <span>M OS Task Manager</span>
              <span>Press Ctrl+Alt+\` or Ctrl+Alt+; to quick open</span>
            </div>
          </div>`;
        }
        if (appId === 'minecraft') {
          // Check if Minecraft is installed
          const isInstalled = state.installedApps && state.installedApps.includes('minecraft');
          
          if (!isInstalled) {
            return `
              <div style="width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%); color: white; text-align: center; padding: 40px;">
                <div style="width: 120px; height: 120px; margin-bottom: 24px;">
                  ${icons.Minecraft}
                </div>
                <h2 style="font-size: 24px; font-weight: 600; margin-bottom: 12px;">Minecraft Not Installed</h2>
                <p style="font-size: 14px; color: #888; margin-bottom: 24px;">Install Minecraft from the App Store to play</p>
                <button 
                  style="padding: 12px 32px; background: hsl(var(--primary)); color: hsl(var(--primary-foreground)); border: none; border-radius: 24px; font-size: 16px; font-weight: 600; cursor: pointer; transition: transform 0.15s ease;"
                  onmouseover="this.style.transform='scale(1.05)';"
                  onmouseout="this.style.transform='scale(1)';"
                  onclick="event.stopPropagation(); window.toggleWindow('appstore');"
                >
                  Open App Store
                </button>
              </div>
            `;
          }
          
          // Use the blob URL created from IndexedDB content during checkInstalledApps
          // This is the correct way to load the Minecraft game after downloading
          if (!state.minecraftBlobUrl) {
            return `
              <div style="width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; background: #1a1a1a; color: white; text-align: center; padding: 40px;">
                <div style="width: 80px; height: 80px; margin-bottom: 24px;">
                  ${icons.Minecraft}
                </div>
                <h2 style="font-size: 20px; font-weight: 600; margin-bottom: 12px;">Loading Minecraft...</h2>
                <p style="font-size: 14px; color: #888; margin-bottom: 24px;">If this persists, please reinstall from App Store.</p>
                <button 
                  style="padding: 10px 24px; background: hsl(var(--primary)); color: hsl(var(--primary-foreground)); border: none; border-radius: 20px; font-size: 14px; font-weight: 600; cursor: pointer; transition: transform 0.15s ease;"
                  onmouseover="this.style.transform='scale(1.05)';"
                  onmouseout="this.style.transform='scale(1)';"
                  onclick="event.stopPropagation(); window.uninstallMinecraft().then(() => window.toggleWindow('appstore'));"
                >
                  Reinstall from App Store
                </button>
              </div>
            `;
          }
          
          // Check if there's a preserved iframe for ANY minecraft window
          // This is a simplified approach since we typically only have one minecraft window
          let hasPreservedIframe = false;
          let preservedKey = null;
          
          for (const key of preservedIframes.keys()) {
            if (key.startsWith('minecraft-')) {
              hasPreservedIframe = true;
              preservedKey = key;
              break;
            }
          }
          
          if (hasPreservedIframe) {
            // Return empty container with exit button - iframe will be reattached after render
            return `
              <div class="minecraft-container" data-preserved="true" data-key="${preservedKey}" style="width: 100%; height: 100%; overflow: hidden; background: #1a1a1a; position: relative;">
                <div class="iframe-click-interceptor" onclick="event.stopPropagation(); const win = state.windows.find(w => w.appId === 'minecraft'); if(win) { window.focusWindow(win.id); const iframe = this.parentElement.querySelector('iframe'); if(iframe) { iframe.focus(); if(iframe.contentWindow) iframe.contentWindow.focus(); } }"></div>
                <button class="fullscreen-exit-btn" onclick="event.stopPropagation(); const win = state.windows.find(w => w.appId === 'minecraft'); if(win) window.toggleFullscreen(win.id);" title="Toggle Fullscreen">
                  <svg viewBox="0 0 24 24">
                    <path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3" stroke-linecap="round" stroke-linejoin="round"/>
                  </svg>
                </button>
              </div>
            `;
          }
          
          // Create iframe that will load Minecraft content programmatically
          // We use data-needs-content flag, then inject content via JS after render
          // This avoids issues with escaping complex HTML in srcdoc attribute
          return `
            <div class="minecraft-container" style="width: 100%; height: 100%; overflow: hidden; background: #1a1a1a; position: relative;">
              <div class="iframe-click-interceptor" onclick="event.stopPropagation(); const win = state.windows.find(w => w.appId === 'minecraft'); if(win) { window.focusWindow(win.id); const iframe = this.parentElement.querySelector('iframe'); if(iframe) { iframe.focus(); if(iframe.contentWindow) iframe.contentWindow.focus(); } }"></div>
              <iframe 
                id="minecraft-frame"
                data-needs-content="true"
                style="width: 100%; height: 100%; border: none; display: block;"
                allow="fullscreen; gamepad; autoplay; accelerometer; gyroscope; xr-spatial-tracking"
                tabindex="0"
                onerror="console.error('Minecraft iframe failed to load');"
              ></iframe>
              <button class="fullscreen-exit-btn" onclick="event.stopPropagation(); const win = state.windows.find(w => w.appId === 'minecraft'); if(win) window.toggleFullscreen(win.id);" title="Toggle Fullscreen">
                <svg viewBox="0 0 24 24">
                  <path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
              </button>
            </div>
          `;
        }
        if (appId === 'appstore') {
          const minecraftInstalled = state.installedApps && state.installedApps.includes('minecraft');
          
          return `
            <div class="appstore-container" style="height: 100%; background: linear-gradient(180deg, hsl(var(--window-bg)) 0%, hsl(var(--accent) / 0.3) 100%); overflow-y: auto; padding: 24px;">
              <div style="max-width: 800px; margin: 0 auto;">
                <h1 style="font-size: 32px; font-weight: 700; margin-bottom: 8px; color: hsl(var(--foreground));">M Store</h1>
                <p style="font-size: 14px; color: hsl(var(--muted-foreground)); margin-bottom: 32px;">Discover and install apps for your MOS desktop</p>
                
                <h2 style="font-size: 18px; font-weight: 600; margin-bottom: 16px; color: hsl(var(--foreground));">Available Apps</h2>
                
                <div style="display: grid; gap: 16px;">
                  <!-- Minecraft App Card -->
                  <div style="display: flex; align-items: center; gap: 16px; padding: 20px; background: hsl(var(--window-bg)); border-radius: 16px; border: 1px solid hsl(var(--window-border)); box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
                    <div style="width: 80px; height: 80px; flex-shrink: 0;">
                      ${icons.Minecraft}
                    </div>
                    <div style="flex: 1; min-width: 0;">
                      <h3 style="font-size: 18px; font-weight: 600; color: hsl(var(--foreground)); margin-bottom: 4px;">Minecraft</h3>
                      <p style="font-size: 13px; color: hsl(var(--muted-foreground)); margin-bottom: 8px;">Classic sandbox game - build, explore, and survive in infinite worlds</p>
                      <div style="display: flex; align-items: center; gap: 8px;">
                        <span style="font-size: 12px; color: hsl(var(--muted-foreground)); background: hsl(var(--accent)); padding: 4px 8px; border-radius: 6px;">Game</span>
                        <span style="font-size: 12px; color: hsl(var(--muted-foreground));">v1.0</span>
                        ${minecraftInstalled ? '<span style="font-size: 12px; color: #4ade80; background: rgba(74, 222, 128, 0.15); padding: 4px 8px; border-radius: 6px;"> Installed</span>' : ''}
                      </div>
                    </div>
                    <div style="flex-shrink: 0; display: flex; gap: 8px;">
                      ${minecraftInstalled ? `
                        <button 
                          style="padding: 10px 24px; background: hsl(var(--primary)); color: hsl(var(--primary-foreground)); border: none; border-radius: 20px; font-size: 14px; font-weight: 600; cursor: pointer; transition: transform 0.15s ease;"
                          onmouseover="this.style.transform='scale(1.05)';"
                          onmouseout="this.style.transform='scale(1)';"
                          onclick="event.stopPropagation(); window.toggleWindow('minecraft');"
                        >
                          Open
                        </button>
                        <button 
                          style="padding: 10px 16px; background: hsl(var(--destructive)); color: hsl(var(--destructive-foreground)); border: none; border-radius: 20px; font-size: 14px; font-weight: 600; cursor: pointer; transition: transform 0.15s ease, box-shadow 0.15s ease;"
                          onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 4px 12px rgba(239,68,68,0.4)';"
                          onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none';"
                          onclick="event.stopPropagation(); window.uninstallMinecraft();"
                          title="Uninstall Minecraft"
                        >
                          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                            <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
                          </svg>
                        </button>
                      ` : `
                        <button 
                          style="padding: 10px 24px; background: hsl(var(--primary)); color: hsl(var(--primary-foreground)); border: none; border-radius: 20px; font-size: 14px; font-weight: 600; cursor: pointer; transition: transform 0.15s ease, box-shadow 0.15s ease;"
                          onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 4px 12px rgba(0,122,255,0.4)';"
                          onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none';"
                          onclick="event.stopPropagation(); window.installMinecraft();"
                        >
                          Download
                        </button>
                      `}
                    </div>
                  </div>
                </div>
                
                <div style="margin-top: 32px; padding: 20px; background: hsl(var(--accent) / 0.3); border-radius: 12px; text-align: center;">
                  <p style="font-size: 13px; color: hsl(var(--muted-foreground));">Apps are stored in your virtual PC and persist across sessions</p>
                </div>
              </div>
            </div>
          `;
        }
        return `<div><h2>${appId}</h2><p>Content for ${appId} app</p></div>`;
      }

      // Task Manager refresh functions
      window.startTaskManagerRefresh = function startTaskManagerRefresh(windowId) {
        // Clear any existing interval
        if (state.taskManagerInterval) {
          clearInterval(state.taskManagerInterval);
        }
        
        // Store the windowId for use in interval
        state.taskManagerWindowId = windowId;
        
        // Use a retry mechanism to ensure the window is ready
        let retryCount = 0;
        const maxRetries = 10;
        
        const tryUpdate = () => {
          const taskManagerWindow = document.querySelector(`[data-id="${windowId}"] .window-content`);
          if (taskManagerWindow) {
            window.updateTaskManagerContent(windowId);
          } else if (retryCount < maxRetries) {
            retryCount++;
            setTimeout(tryUpdate, 50);
          }
        };
        
        // Update immediately with retry
        setTimeout(tryUpdate, 50);
        
        // Start refresh interval (every 1 second)
        state.taskManagerInterval = setInterval(() => {
          // Check if window still exists
          const win = state.windows.find(w => w.id === windowId);
          if (!win) {
            window.stopTaskManagerRefresh();
            return;
          }
          window.updateTaskManagerContent(windowId);
        }, 1000);
      };
      
      window.stopTaskManagerRefresh = function stopTaskManagerRefresh() {
        if (state.taskManagerInterval) {
          clearInterval(state.taskManagerInterval);
          state.taskManagerInterval = null;
        }
        state.taskManagerWindowId = null;
      };
      
      window.updateTaskManagerContent = function updateTaskManagerContent(windowId) {
        const taskManagerWindow = document.querySelector(`[data-id="${windowId}"] .window-content`);
        if (!taskManagerWindow) {
          console.warn('Task Manager window not found:', windowId);
          return;
        }
        
        // Check if window is minimized
        const win = state.windows.find(w => w.id === windowId);
        if (!win || win.isMinimized) return;
        
        // Get process info from open windows
        const processes = state.windows.map((w, idx) => {
          const app = apps.find(a => a.id === w.appId);
          return {
            pid: 1000 + w.id,
            name: app ? app.name : w.appId,
            windowId: w.id,
            cpu: (Math.random() * 15).toFixed(1),
            memory: (Math.random() * 200 + 50).toFixed(0),
            status: w.isMinimized ? 'Suspended' : 'Running'
          };
        });
        
        // Add some fake system processes with slight variations
        const systemProcesses = [
          { pid: 1, name: 'System', cpu: (0.05 + Math.random() * 0.1).toFixed(1), memory: '128', status: 'Running', isSystem: true },
          { pid: 2, name: 'WindowServer', cpu: (2.0 + Math.random() * 0.6).toFixed(1), memory: '256', status: 'Running', isSystem: true },
          { pid: 3, name: 'Dock', cpu: (0.3 + Math.random() * 0.4).toFixed(1), memory: '64', status: 'Running', isSystem: true },
          { pid: 4, name: 'Finder', cpu: (0.5 + Math.random() * 0.6).toFixed(1), memory: '128', status: 'Running', isSystem: true },
          { pid: 5, name: 'SystemUIServer', cpu: (0.2 + Math.random() * 0.2).toFixed(1), memory: '48', status: 'Running', isSystem: true },
        ];
        
        const allProcesses = [...systemProcesses, ...processes];
        const totalCPU = allProcesses.reduce((sum, p) => sum + parseFloat(p.cpu), 0).toFixed(1);
        const totalMemory = allProcesses.reduce((sum, p) => sum + parseInt(p.memory), 0);
        
        // Check if task manager content already exists and has the process list - if so, only update values
        const existingContainer = taskManagerWindow.querySelector('[data-task-manager-container]');
        const processList = existingContainer ? existingContainer.querySelector('[data-process-list]') : null;
        
        if (existingContainer && processList) {
          // Update only the stats text
          const cpuStat = existingContainer.querySelector('[data-stat-cpu]');
          const memoryStat = existingContainer.querySelector('[data-stat-memory]');
          const processesStat = existingContainer.querySelector('[data-stat-processes]');
          
          if (cpuStat) cpuStat.textContent = `CPU: ${totalCPU}%`;
          if (memoryStat) memoryStat.textContent = `Memory: ${totalMemory} MB`;
          if (processesStat) processesStat.textContent = `Processes: ${allProcesses.length}`;
          
          // Update process rows in-place to avoid flicker - only update values, not DOM structure
          const existingRows = processList.querySelectorAll('[data-proc-row]');
          
          // If row count matches, update in place; otherwise rebuild
          if (existingRows.length === allProcesses.length) {
            existingRows.forEach((row, idx) => {
              const proc = allProcesses[idx];
              const cpuSpan = row.querySelector('[data-cpu]');
              const memSpan = row.querySelector('[data-mem]');
              const statusDot = row.querySelector('[data-status-dot]');
              const statusText = row.querySelector('[data-status-text]');
              
              if (cpuSpan) {
                cpuSpan.textContent = `${proc.cpu}%`;
                cpuSpan.style.color = parseFloat(proc.cpu) > 10 ? '#EF4444' : parseFloat(proc.cpu) > 5 ? '#F59E0B' : '#10B981';
              }
              if (memSpan) memSpan.textContent = `${proc.memory} MB`;
              if (statusDot) statusDot.style.background = proc.status === 'Running' ? '#10B981' : '#F59E0B';
              if (statusText) statusText.textContent = proc.status;
            });
            return;
          }
          
          // Row count changed - need to rebuild, preserve scroll
          const scrollTop = processList.scrollTop;
          
          processList.innerHTML = allProcesses.map(proc => `
              <div data-proc-row data-pid="${proc.pid}" style="display: grid; grid-template-columns: 80px 1fr 80px 100px 100px 100px; padding: 10px 20px; border-bottom: 1px solid hsl(var(--window-border) / 0.5); font-size: 12px; cursor: default;" onmouseover="this.style.background='hsl(var(--accent) / 0.3)'" onmouseout="this.style.background='transparent'">
                <span style="color: hsl(var(--muted-foreground));">${proc.pid}</span>
                <span style="font-weight: 500; display: flex; align-items: center; gap: 8px;">
                  ${proc.isSystem ? '<span style="width: 8px; height: 8px; border-radius: 2px; background: hsl(var(--primary));"></span>' : '<span style="width: 8px; height: 8px; border-radius: 2px; background: #10B981;"></span>'}
                  ${proc.name}
                </span>
                <span data-cpu style="color: ${parseFloat(proc.cpu) > 10 ? '#EF4444' : parseFloat(proc.cpu) > 5 ? '#F59E0B' : '#10B981'};">${proc.cpu}%</span>
                <span data-mem>${proc.memory} MB</span>
                <span style="display: flex; align-items: center; gap: 6px;">
                  <span data-status-dot style="width: 6px; height: 6px; border-radius: 50%; background: ${proc.status === 'Running' ? '#10B981' : '#F59E0B'};"></span>
                  <span data-status-text>${proc.status}</span>
                </span>
                <span>
                  ${!proc.isSystem ? `
                    <button onclick="event.stopPropagation(); window.closeWindow(${proc.windowId})" style="padding: 4px 10px; background: hsl(var(--destructive)); color: hsl(var(--destructive-foreground)); border: none; border-radius: 4px; font-size: 10px; cursor: pointer; font-family: inherit;" onmouseover="this.style.filter='brightness(0.9)'" onmouseout="this.style.filter='none'">
                      End Task
                    </button>
                  ` : `
                    <span style="color: hsl(var(--muted-foreground)); font-size: 10px;">System</span>
                  `}
                </span>
              </div>
            `).join('');
          
          processList.scrollTop = scrollTop;
          return;
        }
        
        // Initial render - create full structure with data attributes for later updates
        taskManagerWindow.innerHTML = `
          <div data-task-manager-container style="width: 100%; height: 100%; display: flex; flex-direction: column; background: hsl(var(--window-bg)); color: hsl(var(--foreground)); font-family: 'JetBrains Mono', monospace; overflow: hidden;">
            <!-- Header with stats -->
            <div style="padding: 16px 20px; border-bottom: 1px solid hsl(var(--window-border)); display: flex; gap: 24px; align-items: center; background: hsl(var(--titlebar-bg));">
              <div style="display: flex; align-items: center; gap: 8px;">
                <div style="width: 12px; height: 12px; border-radius: 50%; background: #10B981;"></div>
                <span data-stat-cpu style="font-size: 12px; font-weight: 600;">CPU: ${totalCPU}%</span>
              </div>
              <div style="display: flex; align-items: center; gap: 8px;">
                <div style="width: 12px; height: 12px; border-radius: 50%; background: #3B82F6;"></div>
                <span data-stat-memory style="font-size: 12px; font-weight: 600;">Memory: ${totalMemory} MB</span>
              </div>
              <div style="display: flex; align-items: center; gap: 8px;">
                <div style="width: 12px; height: 12px; border-radius: 50%; background: #F59E0B;"></div>
                <span data-stat-processes style="font-size: 12px; font-weight: 600;">Processes: ${allProcesses.length}</span>
              </div>
              <div style="flex: 1;"></div>
              <div style="font-size: 10px; color: hsl(var(--muted-foreground));">Auto-refresh: 1s</div>
            </div>
            
            <!-- Process table header -->
            <div style="display: grid; grid-template-columns: 80px 1fr 80px 100px 100px 100px; padding: 10px 20px; border-bottom: 1px solid hsl(var(--window-border)); font-size: 11px; font-weight: 600; color: hsl(var(--muted-foreground)); text-transform: uppercase; letter-spacing: 0.05em; background: hsl(var(--accent) / 0.3);">
              <span>PID</span>
              <span>Process Name</span>
              <span>CPU %</span>
              <span>Memory</span>
              <span>Status</span>
              <span>Actions</span>
            </div>
            
            <!-- Process list -->
            <div data-process-list style="flex: 1; overflow-y: auto; scrollbar-width: thin;">
              ${allProcesses.map(proc => `
                <div data-proc-row data-pid="${proc.pid}" style="display: grid; grid-template-columns: 80px 1fr 80px 100px 100px 100px; padding: 10px 20px; border-bottom: 1px solid hsl(var(--window-border) / 0.5); font-size: 12px; cursor: default;" onmouseover="this.style.background='hsl(var(--accent) / 0.3)'" onmouseout="this.style.background='transparent'">
                  <span style="color: hsl(var(--muted-foreground));">${proc.pid}</span>
                  <span style="font-weight: 500; display: flex; align-items: center; gap: 8px;">
                    ${proc.isSystem ? '<span style="width: 8px; height: 8px; border-radius: 2px; background: hsl(var(--primary));"></span>' : '<span style="width: 8px; height: 8px; border-radius: 2px; background: #10B981;"></span>'}
                    ${proc.name}
                  </span>
                  <span data-cpu style="color: ${parseFloat(proc.cpu) > 10 ? '#EF4444' : parseFloat(proc.cpu) > 5 ? '#F59E0B' : '#10B981'};">${proc.cpu}%</span>
                  <span data-mem>${proc.memory} MB</span>
                  <span style="display: flex; align-items: center; gap: 6px;">
                    <span data-status-dot style="width: 6px; height: 6px; border-radius: 50%; background: ${proc.status === 'Running' ? '#10B981' : '#F59E0B'};"></span>
                    <span data-status-text>${proc.status}</span>
                  </span>
                  <span>
                    ${!proc.isSystem ? `
                      <button onclick="event.stopPropagation(); window.closeWindow(${proc.windowId})" style="padding: 4px 10px; background: hsl(var(--destructive)); color: hsl(var(--destructive-foreground)); border: none; border-radius: 4px; font-size: 10px; cursor: pointer; font-family: inherit;" onmouseover="this.style.filter='brightness(0.9)'" onmouseout="this.style.filter='none'">
                        End Task
                      </button>
                    ` : `
                      <span style="color: hsl(var(--muted-foreground)); font-size: 10px;">System</span>
                    `}
                  </span>
                </div>
              `).join('')}
            </div>
            
            <!-- Footer -->
            <div style="padding: 12px 20px; border-top: 1px solid hsl(var(--window-border)); display: flex; justify-content: space-between; align-items: center; background: hsl(var(--titlebar-bg)); font-size: 11px; color: hsl(var(--muted-foreground));">
              <span>M OS Task Manager</span>
              <span>Press Ctrl+Alt+\` or Ctrl+Alt+; to quick open</span>
            </div>
          </div>
        `;
        
        // Restore scroll position from state after initial render
        const newProcessList = taskManagerWindow.querySelector('[data-process-list]');
        if (newProcessList && state.scrollPositions[`${windowId}-taskmanager`] !== undefined) {
          newProcessList.scrollTop = state.scrollPositions[`${windowId}-taskmanager`];
        }
      };

      window.updateInputValue = function updateInputValue(windowId, value) {
        state.inputValues[windowId] = value;
      };

      window.handleBrowserAddressKeydown = function handleBrowserAddressKeydown(e, windowId) {
        if (e.key === 'Enter') {
          e.preventDefault();
          let input = e.target.value.trim();
          
          if (!input) return;
          
          let url;
          let isSearch = false;
          
          // Check if it's a URL or a search query
          const isURL = (str) => {
            // Check for common URL patterns
            if (str.includes(' ')) return false; // URLs don't have spaces
            if (str.match(/^(https?:\/\/|www\.)/i)) return true;
            if (str.match(/^[a-zA-Z0-9-]+\.[a-zA-Z]{2,}/)) return true; // domain.tld pattern
            if (str.match(/^localhost(:\d+)?/)) return true;
            return false;
          };
          
          if (isURL(input)) {
            // It's a URL
            url = input;
            if (!url.startsWith('http://') && !url.startsWith('https://')) {
              url = 'https://' + url;
            }
          } else {
            // It's a search query - use M Search (DuckDuckGo HTML)
            isSearch = true;
            const searchQuery = encodeURIComponent(input);
            url = 'https://html.duckduckgo.com/html/?q=' + searchQuery;
            
            // Save to search history
            const historyEntry = { query: input, timestamp: Date.now() };
            state.browserSearchHistory.unshift(historyEntry);
            // Keep only last 50 searches
            if (state.browserSearchHistory.length > 50) {
              state.browserSearchHistory = state.browserSearchHistory.slice(0, 50);
            }
            localStorage.setItem('browserSearchHistory', JSON.stringify(state.browserSearchHistory));
          }
          
          // Initialize browser history for this window if it doesn't exist
          if (!state.browserHistory[windowId]) {
            state.browserHistory[windowId] = [];
            state.browserHistoryIndex[windowId] = -1;
          }
          
          // Add to history
          state.browserHistory[windowId].push(url);
          state.browserHistoryIndex[windowId] = state.browserHistory[windowId].length - 1;
          
          // Blur input FIRST to allow navigateCurrentTab to update inputValues
          e.target.blur();
          
          // Update inputValues to the new URL (now that input is blurred)
          state.inputValues[windowId] = url;
          
          // Use navigateCurrentTab to update DOM directly without full re-render
          // This prevents iframe reload and input focus issues
          navigateCurrentTab(windowId, url);
        }
      };
      
      // Toggle search history panel - update DOM directly without full render
      window.toggleBrowserHistory = function toggleBrowserHistory() {
        state.showBrowserHistory = !state.showBrowserHistory;
        
        // Find the browser window
        const browserWin = state.windows.find(w => w.appId === 'browser' && !w.isMinimized);
        if (!browserWin) {
          render();
          return;
        }
        
        const windowEl = document.getElementById(`window-${browserWin.id}`);
        if (!windowEl) {
          render();
          return;
        }
        
        const contentWrapper = windowEl.querySelector('.browser-content-wrapper');
        if (!contentWrapper) {
          render();
          return;
        }
        
        // Toggle history panel without full render
        let historyPanel = contentWrapper.querySelector('.browser-history-panel');
        
        if (state.showBrowserHistory) {
          // Create and show history panel
          if (!historyPanel) {
            historyPanel = document.createElement('div');
            historyPanel.className = 'browser-history-panel';
            contentWrapper.appendChild(historyPanel);
          }
          
          const formatTime = (timestamp) => {
            const date = new Date(timestamp);
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);
            
            if (diffMins < 1) return 'Just now';
            if (diffMins < 60) return diffMins + 'm ago';
            if (diffHours < 24) return diffHours + 'h ago';
            if (diffDays < 7) return diffDays + 'd ago';
            return date.toLocaleDateString();
          };
          
          historyPanel.innerHTML = `
            <div class="browser-history-header">
              <h3>Search History</h3>
              <div style="display: flex; gap: 8px;">
                <button onclick="window.clearBrowserSearchHistory()" style="padding: 4px 8px; background: hsl(var(--destructive)); color: hsl(var(--destructive-foreground)); border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Clear All</button>
                <button onclick="window.toggleBrowserHistory()" style="padding: 4px 8px; background: hsl(var(--accent)); color: hsl(var(--foreground)); border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Close</button>
              </div>
            </div>
            <div class="browser-history-list">
              ${state.browserSearchHistory.length === 0 ? `
                <div class="browser-history-empty">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 48px; height: 48px; margin: 0 auto 16px; opacity: 0.3;">
                    <circle cx="11" cy="11" r="8"/>
                    <path d="m21 21-4.35-4.35"/>
                  </svg>
                  <p>No search history yet</p>
                  <p style="font-size: 12px; opacity: 0.7; margin-top: 8px;">Type something in the address bar to search</p>
                </div>
              ` : state.browserSearchHistory.map(item => `
                <div class="browser-history-item" onclick="window.searchFromHistory(${browserWin.id}, '${item.query.replace(/'/g, "\\'")}')">
                  <div class="browser-history-item-icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                      <circle cx="11" cy="11" r="8"/>
                      <path d="m21 21-4.35-4.35"/>
                    </svg>
                  </div>
                  <div class="browser-history-item-text">${item.query}</div>
                  <div class="browser-history-item-time">${formatTime(item.timestamp)}</div>
                </div>
              `).join('')}
            </div>
          `;
        } else {
          // Remove history panel
          if (historyPanel) {
            historyPanel.remove();
          }
        }
        
        // Update button active state
        const historyBtn = windowEl.querySelector('.browser-nav-button[title="Search History"]');
        if (historyBtn) {
          historyBtn.classList.toggle('active', state.showBrowserHistory);
          historyBtn.style.background = state.showBrowserHistory ? 'hsl(var(--primary) / 0.2)' : '';
        }
      };
      
      // Clear search history
      window.clearBrowserSearchHistory = function clearBrowserSearchHistory() {
        state.browserSearchHistory = [];
        localStorage.setItem('browserSearchHistory', JSON.stringify(state.browserSearchHistory));
        
        // Update the history panel content without full render
        const historyList = document.querySelector('.browser-history-list');
        if (historyList) {
          historyList.innerHTML = `
            <div class="browser-history-empty">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 48px; height: 48px; margin: 0 auto 16px; opacity: 0.3;">
                <circle cx="11" cy="11" r="8"/>
                <path d="m21 21-4.35-4.35"/>
              </svg>
              <p>No search history yet</p>
              <p style="font-size: 12px; opacity: 0.7; margin-top: 8px;">Type something in the address bar to search</p>
            </div>
          `;
        }
      };
      
      // Search from history
      window.searchFromHistory = function searchFromHistory(windowId, query) {
        const searchQuery = encodeURIComponent(query);
        const url = 'https://www.google.com/search?q=' + searchQuery;
        state.showBrowserHistory = false;
        
        // Remove history panel
        const historyPanel = document.querySelector('.browser-history-panel');
        if (historyPanel) {
          historyPanel.remove();
        }
        
        // Update button state
        const historyBtn = document.querySelector('.browser-nav-button[title="Search History"]');
        if (historyBtn) {
          historyBtn.classList.remove('active');
          historyBtn.style.background = '';
        }
        
        navigateCurrentTab(windowId, url);
      };
      
      // Toggle vertical tabs - preserve iframes when switching layout
      window.toggleBrowserVerticalTabs = function toggleBrowserVerticalTabs() {
        state.browserVerticalTabs = !state.browserVerticalTabs;
        localStorage.setItem('browserVerticalTabs', state.browserVerticalTabs);
        
        // Find the browser window
        const browserWin = state.windows.find(w => w.appId === 'browser' && !w.isMinimized);
        if (!browserWin) {
          render();
          return;
        }
        
        const windowId = browserWin.id;
        const windowEl = document.getElementById(`window-${windowId}`);
        if (!windowEl) {
          render();
          return;
        }
        
        const browserContainer = windowEl.querySelector('.browser-container');
        if (!browserContainer) {
          render();
          return;
        }
        
        // Preserve all iframes before restructuring
        const preservedIframes = new Map();
        const tabs = state.browserTabs[windowId] || [];
        tabs.forEach(tab => {
          const iframe = browserContainer.querySelector(`#browser-iframe-${windowId}-${tab.id}`);
          if (iframe) {
            preservedIframes.set(tab.id, iframe.cloneNode(true));
            // Keep the src to avoid reload
            const clonedIframe = preservedIframes.get(tab.id);
            clonedIframe.src = iframe.src;
          }
        });
        
        // Get current values
        const isVerticalTabs = state.browserVerticalTabs;
        const savedValue = state.inputValues[windowId] || '';
        const currentUrl = state.browserUrls[windowId] || '';
        
        // Generate tabs HTML
        const generateTabs = () => tabs.map(tab => `
          <div class="browser-tab ${tab.active ? 'active' : ''}" data-tab-id="${tab.id}" onclick="window.switchBrowserTab(${windowId}, ${tab.id})">
            ${tab.loading ? '<div class="browser-tab-loading"></div>' : (tab.favicon ? `<img class="browser-tab-favicon" src="${tab.favicon}" alt="" />` : '')}
            <span class="browser-tab-title">${tab.title}</span>
            <div class="browser-tab-close" onclick="window.closeBrowserTab(event, ${windowId}, ${tab.id})">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 12px; height: 12px;">
                <path d="M18 6L6 18M6 6l12 12" stroke-linecap="round"/>
              </svg>
            </div>
          </div>
        `).join('');
        
        // Generate bookmarks bar
        const generateBookmarksBar = () => `
          <div class="browser-bookmarks-bar">
            ${state.browserBookmarks.map((url, idx) => {
              let domain;
              try { domain = new URL(url).hostname.replace('www.', ''); } 
              catch (e) { domain = url; }
              const favicon = `https://www.google.com/s2/favicons?domain=${domain}&sz=16`;
              return `
                <div class="browser-bookmark ${state.activeBookmarkIndex === idx ? 'show-actions' : ''}" 
                     data-bookmark-index="${idx}"
                     onclick="if(!event.target.closest('.browser-bookmark-remove')){window.openBookmark(${windowId}, '${url.replace(/'/g, "\\'")}')}"
                     title="${url}">
                  <img src="${favicon}" alt="" style="width: 14px; height: 14px; margin-right: 4px; opacity: 0.8;" onerror="this.style.display='none'" />
                  ${domain.length > 15 ? domain.substring(0, 15) + '...' : domain}
                  <span class="browser-bookmark-remove" onclick="event.stopPropagation(); window.removeBookmark(${idx})"></span>
                </div>
              `;
            }).join('')}
            <div class="browser-bookmark" onclick="window.openAddBookmarkDialog()" title="Add Bookmark" style="opacity: 0.5;">+</div>
          </div>
        `;
        
        // Generate toolbar
        const generateToolbar = () => `
          <div class="browser-toolbar">
            <div class="browser-nav-buttons">
              <button class="browser-nav-button" title="Back" onclick="window.browserBack(${windowId})">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M19 12H5M12 19l-7-7 7-7" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
              </button>
              <button class="browser-nav-button" title="Forward" onclick="window.browserForward(${windowId})">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M5 12h14M12 5l7 7-7 7" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
              </button>
              <button class="browser-nav-button" title="Refresh" onclick="window.browserRefresh(${windowId})">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
              </button>
            </div>
            <div class="browser-address-bar">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="11" cy="11" r="8"/>
                <path d="m21 21-4.35-4.35"/>
              </svg>
              <input type="text" class="browser-address-input" data-window-id="${windowId}" value="${savedValue || currentUrl}" placeholder="Search with M Search or enter URL" onclick="event.stopPropagation()" oninput="window.updateInputValue(${windowId}, this.value)" onkeydown="window.handleBrowserAddressKeydown(event, ${windowId})" />
            </div>
            <div class="browser-nav-buttons" style="margin-left: 8px;">
              <button class="browser-nav-button ${isVerticalTabs ? 'active' : ''}" title="Toggle Vertical Tabs" onclick="window.toggleBrowserVerticalTabs()" style="${isVerticalTabs ? 'background: hsl(var(--primary) / 0.2);' : ''}">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="3" y="3" width="18" height="18" rx="2"/>
                  <path d="M9 3v18"/>
                </svg>
              </button>
              <button class="browser-nav-button ${state.showBrowserHistory ? 'active' : ''}" title="Search History" onclick="window.toggleBrowserHistory()" style="${state.showBrowserHistory ? 'background: hsl(var(--primary) / 0.2);' : ''}">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <circle cx="12" cy="12" r="10"/>
                  <polyline points="12 6 12 12 16 14"/>
                </svg>
              </button>
            </div>
          </div>
        `;
        
        // Generate tab content (just wrappers, we'll restore iframes)
        const generateTabContentWrappers = () => tabs.map(tab => {
          const isActive = tab.active;
          return `
            <div class="browser-tab-iframe-wrapper ${isActive ? 'active' : ''}" data-tab-id="${tab.id}">
              ${tab.url ? `
                <div class="iframe-click-interceptor" onclick="event.stopPropagation(); window.focusWindow(${windowId}); const iframe = this.parentElement.querySelector('iframe'); if(iframe) { iframe.focus(); if(iframe.contentWindow) iframe.contentWindow.focus(); }"></div>
                <div class="browser-iframe-blocker" onclick="window.browserBlockerClick(this)"></div>
                <iframe class="browser-iframe" id="browser-iframe-${windowId}-${tab.id}" src="${tab.url}" 
                  sandbox="allow-same-origin allow-scripts allow-popups allow-forms allow-top-navigation allow-pointer-lock" 
                  allow="fullscreen; gamepad" tabindex="0"
                  onload="window.onBrowserTabLoad(${windowId}, ${tab.id})"></iframe>
              ` : getBrowserHomeContent(windowId)}
            </div>
          `;
        }).join('');
        
        // Build new layout
        if (isVerticalTabs) {
          browserContainer.className = 'browser-container vertical-tabs';
          browserContainer.innerHTML = `
            <div class="browser-sidebar">
              <div class="browser-tabs-container">
                ${generateTabs()}
                <button class="browser-new-tab-btn" onclick="window.createBrowserTab(${windowId})" title="New Tab">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 18px; height: 18px;">
                    <path d="M12 5v14M5 12h14" stroke-linecap="round"/>
                  </svg>
                  <span style="margin-left: 8px; font-size: 13px;">New Tab</span>
                </button>
              </div>
            </div>
            <div class="browser-main">
              <div class="browser-header" onmouseenter="window.browserHeaderEnter(this)" onmouseleave="window.browserHeaderLeave(this)">
                ${generateBookmarksBar()}
                ${generateToolbar()}
              </div>
              <div class="browser-content-wrapper" style="position: relative;">
                <div class="browser-tab-iframes">
                  ${generateTabContentWrappers()}
                </div>
              </div>
            </div>
          `;
        } else {
          browserContainer.className = 'browser-container';
          browserContainer.innerHTML = `
            <div class="browser-header" onmouseenter="window.browserHeaderEnter(this)" onmouseleave="window.browserHeaderLeave(this)">
              <div class="browser-tabs-container">
                ${generateTabs()}
                <button class="browser-new-tab-btn" onclick="window.createBrowserTab(${windowId})" title="New Tab">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 18px; height: 18px;">
                    <path d="M12 5v14M5 12h14" stroke-linecap="round"/>
                  </svg>
                </button>
              </div>
              ${generateBookmarksBar()}
              ${generateToolbar()}
            </div>
            <div class="browser-content-wrapper" style="position: relative;">
              <div class="browser-tab-iframes">
                ${generateTabContentWrappers()}
              </div>
            </div>
          `;
        }
      };

      window.browserBack = function browserBack(windowId) {
        if (!state.browserHistory[windowId] || state.browserHistoryIndex[windowId] <= 0) return;

        state.browserHistoryIndex[windowId]--;
        const url = state.browserHistory[windowId][state.browserHistoryIndex[windowId]];
        
        // Update the active tab with the new URL
        const activeTab = state.browserTabs[windowId]?.find(t => t.active);
        if (activeTab) {
          activeTab.url = url;
          activeTab.loading = true;
          try {
            const urlObj = new URL(url);
            activeTab.title = urlObj.hostname.replace('www.', '');
            activeTab.favicon = `https://www.google.com/s2/favicons?domain=${urlObj.hostname}&sz=32`;
          } catch (e) {
            activeTab.title = url.substring(0, 20);
          }
        }
        
        state.browserUrls[windowId] = url;
        state.inputValues[windowId] = url;
        
        // Navigate the current tab
        navigateCurrentTab(windowId, url);
      };

      window.browserForward = function browserForward(windowId) {
        if (!state.browserHistory[windowId] || state.browserHistoryIndex[windowId] >= state.browserHistory[windowId].length - 1) return;

        state.browserHistoryIndex[windowId]++;
        const url = state.browserHistory[windowId][state.browserHistoryIndex[windowId]];
        
        // Update the active tab with the new URL
        const activeTab = state.browserTabs[windowId]?.find(t => t.active);
        if (activeTab) {
          activeTab.url = url;
          activeTab.loading = true;
          try {
            const urlObj = new URL(url);
            activeTab.title = urlObj.hostname.replace('www.', '');
            activeTab.favicon = `https://www.google.com/s2/favicons?domain=${urlObj.hostname}&sz=32`;
          } catch (e) {
            activeTab.title = url.substring(0, 20);
          }
        }
        
        state.browserUrls[windowId] = url;
        state.inputValues[windowId] = url;
        
        // Navigate the current tab
        navigateCurrentTab(windowId, url);
      };

      window.browserRefresh = function browserRefresh(windowId) {
        const activeTab = state.browserTabs[windowId]?.find(t => t.active);
        if (!activeTab || !activeTab.url) return;

        const iframe = document.getElementById(`browser-iframe-${windowId}-${activeTab.id}`);
        if (iframe) {
          activeTab.loading = true;
          iframe.src = iframe.src; // Force reload
          
          // Show loading indicator
          const windowEl = document.getElementById(`window-${windowId}`);
          if (windowEl) {
            const tabEl = windowEl.querySelector(`.browser-tab[data-tab-id="${activeTab.id}"]`);
            if (tabEl && !tabEl.querySelector('.browser-tab-loading')) {
              const loader = document.createElement('div');
              loader.className = 'browser-tab-loading';
              tabEl.insertBefore(loader, tabEl.firstChild);
            }
          }
        }
      };

      // Update browser UI without re-rendering the whole OS (prevents iframe reload)
      function updateBrowserDom(windowId) {
        const windowEl = document.getElementById(`window-${windowId}`);
        if (!windowEl) return false;

        const tabs = state.browserTabs[windowId] || [];

        // Address bar
        const addressInput = windowEl.querySelector(`.browser-address-input[data-window-id="${windowId}"]`);
        if (addressInput && typeof state.inputValues[windowId] === 'string') {
          addressInput.value = state.inputValues[windowId];
        }

        // Tabs (only safe to update if counts match  otherwise fall back to forceRenderBrowser)
        const tabEls = Array.from(windowEl.querySelectorAll('.browser-tab'));
        if (tabEls.length && tabEls.length !== tabs.length) return false;

        if (tabEls.length && tabs.length) {
          tabEls.forEach((el, idx) => {
            const tab = tabs[idx];
            el.classList.toggle('active', !!tab.active);
            const titleEl = el.querySelector('.browser-tab-title');
            if (titleEl) titleEl.textContent = tab.title;
          });
        }

        // Content
        const url = state.browserUrls[windowId] || '';
        const iframe = windowEl.querySelector(`#browser-iframe-${windowId}`);

        // If we're in iframe view, just change src (no full re-render)
        if (iframe && url) {
          if (iframe.getAttribute('src') !== url) iframe.setAttribute('src', url);
          return true;
        }

        // If we're not in iframe view but url is set (or url cleared back to home), we need a render
        const hasIframeView = !!iframe;
        if ((url && !hasIframeView) || (!url && hasIframeView)) return false;

        return true;
      }
      window.updateBrowserDom = updateBrowserDom;

      // Force re-render just the browser window content (preserves other windows' iframes)
      function forceRenderBrowser(windowId) {
        const windowEl = document.getElementById(`window-${windowId}`);
        if (!windowEl) {
          render();
          return;
        }
        
        const contentEl = windowEl.querySelector('.window-content');
        if (!contentEl) {
          render();
          return;
        }
        
        // Re-generate just the browser content
        contentEl.innerHTML = getWindowContent('browser');
      }
      window.forceRenderBrowser = forceRenderBrowser;

      // ========== BROWSER UI INTERACTION SYSTEM ==========
      // Prevents iframe from stealing mouse events when user interacts with browser chrome
      
      window.suspendBrowserIframe = function(element) {
        const container = element.closest('.browser-container');
        if (container) container.classList.add('ui-active');
      };
      
      window.resumeBrowserIframe = function(element) {
        const container = element.closest('.browser-container');
        if (container) container.classList.remove('ui-active');
      };
      
      // Called when mouse enters browser header - blocks iframe clicks
      window.browserHeaderEnter = function(header) {
        const container = header.closest('.browser-container');
        if (container) container.classList.add('ui-active');
      };
      
      // Called when mouse leaves browser header - unblocks iframe clicks
      window.browserHeaderLeave = function(header) {
        const container = header.closest('.browser-container');
        if (container) container.classList.remove('ui-active');
      };
      
      // Click on blocker dismisses it and focuses iframe
      window.browserBlockerClick = function(blocker) {
        const container = blocker.closest('.browser-container');
        if (container) {
          container.classList.remove('ui-active');
          const iframe = container.querySelector('.browser-iframe');
          if (iframe) iframe.focus();
        }
      };

      // ========== BROWSER TAB FUNCTIONS ==========
      
      window.initBrowserTabs = function(windowId) {
        if (!state.browserTabs[windowId]) {
          state.browserTabs[windowId] = [{
            id: Date.now(),
            title: 'New Tab',
            url: '',
            active: true,
            loading: false,
            favicon: null
          }];
        }
        if (!state.browserTabIframes[windowId]) {
          state.browserTabIframes[windowId] = {};
        }
      };

      window.createBrowserTab = function createBrowserTab(windowId) {
        initBrowserTabs(windowId);
        const newTab = {
          id: Date.now(),
          title: 'New Tab',
          url: '',
          active: true,
          loading: false,
          favicon: null
        };
        
        // Set all other tabs to inactive
        state.browserTabs[windowId].forEach(tab => tab.active = false);
        state.browserTabs[windowId].push(newTab);
        
        // Clear current URL for this window
        state.browserUrls[windowId] = '';
        state.inputValues[windowId] = '';
        
        // Update DOM directly for tab switching (preserve existing iframes)
        updateBrowserTabsDom(windowId);
      };

      window.switchBrowserTab = function switchBrowserTab(windowId, tabId) {
        if (!state.browserTabs[windowId]) return;

        state.browserTabs[windowId].forEach(tab => {
          tab.active = (tab.id === tabId);
          if (tab.active) {
            state.browserUrls[windowId] = tab.url;
            state.inputValues[windowId] = tab.url;
          }
        });

        // Update DOM directly - just toggle visibility of tab wrappers
        updateBrowserTabsDom(windowId);
      };

      window.closeBrowserTab = function closeBrowserTab(event, windowId, tabId) {
        event.stopPropagation();
        
        if (!state.browserTabs[windowId]) return;
        const tabs = state.browserTabs[windowId];
        
        // Don't allow closing the last tab
        if (tabs.length === 1) return;
        
        const tabIndex = tabs.findIndex(t => t.id === tabId);
        const wasActive = tabs[tabIndex].active;
        
        // Remove the preserved iframe for this tab
        if (state.browserTabIframes[windowId]) {
          delete state.browserTabIframes[windowId][tabId];
        }
        
        tabs.splice(tabIndex, 1);
        
        // If we closed the active tab, activate another one
        if (wasActive && tabs.length > 0) {
          const newActiveTab = tabs[Math.max(0, tabIndex - 1)];
          newActiveTab.active = true;
          state.browserUrls[windowId] = newActiveTab.url;
          state.inputValues[windowId] = newActiveTab.url;
        }
        
        // Update DOM directly
        updateBrowserTabsDom(windowId);
      };

      // Update browser tabs DOM without full re-render (preserves iframes)
      window.updateBrowserTabsDom = function updateBrowserTabsDom(windowId) {
        const windowEl = document.getElementById(`window-${windowId}`);
        if (!windowEl) {
          forceRenderBrowser(windowId);
          return;
        }

        const tabs = state.browserTabs[windowId] || [];
        const activeTab = tabs.find(t => t.active);
        
        // Update tabs bar
        const tabsContainer = windowEl.querySelector('.browser-tabs-container');
        if (tabsContainer) {
          const tabElements = tabsContainer.querySelectorAll('.browser-tab');
          
          // If tab count changed, we need to rebuild tabs bar only
          if (tabElements.length !== tabs.length) {
            // Rebuild just the tabs
            const newTabsHtml = tabs.map(tab => `
              <div class="browser-tab ${tab.active ? 'active' : ''}" data-tab-id="${tab.id}" onclick="window.switchBrowserTab(${windowId}, ${tab.id})">
                ${tab.loading ? '<div class="browser-tab-loading"></div>' : (tab.favicon ? `<img class="browser-tab-favicon" src="${tab.favicon}" alt="" />` : '')}
                <span class="browser-tab-title">${tab.title}</span>
                <div class="browser-tab-close" onclick="window.closeBrowserTab(event, ${windowId}, ${tab.id})">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 12px; height: 12px;">
                    <path d="M18 6L6 18M6 6l12 12" stroke-linecap="round"/>
                  </svg>
                </div>
              </div>
            `).join('');
            
            // Find new tab button and preserve it
            const newTabBtn = tabsContainer.querySelector('.browser-new-tab-btn');
            const newTabBtnHtml = newTabBtn ? newTabBtn.outerHTML : '';
            
            tabsContainer.innerHTML = newTabsHtml + newTabBtnHtml;
          } else {
            // Just update active states
            tabElements.forEach((el, idx) => {
              const tab = tabs[idx];
              el.classList.toggle('active', !!tab.active);
              const titleEl = el.querySelector('.browser-tab-title');
              if (titleEl) titleEl.textContent = tab.title;
              
              // Update loading indicator
              const existingLoader = el.querySelector('.browser-tab-loading');
              const existingFavicon = el.querySelector('.browser-tab-favicon');
              
              if (tab.loading && !existingLoader) {
                const loader = document.createElement('div');
                loader.className = 'browser-tab-loading';
                el.insertBefore(loader, el.firstChild);
                if (existingFavicon) existingFavicon.remove();
              } else if (!tab.loading && existingLoader) {
                existingLoader.remove();
              }
            });
          }
        }

        // Update address bar - only if NOT focused to avoid overwriting user input
        const addressInput = windowEl.querySelector(`.browser-address-input[data-window-id="${windowId}"]`);
        if (addressInput && document.activeElement !== addressInput) {
          addressInput.value = state.inputValues[windowId] || '';
        }

        // Update iframe content area - show/hide per-tab wrappers
        const iframesContainer = windowEl.querySelector('.browser-tab-iframes');
        if (iframesContainer) {
          // Ensure we have wrappers for all tabs
          tabs.forEach(tab => {
            let wrapper = iframesContainer.querySelector(`[data-tab-id="${tab.id}"]`);
            
            if (!wrapper) {
              // Create wrapper for this tab
              wrapper = document.createElement('div');
              wrapper.className = 'browser-tab-iframe-wrapper';
              wrapper.dataset.tabId = tab.id;
              
              if (tab.url) {
                // Create iframe for this tab
                const iframe = document.createElement('iframe');
                iframe.className = 'browser-iframe';
                iframe.id = `browser-iframe-${windowId}-${tab.id}`;
                iframe.src = tab.url;
                iframe.sandbox = 'allow-same-origin allow-scripts allow-popups allow-forms allow-top-navigation allow-pointer-lock';
                iframe.allow = 'fullscreen; gamepad';
                iframe.tabIndex = 0;
                
                // Add load event to track loading state
                iframe.addEventListener('load', () => {
                  const t = state.browserTabs[windowId]?.find(x => x.id === tab.id);
                  if (t) {
                    t.loading = false;
                    // Try to extract title
                    try {
                      if (iframe.contentDocument && iframe.contentDocument.title) {
                        t.title = iframe.contentDocument.title.substring(0, 30);
                      }
                    } catch (e) {
                      // Cross-origin, use domain
                    }
                    // Update tab display
                    const tabEl = windowEl.querySelector(`.browser-tab[data-tab-id="${tab.id}"]`);
                    if (tabEl) {
                      const loader = tabEl.querySelector('.browser-tab-loading');
                      if (loader) loader.remove();
                      const titleEl = tabEl.querySelector('.browser-tab-title');
                      if (titleEl) titleEl.textContent = t.title;
                    }
                  }
                });
                
                wrapper.appendChild(iframe);
                state.browserTabIframes[windowId] = state.browserTabIframes[windowId] || {};
                state.browserTabIframes[windowId][tab.id] = iframe;
              } else {
                // Home page content
                wrapper.innerHTML = getBrowserHomeContent(windowId);
              }
              
              iframesContainer.appendChild(wrapper);
            }
            
            // Toggle visibility
            wrapper.classList.toggle('active', tab.active);
            
            // If this is active tab and URL changed, update iframe src
            if (tab.active && tab.url) {
              const iframe = wrapper.querySelector('iframe');
              if (iframe && iframe.src !== tab.url) {
                tab.loading = true;
                iframe.src = tab.url;
                // Update loading indicator
                const tabEl = windowEl.querySelector(`.browser-tab[data-tab-id="${tab.id}"]`);
                if (tabEl && !tabEl.querySelector('.browser-tab-loading')) {
                  const loader = document.createElement('div');
                  loader.className = 'browser-tab-loading';
                  tabEl.insertBefore(loader, tabEl.firstChild);
                }
              }
            }
          });
          
          // Remove wrappers for closed tabs
          const wrappers = iframesContainer.querySelectorAll('.browser-tab-iframe-wrapper');
          wrappers.forEach(wrapper => {
            const tabId = parseInt(wrapper.dataset.tabId);
            if (!tabs.find(t => t.id === tabId)) {
              wrapper.remove();
            }
          });
        } else {
          // No iframes container yet - need to rebuild content
          forceRenderBrowser(windowId);
        }
      };

      // Generate home page content for a tab with M Search
      window.getBrowserHomeContent = function getBrowserHomeContent(windowId) {
        return `
          <div class="browser-home">
            <!-- M Search Engine -->
            <div class="m-search-container">
              <div class="m-search-logo">
                <div class="m-search-logo-circle">
                  <span class="m-search-logo-letter">M</span>
                </div>
                <span class="m-search-logo-text">Search</span>
              </div>
              <form class="m-search-form" onsubmit="window.performMSearch(event, ${windowId})">
                <div class="m-search-input-wrapper">
                  <svg class="m-search-input-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="11" cy="11" r="8"/>
                    <path d="m21 21-4.35-4.35"/>
                  </svg>
                  <input type="text" class="m-search-input" id="m-search-input-${windowId}" placeholder="Search with M Search or enter URL" autocomplete="off" />
                  <button type="submit" class="m-search-btn">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M5 12h14M12 5l7 7-7 7"/>
                    </svg>
                  </button>
                </div>
              </form>
            </div>
            
            <!-- Favourites Section -->
            <div style="max-width: 600px; margin: 8px auto 0; padding: 0 20px;">
              <div class="browser-sites-grid" style="max-width: 100%; margin: 0;">
                ${state.browserSavedSites.map((site, idx) => `
                  <div class="browser-site-card ${state.activeSiteIndex === idx ? 'show-actions' : ''}" 
                       onclick="if(!event.target.closest('.browser-site-edit, .browser-site-remove')){window.openSavedSite(${windowId}, '${site.url.replace(/'/g, "\\'")}')}"
                       oncontextmenu="event.preventDefault(); window.toggleSiteActions(${idx})">
                    <div class="browser-site-edit" onclick="event.stopPropagation(); window.openEditSiteDialog(${idx})" title="Edit">&#9998;</div>
                    <div class="browser-site-remove" onclick="event.stopPropagation(); window.removeSavedSite(${idx})">&#215;</div>
                    <div class="browser-site-icon">${site.icon || '&#127760;'}</div>
                    <div class="browser-site-title">${site.title}</div>
                  </div>
                `).join('')}
                <!-- Add Site Button -->
                <button class="browser-site-add" onclick="window.openAddSiteDialog()" title="Add favourite">
                  <div class="browser-site-add-icon">+</div>
                  <div class="browser-site-title">Add Site</div>
                </button>
              </div>
            </div>
          </div>
        `;
      };
      
      // M Search functions
      window.performMSearch = function performMSearch(event, windowId) {
        event.preventDefault();
        const input = document.getElementById('m-search-input-' + windowId);
        if (!input) return;
        
        const query = input.value.trim();
        if (!query) return;
        
        // Save to search history
        const historyEntry = { query: query, timestamp: Date.now() };
        state.browserSearchHistory.unshift(historyEntry);
        if (state.browserSearchHistory.length > 50) {
          state.browserSearchHistory = state.browserSearchHistory.slice(0, 50);
        }
        localStorage.setItem('browserSearchHistory', JSON.stringify(state.browserSearchHistory));
        
        // Use DuckDuckGo HTML which works in iframes
        const searchUrl = 'https://html.duckduckgo.com/html/?q=' + encodeURIComponent(query);
        
        // Navigate to search results
        navigateCurrentTab(windowId, searchUrl);
      };
      
      window.quickMSearch = function quickMSearch(windowId, query) {
        // Save to search history
        const historyEntry = { query: query, timestamp: Date.now() };
        state.browserSearchHistory.unshift(historyEntry);
        if (state.browserSearchHistory.length > 50) {
          state.browserSearchHistory = state.browserSearchHistory.slice(0, 50);
        }
        localStorage.setItem('browserSearchHistory', JSON.stringify(state.browserSearchHistory));
        
        // Use DuckDuckGo HTML
        const searchUrl = 'https://html.duckduckgo.com/html/?q=' + encodeURIComponent(query);
        navigateCurrentTab(windowId, searchUrl);
      };

      window.updateCurrentTabInfo = function updateCurrentTabInfo(windowId) {
        if (!state.browserTabs[windowId]) return;
        
        const activeTab = state.browserTabs[windowId].find(t => t.active);
        if (activeTab) {
          activeTab.url = state.browserUrls[windowId] || '';
          const url = activeTab.url;
          
          // Extract domain for title
          if (url) {
            try {
              const urlObj = new URL(url);
              activeTab.title = urlObj.hostname.replace('www.', '');
              // Try to get favicon
              activeTab.favicon = `https://www.google.com/s2/favicons?domain=${urlObj.hostname}&sz=32`;
            } catch (e) {
              activeTab.title = url.substring(0, 20);
            }
          } else {
            activeTab.title = 'New Tab';
            activeTab.favicon = null;
          }
        }
      };

      // Navigate current active tab to a URL (used by bookmarks, saved sites)
      window.navigateCurrentTab = function navigateCurrentTab(windowId, url) {
        if (!state.browserTabs[windowId]) return;
        
        const activeTab = state.browserTabs[windowId].find(t => t.active);
        if (!activeTab) return;
        
        // Set loading state
        activeTab.loading = true;
        activeTab.url = url;
        
        // Update state
        state.browserUrls[windowId] = url;
        // Only update inputValues if the address bar is not currently focused (user not editing)
        const addressInput = document.querySelector(`.browser-address-input[data-window-id="${windowId}"]`);
        if (!addressInput || document.activeElement !== addressInput) {
          state.inputValues[windowId] = url;
        }
        
        // Update tab info (title, favicon)
        try {
          const urlObj = new URL(url);
          activeTab.title = urlObj.hostname.replace('www.', '');
          activeTab.favicon = `https://www.google.com/s2/favicons?domain=${urlObj.hostname}&sz=32`;
        } catch (e) {
          activeTab.title = url.substring(0, 20);
        }
        
        // Update DOM - check if iframe exists for this tab
        const windowEl = document.getElementById(`window-${windowId}`);
        if (windowEl) {
          const wrapper = windowEl.querySelector(`.browser-tab-iframe-wrapper[data-tab-id="${activeTab.id}"]`);
          if (wrapper) {
            let iframe = wrapper.querySelector('iframe');
            if (!iframe) {
              // Create iframe (tab was on home page)
              wrapper.innerHTML = `
                <div class="browser-iframe-blocker" onclick="window.browserBlockerClick(this)"></div>
                <iframe class="browser-iframe" id="browser-iframe-${windowId}-${activeTab.id}" src="${url}" 
                  sandbox="allow-same-origin allow-scripts allow-popups allow-forms allow-top-navigation allow-pointer-lock" 
                  allow="fullscreen; gamepad" tabindex="0"
                  onload="window.onBrowserTabLoad(${windowId}, ${activeTab.id})"></iframe>
              `;
            } else {
              // Update existing iframe src
              iframe.src = url;
            }
          }
          
          // Update tab UI
          const tabEl = windowEl.querySelector(`.browser-tab[data-tab-id="${activeTab.id}"]`);
          if (tabEl) {
            // Add loading spinner
            if (!tabEl.querySelector('.browser-tab-loading')) {
              const loader = document.createElement('div');
              loader.className = 'browser-tab-loading';
              tabEl.insertBefore(loader, tabEl.firstChild);
            }
            // Update title
            const titleEl = tabEl.querySelector('.browser-tab-title');
            if (titleEl) titleEl.textContent = activeTab.title;
          }
          
          // Update address bar
          const addressInput = windowEl.querySelector(`.browser-address-input[data-window-id="${windowId}"]`);
          if (addressInput) addressInput.value = url;
        }
      };

      // Handle iframe load event
      window.onBrowserTabLoad = function onBrowserTabLoad(windowId, tabId) {
        const tab = state.browserTabs[windowId]?.find(t => t.id === tabId);
        if (!tab) return;
        
        tab.loading = false;
        
        // Update tab UI - remove loading spinner
        const windowEl = document.getElementById(`window-${windowId}`);
        if (windowEl) {
          const tabEl = windowEl.querySelector(`.browser-tab[data-tab-id="${tabId}"]`);
          if (tabEl) {
            const loader = tabEl.querySelector('.browser-tab-loading');
            if (loader) loader.remove();
            
            // Add favicon if not present
            if (tab.favicon && !tabEl.querySelector('.browser-tab-favicon')) {
              const favicon = document.createElement('img');
              favicon.className = 'browser-tab-favicon';
              favicon.src = tab.favicon;
              favicon.alt = '';
              favicon.onerror = () => { favicon.style.display = 'none'; };
              tabEl.insertBefore(favicon, tabEl.firstChild);
            }
          }
        }
      };

      // Bookmark Functions
      window.addBookmark = function addBookmark(url) {
        if (!state.browserBookmarks.includes(url)) {
          state.browserBookmarks.push(url);
          localStorage.setItem('browserBookmarks', JSON.stringify(state.browserBookmarks));
          render();
        }
      };

      window.openBookmark = function openBookmark(windowId, url) {
        navigateCurrentTab(windowId, url);
      };

      window.openSavedSite = function openSavedSite(windowId, url) {
        navigateCurrentTab(windowId, url);
      };

      // Add Site Functions
      window.openAddSiteDialog = function openAddSiteDialog() {
        state.showAddSiteDialog = true;
        render();
        // Focus the first input after render
        setTimeout(() => {
          const input = document.getElementById('add-site-title');
          if (input) input.focus();
        }, 50);
      };

      window.closeAddSiteDialog = function closeAddSiteDialog() {
        state.showAddSiteDialog = false;
        render();
      };

      window.addSavedSite = function addSavedSite() {
        const title = document.getElementById('add-site-title').value.trim();
        const url = document.getElementById('add-site-url').value.trim();
        
        if (!title || !url) {
          alert('Please fill in both title and URL');
          return;
        }
        
        // Add protocol if missing
        let fullUrl = url;
        if (!url.startsWith('http://') && !url.startsWith('https://')) {
          fullUrl = 'https://' + url;
        }
        
        // Try to fetch favicon
        const icon = ''; // Default icon
        
        // Try to get favicon from the URL
        try {
          const urlObj = new URL(fullUrl);
          const faviconUrl = `https://www.google.com/s2/favicons?domain=${urlObj.hostname}&sz=64`;
          
          // Create an image element to check if favicon loads
          const img = new Image();
          img.onload = function() {
            // Favicon loaded successfully, use it
            const newSite = { 
              title, 
              url: fullUrl, 
              icon: `<img src="${faviconUrl}" style="width: 32px; height: 32px; object-fit: contain;" alt="${title}" />` 
            };
            state.browserSavedSites.push(newSite);
            localStorage.setItem('browserSavedSites', JSON.stringify(state.browserSavedSites));
            state.showAddSiteDialog = false;
            render();
          };
          img.onerror = function() {
            // Favicon failed to load, use default icon
            const newSite = { title, url: fullUrl, icon };
            state.browserSavedSites.push(newSite);
            localStorage.setItem('browserSavedSites', JSON.stringify(state.browserSavedSites));
            state.showAddSiteDialog = false;
            render();
          };
          img.src = faviconUrl;
        } catch (e) {
          // If URL parsing fails, use default icon
          const newSite = { title, url: fullUrl, icon };
          state.browserSavedSites.push(newSite);
          localStorage.setItem('browserSavedSites', JSON.stringify(state.browserSavedSites));
          state.showAddSiteDialog = false;
          render();
        }
      };

      window.removeSavedSite = function removeSavedSite(index) {
        if (confirm('Remove this shortcut?')) {
          state.browserSavedSites.splice(index, 1);
          localStorage.setItem('browserSavedSites', JSON.stringify(state.browserSavedSites));
          render();
        }
      };

      // Bookmark Edit Functions
      window.openAddBookmarkDialog = function openAddBookmarkDialog() {
        state.showEditBookmarkDialog = true;
        state.editingBookmarkIndex = null;
        render();
        setTimeout(() => {
          const input = document.getElementById('edit-bookmark-url');
          if (input) input.focus();
        }, 50);
      };

      window.openEditBookmarkDialog = function openEditBookmarkDialog(index) {
        state.showEditBookmarkDialog = true;
        state.editingBookmarkIndex = index;
        render();
        setTimeout(() => {
          const input = document.getElementById('edit-bookmark-url');
          if (input) {
            input.value = state.browserBookmarks[index];
            input.focus();
          }
        }, 50);
      };

      window.closeEditBookmarkDialog = function closeEditBookmarkDialog() {
        state.showEditBookmarkDialog = false;
        state.editingBookmarkIndex = null;
        render();
      };

      window.saveBookmark = function saveBookmark() {
        const url = document.getElementById('edit-bookmark-url').value.trim();
        
        if (!url) {
          alert('Please enter a URL');
          return;
        }
        
        // Add protocol if missing
        let fullUrl = url;
        if (!url.startsWith('http://') && !url.startsWith('https://')) {
          fullUrl = 'https://' + url;
        }
        
        if (state.editingBookmarkIndex !== null) {
          // Editing existing bookmark
          state.browserBookmarks[state.editingBookmarkIndex] = fullUrl;
        } else {
          // Adding new bookmark
          state.browserBookmarks.push(fullUrl);
        }
        
        localStorage.setItem('browserBookmarks', JSON.stringify(state.browserBookmarks));
        state.showEditBookmarkDialog = false;
        state.editingBookmarkIndex = null;
        render();
      };

      window.removeBookmark = function removeBookmark(index) {
        if (confirm('Remove this bookmark?')) {
          state.browserBookmarks.splice(index, 1);
          localStorage.setItem('browserBookmarks', JSON.stringify(state.browserBookmarks));
          render();
        }
      };

      // Saved Site Edit Functions
      window.openEditSiteDialog = function openEditSiteDialog(index) {
        state.showEditSiteDialog = true;
        state.editingSiteIndex = index;
        render();
        setTimeout(() => {
          const titleInput = document.getElementById('edit-site-title');
          const urlInput = document.getElementById('edit-site-url');
          if (titleInput && urlInput) {
            const site = state.browserSavedSites[index];
            titleInput.value = site.title;
            urlInput.value = site.url;
            titleInput.focus();
          }
        }, 50);
      };

      window.closeEditSiteDialog = function closeEditSiteDialog() {
        state.showEditSiteDialog = false;
        state.editingSiteIndex = null;
        render();
      };

      window.saveEditedSite = function saveEditedSite() {
        const title = document.getElementById('edit-site-title').value.trim();
        const url = document.getElementById('edit-site-url').value.trim();
        
        if (!title || !url) {
          alert('Please fill in both title and URL');
          return;
        }
        
        // Add protocol if missing
        let fullUrl = url;
        if (!url.startsWith('http://') && !url.startsWith('https://')) {
          fullUrl = 'https://' + url;
        }
        
        // Update the site
        const icon = state.browserSavedSites[state.editingSiteIndex].icon || '';
        
        // Try to fetch new favicon
        try {
          const urlObj = new URL(fullUrl);
          const faviconUrl = `https://www.google.com/s2/favicons?domain=${urlObj.hostname}&sz=64`;
          
          const img = new Image();
          img.onload = function() {
            state.browserSavedSites[state.editingSiteIndex] = { 
              title, 
              url: fullUrl, 
              icon: `<img src="${faviconUrl}" style="width: 32px; height: 32px; object-fit: contain;" alt="${title}" />` 
            };
            localStorage.setItem('browserSavedSites', JSON.stringify(state.browserSavedSites));
            state.showEditSiteDialog = false;
            state.editingSiteIndex = null;
            render();
          };
          img.onerror = function() {
            state.browserSavedSites[state.editingSiteIndex] = { title, url: fullUrl, icon };
            localStorage.setItem('browserSavedSites', JSON.stringify(state.browserSavedSites));
            state.showEditSiteDialog = false;
            state.editingSiteIndex = null;
            render();
          };
          img.src = faviconUrl;
        } catch (e) {
          state.browserSavedSites[state.editingSiteIndex] = { title, url: fullUrl, icon };
          localStorage.setItem('browserSavedSites', JSON.stringify(state.browserSavedSites));
          state.showEditSiteDialog = false;
          state.editingSiteIndex = null;
          render();
        }
      };

      // Toggle bookmark actions on right-click
      window.toggleBookmarkActions = function toggleBookmarkActions(index) {
        if (state.activeBookmarkIndex === index) {
          state.activeBookmarkIndex = null;
        } else {
          state.activeBookmarkIndex = index;
        }
        render();
      };

      // Toggle site actions on right-click
      window.toggleSiteActions = function toggleSiteActions(index) {
        if (state.activeSiteIndex === index) {
          state.activeSiteIndex = null;
        } else {
          state.activeSiteIndex = index;
        }
        render();
      };

      // New efficient function to update only terminal content
      window.updateTerminalContent = function updateTerminalContent(terminalId, scrollToBottom = true) {
        const terminalContent = document.querySelector(`.terminal-content[data-terminal-id="${terminalId}"]`);
        if (!terminalContent) return;
        
        // Save current scroll position
        const wasAtBottom = terminalContent.scrollHeight - terminalContent.scrollTop <= terminalContent.clientHeight + 10;
        
        const history = state.terminalHistory[terminalId] || [];
        const terminalInput = terminalContent.querySelector('.terminal-input');
        const savedValue = terminalInput ? terminalInput.value : '';
        
        // Update only the terminal content div
        terminalContent.innerHTML = `
          ${history.join('')}
          <div class="terminal-input-line" style="margin-top: 10px;">
            <span>user@mos ~ %</span>
            <input class="terminal-input" data-terminal-id="${terminalId}" type="text" value="${savedValue}" autofocus onkeydown="handleTerminalKeydown(event, ${terminalId})" onclick="event.stopPropagation()" />
          </div>
        `;
        
        // Restore focus
        const newInput = terminalContent.querySelector('.terminal-input');
        if (newInput) {
          newInput.focus();
          // Only scroll to bottom if explicitly requested or if user was already at the bottom
          if (scrollToBottom || wasAtBottom) {
            terminalContent.scrollTop = terminalContent.scrollHeight;
            // Update saved scroll position
            state.scrollPositions[`terminal-${terminalId}`] = terminalContent.scrollHeight;
          }
        }
      };

      // Handle arrow key navigation and enter key
      window.handleTerminalKeydown = function handleTerminalKeydown(e, terminalId) {
        const input = e.target;
        
        // Arrow Up - Navigate to previous command
        if (e.key === 'ArrowUp') {
          e.preventDefault();
          playSound('terminal-key');
          if (state.commandHistory.length === 0) return;
          
          if (state.commandHistoryIndex === -1) {
            // Save current input before navigating history
            state.inputValues[`terminal-${terminalId}`] = input.value;
            state.commandHistoryIndex = state.commandHistory.length - 1;
          } else if (state.commandHistoryIndex > 0) {
            state.commandHistoryIndex--;
          }
          
          input.value = state.commandHistory[state.commandHistoryIndex];
          // Move cursor to end
          setTimeout(() => input.setSelectionRange(input.value.length, input.value.length), 0);
          return;
        }
        
        // Arrow Down - Navigate to next command
        if (e.key === 'ArrowDown') {
          e.preventDefault();
          playSound('terminal-key');
          if (state.commandHistory.length === 0) return;
          
          if (state.commandHistoryIndex !== -1) {
            state.commandHistoryIndex++;
            
            if (state.commandHistoryIndex >= state.commandHistory.length) {
              // Reached the end, restore original input
              state.commandHistoryIndex = -1;
              input.value = state.inputValues[`terminal-${terminalId}`] || '';
            } else {
              input.value = state.commandHistory[state.commandHistoryIndex];
            }
            // Move cursor to end
            setTimeout(() => input.setSelectionRange(input.value.length, input.value.length), 0);
          }
          return;
        }
        
        // Play terminal key sound for regular keypresses
        if (e.key.length === 1 || e.key === 'Backspace' || e.key === 'Delete') {
          playSound('terminal-key');
        }
        
        // Enter key - Execute command
        if (e.key === 'Enter') {
          handleTerminalInput(e, terminalId);
        }
      };

      window.handleTerminalInput = function handleTerminalInput(e, terminalId) {
        const input = e.target.value.trim();
        playSound('terminal-enter');
        
        // Reset history navigation
        state.commandHistoryIndex = -1;
        
        // Add command to history
        if (!state.terminalHistory[terminalId]) {
          state.terminalHistory[terminalId] = [];
        }
        
        state.terminalHistory[terminalId].push(`<div style="color: #0f0; margin-top: 10px;">user@mos ~ % ${input}</div>`);

        // Save command to command history if not empty
        if (input !== '') {
          // Avoid duplicate consecutive commands
          if (state.commandHistory[state.commandHistory.length - 1] !== input) {
            state.commandHistory.push(input);
            // Keep only last 100 commands
            if (state.commandHistory.length > 100) {
              state.commandHistory.shift();
            }
            // Save to localStorage
            localStorage.setItem('commandHistory', JSON.stringify(state.commandHistory));
          }
        }

        if (input === 'help') {
          state.terminalHistory[terminalId].push(`
            <div style="color: #0f0;">Available commands:</div>
            <div style="color: #0f0;">  clear        - Clear the terminal</div>
            <div style="color: #0f0;">  date         - Display current date and time</div>
            <div style="color: #0f0;">  whoami       - Display current user</div>
            <div style="color: #0f0;">  fastfetch    - Display system information</div>
            <div style="color: #0f0;">  history      - Show command history</div>
            <div style="color: #0f0;">  mget install - Install apps (try: mget install minecraft)</div>
            <div style="color: #0f0;">  mget list    - List available apps</div>
            <div style="color: #0f0;">  mget remove  - Uninstall apps</div>
            <div style="color: #0f0;">  help         - Display this help message</div>
            <div style="color: #888; margin-top: 8px; font-size: 12px;">Use  arrow keys to navigate command history</div>
          `);
        } else if (input === 'clear') {
          state.terminalHistory[terminalId] = [];
        } else if (input === 'history') {
          if (state.commandHistory.length === 0) {
            state.terminalHistory[terminalId].push(`<div style="color: #888;">No command history yet</div>`);
          } else {
            state.terminalHistory[terminalId].push(`<div style="color: #0f0;">Command History:</div>`);
            state.commandHistory.forEach((cmd, i) => {
              state.terminalHistory[terminalId].push(`<div style="color: #0f0;">  ${i + 1}. ${cmd}</div>`);
            });
          }
        } else if (input === 'date') {
          state.terminalHistory[terminalId].push(`<div style="color: #0f0;">${new Date().toString()}</div>`);
        } else if (input === 'whoami') {
          const username = localStorage.getItem('mos_username') || 'user';
          state.terminalHistory[terminalId].push(`<div style="color: #0f0;">${username.toLowerCase().replace(/\s+/g, '')}</div>`);
        } else if (input === 'fastfetch') {
          const userAgent = navigator.userAgent;
          const platform = navigator.platform;
          const browserInfo = (() => {
            if (userAgent.includes('Firefox')) return 'Firefox';
            if (userAgent.includes('Edg')) return 'Edge';
            if (userAgent.includes('Chrome')) return 'Chrome';
            if (userAgent.includes('Safari')) return 'Safari';
            return 'Unknown';
          })();
          
          const osInfo = (() => {
            if (platform.includes('Win')) return 'Windows';
            if (platform.includes('Mac')) return 'macOS';
            if (platform.includes('Linux')) return 'Linux';
            if (platform.includes('iPhone') || platform.includes('iPad')) return 'iOS';
            if (platform.includes('Android')) return 'Android';
            return 'Unknown';
          })();
          
          const ascii = `@@@@@@@@@@@@                       @@@@@@@@@@@@ 
@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@     @@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@    (@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@    (@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@    (@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@   /@@@@@@@@@@@    @@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@    @@@@@@@@@@@    @@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@    @@@@@@@@@@@    @@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@    @@@@@@@@@@@    @@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@    @@@@@@@@@@@    @@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@    #@@@@@@@@@,    @@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@`;
          
          const ffUsername = (localStorage.getItem('mos_username') || 'user').toLowerCase().replace(/\s+/g, '');
          const info = `<span style="color: #10B981;">${ffUsername}</span>@<span style="color: #10B981;">mos</span>

<span style="color: #60A5FA;">OS:</span> ${osInfo}
<span style="color: #60A5FA;">Host:</span> Web Desktop Environment
<span style="color: #60A5FA;">Kernel:</span> Browser-based OS
<span style="color: #60A5FA;">Shell:</span> MOS Terminal v1.0
<span style="color: #60A5FA;">Browser:</span> ${browserInfo}
<span style="color: #60A5FA;">Platform:</span> ${platform}
<span style="color: #60A5FA;">Resolution:</span> ${window.innerWidth}x${window.innerHeight}
<span style="color: #60A5FA;">Theme:</span> ${state.isDark ? 'Dark' : 'Light'}
<span style="color: #60A5FA;">WM:</span> MOS Window Manager
<span style="color: #60A5FA;">Uptime:</span> ${Math.floor(performance.now() / 1000)}s`;

          state.terminalHistory[terminalId].push(`<div style="color: #0f0; font-family: monospace; white-space: pre; line-height: 1.2; display: flex; gap: 20px;"><div style="color: #A78BFA;">${ascii}</div><div>${info}</div></div>`);
        } else if (input.startsWith('mget ')) {
          const args = input.slice(5).trim().split(' ');
          const subcommand = args[0];
          const packageName = args[1];
          
          if (subcommand === 'list') {
            const minecraftInstalled = state.installedApps && state.installedApps.includes('minecraft');
            state.terminalHistory[terminalId].push(`
              <div style="color: #0f0;">Available packages:</div>
              <div style="color: #0f0;">  minecraft    - Classic sandbox game ${minecraftInstalled ? '<span style="color: #4ade80;">(installed)</span>' : ''}</div>
              <div style="color: #888; margin-top: 8px;">Use 'mget install &lt;package&gt;' to install</div>
            `);
          } else if (subcommand === 'install') {
            if (!packageName) {
              state.terminalHistory[terminalId].push(`<div style="color: #ff6b6b;">Usage: mget install &lt;package&gt;</div><div style="color: #888;">Try: mget list</div>`);
            } else if (packageName === 'minecraft') {
              const minecraftInstalled = state.installedApps && state.installedApps.includes('minecraft');
              if (minecraftInstalled) {
                state.terminalHistory[terminalId].push(`<div style="color: #facc15;">minecraft is already installed</div>`);
              } else {
                state.terminalHistory[terminalId].push(`<div style="color: #60A5FA;">Installing minecraft...</div>`);
                updateTerminalContent(terminalId);
                // Trigger install
                window.installMinecraft().then(() => {
                  state.terminalHistory[terminalId].push(`<div style="color: #4ade80;"> minecraft installed successfully</div><div style="color: #888;">Run with: open minecraft</div>`);
                  localStorage.setItem('terminalHistory', JSON.stringify(state.terminalHistory));
                  updateTerminalContent(terminalId);
                }).catch((err) => {
                  state.terminalHistory[terminalId].push(`<div style="color: #ff6b6b;">Failed to install minecraft: ${err}</div>`);
                  localStorage.setItem('terminalHistory', JSON.stringify(state.terminalHistory));
                  updateTerminalContent(terminalId);
                });
              }
            } else {
              state.terminalHistory[terminalId].push(`<div style="color: #ff6b6b;">Package not found: ${packageName}</div><div style="color: #888;">Try: mget list</div>`);
            }
          } else if (subcommand === 'remove' || subcommand === 'uninstall') {
            if (!packageName) {
              state.terminalHistory[terminalId].push(`<div style="color: #ff6b6b;">Usage: mget remove &lt;package&gt;</div>`);
            } else if (packageName === 'minecraft') {
              const minecraftInstalled = state.installedApps && state.installedApps.includes('minecraft');
              if (!minecraftInstalled) {
                state.terminalHistory[terminalId].push(`<div style="color: #facc15;">minecraft is not installed</div>`);
              } else {
                window.uninstallMinecraft();
                state.terminalHistory[terminalId].push(`<div style="color: #4ade80;"> minecraft removed successfully</div>`);
              }
            } else {
              state.terminalHistory[terminalId].push(`<div style="color: #ff6b6b;">Package not found: ${packageName}</div>`);
            }
          } else {
            state.terminalHistory[terminalId].push(`<div style="color: #ff6b6b;">Unknown mget command: ${subcommand}</div><div style="color: #888;">Available: install, remove, list</div>`);
          }
        } else if (input !== '') {
          state.terminalHistory[terminalId].push(`<div style="color: #ff6b6b;">command not found: ${input}</div>`);
        }

        // Save terminal history to localStorage
        localStorage.setItem('terminalHistory', JSON.stringify(state.terminalHistory));

        // Clear input and update only this terminal (not the entire page)
        e.target.value = '';
        updateTerminalContent(terminalId);
      };

      let dragState = null;
      let resizeState = null;
      let isAltPressed = false;
      let dockDragState = null;
      
      // Expose states globally for cursor detection
      window.dragState = dragState;
      window.resizeState = resizeState;
      window.dockDragState = dockDragState;
      
      document.addEventListener('keydown', (e) => {
        if (e.altKey || e.key === 'Alt') {
          isAltPressed = true;
        }
        
        // Escape key exits fullscreen mode for any fullscreen window
        if (e.key === 'Escape') {
          const fullscreenWindow = state.windows.find(w => w.isFullscreen);
          if (fullscreenWindow) {
            e.preventDefault();
            window.toggleFullscreen(fullscreenWindow.id);
          }
        }
      });
      
      document.addEventListener('keyup', (e) => {
        if (!e.altKey && e.key === 'Alt') {
          isAltPressed = false;
        }
      });
      
      // Click handler to deactivate windows when clicking outside them
      // ONLY the desktop background should deactivate windows - NOT dock, menubar, etc.
      document.addEventListener('click', (e) => {
        // Skip if we're in the middle of a drag operation
        if (dragState || resizeState || dockDragState) {
          return;
        }
        
        // Skip if clicking on a window or window-related element
        if (e.target.closest('.window')) {
          return;
        }
        
        // Skip if clicking on dock icons - they handle focus themselves
        if (e.target.closest('.dock-icon') || e.target.closest('.dock') || e.target.closest('.dock-container')) {
          return;
        }
        
        // Skip if clicking on menubar
        if (e.target.closest('.menubar')) {
          return;
        }
        
        // Skip if clicking on context menu
        if (e.target.closest('.context-menu')) {
          return;
        }
        
        // Skip if clicking on quick settings panel
        if (e.target.closest('.quick-settings')) {
          return;
        }
        
        // Skip if clicking on notification panel
        if (e.target.closest('.notification-panel')) {
          return;
        }
        
        // Skip if clicking on launchpad
        if (e.target.closest('.launchpad-overlay')) {
          return;
        }
        
        // Skip if clicking on dialogs
        if (e.target.closest('.add-site-dialog-overlay')) {
          return;
        }
        
        // Only deactivate windows when clicking on the desktop background itself
        // Check if click is on the desktop-bg but not on any window or UI element
        const isOnDesktopBackground = e.target.closest('.desktop-bg') || e.target.closest('.desktop');
        if (isOnDesktopBackground) {
          window.deactivateAllWindows();
        }
      });

      document.addEventListener('mousedown', (e) => {
        // Don't interfere with titlebar buttons or input fields
        if (e.target.classList.contains('titlebar-button') ||
            e.target.tagName === 'INPUT' || 
            e.target.tagName === 'TEXTAREA' ||
            e.target.closest('.titlebar-button') ||
            e.target.closest('.terminal-content') ||
            e.target.closest('.browser-address-input')) {
          return;
        }

        if (e.target.classList.contains('resize-handle')) {
          const windowEl = e.target.closest('.window');
          const windowId = parseInt(windowEl.dataset.id, 10);
          const win = state.windows.find((w) => w.id === windowId);
          if (win) {
            const direction = e.target.classList[1]; // Get direction class (se, sw, ne, nw, n, s, e, w)
            resizeState = {
              id: windowId,
              direction: direction,
              startX: e.clientX,
              startY: e.clientY,
              startWidth: win.width,
              startHeight: win.height,
              startPosX: win.x,
              startPosY: win.y,
              resizeFromCenter: isAltPressed,
            };
            window.resizeState = resizeState;
            focusWindow(windowId);
            e.stopPropagation();
          }
          return;
        }

        const titlebar = e.target.closest('.titlebar');
        if (titlebar) {
          const windowEl = titlebar.closest('.window');
          const windowId = parseInt(windowEl.dataset.id, 10);
          const win = state.windows.find((w) => w.id === windowId);
          if (win) {
            // If window is maximized, store click position but don't unmaximize yet
            if (win.isMaximized) {
              // Store click start position to detect drag vs click
              dragState = {
                id: windowId,
                startX: e.clientX,
                startY: e.clientY,
                initialMouseX: e.clientX,
                initialMouseY: e.clientY,
                isMaximized: true,
                dragThreshold: 8, // Minimum pixels to move before starting drag
                hasMoved: false,
              };
              window.dragState = dragState;
              focusWindow(windowId);
              
            } else if (win.isSnapped && win.snapRestorePos) {
              // If window is snapped, store click position but don't unsnap yet - wait for drag
              dragState = {
                id: windowId,
                startX: e.clientX - win.x,
                startY: e.clientY - win.y,
                initialMouseX: e.clientX,
                initialMouseY: e.clientY,
                isSnapped: true,
                snapRestorePos: win.snapRestorePos,
                dragThreshold: 5, // Minimum pixels to move before unsnapping
                hasMoved: false,
              };
              window.dragState = dragState;
              focusWindow(windowId);
            } else {
              // Normal drag - add threshold to prevent accidental movement
              dragState = {
                id: windowId,
                startX: e.clientX - win.x,
                startY: e.clientY - win.y,
                initialMouseX: e.clientX,
                initialMouseY: e.clientY,
                isMaximized: false,
                dragThreshold: 5, // Minimum pixels to move before starting drag
                hasMoved: false,
              };
              window.dragState = dragState;
              focusWindow(windowId);
            }
          }
        }
      });

      document.addEventListener('mousemove', (e) => {
        if (dockDragState) {
          const icon = dockDragState.draggedElement;
          if (!icon) {
            dockDragState = null;
            return;
          }
          
          // Calculate movement maintaining the click offset
          dockDragState.currentX = e.clientX;
          const rawDeltaX = (e.clientX - dockDragState.offsetX) - dockDragState.initialIconLeft;
          
          // Get dock boundaries to constrain dragging
          const dock = document.querySelector('.dock');
          if (dock) {
            const dockRect = dock.getBoundingClientRect();
            const iconRect = icon.getBoundingClientRect();
            
            // Calculate maximum allowed deltaX (left and right boundaries)
            const maxLeft = dockRect.left - dockDragState.initialIconLeft;
            const maxRight = (dockRect.right - dockDragState.iconWidth) - dockDragState.initialIconLeft;
            
            // Constrain deltaX within dock boundaries
            dockDragState.deltaX = Math.max(maxLeft, Math.min(maxRight, rawDeltaX));
          } else {
            dockDragState.deltaX = rawDeltaX;
          }
          
          // Start dragging if moved beyond threshold
          if (!dockDragState.isDragging && Math.abs(dockDragState.deltaX) > dockDragState.dragThreshold) {
            dockDragState.isDragging = true;
            icon.classList.add("dragging");
            document.body.style.cursor = 'grabbing';
          }
          
          if (dockDragState.isDragging) {
            const dock = document.querySelector('.dock');
            if (dock) {
              // Get all dock icons in current DOM order (both pinned and unpinned)
              const allIcons = Array.from(dock.querySelectorAll('.dock-icon'));
              
              if (allIcons.length === 0) return;
              
              // Debounce swaps - only allow one swap every 100ms
              const now = Date.now();
              if (now - dockDragState.lastSwapTime < 100) {
                // Still update visual position (already constrained)
                icon.style.transform = `translateX(${dockDragState.deltaX}px) scale(1.15)`;
                icon.style.transition = 'none';
                icon.style.zIndex = '1000';
                return;
              }
              
              // Find which icon we should swap with
              const mouseX = e.clientX;
              let targetIcon = null;
              let targetIndex = -1;
              
              for (let i = 0; i < allIcons.length; i++) {
                const currentIcon = allIcons[i];
                if (currentIcon === icon) {
                  targetIndex = i;
                  continue;
                }
                
                const rect = currentIcon.getBoundingClientRect();
                const iconCenter = rect.left + rect.width / 2;
                
                // Check if mouse is past 60% of the icon's width (prevents glitchy back-and-forth)
                const threshold = rect.width * 0.6;
                
                if (mouseX >= rect.left && mouseX <= rect.right) {
                  // We're hovering over this icon
                  if (targetIndex < i && mouseX > iconCenter + threshold / 4) {
                    // Moving right, swap if past center
                    targetIcon = currentIcon;
                    break;
                  } else if (targetIndex > i && mouseX < iconCenter - threshold / 4) {
                    // Moving left, swap if past center
                    targetIcon = currentIcon;
                    break;
                  }
                }
              }
              
              // Perform the swap if we found a target
              if (targetIcon && targetIcon !== icon) {
                const targetIdx = allIcons.indexOf(targetIcon);
                const currentIdx = allIcons.indexOf(icon);
                
                if (targetIdx !== -1 && currentIdx !== -1 && targetIdx !== currentIdx) {
                  // Check if target is pinned or unpinned
                  const targetAppId = targetIcon.id.replace('dock-', '');
                  const draggedAppId = icon.id.replace('dock-', '');
                  
                  // Don't allow swapping with the app launcher (finder)
                  if (targetAppId === 'finder') {
                    // Update visual position but don't swap (already constrained)
                    icon.style.transform = `translateX(${dockDragState.deltaX}px) scale(1.15)`;
                    icon.style.transition = 'none';
                    icon.style.zIndex = '1000';
                    return;
                  }
                  
                  const targetIsPinned = state.pinnedApps.includes(targetAppId);
                  
                  // Handle pin/unpin when crossing boundaries
                  if (!dockDragState.isPinned && targetIsPinned) {
                    // Unpinned icon moving to pinned section - pin it
                    if (!state.pinnedApps.includes(draggedAppId)) {
                      const targetPinnedIdx = state.pinnedApps.indexOf(targetAppId);
                      if (targetPinnedIdx !== -1) {
                        // Insert at the target's position
                        state.pinnedApps.splice(targetPinnedIdx, 0, draggedAppId);
                        dockDragState.isPinned = true;
                        localStorage.setItem('pinnedApps', JSON.stringify(state.pinnedApps));
                        console.log('Icon pinned:', draggedAppId);
                      }
                    }
                  } else if (dockDragState.isPinned && !targetIsPinned) {
                    // Pinned icon moving to unpinned section - unpin it
                    const pinnedIdx = state.pinnedApps.indexOf(draggedAppId);
                    if (pinnedIdx !== -1) {
                      state.pinnedApps.splice(pinnedIdx, 1);
                      dockDragState.isPinned = false;
                      localStorage.setItem('pinnedApps', JSON.stringify(state.pinnedApps));
                      console.log('Icon unpinned:', draggedAppId);
                    }
                  }
                  
                  // Physically swap DOM elements
                  if (currentIdx < targetIdx) {
                    // Moving right - insert after target
                    targetIcon.parentNode.insertBefore(icon, targetIcon.nextSibling);
                  } else {
                    // Moving left - insert before target
                    targetIcon.parentNode.insertBefore(icon, targetIcon);
                  }
                  
                  // Update pinned apps order if both are pinned
                  if (dockDragState.isPinned && targetIsPinned) {
                    const fromIdx = state.pinnedApps.indexOf(draggedAppId);
                    const toIdx = state.pinnedApps.indexOf(targetAppId);
                    
                    if (fromIdx !== -1 && toIdx !== -1) {
                      // Create new array with updated order
                      const newPinnedApps = [...state.pinnedApps];
                      const [movedApp] = newPinnedApps.splice(fromIdx, 1);
                      newPinnedApps.splice(toIdx, 0, movedApp);
                      state.pinnedApps = newPinnedApps;
                      
                      // Immediately save to localStorage for persistence
                      localStorage.setItem('pinnedApps', JSON.stringify(state.pinnedApps));
                      console.log('Pinned apps order updated:', state.pinnedApps);
                    }
                  }
                  
                  // Update the initial position after swap to prevent jump
                  const newRect = icon.getBoundingClientRect();
                  dockDragState.initialIconLeft = newRect.left - dockDragState.deltaX;
                  dockDragState.lastSwapTime = now;
                }
              }
              
              // Smooth visual feedback for dragged icon following cursor (already constrained)
              icon.style.transform = `translateX(${dockDragState.deltaX}px) scale(1.15)`;
              icon.style.transition = 'none';
              icon.style.zIndex = '1000';
            }
          }
          
          e.preventDefault();
          return;
        }
        
        if (dragState) {
          const win = state.windows.find((w) => w.id === dragState.id);
          if (win) {
            const windowEl = document.querySelector(`[data-id="${win.id}"]`);
            if (windowEl) {
              // Add dragging class to disable transitions
              windowEl.classList.add('dragging');
              // Add body class to hide dock tooltips and disable dock magnification
              document.body.classList.add('window-dragging');
            }
            
            // Check if window is snapped and we haven't started unsnapping yet
            if (dragState.isSnapped && !dragState.hasMoved) {
              const deltaX = Math.abs(e.clientX - dragState.initialMouseX);
              const deltaY = Math.abs(e.clientY - dragState.initialMouseY);
              
              // Only start unsnapping if moved beyond threshold
              if (deltaX > dragState.dragThreshold || deltaY > dragState.dragThreshold) {
                dragState.hasMoved = true;
                
                // Now unsnap the window
                const restoreX = dragState.snapRestorePos.x;
                const restoreY = dragState.snapRestorePos.y;
                const restoreWidth = dragState.snapRestorePos.width;
                const restoreHeight = dragState.snapRestorePos.height;
                
                win.width = restoreWidth;
                win.height = restoreHeight;
                win.isSnapped = false;
                
                // Position window centered under cursor
                win.x = e.clientX - (win.width / 2);
                win.y = Math.max(28, e.clientY - 20);
                
                // Keep window within screen bounds
                win.x = Math.max(0, Math.min(win.x, window.innerWidth - win.width));
                
                // Clear snap restore position
                win.snapRestorePos = null;
                
                // Update drag state for normal dragging
                dragState.startX = win.width / 2;
                dragState.startY = 20;
                dragState.isSnapped = false;
                
                // Update visual immediately with no animation - NO render() call to eliminate flicker
                const windowEl = document.querySelector(`[data-id="${win.id}"]`);
                if (windowEl) {
                  windowEl.style.transition = 'none';
                  windowEl.style.width = `${win.width}px`;
                  windowEl.style.height = `${win.height}px`;
                  windowEl.style.left = `${win.x}px`;
                  windowEl.style.top = `${win.y}px`;
                  windowEl.style.borderRadius = '12px';
                  windowEl.style.boxShadow = '';
                  windowEl.classList.remove('snapped', 'maximized');
                  void windowEl.offsetHeight;
                }
                
                // NO render() here - DOM is already updated, avoid flicker
              } else {
                // Haven't moved enough yet, don't do anything
                return;
              }
            }
            
            // Check if window is maximized and we haven't started dragging yet
            if (dragState.isMaximized && !dragState.hasMoved) {
              const deltaX = Math.abs(e.clientX - dragState.initialMouseX);
              const deltaY = Math.abs(e.clientY - dragState.initialMouseY);
              
              // Only start dragging if moved beyond threshold (reduced threshold for maximized windows)
              if (deltaX > 2 || deltaY > 2) {
                dragState.hasMoved = true;
                
                // Now unmaximize the window
                win.x = win.restoreX || 100;
                win.y = win.restoreY || 100;
                win.width = win.restoreWidth || 800;
                win.height = win.restoreHeight || 600;
                win.isMaximized = false;
                win.isFullscreen = false;
                
                // Position window so cursor stays under the titlebar
                // Center the window horizontally around the cursor
                win.x = e.clientX - (win.width / 2);
                win.y = 28; // Just below menubar
                
                // Keep window within screen bounds
                win.x = Math.max(0, Math.min(win.x, window.innerWidth - win.width));
                
                // Save unmaximized state to localStorage immediately
                const windowState = state.windowStates[win.appId] || {};
                windowState.x = win.x;
                windowState.y = win.y;
                windowState.width = win.width;
                windowState.height = win.height;
                windowState.isMaximized = false;
                state.windowStates[win.appId] = windowState;
                localStorage.setItem('windowStates', JSON.stringify(state.windowStates));
                
                // Update drag state for normal dragging
                dragState.startX = win.width / 2;
                dragState.startY = 10;
                dragState.isMaximized = false;
                
                // Update visual immediately with no animation - NO render() call to eliminate flicker
                const windowEl = document.querySelector(`[data-id="${win.id}"]`);
                if (windowEl) {
                  windowEl.style.transition = 'none';
                  windowEl.style.width = `${win.width}px`;
                  windowEl.style.height = `${win.height}px`;
                  windowEl.style.left = `${win.x}px`;
                  windowEl.style.top = `${win.y}px`;
                  windowEl.style.borderRadius = '12px';
                  windowEl.style.boxShadow = '';
                  windowEl.classList.remove('maximized', 'snapped');
                  void windowEl.offsetHeight;
                }
                
                // NO render() here - DOM is already updated, avoid flicker
              } else {
                // Haven't moved enough yet, don't do anything
                return;
              }
            }
            
            // Check if normal window hasn't moved beyond threshold yet
            if (!dragState.isMaximized && !dragState.isSnapped && dragState.hasMoved === false) {
              const deltaX = Math.abs(e.clientX - dragState.initialMouseX);
              const deltaY = Math.abs(e.clientY - dragState.initialMouseY);
              
              // Only start dragging if moved beyond threshold
              if (deltaX > dragState.dragThreshold || deltaY > dragState.dragThreshold) {
                dragState.hasMoved = true;
              } else {
                // Haven't moved enough yet, don't move window
                return;
              }
            }
            
            // Normal drag behavior
            if (!dragState.isMaximized && !dragState.isSnapped) {
              // Calculate new position
              let newX = e.clientX - dragState.startX;
              let newY = e.clientY - dragState.startY;
              
              // Constrain to keep at least half the window visible on screen
              const halfWidth = win.width / 2;
              const halfHeight = win.height / 2;
              const minX = -halfWidth;
              const maxX = window.innerWidth - halfWidth;
              const minY = 28; // Keep below menubar
              const maxY = window.innerHeight - halfHeight;
              
              win.x = Math.max(minX, Math.min(maxX, newX));
              win.y = Math.max(minY, Math.min(maxY, newY));
              
              const windowEl = document.querySelector(`[data-id="${win.id}"]`);
              if (windowEl) {
                windowEl.style.left = `${win.x}px`;
                windowEl.style.top = `${win.y}px`;
              }
              
              // Note: Don't save to localStorage during drag - it's too slow
              // We'll save on mouseup instead
            }
            
            // Detect snap zones with improved logic
            const edgeThreshold = 25; // Increased for easier snapping at edges
            const cornerThreshold = 250; // Corner snap zone width
            const bottomCornerThreshold = 200; // Bottom corner snap zone height
            const menubarHeight = 28;
            const dockPosition = state.dockPosition || 'bottom';
            // Calculate dock dimensions based on scale
            const dockDims = getDockDimensions();
            
            const dockSpaceBottom = dockPosition === 'bottom' ? dockDims.getBottomSpace() : 0;
            const dockSpaceSide = (dockPosition === 'left' || dockPosition === 'right') ? dockDims.getSideSpace() : 0;
            const snapIndicator = document.querySelector('.snap-indicator');
            
            // Add dragging class to disable transitions on snap indicator
            if (snapIndicator) {
              snapIndicator.classList.add('dragging');
            }
            
            // Priority order: Corners > Edges > Top (maximize)
            // This ensures corners are accessible even when windows are snapped to edges
            
            // Helper function to calculate snap zone dimensions
            const leftOffset = dockPosition === 'left' ? dockSpaceSide : 0;
            const availableWidth = window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0);
            const availableHeight = window.innerHeight - menubarHeight - dockSpaceBottom;
            
            // Reset snap zone by default
            let detectedSnapZone = null;
            
            // Check bottom corners first (highest priority)
            // Bottom snap zone extends to the dock
            if (e.clientY >= window.innerHeight - bottomCornerThreshold) {
              // Bottom area
              if (e.clientX <= cornerThreshold && e.clientX >= (dockPosition === 'left' ? dockSpaceSide : 0)) {
                // Bottom-left corner
                detectedSnapZone = 'bottom-left';
                if (snapIndicator) {
                  snapIndicator.style.left = `${leftOffset}px`;
                  snapIndicator.style.top = `${menubarHeight + availableHeight / 2}px`;
                  snapIndicator.style.width = `${availableWidth / 2}px`;
                  snapIndicator.style.height = `${availableHeight / 2}px`;
                  snapIndicator.classList.add('active');
                }
              } else if (e.clientX >= window.innerWidth - cornerThreshold && e.clientX <= (window.innerWidth - (dockPosition === 'right' ? dockSpaceSide : 0))) {
                // Bottom-right corner
                detectedSnapZone = 'bottom-right';
                if (snapIndicator) {
                  snapIndicator.style.left = `${leftOffset + availableWidth / 2}px`;
                  snapIndicator.style.top = `${menubarHeight + availableHeight / 2}px`;
                  snapIndicator.style.width = `${availableWidth / 2}px`;
                  snapIndicator.style.height = `${availableHeight / 2}px`;
                  snapIndicator.classList.add('active');
                }
              }
            }
            // Check top corners (second priority) - combine with top maximize zone
            else if (e.clientY <= menubarHeight + edgeThreshold) {
              // Top area
              if (e.clientX <= cornerThreshold) {
                // Top-left corner - always available
                detectedSnapZone = 'top-left';
                if (snapIndicator) {
                  snapIndicator.style.left = `${leftOffset}px`;
                  snapIndicator.style.top = `${menubarHeight}px`;
                  snapIndicator.style.width = `${availableWidth / 2}px`;
                  snapIndicator.style.height = `${availableHeight / 2}px`;
                  snapIndicator.classList.add('active');
                }
              } else if (e.clientX >= window.innerWidth - cornerThreshold) {
                // Top-right corner - always available
                detectedSnapZone = 'top-right';
                if (snapIndicator) {
                  snapIndicator.style.left = `${leftOffset + availableWidth / 2}px`;
                  snapIndicator.style.top = `${menubarHeight}px`;
                  snapIndicator.style.width = `${availableWidth / 2}px`;
                  snapIndicator.style.height = `${availableHeight / 2}px`;
                  snapIndicator.classList.add('active');
                }
              } else {
                // Top center - maximize
                detectedSnapZone = 'top';
                if (snapIndicator) {
                  snapIndicator.style.left = `${leftOffset}px`;
                  snapIndicator.style.top = `${menubarHeight}px`;
                  snapIndicator.style.width = `${availableWidth}px`;
                  snapIndicator.style.height = `${availableHeight}px`;
                  snapIndicator.classList.add('active');
                }
              }
            }
            // Check left edge (third priority) - extends full height
            else if (e.clientX <= edgeThreshold + (dockPosition === 'left' ? dockSpaceSide : 0)) {
              // Left edge - snap regardless of Y position (dock will be avoided in final snap position)
              detectedSnapZone = 'left';
              if (snapIndicator) {
                snapIndicator.style.left = `${leftOffset}px`;
                snapIndicator.style.top = `${menubarHeight}px`;
                snapIndicator.style.width = `${availableWidth / 2}px`;
                snapIndicator.style.height = `${availableHeight}px`;
                snapIndicator.classList.add('active');
              }
            }
            // Check right edge (third priority) - extends full height
            else if (e.clientX >= window.innerWidth - edgeThreshold - (dockPosition === 'right' ? dockSpaceSide : 0)) {
              // Right edge - snap regardless of Y position (dock will be avoided in final snap position)
              detectedSnapZone = 'right';
              if (snapIndicator) {
                snapIndicator.style.left = `${leftOffset + availableWidth / 2}px`;
                snapIndicator.style.top = `${menubarHeight}px`;
                snapIndicator.style.width = `${availableWidth / 2}px`;
                snapIndicator.style.height = `${availableHeight}px`;
                snapIndicator.classList.add('active');
              }
            }
            
            // Update state
            if (detectedSnapZone) {
              state.snapZone = detectedSnapZone;
            } else {
              state.snapZone = null;
              if (snapIndicator) {
                snapIndicator.classList.remove('active');
              }
            }
          }
        }
        if (resizeState) {
          const win = state.windows.find((w) => w.id === resizeState.id);
          if (win) {
            const deltaX = e.clientX - resizeState.startX;
            const deltaY = e.clientY - resizeState.startY;
            const dir = resizeState.direction;
            const fromCenter = resizeState.resizeFromCenter;
            
            let newWidth = resizeState.startWidth;
            let newHeight = resizeState.startHeight;
            let newX = resizeState.startPosX;
            let newY = resizeState.startPosY;
            
            // Handle width changes
            if (dir.includes('e')) {
              newWidth = Math.max(300, resizeState.startWidth + (fromCenter ? deltaX * 2 : deltaX));
              if (fromCenter) newX = resizeState.startPosX - deltaX;
            } else if (dir.includes('w')) {
              newWidth = Math.max(300, resizeState.startWidth - deltaX);
              newX = fromCenter ? resizeState.startPosX + deltaX : resizeState.startPosX + deltaX;
              if (newWidth === 300) {
                newX = resizeState.startPosX + resizeState.startWidth - 300;
              }
            }
            
            // Handle height changes
            if (dir.includes('s')) {
              newHeight = Math.max(200, resizeState.startHeight + (fromCenter ? deltaY * 2 : deltaY));
              if (fromCenter) newY = resizeState.startPosY - deltaY;
            } else if (dir.includes('n')) {
              newHeight = Math.max(200, resizeState.startHeight - deltaY);
              newY = fromCenter ? resizeState.startPosY + deltaY : resizeState.startPosY + deltaY;
              if (newHeight === 200) {
                newY = resizeState.startPosY + resizeState.startHeight - 200;
              }
            }
            
            win.width = newWidth;
            win.height = newHeight;
            win.x = newX;
            win.y = Math.max(28, newY);
            
            const windowEl = document.querySelector(`[data-id="${win.id}"]`);
            if (windowEl) {
              windowEl.style.width = `${win.width}px`;
              windowEl.style.height = `${win.height}px`;
              windowEl.style.left = `${win.x}px`;
              windowEl.style.top = `${win.y}px`;
            }
          }
        }
      });

      document.addEventListener('mouseup', (e) => {
        // Remove dragging class from all windows
        document.querySelectorAll('.window.dragging').forEach(el => {
          el.classList.remove('dragging');
        });
        
        // Remove body dragging class
        document.body.classList.remove('window-dragging');
        
        // Remove dragging class from snap indicator and remove it
        const snapIndicator = document.querySelector('.snap-indicator');
        if (snapIndicator) {
          snapIndicator.classList.remove('dragging');
          if (!state.snapZone) {
            snapIndicator.classList.remove('active');
          }
        }
        
        // Handle maximized window click without drag
        if (dragState && dragState.isMaximized && !dragState.hasMoved) {
          // Just a click on a maximized window, do nothing
          dragState = null;
          window.dragState = null;
          return;
        }
        
        // Handle snapped window click without drag
        if (dragState && dragState.isSnapped && !dragState.hasMoved) {
          // Just a click on a snapped window, do nothing (don't unsnap it)
          dragState = null;
          window.dragState = null;
          return;
        }
        
        // Handle normal window click without drag
        if (dragState && !dragState.isMaximized && !dragState.isSnapped && dragState.hasMoved === false) {
          // Just a click on a normal window, do nothing (don't move it)
          dragState = null;
          window.dragState = null;
          return;
        }
        
        if (dockDragState) {
          const { appId, isDragging, draggedElement, isPinned } = dockDragState;
          const icon = draggedElement;
          
          // Reset cursor
          document.body.style.cursor = '';
          
          if (icon) {
            icon.classList.remove('dragging');
            // Smooth transition back to its new position
            icon.style.transition = 'transform 0.25s cubic-bezier(0.16, 1, 0.3, 1), z-index 0s 0.25s';
            icon.style.transform = '';
            icon.style.zIndex = '';
            
            setTimeout(() => {
              if (icon) {
                icon.style.transition = '';
              }
            }, 250);
          }
          
          // If we actually dragged, ensure the final order is saved and re-render
          if (isDragging) {
            // Rebuild the pinnedApps array based on current DOM order
            const dockElement = document.querySelector('.dock');
            if (dockElement) {
              const allIcons = Array.from(dockElement.querySelectorAll('.dock-icon'));
              const newPinnedApps = [];
              
              // Collect all pinned apps in their current DOM order
              allIcons.forEach(el => {
                const id = el.id.replace('dock-', '');
                if (state.pinnedApps.includes(id)) {
                  newPinnedApps.push(id);
                }
              });
              
              // Only update if order actually changed
              const currentOrder = JSON.stringify(state.pinnedApps);
              const newOrder = JSON.stringify(newPinnedApps);
              
              if (currentOrder !== newOrder && newPinnedApps.length > 0) {
                state.pinnedApps = newPinnedApps;
                localStorage.setItem('pinnedApps', JSON.stringify(state.pinnedApps));
                console.log('Final pinned apps order saved:', state.pinnedApps);
              }
            }
            
            // Re-render to show updated dock with correct pin states
            setTimeout(() => render(), 300);
          } else {
            // Treat as simple click if we didn't drag
            handleDockClick(e, appId);
          }
          
          dockDragState = null;
          window.dockDragState = null;
          return;
        }
        
        // Apply window snap if in snap zone
        if (dragState && state.snapZone) {
          const win = state.windows.find((w) => w.id === dragState.id);
          if (win) {
            const menubarHeight = 28;
            const dockPosition = state.dockPosition || 'bottom';
            
            // Calculate dock dimensions based on scale
            const dockDims = getDockDimensions();
            
            const dockSpaceBottom = dockPosition === 'bottom' ? dockDims.getBottomSpace() : 0;
            const dockSpaceSide = (dockPosition === 'left' || dockPosition === 'right') ? dockDims.getSideSpace() : 0;
            
            // Store original position for restore (only if not already stored)
            if (!win.isMaximized && !win.snapRestorePos && state.snapZone !== 'top') {
              win.snapRestorePos = { x: win.x, y: win.y, width: win.width, height: win.height };
            }
            
            // Get the window element for smooth animation
            const windowEl = document.querySelector(`[data-id="${win.id}"]`);
            
            // Calculate target dimensions based on snap zone
            let targetX, targetY, targetWidth, targetHeight;
            
            switch (state.snapZone) {
              case 'left':
                targetX = dockPosition === 'left' ? dockSpaceSide : 0;
                targetY = menubarHeight;
                targetWidth = (window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0)) / 2;
                targetHeight = window.innerHeight - menubarHeight - dockSpaceBottom;
                win.isMaximized = false;
                win.isSnapped = true;
                break;
              case 'right':
                targetX = (window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0)) / 2 + (dockPosition === 'left' ? dockSpaceSide : 0);
                targetY = menubarHeight;
                targetWidth = (window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0)) / 2;
                targetHeight = window.innerHeight - menubarHeight - dockSpaceBottom;
                win.isMaximized = false;
                win.isSnapped = true;
                break;
              case 'top':
                // Top center snap - call maximizeWindow for proper maximize behavior
                console.log('Snap finalize: top zone, calling maximizeWindow for same behavior as double-click');
                
                // Clear snap indicator immediately
                const snapIndicator = document.querySelector('.snap-indicator');
                if (snapIndicator) {
                  snapIndicator.classList.remove('active');
                }
                
                // Reset snap zone state
                state.snapZone = null;
                
                // Remove dragging class from window element immediately
                if (windowEl) {
                  windowEl.classList.remove('dragging');
                  // Clear inline transition that might interfere
                  windowEl.style.transition = '';
                }
                
                // Clear drag state to prevent window from sticking to cursor
                dragState = null;
                window.dragState = null;
                
                // Use requestAnimationFrame to ensure the drag is fully complete
                // before starting the maximize animation
                requestAnimationFrame(() => {
                  // Call the maximize function for consistent behavior and proper restore handling
                  window.maximizeWindow(win.id);
                });
                
                // Early return - don't continue to shared animation code
                return;
              case 'top-left':
                targetX = dockPosition === 'left' ? dockSpaceSide : 0;
                targetY = menubarHeight;
                targetWidth = (window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0)) / 2;
                targetHeight = (window.innerHeight - menubarHeight - dockSpaceBottom) / 2;
                win.isMaximized = false;
                win.isSnapped = true;
                break;
              case 'top-right':
                targetX = (window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0)) / 2 + (dockPosition === 'left' ? dockSpaceSide : 0);
                targetY = menubarHeight;
                targetWidth = (window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0)) / 2;
                targetHeight = (window.innerHeight - menubarHeight - dockSpaceBottom) / 2;
                win.isMaximized = false;
                win.isSnapped = true;
                break;
              case 'bottom-left':
                targetX = dockPosition === 'left' ? dockSpaceSide : 0;
                targetY = menubarHeight + (window.innerHeight - menubarHeight - dockSpaceBottom) / 2;
                targetWidth = (window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0)) / 2;
                targetHeight = (window.innerHeight - menubarHeight - dockSpaceBottom) / 2;
                win.isMaximized = false;
                win.isSnapped = true;
                break;
              case 'bottom-right':
                targetX = (window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0)) / 2 + (dockPosition === 'left' ? dockSpaceSide : 0);
                targetY = menubarHeight + (window.innerHeight - menubarHeight - dockSpaceBottom) / 2;
                targetWidth = (window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0)) / 2;
                targetHeight = (window.innerHeight - menubarHeight - dockSpaceBottom) / 2;
                win.isMaximized = false;
                win.isSnapped = true;
                break;
            }
            
            // Snap window with animation - ALWAYS trigger animation
            if (windowEl) {
              // Mark that a snap animation is in progress so global click handlers
              // don't trigger a full render that would cancel the transition.
              state.isSnappingWindow = true;
              
              // Capture EXACT current position from inline styles (set during drag)
              // This is more reliable than getBoundingClientRect()
              const currentLeft = parseFloat(windowEl.style.left) || win.x;
              const currentTop = parseFloat(windowEl.style.top) || win.y;
              const currentWidth = parseFloat(windowEl.style.width) || win.width;
              const currentHeight = parseFloat(windowEl.style.height) || win.height;
              
              // STEP 1: Clear ALL classes and styles immediately
              windowEl.classList.remove('snapping', 'snapped', 'maximizing', 'restoring', 'dragging');
              windowEl.style.willChange = '';
              windowEl.style.transform = '';
              windowEl.style.transition = '';
              windowEl.style.animation = '';
              
              // STEP 2: Force reflow to ensure clean slate
              void windowEl.offsetHeight;
              
              // STEP 3: Set starting position explicitly with NO transition
              windowEl.style.transition = 'none';
              windowEl.style.left = `${currentLeft}px`;
              windowEl.style.top = `${currentTop}px`;
              windowEl.style.width = `${currentWidth}px`;
              windowEl.style.height = `${currentHeight}px`;
              windowEl.style.borderRadius = '12px';
              
              // STEP 4: Force another reflow with starting position locked in
              void windowEl.offsetHeight;
              
              // STEP 5: Use double requestAnimationFrame to GUARANTEE animation plays
              // This ensures the starting position is painted before we animate
              requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                  // Enable transition - SAME AS MAXIMIZE (0.3s)
                  windowEl.style.transition = 'all 0.3s cubic-bezier(0.16, 1, 0.3, 1)';
                  windowEl.style.willChange = 'left, top, width, height, border-radius, box-shadow';
                  windowEl.classList.add('snapping');
                  
                  // STEP 6: Animate to target position
                  windowEl.style.left = `${targetX}px`;
                  windowEl.style.top = `${targetY}px`;
                  windowEl.style.width = `${targetWidth}px`;
                  windowEl.style.height = `${targetHeight}px`;
                  windowEl.style.borderRadius = '0px';
                  windowEl.style.boxShadow = 'none';
                });
              });
              
              // Update state after starting animation
              win.x = targetX;
              win.y = targetY;
              win.width = targetWidth;
              win.height = targetHeight;
              
              // Clean up after animation completes (300ms to match maximize)
              setTimeout(() => {
                if (windowEl) {
                  windowEl.classList.remove('snapping');
                  windowEl.style.willChange = '';
                  windowEl.style.transition = '';
                  windowEl.style.transform = '';
                }
                // Allow global click handlers to render again
                state.isSnappingWindow = false;
              }, 300);
            } else {
              // Fallback - instant snap
              win.x = targetX;
              win.y = targetY;
              win.width = targetWidth;
              win.height = targetHeight;
              if (windowEl) {
                windowEl.style.borderRadius = '0px';
              }
            }
            
            // Save window state to localStorage after snap
            const windowState = state.windowStates[win.appId] || {};
            windowState.x = win.x;
            windowState.y = win.y;
            windowState.width = win.width;
            windowState.height = win.height;
            windowState.isMaximized = win.isMaximized;
            windowState.isSnapped = win.isSnapped;
            // Save snapRestorePos so we can restore original size when unsnapping
            if (win.snapRestorePos) {
              windowState.snapRestorePos = win.snapRestorePos;
            }
            state.windowStates[win.appId] = windowState;
            localStorage.setItem('windowStates', JSON.stringify(state.windowStates));
            
            // Keep window active after snapping
            focusWindow(win.id);
          }
          
          // Hide snap indicator
          const snapIndicator = document.querySelector('.snap-indicator');
          if (snapIndicator) {
            snapIndicator.classList.remove('active');
          }
          state.snapZone = null;
        }
        
        // Save window position if it was dragged (not snapped)
        if (dragState && dragState.hasMoved) {
          const win = state.windows.find((w) => w.id === dragState.id);
          if (win && !win.isSnapped) {
            // Save state for both normal dragging and unmaximized-via-drag windows
            const windowState = state.windowStates[win.appId] || {};
            windowState.x = win.x;
            windowState.y = win.y;
            windowState.width = win.width;
            windowState.height = win.height;
            windowState.isMaximized = win.isMaximized; // Use current state, not hardcoded false
            windowState.isSnapped = false;
            windowState.snapRestorePos = null;
            state.windowStates[win.appId] = windowState;
            localStorage.setItem('windowStates', JSON.stringify(state.windowStates));
            console.log('Window state saved on mouseup:', win.appId, windowState);
          }
        }
        
        // Save window size when resize is complete
        if (resizeState) {
          const win = state.windows.find((w) => w.id === resizeState.id);
          if (win) {
            const savedSizes = JSON.parse(localStorage.getItem('windowSizes') || '{}');
            savedSizes[win.appId] = { width: win.width, height: win.height };
            localStorage.setItem('windowSizes', JSON.stringify(savedSizes));
          }
        }
        
        dragState = null;
        resizeState = null;
        window.dragState = null;
        window.resizeState = null;
      });

      // ============= TOUCH EVENT SUPPORT FOR WINDOW DRAGGING =============
      // Convert touch events to mouse-like events for window dragging
      let touchDragState = null;
      
      document.addEventListener('touchstart', (e) => {
        if (e.touches.length !== 1) return;
        
        const touch = e.touches[0];
        const target = document.elementFromPoint(touch.clientX, touch.clientY);
        
        // Check if touching a titlebar for window dragging
        const titlebar = target?.closest('.titlebar');
        if (titlebar) {
          const windowEl = titlebar.closest('.window');
          if (windowEl) {
            const windowId = parseInt(windowEl.dataset.id);
            const win = state.windows.find(w => w.id === windowId);
            
            if (win) {
              // Prevent default to stop scrolling while dragging
              e.preventDefault();
              
              // Focus the window
              focusWindow(windowId);
              
              // Initialize touch drag state
              touchDragState = {
                id: windowId,
                startX: touch.clientX - win.x,
                startY: touch.clientY - win.y,
                initialMouseX: touch.clientX,
                initialMouseY: touch.clientY,
                isMaximized: win.isMaximized,
                isSnapped: win.isSnapped || false,
                hasMoved: false,
                dragThreshold: 5,
                restoreWidth: win.restoreWidth || win.width,
                restoreHeight: win.restoreHeight || win.height,
                snapRestorePos: win.snapRestorePos || null
              };
              
              // Also set mouse dragState for compatibility with existing snap logic
              dragState = touchDragState;
              window.dragState = dragState;
            }
          }
        }
        
        // Check if touching a resize handle
        const resizeHandle = target?.closest('.resize-handle');
        if (resizeHandle && !touchDragState) {
          const windowEl = resizeHandle.closest('.window');
          if (windowEl) {
            const windowId = parseInt(windowEl.dataset.id);
            const win = state.windows.find(w => w.id === windowId);
            
            if (win && !win.isMaximized && !win.isSnapped) {
              e.preventDefault();
              
              const direction = resizeHandle.dataset.direction;
              resizeState = {
                id: windowId,
                direction: direction,
                startX: touch.clientX,
                startY: touch.clientY,
                startWidth: win.width,
                startHeight: win.height,
                startPosX: win.x,
                startPosY: win.y,
                resizeFromCenter: e.altKey
              };
              window.resizeState = resizeState;
            }
          }
        }
      }, { passive: false });
      
      document.addEventListener('touchmove', (e) => {
        if (e.touches.length !== 1) return;
        
        const touch = e.touches[0];
        
        if (touchDragState || (dragState && dragState === touchDragState)) {
          const currentDragState = touchDragState || dragState;
          const win = state.windows.find(w => w.id === currentDragState.id);
          if (!win) return;
          
          e.preventDefault();
          
          const windowEl = document.querySelector(`[data-id="${win.id}"]`);
          if (windowEl) {
            windowEl.classList.add('dragging');
            document.body.classList.add('window-dragging');
          }
          
          // Check if we've moved beyond threshold
          const deltaX = Math.abs(touch.clientX - currentDragState.initialMouseX);
          const deltaY = Math.abs(touch.clientY - currentDragState.initialMouseY);
          
          if (!currentDragState.hasMoved && (deltaX > currentDragState.dragThreshold || deltaY > currentDragState.dragThreshold)) {
            currentDragState.hasMoved = true;
            
            // Handle unmaximizing
            if (currentDragState.isMaximized) {
              win.x = touch.clientX - (currentDragState.restoreWidth / 2);
              win.y = 28;
              win.width = currentDragState.restoreWidth;
              win.height = currentDragState.restoreHeight;
              win.isMaximized = false;
              
              currentDragState.startX = currentDragState.restoreWidth / 2;
              currentDragState.startY = 10;
              currentDragState.isMaximized = false;
              
              if (windowEl) {
                windowEl.style.transition = 'none';
                windowEl.style.width = `${win.width}px`;
                windowEl.style.height = `${win.height}px`;
                windowEl.style.borderRadius = '12px';
                windowEl.classList.remove('maximized', 'snapped');
              }
            }
            
            // Handle unsnapping
            if (currentDragState.isSnapped && currentDragState.snapRestorePos) {
              win.width = currentDragState.snapRestorePos.width;
              win.height = currentDragState.snapRestorePos.height;
              win.isSnapped = false;
              win.x = touch.clientX - (win.width / 2);
              win.y = Math.max(28, touch.clientY - 20);
              win.snapRestorePos = null;
              
              currentDragState.startX = win.width / 2;
              currentDragState.startY = 20;
              currentDragState.isSnapped = false;
              
              if (windowEl) {
                windowEl.style.transition = 'none';
                windowEl.style.width = `${win.width}px`;
                windowEl.style.height = `${win.height}px`;
                windowEl.style.borderRadius = '12px';
                windowEl.classList.remove('snapped', 'maximized');
              }
            }
          }
          
          // Normal drag behavior
          if (currentDragState.hasMoved && !currentDragState.isMaximized && !currentDragState.isSnapped) {
            let newX = touch.clientX - currentDragState.startX;
            let newY = touch.clientY - currentDragState.startY;
            
            // Constrain to screen
            const halfWidth = win.width / 2;
            const halfHeight = win.height / 2;
            win.x = Math.max(-halfWidth, Math.min(window.innerWidth - halfWidth, newX));
            win.y = Math.max(28, Math.min(window.innerHeight - halfHeight, newY));
            
            if (windowEl) {
              windowEl.style.left = `${win.x}px`;
              windowEl.style.top = `${win.y}px`;
            }
            
            // Detect snap zones (simplified for touch)
            const edgeThreshold = 40;
            const snapIndicator = document.querySelector('.snap-indicator');
            const menubarHeight = 28;
            const dockPosition = state.dockPosition || 'bottom';
            const dockDims = getDockDimensions();
            const dockSpaceBottom = dockPosition === 'bottom' ? dockDims.getBottomSpace() : 0;
            const dockSpaceSide = (dockPosition === 'left' || dockPosition === 'right') ? dockDims.getSideSpace() : 0;
            const leftOffset = dockPosition === 'left' ? dockSpaceSide : 0;
            const availableWidth = window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0);
            const availableHeight = window.innerHeight - menubarHeight - dockSpaceBottom;
            
            let detectedSnapZone = null;
            
            if (touch.clientY <= menubarHeight + edgeThreshold) {
              detectedSnapZone = 'top';
              if (snapIndicator) {
                snapIndicator.style.left = `${leftOffset}px`;
                snapIndicator.style.top = `${menubarHeight}px`;
                snapIndicator.style.width = `${availableWidth}px`;
                snapIndicator.style.height = `${availableHeight}px`;
                snapIndicator.classList.add('active');
              }
            } else if (touch.clientX <= edgeThreshold + leftOffset) {
              detectedSnapZone = 'left';
              if (snapIndicator) {
                snapIndicator.style.left = `${leftOffset}px`;
                snapIndicator.style.top = `${menubarHeight}px`;
                snapIndicator.style.width = `${availableWidth / 2}px`;
                snapIndicator.style.height = `${availableHeight}px`;
                snapIndicator.classList.add('active');
              }
            } else if (touch.clientX >= window.innerWidth - edgeThreshold - (dockPosition === 'right' ? dockSpaceSide : 0)) {
              detectedSnapZone = 'right';
              if (snapIndicator) {
                snapIndicator.style.left = `${leftOffset + availableWidth / 2}px`;
                snapIndicator.style.top = `${menubarHeight}px`;
                snapIndicator.style.width = `${availableWidth / 2}px`;
                snapIndicator.style.height = `${availableHeight}px`;
                snapIndicator.classList.add('active');
              }
            } else {
              if (snapIndicator) {
                snapIndicator.classList.remove('active');
              }
            }
            
            state.snapZone = detectedSnapZone;
          }
        }
        
        // Handle touch resize
        if (resizeState) {
          e.preventDefault();
          
          const win = state.windows.find(w => w.id === resizeState.id);
          if (win) {
            const deltaX = touch.clientX - resizeState.startX;
            const deltaY = touch.clientY - resizeState.startY;
            const dir = resizeState.direction;
            
            let newWidth = resizeState.startWidth;
            let newHeight = resizeState.startHeight;
            let newX = resizeState.startPosX;
            let newY = resizeState.startPosY;
            
            if (dir.includes('e')) {
              newWidth = Math.max(300, resizeState.startWidth + deltaX);
            } else if (dir.includes('w')) {
              newWidth = Math.max(300, resizeState.startWidth - deltaX);
              newX = resizeState.startPosX + deltaX;
              if (newWidth === 300) newX = resizeState.startPosX + resizeState.startWidth - 300;
            }
            
            if (dir.includes('s')) {
              newHeight = Math.max(200, resizeState.startHeight + deltaY);
            } else if (dir.includes('n')) {
              newHeight = Math.max(200, resizeState.startHeight - deltaY);
              newY = resizeState.startPosY + deltaY;
              if (newHeight === 200) newY = resizeState.startPosY + resizeState.startHeight - 200;
            }
            
            win.width = newWidth;
            win.height = newHeight;
            win.x = newX;
            win.y = Math.max(28, newY);
            
            const windowEl = document.querySelector(`[data-id="${win.id}"]`);
            if (windowEl) {
              windowEl.style.width = `${win.width}px`;
              windowEl.style.height = `${win.height}px`;
              windowEl.style.left = `${win.x}px`;
              windowEl.style.top = `${win.y}px`;
            }
          }
        }
      }, { passive: false });
      
      document.addEventListener('touchend', (e) => {
        if (touchDragState || dragState) {
          const currentDragState = touchDragState || dragState;
          
          // Remove dragging classes
          document.querySelectorAll('.window.dragging').forEach(el => {
            el.classList.remove('dragging');
          });
          document.body.classList.remove('window-dragging');
          
          // Handle snap zones
          if (currentDragState && state.snapZone && currentDragState.hasMoved) {
            const win = state.windows.find(w => w.id === currentDragState.id);
            if (win) {
              // Store original position for restore
              if (!win.snapRestorePos) {
                win.snapRestorePos = { x: win.x, y: win.y, width: win.width, height: win.height };
              }
              
              if (state.snapZone === 'top') {
                window.maximizeWindow(win.id);
              } else {
                const menubarHeight = 28;
                const dockPosition = state.dockPosition || 'bottom';
                const dockDims = getDockDimensions();
                const dockSpaceBottom = dockPosition === 'bottom' ? dockDims.getBottomSpace() : 0;
                const dockSpaceSide = (dockPosition === 'left' || dockPosition === 'right') ? dockDims.getSideSpace() : 0;
                const leftOffset = dockPosition === 'left' ? dockSpaceSide : 0;
                const availableWidth = window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0);
                const availableHeight = window.innerHeight - menubarHeight - dockSpaceBottom;
                
                if (state.snapZone === 'left') {
                  win.x = leftOffset;
                  win.y = menubarHeight;
                  win.width = availableWidth / 2;
                  win.height = availableHeight;
                  win.isSnapped = true;
                } else if (state.snapZone === 'right') {
                  win.x = leftOffset + availableWidth / 2;
                  win.y = menubarHeight;
                  win.width = availableWidth / 2;
                  win.height = availableHeight;
                  win.isSnapped = true;
                }
                
                const windowEl = document.querySelector(`[data-id="${win.id}"]`);
                if (windowEl) {
                  windowEl.style.transition = 'all 0.3s cubic-bezier(0.16, 1, 0.3, 1)';
                  windowEl.style.left = `${win.x}px`;
                  windowEl.style.top = `${win.y}px`;
                  windowEl.style.width = `${win.width}px`;
                  windowEl.style.height = `${win.height}px`;
                  windowEl.classList.add('snapped');
                  
                  setTimeout(() => {
                    windowEl.style.transition = '';
                  }, 300);
                }
              }
            }
            
            // Hide snap indicator
            const snapIndicator = document.querySelector('.snap-indicator');
            if (snapIndicator) {
              snapIndicator.classList.remove('active');
            }
            state.snapZone = null;
          }
          
          // Save window position
          if (currentDragState && currentDragState.hasMoved) {
            const win = state.windows.find(w => w.id === currentDragState.id);
            if (win && !win.isSnapped && !win.isMaximized) {
              const windowState = state.windowStates[win.appId] || {};
              windowState.x = win.x;
              windowState.y = win.y;
              windowState.width = win.width;
              windowState.height = win.height;
              windowState.isMaximized = false;
              windowState.isSnapped = false;
              state.windowStates[win.appId] = windowState;
              localStorage.setItem('windowStates', JSON.stringify(state.windowStates));
            }
          }
          
          touchDragState = null;
          dragState = null;
          window.dragState = null;
        }
        
        // Handle resize end
        if (resizeState) {
          const win = state.windows.find(w => w.id === resizeState.id);
          if (win) {
            const savedSizes = JSON.parse(localStorage.getItem('windowSizes') || '{}');
            savedSizes[win.appId] = { width: win.width, height: win.height };
            localStorage.setItem('windowSizes', JSON.stringify(savedSizes));
          }
          resizeState = null;
          window.resizeState = null;
        }
      });
      
      // Prevent touchcancel from leaving windows in dragging state
      document.addEventListener('touchcancel', () => {
        if (touchDragState || dragState) {
          document.querySelectorAll('.window.dragging').forEach(el => {
            el.classList.remove('dragging');
          });
          document.body.classList.remove('window-dragging');
          
          const snapIndicator = document.querySelector('.snap-indicator');
          if (snapIndicator) {
            snapIndicator.classList.remove('active');
          }
          state.snapZone = null;
          
          touchDragState = null;
          dragState = null;
          window.dragState = null;
        }
        
        if (resizeState) {
          resizeState = null;
          window.resizeState = null;
        }
      });

      function renderDockOnly() {
        // Quick render just for the dock during drag operations
        const dockElement = document.querySelector('.dock');
        if (!dockElement) return;
        
        const finderApp = apps.find(app => app.id === 'finder');
        const isLaunchpadActive = state.showLaunchpad;
        const finderIconKey = finderApp.icon;
        const finderName = finderApp.name;
        
        const dockHTML = `
          ${finderApp ? `
            <div class="dock-icon" id="dock-finder" onmousedown="window.initDockDrag(event, 'finder'); window.handleDockMouseDown(event, 'finder')" oncontextmenu="window.showContextMenu(event, 'finder')">
              ${icons[finderIconKey]}
              <div class="dock-tooltip">${finderName}</div>
              ${isLaunchpadActive
                ? `
                  <div style="position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%);">
                    <div style="width: 5px; height: 5px; border-radius: 50%; background: ${state.accentColor};"></div>
                  </div>
                `
                : ''}
            </div>
          ` : ''}
          ${state.pinnedApps
            .map((appId) => apps.find((app) => app.id === appId))
            .filter((app) => app !== undefined && app.id !== 'finder')
            .map((app) => {
              const openWindows = state.windows.filter((w) => w.appId === app.id && !w.isMinimized);
              const minimizedWindows = state.windows.filter((w) => w.appId === app.id && w.isMinimized);
              const windowCount = openWindows.length;
              const hasMinimized = minimizedWindows.length > 0;
              return `
                <div class="dock-icon" id="dock-${app.id}" onmousedown="window.initDockDrag(event, '${app.id}'); window.handleDockMouseDown(event, '${app.id}')" oncontextmenu="window.showContextMenu(event, '${app.id}')">
                  ${icons[app.icon]}
                  <div class="dock-tooltip">${app.name}</div>
                  ${windowCount > 0
                    ? `
                      <div style="position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%); display: flex; gap: 3px;">
                        ${Array.from({ length: Math.min(windowCount, 3) })
                          .map(
                            () => `
                              <div style="width: 5px; height: 5px; border-radius: 50%; background: ${state.accentColor};"></div>
                            `,
                          )
                          .join('')}
                      </div>
                    `
                    : hasMinimized
                    ? `
                      <div style="position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%);">
                        <div style="width: 5px; height: 5px; border-radius: 50%; background: ${state.accentColor}; opacity: 0.6;"></div>
                      </div>
                    `
                    : ''}
                </div>
              `;
            })
            .join('')}
          ${(() => {
            const unpinnedOpenApps = apps.filter(app => 
              !state.pinnedApps.includes(app.id) && 
              state.windows.some(w => w.appId === app.id)
            );
            
            if (unpinnedOpenApps.length === 0) return '';
            
            return `
              <div class="dock-divider"></div>
              ${unpinnedOpenApps.map((app) => {
                const openWindows = state.windows.filter((w) => w.appId === app.id && !w.isMinimized);
                const minimizedWindows = state.windows.filter((w) => w.appId === app.id && w.isMinimized);
                const windowCount = openWindows.length;
                const hasMinimized = minimizedWindows.length > 0;
                return `
                  <div class="dock-icon" id="dock-${app.id}" onmousedown="window.initDockDrag(event, '${app.id}'); window.handleDockMouseDown(event, '${app.id}')" oncontextmenu="window.showContextMenu(event, '${app.id}')">
                    ${icons[app.icon]}
                    <div class="dock-tooltip">${app.name}</div>
                    ${windowCount > 0
                      ? `
                        <div style="position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%); display: flex; gap: 3px;">
                          ${Array.from({ length: Math.min(windowCount, 3) })
                            .map(
                              () => `
                                <div style="width: 5px; height: 5px; border-radius: 50%; background: ${state.accentColor};"></div>
                              `,
                            )
                            .join('')}
                        </div>
                      `
                      : hasMinimized
                      ? `
                        <div style="position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%);">
                          <div style="width: 5px; height: 5px; border-radius: 50%; background: ${state.accentColor}; opacity: 0.6;"></div>
                        </div>
                      `
                      : ''}
                  </div>
                `;
              }).join('')}
            `;
          })()}
        `;
        // Track existing dock icon IDs before updating
        const existingIconIds = new Set(
          Array.from(dockElement.querySelectorAll('.dock-icon')).map(icon => icon.id)
        );
        
        dockElement.innerHTML = dockHTML;
        
        // Animate only newly appeared dock icons
        requestAnimationFrame(() => {
          const dockIcons = dockElement.querySelectorAll('.dock-icon');
          dockIcons.forEach((icon) => {
            // Only animate icons that didn't exist before
            if (icon.id && !existingIconIds.has(icon.id)) {
              icon.classList.add('appearing');
              
              // Remove appearing class after animation completes
              setTimeout(() => {
                icon.classList.remove('appearing');
              }, 400); // Match animation duration
            }
          });
        });
      }

      // ============= Background Process System =============
      // Like a real OS, apps can run in background and preserve state when minimized/restored
      
      window.startBackgroundProcess = function(appId, processData = {}) {
        state.backgroundProcesses[appId] = {
          state: 'running',
          data: processData,
          startTime: Date.now(),
          lastUpdate: Date.now()
        };
        state.processStartTimes[appId] = Date.now();
        localStorage.setItem('backgroundProcesses', JSON.stringify(state.backgroundProcesses));
      };
      
      window.updateBackgroundProcess = function(appId, newData) {
        if (state.backgroundProcesses[appId]) {
          state.backgroundProcesses[appId].data = {
            ...state.backgroundProcesses[appId].data,
            ...newData
          };
          state.backgroundProcesses[appId].lastUpdate = Date.now();
          localStorage.setItem('backgroundProcesses', JSON.stringify(state.backgroundProcesses));
        }
      };
      
      window.getBackgroundProcess = function(appId) {
        return state.backgroundProcesses[appId] || null;
      };
      
      window.stopBackgroundProcess = function(appId) {
        delete state.backgroundProcesses[appId];
        delete state.processStartTimes[appId];
        localStorage.setItem('backgroundProcesses', JSON.stringify(state.backgroundProcesses));
      };
      
      window.isProcessRunning = function(appId) {
        return !!state.backgroundProcesses[appId];
      };
      
      window.getProcessUptime = function(appId) {
        if (state.processStartTimes[appId]) {
          return Date.now() - state.processStartTimes[appId];
        }
        return 0;
      };
      
      window.getAllRunningProcesses = function() {
        const processes = [];
        // Add system processes
        processes.push({
          pid: 1,
          name: 'System',
          appId: 'system',
          cpu: Math.random() * 5,
          memory: 150 + Math.random() * 50,
          uptime: Date.now() - (state.systemStartTime || Date.now())
        });
        processes.push({
          pid: 2,
          name: 'Dock',
          appId: 'dock',
          cpu: Math.random() * 2,
          memory: 30 + Math.random() * 10,
          uptime: Date.now() - (state.systemStartTime || Date.now())
        });
        processes.push({
          pid: 3,
          name: 'Menubar',
          appId: 'menubar',
          cpu: Math.random() * 1,
          memory: 20 + Math.random() * 10,
          uptime: Date.now() - (state.systemStartTime || Date.now())
        });
        
        // Add open window processes
        state.windows.forEach((win, idx) => {
          const app = apps.find(a => a.id === win.appId);
          const process = state.backgroundProcesses[win.appId];
          processes.push({
            pid: 100 + idx,
            name: app ? app.name : win.appId,
            appId: win.appId,
            windowId: win.id,
            isMinimized: win.isMinimized,
            cpu: win.isMinimized ? Math.random() * 0.5 : 5 + Math.random() * 15,
            memory: win.isMinimized ? 50 + Math.random() * 30 : 100 + Math.random() * 200,
            uptime: process ? Date.now() - process.startTime : 0,
            state: win.isMinimized ? 'background' : 'active'
          });
        });
        
        // Add background processes without open windows
        Object.entries(state.backgroundProcesses).forEach(([appId, process]) => {
          if (!state.windows.some(w => w.appId === appId)) {
            const app = apps.find(a => a.id === appId);
            processes.push({
              pid: 200 + processes.length,
              name: app ? app.name : appId,
              appId: appId,
              cpu: Math.random() * 3,
              memory: 40 + Math.random() * 60,
              uptime: Date.now() - process.startTime,
              state: 'background'
            });
          }
        });
        
        return processes.sort((a, b) => b.cpu - a.cpu);
      };
      
      // Initialize system start time
      if (!state.systemStartTime) {
        state.systemStartTime = Date.now();
      }
      
      // ============= Throttled Render System =============
      // Prevents excessive re-renders during rapid state changes
      
      const RENDER_THROTTLE_MS = 16; // ~60fps
      
      function throttledRender() {
        const now = Date.now();
        
        // If a render is already queued, skip
        if (state.renderQueued) return;
        
        // Calculate time since last render
        const timeSinceLastRender = now - state.lastRenderTime;
        
        if (timeSinceLastRender >= RENDER_THROTTLE_MS) {
          // Enough time has passed, render immediately
          state.lastRenderTime = now;
          render();
        } else {
          // Queue a render for later
          state.renderQueued = true;
          requestAnimationFrame(() => {
            state.renderQueued = false;
            state.lastRenderTime = Date.now();
            render();
          });
        }
      }

      // ============= Split Render System =============
      // renderShell() - Renders desktop shell (bg, menubar, dock, quick settings, launchpad, dialogs)
      // renderWindows() - Renders only the windows layer
      // render() - Full render (calls both + handles iframe preservation, scroll restoration, etc.)
      
      // Generate windows HTML - extracted for reuse
      function generateWindowsHTML() {
        return state.windows
          .filter((w) => !w.isMinimized && !state.showLaunchpad)
          .map((win) => {
            let style = '';
            let className = 'window';
            
            // Add inactive class for non-active windows
            const isActive = state.activeWindowId === win.id;
            if (!isActive) {
              className += ' inactive';
            }

            if (win.isFullscreen) {
              className += ' fullscreen';
              style = `top: 0; left: 0; width: 100vw; height: 100vh; z-index: ${win.zIndex}`;
             } else if (win.isMaximized) {
              className += ' maximized';
              // Calculate dock space based on current dock position and scale
              const dockPosition = state.dockPosition || 'bottom';
              const menubarHeight = 28;
              const dockDims = getDockDimensions();
              
              const dockSpaceBottom = dockPosition === 'bottom' ? dockDims.getBottomSpace() : 0;
              const dockSpaceSide = (dockPosition === 'left' || dockPosition === 'right') ? dockDims.getSideSpace() : 0;
              const targetWidth = window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0);
              const targetHeight = window.innerHeight - menubarHeight - dockSpaceBottom;
              const targetLeft = dockPosition === 'left' ? dockSpaceSide : 0;
              const targetTop = menubarHeight;
              style = `top: ${targetTop}px; left: ${targetLeft}px; width: ${targetWidth}px; height: ${targetHeight}px; z-index: ${win.zIndex}; border-radius: 0`;
            } else {
              // Add 'snapped' class when window is snapped
              if (win.isSnapped) {
                className += ' snapped';
              }
              style = `top: ${win.y}px; left: ${win.x}px; width: ${win.width}px; height: ${win.height}px; z-index: ${win.zIndex}${win.isSnapped ? '; border-radius: 0' : ''}`;
            }

            return `
              <div class="${className}" id="window-${win.id}" data-id="${win.id}" data-app="${win.appId}" style="${style}" onmousedown="if (!event.target.closest('button, input, select, .toggle-switch, .wallpaper-thumbnail, .wallpaper-upload-btn, .wallpaper-reset-btn, a')) window.focusWindow(${win.id})" ondblclick="window.handleWindowDblClick(event, ${win.id})">
                ${!win.isFullscreen
                  ? `
                    <div class="titlebar ${state.mirroredControls ? 'mirrored-controls' : ''}" ondblclick="event.stopPropagation(); window.maximizeWindow(${win.id})">
                      ${(() => {
                        const app = apps.find(a => a.id === win.appId);
                        const supportsFullscreen = app && app.supportsFullscreen;
                        return supportsFullscreen ? `
                          <button class="titlebar-fullscreen-btn" onclick="event.stopPropagation(); window.toggleFullscreen(${win.id})" title="Enter Fullscreen">
                            <svg viewBox="0 0 24 24">
                              <path d="M15 3h6v6M9 21H3v-6M21 3l-7 7M3 21l7-7"/>
                            </svg>
                          </button>
                        ` : '';
                      })()}
                      <div class="titlebar-buttons">
                        <button class="titlebar-button close" onclick="event.stopPropagation(); window.closeWindow(${win.id})"></button>
                        ${win.appId !== 'versionmanager' ? `<button class="titlebar-button minimize ${win.isMaximized ? 'is-maximized' : ''}" onclick="event.stopPropagation(); window.minimizeWindow(${win.id})"></button>` : ''}
                        <button class="titlebar-button maximize" onclick="event.stopPropagation(); window.maximizeWindow(${win.id})"></button>
                      </div>
                      <div class="titlebar-title">${win.title}</div>
                    </div>
                  `
                  : ''}
                <div class="window-content" ondblclick="event.stopPropagation()">
                  ${getWindowContent(win.appId)}
                </div>
                ${win.isFullscreen
                  ? `
                    <div class="fullscreen-hover-zone" onmouseenter="window.showFullscreenUI(${win.id})" onmouseleave="window.hideFullscreenUI(${win.id})"></div>
                    <div class="fullscreen-overlay-ui" onmouseenter="window.showFullscreenUI(${win.id})" onmouseleave="window.hideFullscreenUI(${win.id})">
                      <div class="fullscreen-exit-btn" onclick="window.toggleFullscreen(${win.id})">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                          <path d="M4 14h6v6M20 10h-6V4M14 10l7-7M3 21l7-7" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                        <span>Exit Fullscreen</span>
                      </div>
                      <div class="fullscreen-hint">Press ESC or Ctrl+Shift+F to exit</div>
                    </div>
                  `
                  : ''}
                ${!win.isMaximized && !win.isFullscreen
                  ? `
                    <div class="resize-handle se"></div>
                    <div class="resize-handle sw"></div>
                    <div class="resize-handle ne"></div>
                    <div class="resize-handle nw"></div>
                    <div class="resize-handle n"></div>
                    <div class="resize-handle s"></div>
                    <div class="resize-handle e"></div>
                    <div class="resize-handle w"></div>
                  `
                  : ''}
              </div>
            `;
          })
          .join('');
      }
      
      // ============= DOM Diffing System for Windows =============
      // Computes minimal DOM mutations to update windows layer efficiently
      
      // Compute the desired state for a window (style, classes, etc.)
      function computeWindowState(win) {
        let style = '';
        let classes = ['window'];
        
        // Active/inactive state
        if (state.activeWindowId !== win.id) {
          classes.push('inactive');
        }

        if (win.isFullscreen) {
          classes.push('fullscreen');
          style = 'top: 0; left: 0; width: 100vw; height: 100vh; z-index: ' + win.zIndex;
        } else if (win.isMaximized) {
          classes.push('maximized');
          const dockPosition = state.dockPosition || 'bottom';
          const menubarHeight = 28;
          const dockDims = getDockDimensions();
          
          const dockSpaceBottom = dockPosition === 'bottom' ? dockDims.getBottomSpace() : 0;
          const dockSpaceSide = (dockPosition === 'left' || dockPosition === 'right') ? dockDims.getSideSpace() : 0;
          const targetWidth = window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0);
          const targetHeight = window.innerHeight - menubarHeight - dockSpaceBottom;
          const targetLeft = dockPosition === 'left' ? dockSpaceSide : 0;
          const targetTop = menubarHeight;
          style = 'top: ' + targetTop + 'px; left: ' + targetLeft + 'px; width: ' + targetWidth + 'px; height: ' + targetHeight + 'px; z-index: ' + win.zIndex + '; border-radius: 0';
        } else {
          if (win.isSnapped) {
            classes.push('snapped');
          }
          style = 'top: ' + win.y + 'px; left: ' + win.x + 'px; width: ' + win.width + 'px; height: ' + win.height + 'px; z-index: ' + win.zIndex + (win.isSnapped ? '; border-radius: 0' : '');
        }

        return {
          id: win.id,
          appId: win.appId,
          title: win.title,
          style: style,
          className: classes.join(' '),
          isFullscreen: win.isFullscreen,
          isMaximized: win.isMaximized
        };
      }
      
      // Generate single window HTML (for creating new windows)
      function generateSingleWindowHTML(win) {
        const computed = computeWindowState(win);
        const app = apps.find(a => a.id === win.appId);
        const supportsFullscreen = app && app.supportsFullscreen;
        
        let html = '<div class="' + computed.className + '" id="window-' + win.id + '" data-id="' + win.id + '" data-app="' + win.appId + '" style="' + computed.style + '" onmousedown="if (!event.target.closest(\'button, input, select, .toggle-switch, .wallpaper-thumbnail, .wallpaper-upload-btn, .wallpaper-reset-btn, a\')) window.focusWindow(' + win.id + ')" ondblclick="window.handleWindowDblClick(event, ' + win.id + ')">';
        
        if (!win.isFullscreen) {
          html += '<div class="titlebar ' + (state.mirroredControls ? 'mirrored-controls' : '') + '" ondblclick="event.stopPropagation(); window.maximizeWindow(' + win.id + ')">';
          if (supportsFullscreen) {
            html += '<button class="titlebar-fullscreen-btn" onclick="event.stopPropagation(); window.toggleFullscreen(' + win.id + ')" title="Enter Fullscreen">';
            html += '<svg viewBox="0 0 24 24"><path d="M15 3h6v6M9 21H3v-6M21 3l-7 7M3 21l7-7"/></svg>';
            html += '</button>';
          }
          html += '<div class="titlebar-buttons">';
          html += '<button class="titlebar-button close" onclick="event.stopPropagation(); window.closeWindow(' + win.id + ')"></button>';
          if (win.appId !== 'versionmanager') {
            html += '<button class="titlebar-button minimize ' + (win.isMaximized ? 'is-maximized' : '') + '" onclick="event.stopPropagation(); window.minimizeWindow(' + win.id + ')"></button>';
          }
          html += '<button class="titlebar-button maximize" onclick="event.stopPropagation(); window.maximizeWindow(' + win.id + ')"></button>';
          html += '</div>';
          html += '<div class="titlebar-title">' + win.title + '</div>';
          html += '</div>';
        }
        
        html += '<div class="window-content" ondblclick="event.stopPropagation()">' + getWindowContent(win.appId) + '</div>';
        
        if (win.isFullscreen) {
          html += '<div class="fullscreen-hover-zone" onmouseenter="window.showFullscreenUI(' + win.id + ')" onmouseleave="window.hideFullscreenUI(' + win.id + ')"></div>';
          html += '<div class="fullscreen-overlay-ui" onmouseenter="window.showFullscreenUI(' + win.id + ')" onmouseleave="window.hideFullscreenUI(' + win.id + ')">';
          html += '<div class="fullscreen-exit-btn" onclick="window.toggleFullscreen(' + win.id + ')">';
          html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;"><path d="M4 14h6v6M20 10h-6V4M14 10l7-7M3 21l7-7" stroke-linecap="round" stroke-linejoin="round"/></svg>';
          html += '<span>Exit Fullscreen</span>';
          html += '</div>';
          html += '<div class="fullscreen-hint">Press ESC or Ctrl+Shift+F to exit</div>';
          html += '</div>';
        }
        
        if (!win.isMaximized && !win.isFullscreen) {
          html += '<div class="resize-handle se"></div>';
          html += '<div class="resize-handle sw"></div>';
          html += '<div class="resize-handle ne"></div>';
          html += '<div class="resize-handle nw"></div>';
          html += '<div class="resize-handle n"></div>';
          html += '<div class="resize-handle s"></div>';
          html += '<div class="resize-handle e"></div>';
          html += '<div class="resize-handle w"></div>';
        }
        
        html += '</div>';
        return html;
      }
      
      // Diff and patch a single window element
      function patchWindow(windowEl, win, prevState) {
        const newState = computeWindowState(win);
        
        // Update style if changed
        if (windowEl.getAttribute('style') !== newState.style) {
          windowEl.setAttribute('style', newState.style);
        }
        
        // Update class if changed
        if (windowEl.className !== newState.className) {
          windowEl.className = newState.className;
        }
        
        // Update title if changed
        const titleEl = windowEl.querySelector('.titlebar-title');
        if (titleEl && titleEl.textContent !== newState.title) {
          titleEl.textContent = newState.title;
        }
        
        // Handle fullscreen/maximize state changes that require structure updates
        const hadTitlebar = windowEl.querySelector('.titlebar') !== null;
        const needsTitlebar = !win.isFullscreen;
        
        if (hadTitlebar !== needsTitlebar) {
          // Structure changed significantly, rebuild content
          return false; // Signal needs full rebuild
        }
        
        // Handle resize handles visibility
        const hasResizeHandles = windowEl.querySelector('.resize-handle') !== null;
        const needsResizeHandles = !win.isMaximized && !win.isFullscreen;
        
        if (hasResizeHandles !== needsResizeHandles) {
          return false; // Signal needs full rebuild
        }
        
        // Update mirrored controls class on titlebar
        const titlebar = windowEl.querySelector('.titlebar');
        if (titlebar) {
          const hasMirrored = titlebar.classList.contains('mirrored-controls');
          if (hasMirrored !== state.mirroredControls) {
            if (state.mirroredControls) {
              titlebar.classList.add('mirrored-controls');
            } else {
              titlebar.classList.remove('mirrored-controls');
            }
          }
          
          // Update minimize button is-maximized class
          const minBtn = titlebar.querySelector('.titlebar-button.minimize');
          if (minBtn) {
            const hasIsMaximized = minBtn.classList.contains('is-maximized');
            if (hasIsMaximized !== win.isMaximized) {
              if (win.isMaximized) {
                minBtn.classList.add('is-maximized');
              } else {
                minBtn.classList.remove('is-maximized');
              }
            }
          }
        }
        
        return true; // Successfully patched
      }
      
      // Render only the windows layer with DOM diffing
      function renderWindows() {
        // Update apps list
        apps = getApps();
        
        const windowsLayer = document.querySelector('.windows-layer');
        if (!windowsLayer) {
          // Shell not rendered yet, do full render
          render();
          return;
        }
        
        // Skip during drag/resize
        if (dragState || resizeState) {
          return;
        }
        
        // Get visible windows
        const visibleWindows = state.windows.filter(w => !w.isMinimized && !state.showLaunchpad);
        const visibleIds = new Set(visibleWindows.map(w => w.id));
        
        // Get existing window elements
        const existingEls = Array.from(windowsLayer.querySelectorAll(':scope > .window'));
        const existingById = new Map();
        existingEls.forEach(el => {
          const id = parseInt(el.dataset.id, 10);
          existingById.set(id, el);
        });
        
        // Track windows that need full rebuild
        const needsRebuild = new Set();
        
        // Phase 1: Remove windows that no longer exist
        existingEls.forEach(el => {
          const id = parseInt(el.dataset.id, 10);
          if (!visibleIds.has(id)) {
            // Preserve iframes before removing
            const win = state.windows.find(w => w.id === id);
            if (win) {
              preserveWindowIframes(el, win);
            }
            el.remove();
            existingById.delete(id);
          }
        });
        
        // Phase 2: Patch existing windows or mark for rebuild
        visibleWindows.forEach(win => {
          const el = existingById.get(win.id);
          if (el) {
            // Try to patch
            const success = patchWindow(el, win);
            if (!success) {
              needsRebuild.add(win.id);
            }
          }
        });
        
        // Phase 3: Rebuild windows that need it (preserving iframes)
        needsRebuild.forEach(id => {
          const el = existingById.get(id);
          const win = visibleWindows.find(w => w.id === id);
          if (el && win) {
            preserveWindowIframes(el, win);
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = generateSingleWindowHTML(win);
            const newEl = tempDiv.firstElementChild;
            el.replaceWith(newEl);
            existingById.set(id, newEl);
            restoreWindowIframes(newEl, win);
          }
        });
        
        // Phase 4: Add new windows
        visibleWindows.forEach(win => {
          if (!existingById.has(win.id)) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = generateSingleWindowHTML(win);
            const newEl = tempDiv.firstElementChild;
            windowsLayer.appendChild(newEl);
            existingById.set(win.id, newEl);
          }
        });
        
        // Phase 5: Reorder windows by z-index if needed
        const sortedWindows = [...visibleWindows].sort((a, b) => a.zIndex - b.zIndex);
        let needsReorder = false;
        const currentOrder = Array.from(windowsLayer.querySelectorAll(':scope > .window')).map(el => parseInt(el.dataset.id, 10));
        const targetOrder = sortedWindows.map(w => w.id);
        
        if (currentOrder.length === targetOrder.length) {
          for (let i = 0; i < currentOrder.length; i++) {
            if (currentOrder[i] !== targetOrder[i]) {
              needsReorder = true;
              break;
            }
          }
        }
        
        if (needsReorder) {
          sortedWindows.forEach(win => {
            const el = existingById.get(win.id);
            if (el) {
              windowsLayer.appendChild(el); // Move to end in z-order
            }
          });
        }
        
        // Restore any preserved Task Manager content
        preservedTaskManagerContent.forEach((data, key) => {
          const windowEl = document.getElementById('window-' + data.winId);
          if (windowEl) {
            const windowContent = windowEl.querySelector('.window-content');
            if (windowContent && data.element) {
              windowContent.innerHTML = '';
              windowContent.appendChild(data.element);
              
              // Restore scroll position
              const processList = data.element.querySelector('[data-process-list]');
              if (processList && data.scrollTop) {
                processList.scrollTop = data.scrollTop;
              }
              
              preservedTaskManagerContent.delete(key);
            }
          }
        });
        
        // Restore any remaining preserved iframes
        preservedIframes.forEach((data, key) => {
          const windowEl = document.getElementById('window-' + data.winId);
          if (windowEl) {
            restoreIframeToWindow(windowEl, data, key);
          }
        });
        
        // Restore scroll positions
        requestAnimationFrame(() => {
          document.querySelectorAll('.window-content').forEach(content => {
            const windowEl = content.closest('.window');
            if (windowEl) {
              const windowId = windowEl.dataset.id;
              if (windowId && state.scrollPositions[windowId] !== undefined) {
                content.scrollTop = state.scrollPositions[windowId];
              }
            }
          });
        });
        
        // Setup fullscreen iframe focus if needed
        setupFullscreenIframeFocus();
        
        // Inject content into Minecraft iframes that need it
        injectMinecraftIframeContent();
      }
      
      // Helper: Inject content into Minecraft iframes marked with data-needs-content
      function injectMinecraftIframeContent() {
        const iframes = document.querySelectorAll('iframe[data-needs-content="true"]');
        iframes.forEach(iframe => {
          if (state.minecraftHtmlContent) {
            iframe.removeAttribute('data-needs-content');
            iframe.srcdoc = state.minecraftHtmlContent;
            iframe.onload = function() {
              this.focus();
              if (this.contentWindow) this.contentWindow.focus();
              console.log('Minecraft iframe content injected successfully');
            };
          } else if (state.minecraftBlobUrl) {
            // Fallback to blob URL if HTML content not available
            iframe.removeAttribute('data-needs-content');
            iframe.src = state.minecraftBlobUrl;
            iframe.onload = function() {
              this.focus();
              if (this.contentWindow) this.contentWindow.focus();
              console.log('Minecraft iframe loaded via blob URL fallback');
            };
          }
        });
      }
      
      // Helper: Preserve iframes and task manager content from a window element
      function preserveWindowIframes(windowEl, win) {
        // PRESERVE TASK MANAGER CONTENT
        if (win.appId === 'taskmanager') {
          const taskManagerContainer = windowEl.querySelector('[data-task-manager-container]');
          if (taskManagerContainer) {
            const tmKey = `taskmanager-${win.id}`;
            const processList = taskManagerContainer.querySelector('[data-process-list]');
            const scrollTop = processList ? processList.scrollTop : 0;
            
            preservedTaskManagerContent.set(tmKey, {
              element: taskManagerContainer,
              winId: win.id,
              scrollTop: scrollTop
            });
            taskManagerContainer.remove();
          }
        }
        
        // PRESERVE IFRAMES
        const iframes = windowEl.querySelectorAll('iframe');
        iframes.forEach((iframe, idx) => {
          const iframeKey = win.appId + '-' + win.id + '-' + idx;
          const hasContent = iframe.src && iframe.src !== 'about:blank';
          const isMCFrame = iframe.id === 'minecraft-frame';
          const isBrowserFrame = iframe.classList.contains('browser-iframe');
          
          if (hasContent || isMCFrame || isBrowserFrame) {
            const container = iframe.parentElement;
            if (container) {
              preservedIframes.set(iframeKey, {
                iframe: iframe,
                parentStyles: container.getAttribute('style'),
                isMinimized: win.isMinimized,
                appId: win.appId,
                winId: win.id,
                idx: idx,
                src: iframe.src
              });
              iframe.remove();
            }
          }
        });
        
        // Save scroll position
        const content = windowEl.querySelector('.window-content');
        if (content) {
          state.scrollPositions[win.id] = content.scrollTop;
        }
      }
      
      // Helper: Restore iframes and task manager content to a window element
      function restoreWindowIframes(windowEl, win) {
        // RESTORE TASK MANAGER CONTENT
        if (win.appId === 'taskmanager') {
          const tmKey = `taskmanager-${win.id}`;
          const data = preservedTaskManagerContent.get(tmKey);
          if (data) {
            const windowContent = windowEl.querySelector('.window-content');
            if (windowContent && data.element) {
              windowContent.innerHTML = '';
              windowContent.appendChild(data.element);
              
              // Restore scroll position
              const processList = data.element.querySelector('[data-process-list]');
              if (processList && data.scrollTop) {
                processList.scrollTop = data.scrollTop;
              }
              
              preservedTaskManagerContent.delete(tmKey);
            }
          }
        }
        
        // RESTORE IFRAMES
        preservedIframes.forEach((data, key) => {
          if (data.winId === win.id) {
            restoreIframeToWindow(windowEl, data, key);
          }
        });
      }
      
      // Helper: Restore a single iframe to its window
      function restoreIframeToWindow(windowEl, data, key) {
        if (data.appId === 'minecraft') {
          const container = windowEl.querySelector('.minecraft-container');
          if (container) {
            // For Minecraft/WebGL: recreate the iframe instead of reusing
            // WebGL context is lost when iframe is detached from DOM
            // Creating a new iframe and injecting content will restore the game
            if (state.minecraftHtmlContent) {
              const newIframe = document.createElement('iframe');
              newIframe.id = 'minecraft-frame';
              newIframe.style.cssText = 'width: 100%; height: 100%; border: none; display: block;';
              newIframe.setAttribute('allow', 'fullscreen; gamepad; autoplay; accelerometer; gyroscope; xr-spatial-tracking');
              newIframe.setAttribute('tabindex', '0');
              newIframe.onload = function() {
                this.focus();
                if (this.contentWindow) this.contentWindow.focus();
                console.log('Minecraft iframe restored with new WebGL context');
              };
              container.appendChild(newIframe);
              // Inject content via srcdoc for proper localStorage access
              newIframe.srcdoc = state.minecraftHtmlContent;
            } else if (state.minecraftBlobUrl) {
              // Fallback to blob URL
              const newIframe = document.createElement('iframe');
              newIframe.id = 'minecraft-frame';
              newIframe.src = state.minecraftBlobUrl;
              newIframe.style.cssText = 'width: 100%; height: 100%; border: none; display: block;';
              newIframe.setAttribute('allow', 'fullscreen; gamepad; autoplay; accelerometer; gyroscope; xr-spatial-tracking');
              newIframe.setAttribute('tabindex', '0');
              newIframe.onload = function() {
                this.focus();
                if (this.contentWindow) this.contentWindow.focus();
                console.log('Minecraft iframe restored (blob URL fallback)');
              };
              container.appendChild(newIframe);
            } else if (data.iframe) {
              // Fallback: try to reuse old iframe if no content available
              container.appendChild(data.iframe);
            }
            preservedIframes.delete(key);
          }
        } else if (data.appId === 'browser') {
          // Browser can have MULTIPLE iframes (tabs). Restore by matching the original iframe id.
          let target = null;
          if (data.iframe && data.iframe.id) {
            const byId = document.getElementById(data.iframe.id);
            if (byId && windowEl.contains(byId)) target = byId;
          }

          if (!target) {
            const iframes = windowEl.querySelectorAll('iframe.browser-iframe');
            target = iframes[data.idx] || iframes[0] || null;
          }

          if (target && data.iframe) {
            target.replaceWith(data.iframe);
            preservedIframes.delete(key);
          }
        } else {
          const iframes = windowEl.querySelectorAll('iframe');
          if (iframes[data.idx]) {
            iframes[data.idx].replaceWith(data.iframe);
            preservedIframes.delete(key);
          } else if (iframes.length > 0) {
            iframes[0].replaceWith(data.iframe);
            preservedIframes.delete(key);
          }
        }
      }
      
      // Render only the shell (dock, menubar, etc.) without touching windows
      function renderShell() {
        const root = document.getElementById('root');
        const existingDesktop = root.querySelector('.desktop');
        
        if (!existingDesktop) {
          // No desktop yet, do full render
          render();
          return;
        }
        
        // Update dock
        const dockContainer = existingDesktop.querySelector('.dock-container');
        if (dockContainer && !state.showLaunchpad) {
          dockContainer.outerHTML = generateDockHTML();
          setupDockMagnification();
        }
        
        // Update menubar quick settings state if needed
        const quickSettings = existingDesktop.querySelector('.quick-settings');
        if (quickSettings) {
          if (state.showQuickSettings) {
            quickSettings.classList.add('active');
          } else {
            quickSettings.classList.remove('active');
          }
        }
      }
      
      // Generate dock HTML - extracted for shell updates
      function generateDockHTML() {
        if (state.showLaunchpad) return '';
        
        const finderApp = apps.find(app => app.id === 'finder');
        const isLaunchpadActive = state.showLaunchpad;
        
        // Generate finder icon
        let finderHTML = '';
        if (finderApp) {
          const finderIconKey = finderApp.icon;
          const finderName = finderApp.name;
          finderHTML = '<div class="dock-icon" id="dock-finder" onmousedown="window.initDockDrag(event, \'finder\'); window.handleDockMouseDown(event, \'finder\')" oncontextmenu="window.showContextMenu(event, \'finder\')">' +
            icons[finderIconKey] +
            '<div class="dock-tooltip">' + finderName + '</div>' +
            (isLaunchpadActive ? '<div style="position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%);"><div style="width: 5px; height: 5px; border-radius: 50%; background: ' + state.accentColor + ';"></div></div>' : '') +
            '</div>';
        }
        
        // Generate pinned apps
        const pinnedHTML = state.pinnedApps
          .map((appId) => apps.find((app) => app.id === appId))
          .filter((app) => app !== undefined && app.id !== 'finder')
          .map((app) => {
            const openWindows = state.windows.filter((w) => w.appId === app.id && !w.isMinimized);
            const minimizedWindows = state.windows.filter((w) => w.appId === app.id && w.isMinimized);
            const windowCount = openWindows.length;
            const hasMinimized = minimizedWindows.length > 0;
            
            let indicator = '';
            if (windowCount > 0) {
              const dots = Array.from({ length: Math.min(windowCount, 3) })
                .map(() => '<div style="width: 5px; height: 5px; border-radius: 50%; background: ' + state.accentColor + ';"></div>')
                .join('');
              indicator = '<div style="position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%); display: flex; gap: 3px;">' + dots + '</div>';
            } else if (hasMinimized) {
              indicator = '<div style="position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%);"><div style="width: 5px; height: 5px; border-radius: 50%; background: ' + state.accentColor + '; opacity: 0.6;"></div></div>';
            }
            
            return '<div class="dock-icon" id="dock-' + app.id + '" onmousedown="window.initDockDrag(event, \'' + app.id + '\'); window.handleDockMouseDown(event, \'' + app.id + '\')" oncontextmenu="window.showContextMenu(event, \'' + app.id + '\')">' +
              icons[app.icon] +
              '<div class="dock-tooltip">' + app.name + '</div>' +
              indicator +
              '</div>';
          })
          .join('');
        
        // Generate unpinned open apps
        const unpinnedOpenApps = apps.filter(app => 
          !state.pinnedApps.includes(app.id) && 
          state.windows.some(w => w.appId === app.id)
        );
        
        let unpinnedHTML = '';
        if (unpinnedOpenApps.length > 0) {
          unpinnedHTML = '<div class="dock-divider"></div>';
          unpinnedHTML += unpinnedOpenApps.map((app) => {
            const openWindows = state.windows.filter((w) => w.appId === app.id && !w.isMinimized);
            const minimizedWindows = state.windows.filter((w) => w.appId === app.id && w.isMinimized);
            const windowCount = openWindows.length;
            const hasMinimized = minimizedWindows.length > 0;
            
            let indicator = '';
            if (windowCount > 0) {
              const dots = Array.from({ length: Math.min(windowCount, 3) })
                .map(() => '<div style="width: 5px; height: 5px; border-radius: 50%; background: ' + state.accentColor + ';"></div>')
                .join('');
              indicator = '<div style="position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%); display: flex; gap: 3px;">' + dots + '</div>';
            } else if (hasMinimized) {
              indicator = '<div style="position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%);"><div style="width: 5px; height: 5px; border-radius: 50%; background: ' + state.accentColor + '; opacity: 0.6;"></div></div>';
            }
            
            return '<div class="dock-icon" id="dock-' + app.id + '" onmousedown="window.initDockDrag(event, \'' + app.id + '\'); window.handleDockMouseDown(event, \'' + app.id + '\')" oncontextmenu="window.showContextMenu(event, \'' + app.id + '\')">' +
              icons[app.icon] +
              '<div class="dock-tooltip">' + app.name + '</div>' +
              indicator +
              '</div>';
          }).join('');
        }
        
        return '<div class="dock-container dock-' + (state.dockPosition || 'bottom') + '">' +
          '<div class="dock">' +
          finderHTML +
          pinnedHTML +
          unpinnedHTML +
          '</div>' +
          '</div>';
      }

      function render() {
        // Track if quick settings and notification panel were already open before render
        // This is used to prevent animation replay when only theme changes
        const wasQuickSettingsOpen = state.showQuickSettings && document.querySelector('.quick-settings.active');
        const wasNotificationPanelOpen = state.showNotificationPanel && document.querySelector('.notification-panel.active');
        
        // Update apps list with installed apps
        apps = getApps();
        
        // Initialize icon pack class on document root for CSS-based icon styling
        const iconPack = state.iconPack || 'classic';
        const docRoot = document.documentElement;
        if (!docRoot.classList.contains('icon-pack-' + iconPack)) {
          docRoot.classList.remove('icon-pack-classic', 'icon-pack-monochrome', 'icon-pack-accent', 'icon-pack-glass');
          docRoot.classList.add('icon-pack-' + iconPack);
        }
        
        // CRITICAL: Don't re-render during active window dragging/resizing to eliminate flicker
        // The drag handlers update DOM styles directly, so render() would cause visual reset
        if (dragState || resizeState) {
          // Skip render during drag/resize - DOM is updated directly in mousemove handler
          return;
        }
        
        // CRITICAL: Don't re-render during scrollbar interaction to prevent scroll position reset
        if (state.isScrolling) {
          return;
        }
        
        // CRITICAL: Don't re-render when Minecraft is actively running to prevent game interruption
        // This prevents the 3D rendering from being interrupted by UI updates
        const minecraftWin = state.windows.find(w => w.appId === 'minecraft' && !w.isMinimized);
        const minecraftFrame = minecraftWin ? document.querySelector('#minecraft-frame') : null;
        if (minecraftFrame && document.activeElement === minecraftFrame) {
          // Only skip if Minecraft has focus - allow other renders when user is interacting with OS
          console.log('Skipping render - Minecraft has focus');
          return;
        }
        
        // Don't re-render if user has text selected anywhere to preserve selection
        const selection = window.getSelection();
        if (selection && selection.toString().length > 0) {
          // Skip render to preserve text selection
          return;
        }
        
        // Don't re-render if a select dropdown is active
        const activeElement = document.activeElement;
        if (activeElement && activeElement.tagName === 'SELECT') {
          // Skip render to preserve dropdown state
          return;
        }
        
        // Don't re-render if a calibration input is focused to preserve input state
        if (activeElement && activeElement.id && activeElement.id.startsWith('cal-') && 
            (activeElement.id.endsWith('-x') || activeElement.id.endsWith('-y'))) {
          // Skip render to preserve calibration input focus and values
          return;
        }
        
        // Don't re-render if a browser address input is focused to preserve typing state
        if (activeElement && activeElement.classList && activeElement.classList.contains('browser-address-input')) {
          // Skip render to preserve browser address input focus and values
          return;
        }
        
        // Don't re-render if any input or textarea is focused to preserve typing state
        // EXCEPTION: Allow render if the input is a search/filter that expects updates
        if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
          // Allow render for settings search input and version manager interactions
          const isSettingsSearch = activeElement.closest('.settings-search');
          const isVersionManager = activeElement.closest('[data-version-manager]');
          if (!isSettingsSearch && !isVersionManager) {
            // Skip render to preserve input focus and prevent losing user's typing
            return;
          }
        }
        
        // NOTE: We no longer skip full renders just because Task Manager / Minecraft / Browser are open.
        // Those early-returns froze the rest of the desktop (opening apps, updating UI) whenever these apps existed.
        // Instead we rely on the iframe preservation system below to avoid reloads, and on app-specific in-place
        // updates (e.g. Task Manager) to reduce flicker.

        // PRESERVE IFRAMES: Save ALL iframes before re-render to prevent reload
        // This prevents game reset, browser page reload, and any other iframe content loss
        state.windows.forEach(win => {
          const windowEl = document.getElementById(`window-${win.id}`);
          if (windowEl) {
            // PRESERVE TASK MANAGER CONTENT: Save the entire Task Manager container to prevent refresh
            if (win.appId === 'taskmanager') {
              const taskManagerContainer = windowEl.querySelector('[data-task-manager-container]');
              if (taskManagerContainer) {
                const tmKey = `taskmanager-${win.id}`;
                // Save scroll position before preserving
                const processList = taskManagerContainer.querySelector('[data-process-list]');
                const scrollTop = processList ? processList.scrollTop : 0;
                
                preservedTaskManagerContent.set(tmKey, {
                  element: taskManagerContainer,
                  winId: win.id,
                  scrollTop: scrollTop
                });
                taskManagerContainer.remove();
              }
            }
            
            // Find all iframes in this window
            const iframes = windowEl.querySelectorAll('iframe');
            iframes.forEach((iframe, idx) => {
              // Generate a unique key for this iframe
              const iframeKey = `${win.appId}-${win.id}-${idx}`;
              
              // Check if iframe has content worth preserving
              const hasContent = iframe.src && iframe.src !== 'about:blank';
              const isMCFrame = iframe.id === 'minecraft-frame';
              const isBrowserFrame = iframe.classList.contains('browser-iframe');
              
              if (hasContent || isMCFrame || isBrowserFrame) {
                const container = iframe.parentElement;
                if (container) {
                  preservedIframes.set(iframeKey, {
                    iframe: iframe,
                    parentStyles: container.getAttribute('style'),
                    isMinimized: win.isMinimized,
                    appId: win.appId,
                    winId: win.id,
                    idx: idx,
                    src: iframe.src
                  });
                  iframe.remove();
                }
              }
            });
          }
        });
        
        // Preserve focus state before re-render
        const wasInputFocused = activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA');
        const inputTerminalId = wasInputFocused && activeElement.dataset ? activeElement.dataset.terminalId : null;
        const inputWindowId = wasInputFocused && activeElement.dataset ? activeElement.dataset.windowId : null;
        const cursorPosition = wasInputFocused && activeElement.selectionStart !== undefined ? activeElement.selectionStart : 0;
        
        // Save current input values before re-render
        document.querySelectorAll('.browser-address-input').forEach(input => {
          const winId = input.dataset.windowId;
          if (winId) {
            state.inputValues[winId] = input.value;
          }
        });
        
        // Save terminal input values before re-render
        document.querySelectorAll('.terminal-input').forEach(input => {
          const termId = input.dataset.terminalId;
          if (termId) {
            state.inputValues[`terminal-${termId}`] = input.value;
          }
        });
        
        // Save calibration input values before re-render (preserve hotspot values)
        const cursorTypes = typeof DEFAULT_HOTSPOTS !== 'undefined' ? Object.keys(DEFAULT_HOTSPOTS) : [];
        cursorTypes.forEach(type => {
          const xInput = document.querySelector(`#cal-${type}-x`);
          const yInput = document.querySelector(`#cal-${type}-y`);
          if (xInput && yInput) {
            liveHotspots[type].x = parseFloat(xInput.value) || 0;
            liveHotspots[type].y = parseFloat(yInput.value) || 0;
          }
        });
        
        // Save scroll positions for all windows (only if not actively scrolling)
        if (!state.isScrolling) {
          document.querySelectorAll('.window-content').forEach(content => {
            const windowEl = content.closest('.window');
            if (windowEl) {
              const windowId = windowEl.dataset.id;
              if (windowId) {
                state.scrollPositions[windowId] = content.scrollTop;
              }
            }
          });
          
          // Save terminal scroll positions
          document.querySelectorAll('.terminal-content').forEach(el => {
            const terminalId = el.dataset.terminalId;
            if (terminalId) {
              state.scrollPositions[`terminal-${terminalId}`] = el.scrollTop;
            }
          });
          
          // Save browser-specific scrollable areas
          document.querySelectorAll('.youtube-videos').forEach(el => {
            const windowEl = el.closest('.window');
            if (windowEl) {
              const windowId = windowEl.dataset.id;
              if (windowId) {
                state.scrollPositions[`${windowId}-youtube-videos`] = el.scrollTop;
              }
            }
          });
          
          document.querySelectorAll('.youtube-sidebar').forEach(el => {
            const windowEl = el.closest('.window');
            if (windowEl) {
              const windowId = windowEl.dataset.id;
              if (windowId) {
                state.scrollPositions[`${windowId}-youtube-sidebar`] = el.scrollTop;
              }
            }
          });
          
          document.querySelectorAll('.browser-home').forEach(el => {
            const windowEl = el.closest('.window');
            if (windowEl) {
              const windowId = windowEl.dataset.id;
              if (windowId) {
                state.scrollPositions[`${windowId}-browser-home`] = el.scrollTop;
              }
            }
          });
          
          // Also save launchpad scroll position
          const launchpadGrid = document.querySelector('.launchpad-grid');
          if (launchpadGrid) {
            state.scrollPositions['launchpad'] = launchpadGrid.scrollTop;
          }
          
           // Save settings content scroll position
           const settingsContent = document.querySelector('.settings-content');
           if (settingsContent) {
             state.scrollPositions['settings-content'] = settingsContent.scrollTop;
           }
           
           // Save settings sidebar scroll position
           const settingsSidebar = document.querySelector('.settings-sidebar');
           if (settingsSidebar) {
             state.scrollPositions['settings-sidebar'] = settingsSidebar.scrollTop;
           }
           
           // Save version manager internal scroll panes (list + details)
           document.querySelectorAll('.window').forEach(windowEl => {
             const windowId = windowEl.dataset.id;
             if (!windowId) return;
             const win = state.windows.find(w => w.id === parseInt(windowId));
             if (!win || win.appId !== 'versionmanager') return;

             const listEl = windowEl.querySelector('.versionmanager-list');
             if (listEl) state.scrollPositions[`${windowId}-versionmanager-list`] = listEl.scrollTop;

             const detailsEl = windowEl.querySelector('.versionmanager-details');
             if (detailsEl) state.scrollPositions[`${windowId}-versionmanager-details`] = detailsEl.scrollTop;
           });
          // Save appstore scroll positions
          document.querySelectorAll('.appstore-container').forEach(el => {
            const windowEl = el.closest('.window');
            if (windowEl) {
              const windowId = windowEl.dataset.id;
              if (windowId) {
                state.scrollPositions[`${windowId}-appstore`] = el.scrollTop;
              }
            }
          });
          
          // Save task manager scroll positions
          document.querySelectorAll('[data-process-list]').forEach(el => {
            const windowEl = el.closest('.window');
            if (windowEl) {
              const windowId = windowEl.dataset.id;
              if (windowId) {
                state.scrollPositions[`${windowId}-taskmanager`] = el.scrollTop;
              }
            }
          });
          
          // Save browser vertical tabs scroll positions
          document.querySelectorAll('.browser-sidebar .browser-tabs-container').forEach(el => {
            const windowEl = el.closest('.window');
            if (windowEl) {
              const windowId = windowEl.dataset.id;
              if (windowId) {
                state.scrollPositions[`${windowId}-browser-vertical-tabs`] = el.scrollTop;
              }
            }
          });
        }
        
        const root = document.getElementById('root');
        root.innerHTML = `
          <div class="desktop" style="--dock-scale: ${state.dockScale || 1.0};">
            <div class="desktop-bg" style="${state.customWallpaper ? `background-image: url('${state.customWallpaper}'); background-size: cover; background-position: center;` : ''}"></div>

            ${!state.showLaunchpad ? `
            <div class="menubar ${state.contextMenuCustomizeMode ? 'customize-mode' : ''}" oncontextmenu="window.showContextMenuRightClick(event)">
                <!-- M OS Context Menu (Top Bar) -->
                ${renderContextMenuBar()}
            </div>
            
            ${state.contextMenuCustomizeMode ? `
              <div class="context-menu-customize-bar">
                <div class="widgets-header">
                  <h2>
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 20px; height: 20px;">
                      <rect x="3" y="3" width="7" height="7" rx="1"/>
                      <rect x="14" y="3" width="7" height="7" rx="1"/>
                      <rect x="3" y="14" width="7" height="7" rx="1"/>
                      <rect x="14" y="14" width="7" height="7" rx="1"/>
                    </svg>
                    Widgets
                  </h2>
                  <button class="done-btn" onclick="window.exitContextMenuCustomizeMode()" style="padding: 6px 14px; border-radius: 6px; font-size: 12px; font-weight: 500; cursor: pointer; background: hsl(var(--primary)); color: hsl(var(--primary-foreground)); border: none;">
                     Close
                  </button>
                </div>
                
                <input type="text" class="widgets-search" placeholder="Search widgets..." oninput="window.filterWidgets(this.value)" />
                
                <div class="widgets-grid" id="widgets-grid">
                  ${(() => {
                    const allElements = [
                      { id: 'logo', name: 'Logo', desc: 'M OS logo button', icon: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg>' },
                      { id: 'menus', name: 'App Menus', desc: 'File, Edit, View menus', icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg>' },
                      { id: 'clock', name: 'Clock', desc: 'Date and time display', icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg>' },
                      { id: 'systray', name: 'System Tray', desc: 'WiFi, Volume, Power icons', icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 12.55a11 11 0 0 1 14.08 0"/><path d="M8.53 16.11a6 6 0 0 1 6.95 0"/><circle cx="12" cy="20" r="1" fill="currentColor"/></svg>' },
                      { id: 'notifications', name: 'Notifications', desc: 'Notification bell indicator', icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"/><path d="M13.73 21a2 2 0 0 1-3.46 0"/></svg>' },
                      { id: 'quicksettings', name: 'Quick Settings', desc: 'Power button shortcut', icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18.36 6.64a9 9 0 1 1-12.73 0"/><line x1="12" y1="2" x2="12" y2="12"/></svg>' },
                      { id: 'workspaces', name: 'Workspaces', desc: 'Virtual desktop switcher', icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/></svg>' },
                      { id: 'battery', name: 'Battery', desc: 'Battery level indicator', icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="1" y="6" width="18" height="12" rx="2"/><line x1="23" y1="10" x2="23" y2="14"/><rect x="3" y="8" width="8" height="8" fill="currentColor" opacity="0.3"/></svg>' },
                      { id: 'separator1', name: 'Separator', desc: 'Visual divider line', icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="4" x2="12" y2="20"/></svg>' },
                      { id: 'separator2', name: 'Separator', desc: 'Visual divider line', icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="4" x2="12" y2="20"/></svg>' }
                    ];
                    
                    const visibleIds = state.contextMenuLayout.elements.filter(e => e.visible).map(e => e.id);
                    
                    return allElements.map(el => {
                      const isInUse = visibleIds.includes(el.id);
                      return `
                        <div class="widget-card ${isInUse ? 'in-use' : ''}" 
                             draggable="true"
                             ondragstart="window.handleWidgetDragStart(event, '${el.id}')"
                             ondragend="window.handleWidgetDragEnd(event)"
                             onclick="${isInUse ? '' : `window.addContextMenuElement('${el.id}', 'center')`}">
                          <div class="widget-icon">${el.icon}</div>
                          <div class="widget-name">${el.name}</div>
                          <div class="widget-desc">${isInUse ? ' In use' : el.desc}</div>
                        </div>
                      `;
                    }).join('');
                  })()}
                </div>
                
                <div class="widgets-footer">
                  <button class="reset-btn" onclick="window.resetContextMenuLayout()" style="flex: 1; padding: 10px; border-radius: 8px; font-size: 12px; font-weight: 500; cursor: pointer; background: hsl(var(--accent)); color: hsl(var(--foreground)); border: none;">Reset Layout</button>
                </div>
              </div>
            ` : ''}
            
            <!-- Quick Settings Panel -->
            <div class="quick-settings ${state.showQuickSettings ? 'active' : ''}${state.showQuickSettings && wasQuickSettingsOpen ? ' skip-animation' : ''}" onclick="event.stopPropagation()">
              <div class="quick-settings-volume">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" onclick="window.setVolume(0)" style="cursor: pointer;">
                  <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>
                  ${state.volume > 50 ? '<path d="M19.07 4.93a10 10 0 0 1 0 14.14"/>' : ''}
                  ${state.volume > 0 ? '<path d="M15.54 8.46a5 5 0 0 1 0 7.07"/>' : '<line x1="23" y1="9" x2="17" y2="15"/><line x1="17" y1="9" x2="23" y2="15"/>'}
                </svg>
                <div class="volume-slider" onmousedown="window.startVolumeSlide(event)" ontouchstart="window.startVolumeSlide(event)">
                  <div class="volume-slider-fill" style="width: ${state.volume}%;"></div>
                  <div class="volume-slider-thumb" style="left: ${state.volume}%;"></div>
                </div>
                <span style="font-size: 12px; min-width: 28px; text-align: right; color: hsl(var(--muted-foreground));">${state.volume}%</span>
              </div>
              
              <!-- Icon Grid - M OS Control Center -->
              <div class="quick-settings-icons">
                <div class="quick-settings-icon-btn ${state.wifiEnabled ? 'active' : ''}" onclick="window.toggleWifi()">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M5 12.55a11 11 0 0 1 14.08 0"/>
                    <path d="M1.42 9a16 16 0 0 1 21.16 0"/>
                    <path d="M8.53 16.11a6 6 0 0 1 6.95 0"/>
                    <circle cx="12" cy="20" r="1" fill="currentColor"/>
                  </svg>
                  <span>Wi-Fi</span>
                </div>
                <div class="quick-settings-icon-btn ${state.bluetoothEnabled ? 'active' : ''}" onclick="window.toggleBluetooth()">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="6.5 6.5 17.5 17.5 12 23 12 1 17.5 6.5 6.5 17.5"/>
                  </svg>
                  <span>Bluetooth</span>
                </div>
                <div class="quick-settings-icon-btn ${state.shareEnabled ? 'active' : ''}" onclick="window.toggleShare()">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="18" cy="5" r="3"/>
                    <circle cx="6" cy="12" r="3"/>
                    <circle cx="18" cy="19" r="3"/>
                    <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/>
                    <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/>
                  </svg>
                  <span>Share</span>
                </div>
                <div class="quick-settings-icon-btn ${state.isDark ? 'active' : ''}" onclick="window.toggleTheme()">
                  <span class="qs-theme-icon theme-toggle-icon">
                    ${state.isDark ? icons.Moon : icons.Sun}
                  </span>
                  <span>${state.isDark ? 'Dark' : 'Light'}</span>
                </div>
                <div class="quick-settings-icon-btn ${state.focusEnabled ? 'active' : ''}" onclick="window.toggleFocus()">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"/>
                    <path d="M13.73 21a2 2 0 0 1-3.46 0"/>
                  </svg>
                  <span>Focus</span>
                </div>
                <div class="quick-settings-icon-btn destructive" onclick="window.showPowerDialog()">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M18.36 6.64a9 9 0 1 1-12.73 0"/>
                    <line x1="12" y1="2" x2="12" y2="12"/>
                  </svg>
                  <span>Power</span>
                </div>
              </div>
              
              <div class="quick-settings-option">
                <div class="quick-settings-option-label">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px; margin-right: 8px; display: inline-block;">
                    <path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83"/>
                  </svg>
                  Performance
                </div>
                <span class="quick-settings-option-value">Balanced</span>
              </div>
            </div>
            
            <!-- Notification Panel -->
            <div class="notification-panel ${state.showNotificationPanel ? 'active' : ''}${state.showNotificationPanel && wasNotificationPanelOpen ? ' skip-animation' : ''}" onclick="event.stopPropagation()">
              <!-- Clock & Date Section (Top) -->
              <div class="notification-clock-section">
                <div class="notification-clock-main">
                  <div class="notification-clock-time" id="notification-clock-time">${new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false })}</div>
                  <div class="notification-clock-date">${new Date().toLocaleDateString('en-US', { weekday: 'long', day: 'numeric', month: 'long' })}</div>
                </div>
              </div>
              
              <!-- Calendar Section -->
              <div class="notification-calendar-section">
                <div class="notification-calendar-header">
                  <span class="notification-calendar-month">${new Date(state.calendarYear, state.calendarMonth).toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}</span>
                  <div class="notification-calendar-nav">
                    <button onclick="window.changeCalendarMonth(-1)">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M15 18l-6-6 6-6"/>
                      </svg>
                    </button>
                    <button onclick="window.changeCalendarMonth(1)">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M9 18l6-6-6-6"/>
                      </svg>
                    </button>
                  </div>
                </div>
                
                <div class="notification-calendar-weekdays">
                  ${['Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa', 'Su'].map(d => `<span class="notification-calendar-weekday">${d}</span>`).join('')}
                </div>
                
                <div class="notification-calendar-days">
                  ${(() => {
                    const year = state.calendarYear;
                    const month = state.calendarMonth;
                    const firstDay = new Date(year, month, 1);
                    const lastDay = new Date(year, month + 1, 0);
                    const startPad = (firstDay.getDay() + 6) % 7;
                    const today = new Date();
                    const isCurrentMonth = today.getMonth() === month && today.getFullYear() === year;
                    
                    let days = '';
                    
                    // Previous month padding
                    const prevMonthLastDay = new Date(year, month, 0).getDate();
                    for (let i = startPad - 1; i >= 0; i--) {
                      days += '<span class="notification-calendar-day other-month">' + (prevMonthLastDay - i) + '</span>';
                    }
                    
                    // Current month days
                    for (let d = 1; d <= lastDay.getDate(); d++) {
                      const isToday = isCurrentMonth && d === today.getDate();
                      days += '<span class="notification-calendar-day' + (isToday ? ' today' : '') + '">' + d + '</span>';
                    }
                    
                    // Next month padding
                    const totalCells = startPad + lastDay.getDate();
                    const remaining = totalCells % 7 === 0 ? 0 : 7 - (totalCells % 7);
                    for (let i = 1; i <= remaining; i++) {
                      days += '<span class="notification-calendar-day other-month">' + i + '</span>';
                    }
                    
                    return days;
                  })()}
                </div>
              </div>
              
              <!-- Focus Timer Footer -->
              <div class="notification-footer">
                <div class="notification-footer-timer">
                  <button class="notification-footer-timer-btn" onclick="window.adjustFocusTimer(-5); event.stopPropagation();">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M5 12h14"/>
                    </svg>
                  </button>
                  <span class="notification-footer-timer-value">${state.focusTimerMinutes} min</span>
                  <button class="notification-footer-timer-btn" onclick="window.adjustFocusTimer(5); event.stopPropagation();">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M12 5v14M5 12h14"/>
                    </svg>
                  </button>
                </div>
                <button class="notification-footer-focus ${state.focusEnabled ? 'active' : ''}" onclick="window.toggleFocusMode(); event.stopPropagation();">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    ${state.focusEnabled ? '<rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/>' : '<polygon points="5 3 19 12 5 21 5 3"/>'}
                  </svg>
                  ${state.focusEnabled ? 'Stop Focus' : 'Focus'}
                </button>
              </div>
              
              <!-- Notifications Section -->
              <div class="notification-section">
                <div class="notification-header">
                  <span class="notification-header-title">Notifications</span>
                  <div class="notification-header-actions">
                    <button class="notification-header-btn" onclick="window.clearNotifications(); event.stopPropagation();" title="Clear all">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="3" width="18" height="18" rx="2"/>
                        <path d="M9 9l6 6M15 9l-6 6"/>
                      </svg>
                      Clear all
                    </button>
                  </div>
                </div>
                
                <div class="notification-list">
                  ${state.notifications.length === 0 ? `
                    <div class="notification-empty">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"/>
                        <path d="M13.73 21a2 2 0 0 1-3.46 0"/>
                      </svg>
                      <span>No notifications</span>
                    </div>
                  ` : state.notifications.map((notif, index) => {
                    const notifTime = new Date(notif.time);
                    const timeStr = notifTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                    return `
                      <div class="notification-item" style="animation-delay: ${index * 0.03}s" onclick="window.removeNotification(${notif.id}); event.stopPropagation();">
                        <div class="notification-icon">
                          ${notif.icon ? `<img src="${notif.icon}" alt="">` : `
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                              <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"/>
                              <path d="M13.73 21a2 2 0 0 1-3.46 0"/>
                            </svg>
                          `}
                        </div>
                        <div class="notification-content">
                          <div class="notification-app">
                            ${notif.app}
                            <span class="notification-time">${timeStr}</span>
                          </div>
                          <div class="notification-title">${notif.title}</div>
                          <div class="notification-body">${notif.message}</div>
                        </div>
                      </div>
                    `;
                  }).join('')}
                </div>
              </div>
            </div>
            ` : ''}

            <div class="windows-layer">
            ${generateWindowsHTML()}
            </div>

            ${!state.showLaunchpad ? `
            <div class="dock-container dock-${state.dockPosition || 'bottom'}">
              <div class="dock">
                ${(() => {
                  const finderApp = apps.find(app => app.id === 'finder');
                  const isLaunchpadActive = state.showLaunchpad;
                  const finderIconKey = finderApp.icon;
                  const finderName = finderApp.name;
                  
                  // Show finder first (macOS style)
                  if (finderApp) {
                    return `
                      <div class="dock-icon" id="dock-finder" onmousedown="window.initDockDrag(event, 'finder'); window.handleDockMouseDown(event, 'finder')" oncontextmenu="window.showContextMenu(event, 'finder')">
                        ${icons[finderIconKey]}
                        <div class="dock-tooltip">${finderName}</div>
                        ${isLaunchpadActive
                          ? `
                            <div style="position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%);">
                              <div style="width: 5px; height: 5px; border-radius: 50%; background: ${state.accentColor};"></div>
                            </div>
                          `
                          : ''}
                      </div>
                    `;
                  }
                  return '';
                })()}
                ${state.pinnedApps
                  .map((appId) => apps.find((app) => app.id === appId))
                  .filter((app) => app !== undefined && app.id !== 'finder')
                  .map((app) => {
                    const openWindows = state.windows.filter((w) => w.appId === app.id && !w.isMinimized);
                    const minimizedWindows = state.windows.filter((w) => w.appId === app.id && w.isMinimized);
                    const windowCount = openWindows.length;
                    const hasMinimized = minimizedWindows.length > 0;
                    
                    return `
                      <div class="dock-icon" id="dock-${app.id}" onmousedown="window.initDockDrag(event, '${app.id}'); window.handleDockMouseDown(event, '${app.id}')" oncontextmenu="window.showContextMenu(event, '${app.id}')">
                        ${icons[app.icon]}
                        <div class="dock-tooltip">${app.name}</div>
                        ${windowCount > 0
                          ? `
                            <div style="position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%); display: flex; gap: 3px;">
                              ${Array.from({ length: Math.min(windowCount, 3) })
                                .map(
                                  () => `
                                    <div style="width: 5px; height: 5px; border-radius: 50%; background: ${state.accentColor};"></div>
                                  `,
                                )
                                .join('')}
                            </div>
                          `
                          : hasMinimized
                          ? `
                            <div style="position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%);">
                              <div style="width: 5px; height: 5px; border-radius: 50%; background: ${state.accentColor}; opacity: 0.6;"></div>
                            </div>
                          `
                          : ''}
                      </div>
                    `;
                  })
                  .join('')}
                ${(() => {
                  // Get unpinned apps that have open or minimized windows
                  const unpinnedOpenApps = apps.filter(app => 
                    !state.pinnedApps.includes(app.id) && 
                    state.windows.some(w => w.appId === app.id)
                  );
                  
                  if (unpinnedOpenApps.length === 0) return '';
                  
                  return `
                    <div class="dock-divider"></div>
                    ${unpinnedOpenApps.map((app) => {
                      const openWindows = state.windows.filter((w) => w.appId === app.id && !w.isMinimized);
                      const minimizedWindows = state.windows.filter((w) => w.appId === app.id && w.isMinimized);
                      const windowCount = openWindows.length;
                      const hasMinimized = minimizedWindows.length > 0;
                      return `
                        <div class="dock-icon" id="dock-${app.id}" onmousedown="window.initDockDrag(event, '${app.id}'); window.handleDockMouseDown(event, '${app.id}')" oncontextmenu="window.showContextMenu(event, '${app.id}')">
                          ${icons[app.icon]}
                          <div class="dock-tooltip">${app.name}</div>
                          ${windowCount > 0
                            ? `
                              <div style="position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%); display: flex; gap: 3px;">
                                ${Array.from({ length: Math.min(windowCount, 3) })
                                  .map(
                                    () => `
                                      <div style="width: 5px; height: 5px; border-radius: 50%; background: ${state.accentColor};"></div>
                                    `,
                                  )
                                  .join('')}
                              </div>
                            `
                            : hasMinimized
                            ? `
                              <div style="position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%);">
                                <div style="width: 5px; height: 5px; border-radius: 50%; background: ${state.accentColor}; opacity: 0.6;"></div>
                              </div>
                            `
                            : ''}
                        </div>
                      `;
                    }).join('')}
                  `;
                })()}
              </div>
            </div>
            ` : ''}

            ${state.showLaunchpad ? `
              <div class="launchpad-overlay" onclick="if(event.target === event.currentTarget) window.closeLaunchpad();">
                <div class="launchpad-search-container">
                  <input 
                    type="text" 
                    id="launchpad-search" 
                    class="launchpad-search" 
                    placeholder="Search" 
                    value="${state.launchpadSearch}"
                    oninput="window.handleLaunchpadSearch(event)"
                    onclick="event.stopPropagation()"
                  />
                </div>
                <div class="launchpad-grid" onclick="if(event.target === event.currentTarget) window.closeLaunchpad();">
                  ${apps
                    .filter(app => {
                      if (app.id === 'finder') return false; // Hide app launcher from launchpad
                      if (!state.launchpadSearch) return true;
                      const searchLower = state.launchpadSearch.toLowerCase();
                      return app.name.toLowerCase().includes(searchLower);
                    })
                    .map(app => `
                      <div class="launchpad-item" onclick="window.toggleWindow('${app.id}'); window.closeLaunchpad();">
                        ${icons[app.icon]}
                        <span style="color: white; font-size: 13px; text-align: center; font-weight: 500;">${app.name}</span>
                      </div>
                    `)
                    .join('')}
                </div>
              </div>
            ` : ''}

            ${state.contextMenu
              ? `
                <div class="context-menu" style="left: ${state.contextMenu.x}px; top: ${state.contextMenu.y}px;">
                  <div class="context-menu-item" onclick="window.toggleWindow('${state.contextMenu.appId}'); state.contextMenu = null; render();">
                    Open
                  </div>
                  ${!apps.find((a) => a.id === state.contextMenu.appId)?.isPermanent
                    ? `
                      <div class="context-menu-divider"></div>
                      <div class="context-menu-item" onclick="window.togglePinApp('${state.contextMenu.appId}')">
                        ${state.pinnedApps.includes(state.contextMenu.appId) ? 'Unpin from Dock' : 'Pin to Dock'}
                      </div>
                    `
                    : ''}
                  <div class="context-menu-divider"></div>
                  <div class="context-menu-item" onclick="window.toggleWindow('taskmanager'); state.contextMenu = null; render();">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px; margin-right: 6px; vertical-align: middle;">
                      <rect x="3" y="3" width="7" height="7"/>
                      <rect x="14" y="3" width="7" height="7"/>
                      <rect x="14" y="14" width="7" height="7"/>
                      <rect x="3" y="14" width="7" height="7"/>
                    </svg>
                    Task Manager
                  </div>
                </div>
              `
              : ''}

            ${state.menubarContextMenu
              ? `
                <div class="menubar-context-menu" style="left: ${state.menubarContextMenu.x}px; top: ${state.menubarContextMenu.y}px;" onclick="event.stopPropagation()">
                  <div class="menubar-context-menu-header">Context Menu</div>
                  <div class="context-menu-item" onclick="window.enterContextMenuCustomizeMode(); state.menubarContextMenu = null; render();">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                      <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                      <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                    </svg>
                    Customize Layout
                  </div>
                  <div class="context-menu-divider"></div>
                  <div class="context-menu-item" onclick="window.toggleWindow('settings'); state.menubarContextMenu = null; render();">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                      <circle cx="12" cy="12" r="3"/>
                      <path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/>
                    </svg>
                    Settings
                  </div>
                  <div class="context-menu-divider"></div>
                  <div class="context-menu-item" onclick="window.toggleTheme(); state.menubarContextMenu = null; render();">
                    ${state.isDark 
                      ? `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>` 
                      : `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>`
                    }
                    ${state.isDark ? 'Switch to Light' : 'Switch to Dark'}
                  </div>
                  <div class="context-menu-item" onclick="window.toggleQuickSettings(); state.menubarContextMenu = null; render();">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                      <rect x="3" y="3" width="7" height="7"/>
                      <rect x="14" y="3" width="7" height="7"/>
                      <rect x="14" y="14" width="7" height="7"/>
                      <rect x="3" y="14" width="7" height="7"/>
                    </svg>
                    Control Center
                  </div>
                  <div class="context-menu-divider"></div>
                  <div class="context-menu-item" onclick="state.showLaunchpad = true; state.menubarContextMenu = null; render();">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                      <circle cx="12" cy="12" r="10"/>
                      <path d="M14.31 8l5.74 9.94M9.69 8h11.48M7.38 12l5.74-9.94M9.69 16L3.95 6.06M14.31 16H2.83M16.62 12l-5.74 9.94"/>
                    </svg>
                    Show Launchpad
                  </div>
                  <div class="context-menu-item" onclick="window.toggleWindow('taskmanager'); state.menubarContextMenu = null; render();">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                      <rect x="3" y="14" width="4" height="7"/>
                      <rect x="10" y="9" width="4" height="12"/>
                      <rect x="17" y="4" width="4" height="17"/>
                    </svg>
                    Task Manager
                  </div>
                </div>
              `
              : ''}
            
            ${state.showAddSiteDialog ? `
              <div class="add-site-dialog-overlay" onclick="if(event.target === this) window.closeAddSiteDialog()">
                <div class="add-site-dialog" onclick="event.stopPropagation()">
                  <h3>Add Shortcut</h3>
                  <div class="add-site-form">
                    <div class="add-site-input-group">
                      <label class="add-site-label" for="add-site-title">Title</label>
                      <input type="text" id="add-site-title" class="add-site-input" placeholder="My Favorite Site" />
                    </div>
                    <div class="add-site-input-group">
                      <label class="add-site-label" for="add-site-url">URL</label>
                      <input type="text" id="add-site-url" class="add-site-input" placeholder="example.com" onkeydown="if(event.key === 'Enter') window.addSavedSite()" />
                    </div>
                    <div class="add-site-buttons">
                      <button class="add-site-button add-site-button-cancel" onclick="window.closeAddSiteDialog()">Cancel</button>
                      <button class="add-site-button add-site-button-submit" onclick="window.addSavedSite()">Add</button>
                    </div>
                  </div>
                </div>
              </div>
            ` : ''}
            
            ${state.showEditBookmarkDialog ? `
              <div class="add-site-dialog-overlay" onclick="if(event.target === this) window.closeEditBookmarkDialog()">
                <div class="add-site-dialog" onclick="event.stopPropagation()">
                  <h3>${state.editingBookmarkIndex !== null ? 'Edit Bookmark' : 'Add Bookmark'}</h3>
                  <div class="add-site-form">
                    <div class="add-site-input-group">
                      <label class="add-site-label" for="edit-bookmark-url">URL</label>
                      <input type="text" id="edit-bookmark-url" class="add-site-input" placeholder="https://example.com" onkeydown="if(event.key === 'Enter') window.saveBookmark()" />
                    </div>
                    <div class="add-site-buttons">
                      <button class="add-site-button add-site-button-cancel" onclick="window.closeEditBookmarkDialog()">Cancel</button>
                      <button class="add-site-button add-site-button-submit" onclick="window.saveBookmark()">Save</button>
                    </div>
                  </div>
                </div>
              </div>
            ` : ''}
            
            ${state.showEditSiteDialog ? `
              <div class="add-site-dialog-overlay" onclick="if(event.target === this) window.closeEditSiteDialog()">
                <div class="add-site-dialog" onclick="event.stopPropagation()">
                  <h3>Edit Shortcut</h3>
                  <div class="add-site-form">
                    <div class="add-site-input-group">
                      <label class="add-site-label" for="edit-site-title">Title</label>
                      <input type="text" id="edit-site-title" class="add-site-input" placeholder="My Favorite Site" />
                    </div>
                    <div class="add-site-input-group">
                      <label class="add-site-label" for="edit-site-url">URL</label>
                      <input type="text" id="edit-site-url" class="add-site-input" placeholder="example.com" onkeydown="if(event.key === 'Enter') window.saveEditedSite()" />
                    </div>
                    <div class="add-site-buttons">
                      <button class="add-site-button add-site-button-cancel" onclick="window.closeEditSiteDialog()">Cancel</button>
                      <button class="add-site-button add-site-button-submit" onclick="window.saveEditedSite()">Save</button>
                    </div>
                  </div>
                </div>
              </div>
            ` : ''}
            
            <!-- Snap Indicator -->
            <div class="snap-indicator"></div>
          </div>
        `;
        
        // Restore focus to input fields after re-render
        if (wasInputFocused) {
          requestAnimationFrame(() => {
            let newInput = null;
            
            // For terminal inputs, use data-terminal-id to find the correct input
            if (inputTerminalId) {
              newInput = document.querySelector(`input[data-terminal-id="${inputTerminalId}"]`);
            } else if (inputWindowId) {
              // For browser inputs, use data-window-id
              newInput = document.querySelector(`input[data-window-id="${inputWindowId}"]`);
            }
            
            if (newInput && (newInput.tagName === 'INPUT' || newInput.tagName === 'TEXTAREA')) {
              // Restore value for browser inputs
              if (inputWindowId && state.inputValues[inputWindowId] !== undefined) {
                newInput.value = state.inputValues[inputWindowId];
              }
              // Restore value for terminal inputs
              if (inputTerminalId && state.inputValues[`terminal-${inputTerminalId}`] !== undefined) {
                newInput.value = state.inputValues[`terminal-${inputTerminalId}`];
              }
              newInput.focus();
              // Restore cursor position
              if (newInput.setSelectionRange && typeof cursorPosition === 'number') {
                newInput.setSelectionRange(cursorPosition, cursorPosition);
              }
            }
          });
        }
        
        // RESTORE PRESERVED TASK MANAGER CONTENT: Re-attach preserved Task Manager containers
        // Do this synchronously before iframes for immediate restoration
        preservedTaskManagerContent.forEach((data, key) => {
          const windowEl = document.getElementById(`window-${data.winId}`);
          if (windowEl) {
            const windowContent = windowEl.querySelector('.window-content');
            if (windowContent && data.element) {
              // Clear the placeholder content and append the preserved Task Manager
              windowContent.innerHTML = '';
              windowContent.appendChild(data.element);
              
              // Restore scroll position
              const processList = data.element.querySelector('[data-process-list]');
              if (processList && data.scrollTop) {
                processList.scrollTop = data.scrollTop;
              }
              
              preservedTaskManagerContent.delete(key);
            }
          }
        });
        
        // RESTORE PRESERVED IFRAMES: Re-attach all preserved iframes to prevent reload
        // Do this synchronously, not in requestAnimationFrame, for immediate restoration
        preservedIframes.forEach((data, key) => {
          const windowEl = document.getElementById(`window-${data.winId}`);
          if (windowEl) {
            // Find the appropriate container based on appId
            let container = null;
            let newIframe = null;
            
            if (data.appId === 'minecraft') {
              container = windowEl.querySelector('.minecraft-container');
              if (container && data.iframe) {
                container.appendChild(data.iframe);
                preservedIframes.delete(key);
              }
            } else if (data.appId === 'browser') {
              // Browser can have multiple tab iframes; restore by matching the original iframe id.
              let target = null;
              if (data.iframe && data.iframe.id) {
                const byId = document.getElementById(data.iframe.id);
                if (byId && windowEl.contains(byId)) target = byId;
              }

              if (!target) {
                const iframes = windowEl.querySelectorAll('iframe.browser-iframe');
                target = iframes[data.idx] || iframes[0] || null;
              }

              if (target && data.iframe) {
                target.replaceWith(data.iframe);
                preservedIframes.delete(key);
              }
            } else {
              // Generic iframe restoration - find iframe at same position
              const iframes = windowEl.querySelectorAll('iframe');
              if (iframes[data.idx]) {
                iframes[data.idx].replaceWith(data.iframe);
                preservedIframes.delete(key);
              } else if (iframes.length > 0) {
                // Fallback: replace first iframe found
                iframes[0].replaceWith(data.iframe);
                preservedIframes.delete(key);
              }
            }
          }
          // If windowEl doesn't exist (window is minimized), keep the iframe preserved
          // It will be reattached when the window is restored
        });
        
        // Restore scroll positions IMMEDIATELY - must happen synchronously to prevent visual flash
        const restoreAllScrolls = () => {
           document.querySelectorAll('.window-content').forEach(content => {
             const windowEl = content.closest('.window');
             if (windowEl) {
               const windowId = windowEl.dataset.id;
               if (windowId && state.scrollPositions[windowId] !== undefined) {
                 content.scrollTop = state.scrollPositions[windowId];
               }
             }
           });
           
           // Restore version manager internal scroll panes (list + details)
           document.querySelectorAll('.window').forEach(windowEl => {
             const windowId = windowEl.dataset.id;
             if (!windowId) return;
             const win = state.windows.find(w => w.id === parseInt(windowId));
             if (!win || win.appId !== 'versionmanager') return;

             const listEl = windowEl.querySelector('.versionmanager-list');
             if (listEl && state.scrollPositions[`${windowId}-versionmanager-list`] !== undefined) {
               listEl.scrollTop = state.scrollPositions[`${windowId}-versionmanager-list`];
             }

             const detailsEl = windowEl.querySelector('.versionmanager-details');
             if (detailsEl && state.scrollPositions[`${windowId}-versionmanager-details`] !== undefined) {
               detailsEl.scrollTop = state.scrollPositions[`${windowId}-versionmanager-details`];
             }
           });
          
          // Restore terminal scroll positions
          document.querySelectorAll('.terminal-content').forEach(el => {
            const terminalId = el.dataset.terminalId;
            if (terminalId && state.scrollPositions[`terminal-${terminalId}`] !== undefined) {
              el.scrollTop = state.scrollPositions[`terminal-${terminalId}`];
            }
          });
          
          // Restore browser-specific scrollable areas
          document.querySelectorAll('.youtube-videos').forEach(el => {
            const windowEl = el.closest('.window');
            if (windowEl) {
              const windowId = windowEl.dataset.id;
              if (windowId && state.scrollPositions[`${windowId}-youtube-videos`] !== undefined) {
                el.scrollTop = state.scrollPositions[`${windowId}-youtube-videos`];
              }
            }
          });
          
          document.querySelectorAll('.youtube-sidebar').forEach(el => {
            const windowEl = el.closest('.window');
            if (windowEl) {
              const windowId = windowEl.dataset.id;
              if (windowId && state.scrollPositions[`${windowId}-youtube-sidebar`] !== undefined) {
                el.scrollTop = state.scrollPositions[`${windowId}-youtube-sidebar`];
              }
            }
          });
          
          document.querySelectorAll('.browser-home').forEach(el => {
            const windowEl = el.closest('.window');
            if (windowEl) {
              const windowId = windowEl.dataset.id;
              if (windowId && state.scrollPositions[`${windowId}-browser-home`] !== undefined) {
                el.scrollTop = state.scrollPositions[`${windowId}-browser-home`];
              }
            }
          });
          
          const launchpad = document.querySelector('.launchpad-grid');
          if (launchpad && state.scrollPositions['launchpad'] !== undefined) {
            launchpad.scrollTop = state.scrollPositions['launchpad'];
          }
          
          const settingsContent = document.querySelector('.settings-content');
          if (settingsContent && state.scrollPositions['settings-content'] !== undefined) {
            settingsContent.scrollTop = state.scrollPositions['settings-content'];
          }
          
          const settingsSidebar = document.querySelector('.settings-sidebar');
          if (settingsSidebar && state.scrollPositions['settings-sidebar'] !== undefined) {
            settingsSidebar.scrollTop = state.scrollPositions['settings-sidebar'];
          }
          
          // Restore appstore scroll positions
          document.querySelectorAll('.appstore-container').forEach(el => {
            const windowEl = el.closest('.window');
            if (windowEl) {
              const windowId = windowEl.dataset.id;
              if (windowId && state.scrollPositions[`${windowId}-appstore`] !== undefined) {
                el.scrollTop = state.scrollPositions[`${windowId}-appstore`];
              }
            }
          });
          
          // Restore task manager scroll positions
          document.querySelectorAll('[data-process-list]').forEach(el => {
            const windowEl = el.closest('.window');
            if (windowEl) {
              const windowId = windowEl.dataset.id;
              if (windowId && state.scrollPositions[`${windowId}-taskmanager`] !== undefined) {
                el.scrollTop = state.scrollPositions[`${windowId}-taskmanager`];
              }
            }
          });
          
          // Restore browser vertical tabs scroll positions
          document.querySelectorAll('.browser-sidebar .browser-tabs-container').forEach(el => {
            const windowEl = el.closest('.window');
            if (windowEl) {
              const windowId = windowEl.dataset.id;
              if (windowId && state.scrollPositions[`${windowId}-browser-vertical-tabs`] !== undefined) {
                el.scrollTop = state.scrollPositions[`${windowId}-browser-vertical-tabs`];
              }
            }
          });
        };
        
        // Call immediately to prevent visual flash
        restoreAllScrolls();
        
        // Force a synchronous reflow to ensure scroll positions are applied before paint
        void document.body.offsetHeight;
        
        // Also restore in next frame as a backup for any delayed content rendering
        requestAnimationFrame(restoreAllScrolls);
        
        // Setup scroll tracking for all scrollable areas to maintain positions during re-renders
        const setupScrollTracking = () => {
          // Track scrolling state
          const handleScroll = (e) => {
            const element = e.target;
            state.isScrolling = true;
            
            // Clear existing timeout
            if (state.scrollTimeout) {
              clearTimeout(state.scrollTimeout);
            }
            
            // Update scroll position immediately
            if (element.classList.contains('window-content')) {
              const windowEl = element.closest('.window');
              if (windowEl) {
                const windowId = windowEl.dataset.id;
                if (windowId) {
                  state.scrollPositions[windowId] = element.scrollTop;
                }
              }
            } else if (element.classList.contains('terminal-content')) {
              const terminalId = element.dataset.terminalId;
              if (terminalId) {
                state.scrollPositions[`terminal-${terminalId}`] = element.scrollTop;
              }
            } else if (element.classList.contains('youtube-videos')) {
              const windowEl = element.closest('.window');
              if (windowEl) {
                const windowId = windowEl.dataset.id;
                if (windowId) {
                  state.scrollPositions[`${windowId}-youtube-videos`] = element.scrollTop;
                }
              }
            } else if (element.classList.contains('youtube-sidebar')) {
              const windowEl = element.closest('.window');
              if (windowEl) {
                const windowId = windowEl.dataset.id;
                if (windowId) {
                  state.scrollPositions[`${windowId}-youtube-sidebar`] = element.scrollTop;
                }
              }
            } else if (element.classList.contains('browser-home')) {
              const windowEl = element.closest('.window');
              if (windowEl) {
                const windowId = windowEl.dataset.id;
                if (windowId) {
                  state.scrollPositions[`${windowId}-browser-home`] = element.scrollTop;
                }
              }
            } else if (element.classList.contains('launchpad-grid')) {
              state.scrollPositions['launchpad'] = element.scrollTop;
            } else if (element.classList.contains('settings-content')) {
              state.scrollPositions['settings-content'] = element.scrollTop;
            } else if (element.classList.contains('settings-sidebar')) {
              state.scrollPositions['settings-sidebar'] = element.scrollTop;
            } else if (element.classList.contains('appstore-container')) {
              const windowEl = element.closest('.window');
              if (windowEl) {
                const windowId = windowEl.dataset.id;
                if (windowId) {
                  state.scrollPositions[`${windowId}-appstore`] = element.scrollTop;
                }
              }
            } else if (element.classList.contains('browser-tabs-container') && element.closest('.browser-sidebar')) {
              const windowEl = element.closest('.window');
              if (windowEl) {
                const windowId = windowEl.dataset.id;
                if (windowId) {
                  state.scrollPositions[`${windowId}-browser-vertical-tabs`] = element.scrollTop;
                }
              }
            }
            
            // Set timeout to mark scrolling as finished after 150ms of no scroll events
            state.scrollTimeout = setTimeout(() => {
              state.isScrolling = false;
            }, 150);
          };
          
          // Add scroll listeners to all scrollable areas
           document.querySelectorAll('.window-content, .terminal-content, .youtube-videos, .youtube-sidebar, .browser-home, .versionmanager-list, .versionmanager-details, .launchpad-grid, .settings-content, .settings-sidebar, .appstore-container, .browser-sidebar .browser-tabs-container').forEach(el => {
             el.addEventListener('scroll', handleScroll, { passive: true });
           });
        };
        
        // Setup scroll tracking after a short delay to ensure all elements are rendered
        setTimeout(setupScrollTracking, 50);
        
        // Add skip-animation class to quick-settings if it was already open before render
        // This prevents the open animation from replaying when only theme/content changes
        if (wasQuickSettingsOpen && state.showQuickSettings) {
          const quickSettingsEl = document.querySelector('.quick-settings');
          if (quickSettingsEl) {
            quickSettingsEl.classList.add('skip-animation');
          }
        }
        
        // Add skip-animation class to notification panel if it was already open before render
        if (wasNotificationPanelOpen && state.showNotificationPanel) {
          const notificationPanelEl = document.querySelector('.notification-panel');
          if (notificationPanelEl) {
            notificationPanelEl.classList.add('skip-animation');
          }
        }
        
        // Setup dock magnification effect
        setupDockMagnification();
        
        // Focus iframe in fullscreen windows so keyboard controls work
        setupFullscreenIframeFocus();
        
        // Inject content into Minecraft iframes that need it
        injectMinecraftIframeContent();
        
        // Re-setup calibration events if calibration window exists (content is now inline)
        if (calibrationWindowId !== null) {
          const calibrationWin = state.windows.find(w => w.id === calibrationWindowId);
          if (calibrationWin && !calibrationWin.isMinimized) {
            requestAnimationFrame(() => {
              const windowContent = document.querySelector(`[data-id="${calibrationWindowId}"] .window-content`);
              if (windowContent) {
                setupCalibrationEvents(windowContent);
                updateCalibrationPreview();
              }
            });
          }
        }
      }
      
      // Setup focus on iframes in fullscreen windows for keyboard controls
      function setupFullscreenIframeFocus() {
        state.windows.forEach(win => {
          if (win.isFullscreen) {
            const windowEl = document.getElementById(`window-${win.id}`);
            if (windowEl) {
              const iframe = windowEl.querySelector('iframe');
              if (iframe) {
                // Delay focus slightly to ensure iframe is ready
                setTimeout(() => {
                  try {
                    iframe.focus();
                    if (iframe.contentWindow) {
                      iframe.contentWindow.focus();
                    }
                  } catch (e) {
                    iframe.focus();
                  }
                }, 100);
              }
            }
          }
        });
      }

      // Dock magnification effect setup
      function setupDockMagnification() {
        const dock = document.querySelector('.dock');
        const dockContainer = document.querySelector('.dock-container');
        
        if (!dock || !dockContainer) return;
        
        const maxScale = 1.5; // Maximum magnification scale
        const influenceRadius = 120; // Distance in pixels that affects nearby icons
        
        // Remove any existing listener
        if (dockContainer._magnifyHandler) {
          dockContainer.removeEventListener('mousemove', dockContainer._magnifyHandler);
          dockContainer.removeEventListener('mouseleave', dockContainer._magnifyLeave);
        }
        
        const magnifyHandler = (e) => {
          // Skip magnification when dragging windows or resizing
          if (dragState || resizeState || document.body.classList.contains('window-dragging')) {
            // Reset all icons to default scale when dragging
            const icons = Array.from(dock.querySelectorAll('.dock-icon'));
            const dividers = Array.from(dock.querySelectorAll('.dock-divider'));
            
            icons.forEach(icon => {
              icon.style.setProperty('--icon-magnify', 1);
              const svg = icon.querySelector('svg');
              if (svg) {
                svg.style.transform = 'translateY(0)';
              }
            });
            
            dividers.forEach(divider => {
              divider.style.setProperty('--icon-magnify', 1);
            });
            return;
          }
          
          const icons = Array.from(dock.querySelectorAll('.dock-icon'));
          if (icons.length === 0) return;
          
          const dockPosition = state.dockPosition || 'bottom';
          
          icons.forEach(icon => {
            const rect = icon.getBoundingClientRect();
            const iconCenter = {
              x: rect.left + rect.width / 2,
              y: rect.top + rect.height / 2
            };
            
            // Calculate distance from mouse to icon center
            const distance = dockPosition === 'bottom' 
              ? Math.abs(e.clientX - iconCenter.x)
              : Math.abs(e.clientY - iconCenter.y);
            
            // Calculate scale based on distance
            let scale = 1;
            if (distance < influenceRadius) {
              const normalizedDistance = distance / influenceRadius;
              scale = maxScale - (maxScale - 1) * normalizedDistance;
            }
            
            // Apply scale via CSS variable (horizontal growth)
            icon.style.setProperty('--icon-magnify', scale);
            
            // For bottom dock: Calculate vertical translation (move icon up as it scales)
            if (dockPosition === 'bottom') {
              const baseSize = 48 * (state.dockScale || 1);
              const scaledSize = baseSize * scale;
              const verticalOffset = (scaledSize - baseSize); // Move up by full growth amount
              
              // Apply transform for vertical movement to the SVG
              const svg = icon.querySelector('svg');
              if (svg) {
                svg.style.transform = `translateY(${-verticalOffset}px)`;
              }
            }
            
            // Don't scale dividers
            const divider = icon.nextElementSibling;
            if (divider && divider.classList.contains('dock-divider')) {
              divider.style.setProperty('--icon-magnify', 1);
            }
          });
        };
        
        const leaveHandler = () => {
          const icons = Array.from(dock.querySelectorAll('.dock-icon'));
          const dividers = Array.from(dock.querySelectorAll('.dock-divider'));
          
          icons.forEach(icon => {
            icon.style.setProperty('--icon-magnify', 1);
            const svg = icon.querySelector('svg');
            if (svg) {
              svg.style.transform = 'translateY(0)';
            }
          });
          
          dividers.forEach(divider => {
            divider.style.setProperty('--icon-magnify', 1);
          });
        };
        
        // Store handlers for removal
        dockContainer._magnifyHandler = magnifyHandler;
        dockContainer._magnifyLeave = leaveHandler;
        
        dockContainer.addEventListener('mousemove', magnifyHandler);
        dockContainer.addEventListener('mouseleave', leaveHandler);
      }
        const win = state.windows.find((w) => w.id === id);
        if (win && !win.isFullscreen && win.appId !== 'terminal') {
          maximizeWindow(id);
        };

      window.handleWallpaperUpload = function handleWallpaperUpload(event) {
        // Deprecated - kept for compatibility
      };

      let tempWallpaperPair = { dark: null, light: null };
      window.tempWallpaperName = ''; // Global variable to persist wallpaper name across renders

      window.showAddWallpaperDialog = function showAddWallpaperDialog() {
        const overlay = document.createElement('div');
        overlay.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); backdrop-filter: blur(4px); display: flex; align-items: center; justify-content: center; z-index: 10000; animation: fadeIn 0.2s ease;';
        
        const dialog = document.createElement('div');
        dialog.style.cssText = 'background: hsl(var(--background)); border-radius: 12px; padding: 24px; width: 90%; max-width: 500px; box-shadow: 0 20px 40px rgba(0,0,0,0.3); animation: slideUp 0.3s ease;';
        
        dialog.innerHTML = `
          <style>
            @keyframes fadeIn {
              from { opacity: 0; }
              to { opacity: 1; }
            }
            @keyframes slideUp {
              from { transform: translateY(20px); opacity: 0; }
              to { transform: translateY(0); opacity: 1; }
            }
          </style>
          <h3 style="font-size: 18px; font-weight: 600; margin-bottom: 16px; color: hsl(var(--foreground));">Add New Wallpaper Pair</h3>
          <input type="text" id="dialog-wallpaper-name" placeholder="Wallpaper Name" value="${window.tempWallpaperName || ''}" style="width: 100%; padding: 10px; margin-bottom: 12px; background: hsl(var(--accent)); border: 1px solid hsl(var(--border)); border-radius: 8px; font-size: 14px; color: hsl(var(--foreground));" />
          
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px;">
            <div>
              <label style="display: block; font-size: 12px; font-weight: 500; margin-bottom: 6px; color: hsl(var(--muted-foreground));">Dark Mode</label>
              <input type="file" id="dialog-wallpaper-dark" accept="image/*" style="display: none;" />
              <button class="wallpaper-upload-btn" onclick="document.getElementById('dialog-wallpaper-dark').click()" style="width: 100%; padding: 10px; font-size: 13px;">
                Choose Image
              </button>
              <div id="dialog-dark-preview" style="margin-top: 6px; font-size: 11px; color: hsl(var(--muted-foreground)); text-align: center;">No file selected</div>
            </div>
            <div>
              <label style="display: block; font-size: 12px; font-weight: 500; margin-bottom: 6px; color: hsl(var(--muted-foreground));">Light Mode</label>
              <input type="file" id="dialog-wallpaper-light" accept="image/*" style="display: none;" />
              <button class="wallpaper-upload-btn" onclick="document.getElementById('dialog-wallpaper-light').click()" style="width: 100%; padding: 10px; font-size: 13px;">
                Choose Image
              </button>
              <div id="dialog-light-preview" style="margin-top: 6px; font-size: 11px; color: hsl(var(--muted-foreground)); text-align: center;">No file selected</div>
            </div>
          </div>
          
          <div style="display: flex; gap: 8px; justify-content: flex-end;">
            <button id="dialog-cancel" style="padding: 10px 20px; background: hsl(var(--secondary)); color: hsl(var(--secondary-foreground)); border: none; border-radius: 8px; font-size: 14px; font-weight: 500; cursor: pointer;">
              Cancel
            </button>
            <button id="dialog-save" style="padding: 10px 20px; background: hsl(var(--primary)); color: hsl(var(--primary-foreground)); border: none; border-radius: 8px; font-size: 14px; font-weight: 500; cursor: pointer;">
              Add Wallpaper
            </button>
          </div>
        `;
        
        overlay.appendChild(dialog);
        document.body.appendChild(overlay);
        
        // Focus input
        setTimeout(() => document.getElementById('dialog-wallpaper-name').focus(), 100);
        
        // Handle name input
        const nameInput = document.getElementById('dialog-wallpaper-name');
        nameInput.addEventListener('input', (e) => {
          window.tempWallpaperName = e.target.value;
        });
        
        // Handle file uploads
        document.getElementById('dialog-wallpaper-dark').addEventListener('change', (e) => {
          window.handleWallpaperPairUpload('dark', e, 'dialog-dark-preview');
        });
        
        document.getElementById('dialog-wallpaper-light').addEventListener('change', (e) => {
          window.handleWallpaperPairUpload('light', e, 'dialog-light-preview');
        });
        
        // Handle buttons
        document.getElementById('dialog-cancel').addEventListener('click', () => {
          document.body.removeChild(overlay);
        });
        
        document.getElementById('dialog-save').addEventListener('click', () => {
          window.saveWallpaperPair();
          document.body.removeChild(overlay);
        });
        
        // Close on overlay click
        overlay.addEventListener('click', (e) => {
          if (e.target === overlay) {
            document.body.removeChild(overlay);
          }
        });
      };

      window.handleWallpaperPairUpload = function handleWallpaperPairUpload(type, event, previewId) {
        const file = event.target.files[0];
        if (!file) return;

        if (!file.type.startsWith('image/')) {
          alert('Please upload an image file');
          return;
        }

        const reader = new FileReader();
        reader.onload = function(e) {
          tempWallpaperPair[type] = e.target.result;
          const preview = document.getElementById(previewId || `${type}-preview`);
          if (preview) {
            preview.textContent = ' ' + file.name.substring(0, 15) + (file.name.length > 15 ? '...' : '');
            preview.style.color = 'hsl(var(--primary))';
          }
        };
        reader.readAsDataURL(file);
      };

      window.saveWallpaperPair = function saveWallpaperPair() {
        const name = (window.tempWallpaperName || '').trim();
        
        if (!name) {
          alert('Please enter a wallpaper name');
          return;
        }
        
        if (!tempWallpaperPair.dark || !tempWallpaperPair.light) {
          alert('Please select both dark and light wallpapers');
          return;
        }
        
        if (state.customWallpapers.length >= 50) {
          alert('Maximum 50 wallpaper pairs reached');
          return;
        }
        
        const newWallpaper = {
          id: Date.now(),
          name: name,
          dark: tempWallpaperPair.dark,
          light: tempWallpaperPair.light
        };
        
        state.customWallpapers.push(newWallpaper);
        localStorage.setItem('customWallpapers', JSON.stringify(state.customWallpapers));
        
        // Reset temp data
        tempWallpaperPair = { dark: null, light: null };
        window.tempWallpaperName = '';
        
        // Refresh settings to show new wallpaper
        refreshSettingsContent();
      };

      window.deleteWallpaperPair = function deleteWallpaperPair(index) {
        if (!confirm('Delete this wallpaper pair?')) return;
        
        state.customWallpapers.splice(index, 1);
        localStorage.setItem('customWallpapers', JSON.stringify(state.customWallpapers));
        
        // If deleted wallpaper was active, reset to default
        if (state.activeCustomWallpaper === index) {
          state.activeCustomWallpaper = -2; // Default to Tahoe
          localStorage.setItem('activeCustomWallpaper', '-2');
          window.setActiveWallpaper(-2);
        } else if (state.activeCustomWallpaper > index) {
          // Adjust index if active wallpaper is after deleted one
          state.activeCustomWallpaper--;
          localStorage.setItem('activeCustomWallpaper', state.activeCustomWallpaper.toString());
        }
        
        refreshSettingsContent();
      };

      window.setActiveWallpaper = function setActiveWallpaper(index) {
        state.activeCustomWallpaper = index;
        localStorage.setItem('activeCustomWallpaper', index.toString());
        
        // Built-in wallpapers with external URLs
        const builtInWallpapers = {
          '-1': { // Ubuntu Quokka
            light: 'https://res.cloudinary.com/canonical/image/fetch/f_auto,q_auto,fl_sanitize,c_fill,w_1920/https%3A%2F%2Fubuntu.com%2Fwp-content%2Fuploads%2F2e6a%2FQuesting_Quokka_Wallpaper_Color_1920x1080.png',
            dark: 'https://res.cloudinary.com/canonical/image/fetch/f_auto,q_auto,fl_sanitize,c_fill,w_1920/https%3A%2F%2Fubuntu.com%2Fwp-content%2Fuploads%2F196b%2FQuesting_Quokka_Wallpaper_Dark_1920x1080.png'
          },
          '-2': { // Tahoe
            light: 'https://raw.githubusercontent.com/Matko802/my-web-os-things/refs/heads/main/26-Tahoe-Light-1080x1920.png',
            dark: 'https://raw.githubusercontent.com/Matko802/my-web-os-things/refs/heads/main/26-Tahoe-Dark-1080x1920.png'
          },
          '-3': { // macOS Sonoma
            light: 'https://512pixels.net/downloads/macos-wallpapers-thumbs/14-0-Sonoma-L.jpg',
            dark: 'https://512pixels.net/downloads/macos-wallpapers-thumbs/14-0-Sonoma-D.jpg'
          }
        };
        
        if (index < 0 && builtInWallpapers[index]) {
          // Use built-in wallpaper
          const wallpaper = builtInWallpapers[index];
          const wallpaperURL = state.isDark ? wallpaper.dark : wallpaper.light;
          window.setWallpaperFromURL(wallpaperURL);
        } else if (index >= 0) {
          // Use custom wallpaper
          const customWallpaper = state.customWallpapers[index];
          if (customWallpaper) {
            const wallpaperURL = state.isDark ? customWallpaper.dark : customWallpaper.light;
            window.setWallpaperFromURL(wallpaperURL);
          }
        }
        
        // Refresh settings content if settings window is open
        refreshSettingsContent();
      };

      window.resetWallpaper = function resetWallpaper() {
        state.customWallpaper = null;
        localStorage.removeItem('customWallpaper');
        
        // Set wallpaper based on current theme (default to Ubuntu Quokka)
        const wallpaperURL = state.isDark 
          ? 'https://res.cloudinary.com/canonical/image/fetch/f_auto,q_auto,fl_sanitize,c_fill,w_1920/https%3A%2F%2Fubuntu.com%2Fwp-content%2Fuploads%2F196b%2FQuesting_Quokka_Wallpaper_Dark_1920x1080.png'
          : 'https://res.cloudinary.com/canonical/image/fetch/f_auto,q_auto,fl_sanitize,c_fill,w_1920/https%3A%2F%2Fubuntu.com%2Fwp-content%2Fuploads%2F2e6a%2FQuesting_Quokka_Wallpaper_Color_1920x1080.png';
        
        window.setWallpaperFromURL(wallpaperURL);
        
        // Remove preview and actions in settings
        const preview = document.querySelector('.wallpaper-preview');
        const actions = document.querySelector('.wallpaper-actions');
        if (preview) preview.remove();
        if (actions) actions.remove();
      };

      window.setWallpaperFromURL = function setWallpaperFromURL(url, animate = true) {
        const oldWallpaper = state.customWallpaper;
        state.customWallpaper = url;
        localStorage.setItem('customWallpaper', url);
        
        // Update desktop background with crossfade animation
        const desktopBg = document.querySelector('.desktop-bg');
        let desktopBgNext = document.querySelector('.desktop-bg-next');
        
        if (desktopBg) {
          if (animate && oldWallpaper && oldWallpaper !== url) {
            // Create or get the next background layer for crossfade
            if (!desktopBgNext) {
              desktopBgNext = document.createElement('div');
              desktopBgNext.className = 'desktop-bg-next';
              desktopBg.parentNode.insertBefore(desktopBgNext, desktopBg.nextSibling);
            }
            
            // Preload the new image
            const img = new Image();
            img.onload = () => {
              // Set new wallpaper on the next layer
              desktopBgNext.style.backgroundImage = `url('${url}')`;
              
              // Trigger crossfade
              requestAnimationFrame(() => {
                desktopBgNext.classList.add('visible');
                
                // After transition, update main bg and reset next layer
                setTimeout(() => {
                  desktopBg.style.backgroundImage = `url('${url}')`;
                  desktopBg.style.backgroundSize = 'cover';
                  desktopBg.style.backgroundPosition = 'center';
                  desktopBgNext.classList.remove('visible');
                  desktopBgNext.style.backgroundImage = '';
                }, 600); // Match transition duration
              });
            };
            img.src = url;
          } else {
            // No animation, just set directly
            desktopBg.style.backgroundImage = `url('${url}')`;
            desktopBg.style.backgroundSize = 'cover';
            desktopBg.style.backgroundPosition = 'center';
          }
        }
        
        // Update active state on wallpaper options
        document.querySelectorAll('.wallpaper-option').forEach(option => {
          if (option.style.backgroundImage.includes(url)) {
            option.classList.add('active');
          } else {
            option.classList.remove('active');
          }
        });
      };

      window.handleCursorUpload = function handleCursorUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        // Check if it's a ZIP file (cursor pack)
        if (file.type === 'application/zip' || file.name.endsWith('.zip')) {
          alert('Cursor pack support coming soon! For now, please upload individual cursor images.');
          return;
        }

        if (!file.type.startsWith('image/')) {
          alert('Please upload an image file or cursor pack (ZIP)');
          return;
        }

        const reader = new FileReader();
        reader.onload = function(e) {
          state.customCursor = e.target.result;
          state.cursorPack = null;
          localStorage.setItem('customCursor', e.target.result);
          localStorage.removeItem('cursorPack');
          document.body.style.cursor = `url('${e.target.result}') 0 0, auto`;
          
          // Update settings preview if in settings window - don't call render()
          const preview = document.querySelector('.wallpaper-preview');
          if (preview && preview.parentElement && preview.parentElement.previousElementSibling) {
            const label = preview.parentElement.previousElementSibling.querySelector('.settings-label');
            if (label && label.textContent === 'Custom Cursor') {
              if (!document.querySelector('.wallpaper-actions')) {
                const actions = document.createElement('div');
                actions.className = 'wallpaper-actions';
                actions.innerHTML = '<button class="wallpaper-reset-btn" onclick="event.stopPropagation(); window.resetCursor()">Reset to Default</button>';
                preview.parentElement.appendChild(actions);
              }
            }
          }
        };
        reader.readAsDataURL(file);
      };

      window.resetCursor = function resetCursor() {
        state.customCursor = null;
        state.cursorPack = null;
        localStorage.removeItem('customCursor');
        localStorage.removeItem('cursorPack');
        document.body.style.cursor = 'auto';
        
        // Just remove preview elements without full re-render
        const previews = document.querySelectorAll('.wallpaper-preview');
        previews.forEach(preview => {
          if (preview.parentElement && preview.parentElement.previousElementSibling) {
            const label = preview.parentElement.previousElementSibling.querySelector('.settings-label');
            if (label && label.textContent === 'Custom Cursor') {
              preview.remove();
              const actions = preview.parentElement.querySelector('.wallpaper-actions');
              if (actions) actions.remove();
            }
          }
        });
      };

      window.handleDockPosition = function handleDockPosition(position) {
        state.dockPosition = position;
        localStorage.setItem('dockPosition', position);
        // Delay render to allow select to lose focus first
        setTimeout(() => {
          document.activeElement.blur();
          setTimeout(() => render(), 50);
        }, 100);
      };

      window.handleDockScale = function handleDockScale(scale) {
        state.dockScale = parseFloat(scale);
        localStorage.setItem('dockScale', scale);
        
        // Update UI elements directly without full re-render
        const percentage = Math.round(parseFloat(scale) * 100);
        const percentageEl = document.getElementById('dock-size-percentage');
        const descriptionEl = document.getElementById('dock-size-description');
        if (percentageEl) percentageEl.textContent = percentage + '%';
        if (descriptionEl) descriptionEl.textContent = 'Adjust the size of dock icons (' + percentage + '%)';
        
        // Update dock size in real-time
        const dock = document.querySelector('.dock');
        if (dock) {
          const baseIconSize = 48;
          const baseGap = 8;
          const basePadding = 8;
          const iconSize = baseIconSize * parseFloat(scale);
          const gap = baseGap * parseFloat(scale);
          const padding = basePadding * parseFloat(scale);
          
          dock.style.gap = gap + 'px';
          dock.style.padding = padding + 'px';
          
          const icons = dock.querySelectorAll('.dock-icon');
          icons.forEach(icon => {
            icon.style.width = iconSize + 'px';
            icon.style.height = iconSize + 'px';
            icon.style.fontSize = (iconSize * 0.5) + 'px';
          });
        }
      };

      // ============= SETTINGS TOGGLE HELPER FUNCTIONS =============
      // Helper function to update a toggle switch by its label text
      // This ensures the toggle UI stays in sync with the actual state
      function updateToggleByLabel(labelText, isActive) {
        const settingsItems = document.querySelectorAll('.settings-item');
        settingsItems.forEach(item => {
          const label = item.querySelector('.settings-label');
          if (label && label.textContent === labelText) {
            const toggle = item.querySelector('.toggle-switch');
            if (toggle) {
              if (isActive) {
                toggle.classList.add('active');
              } else {
                toggle.classList.remove('active');
              }
              // Add pulse animation for visual feedback
              toggle.classList.add('just-toggled');
              setTimeout(() => toggle.classList.remove('just-toggled'), 400);
            }
          }
        });
      }
      
      // ============= SETTINGS TOAST NOTIFICATION SYSTEM =============
      let toastContainer = null;
      
      function ensureToastContainer() {
        if (!toastContainer || !document.body.contains(toastContainer)) {
          toastContainer = document.createElement('div');
          toastContainer.className = 'settings-toast-container';
          document.body.appendChild(toastContainer);
        }
        return toastContainer;
      }
      
      function showSettingsToast(message, type = 'success') {
        const container = ensureToastContainer();
        
        const toast = document.createElement('div');
        toast.className = 'settings-toast';
        
        const iconSvg = type === 'success' 
          ? '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><polyline points="20 6 9 17 4 12"></polyline></svg>'
          : '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line></svg>';
        
        toast.innerHTML = `
          <div class="settings-toast-icon ${type}">${iconSvg}</div>
          <span>${message}</span>
        `;
        
        container.appendChild(toast);
        
        // Auto-remove after 2 seconds
        setTimeout(() => {
          toast.classList.add('toast-out');
          setTimeout(() => {
            if (toast.parentNode) {
              toast.parentNode.removeChild(toast);
            }
          }, 250);
        }, 2000);
      }
      
      window.showSettingsToast = showSettingsToast;
      
      // Apply a setting immediately based on its key
      // This centralizes the logic for applying settings without reload
      function applySettingImmediately(settingKey, value) {
        switch (settingKey) {
          case 'animationsEnabled':
            if (value) {
              document.body.classList.remove('no-animations');
            } else {
              document.body.classList.add('no-animations');
            }
            break;
            
          case 'mirroredControls':
            // Update all existing window titlebars
            const titlebars = document.querySelectorAll('.titlebar');
            titlebars.forEach(titlebar => {
              const buttons = titlebar.querySelector('.titlebar-buttons');
              const fullscreenBtn = titlebar.querySelector('.titlebar-fullscreen-btn');
              
              if (buttons) {
                buttons.classList.remove('animating-to-right', 'animating-to-left');
                void buttons.offsetWidth;
                
                if (value) {
                  titlebar.classList.add('mirrored-controls');
                  buttons.classList.add('animating-to-right');
                } else {
                  titlebar.classList.remove('mirrored-controls');
                  buttons.classList.add('animating-to-left');
                }
                
                setTimeout(() => {
                  buttons.classList.remove('animating-to-right', 'animating-to-left');
                }, 400);
              }
              
              if (fullscreenBtn) {
                fullscreenBtn.classList.remove('animating-to-right', 'animating-to-left');
                void fullscreenBtn.offsetWidth;
                
                if (value) {
                  fullscreenBtn.classList.add('animating-to-left');
                } else {
                  fullscreenBtn.classList.add('animating-to-right');
                }
                
                setTimeout(() => {
                  fullscreenBtn.classList.remove('animating-to-right', 'animating-to-left');
                }, 400);
              }
            });
            break;
            
          case 'soundEnabled':
            // Sound state is read directly from state.soundEnabled, no additional action needed
            break;
            
          case 'dockPosition':
            // This requires a re-render for dock position
            break;
            
          default:
            // Unknown setting - may require render
            break;
        }
      }

      window.handleMirroredControls = function handleMirroredControls(enabled) {
        state.mirroredControls = enabled;
        localStorage.setItem('mirroredControls', enabled ? 'true' : 'false');
        render();
      };

      window.toggleMirroredControls = function toggleMirroredControls() {
        // 1. Update state immediately
        state.mirroredControls = !state.mirroredControls;
        
        // 2. Save to localStorage immediately
        localStorage.setItem('mirroredControls', state.mirroredControls ? 'true' : 'false');
        
        // 3. Update the toggle UI immediately (before any animation)
        updateToggleByLabel('Mirror Window Controls', state.mirroredControls);
        
        // 4. Apply the effect immediately to existing windows
        applySettingImmediately('mirroredControls', state.mirroredControls);
        
        // 5. Play sound feedback
        playSound('click');
        
        // 6. Show toast notification
        showSettingsToast(state.mirroredControls ? 'Window controls moved to right' : 'Window controls moved to left');
        
        // 7. Re-render windows to update the titlebar layout properly
        // Use setTimeout to allow the toggle animation to complete first
        setTimeout(() => {
          renderWindows();
        }, 50);
      };

      window.toggleAnimations = function toggleAnimations() {
        state.animationsEnabled = !state.animationsEnabled;
        localStorage.setItem('animationsEnabled', state.animationsEnabled.toString());
        
        // Apply or remove no-animations class
        if (state.animationsEnabled) {
          document.body.classList.remove('no-animations');
        } else {
          document.body.classList.add('no-animations');
        }
        
        // Update toggle using helper function for reliable DOM update
        updateToggleByLabel('Animations', state.animationsEnabled);
        
        playSound('click');
        
        // Show toast notification
        showSettingsToast(state.animationsEnabled ? 'Animations enabled' : 'Animations disabled');
      };

      window.toggleSound = function toggleSound() {
        state.soundEnabled = !state.soundEnabled;
        localStorage.setItem('soundEnabled', state.soundEnabled.toString());
        
        // Update toggle using helper function for reliable DOM update
        updateToggleByLabel('Sound Effects', state.soundEnabled);
        
        // Show toast notification
        showSettingsToast(state.soundEnabled ? 'Sound effects enabled' : 'Sound effects disabled');
        
        // Play a test sound if enabling
        if (state.soundEnabled) {
          playSound('click');
        }
      };

      // Sound Effects System - Lineage OS Sounds with localStorage caching
      const SOUND_CONFIG = {
        baseUrl: 'https://raw.githubusercontent.com/EvilScout/Lineage-OS-Sounds/main/system/media/audio',
        storageKey: 'lineageSoundsInstalled',
        enabledKey: 'soundEnabled',
        files: [
          // UI Sounds
          'ui/Effect_Tick.ogg',
          'ui/Dock.ogg',
          'ui/Undock.ogg',
          'ui/Lock.ogg',
          'ui/Unlock.ogg',
          'ui/KeypressStandard.ogg',
          'ui/KeypressReturn.ogg',
          'ui/KeypressDelete.ogg',
          'ui/KeypressSpacebar.ogg',
          'ui/KeypressInvalid.ogg',
          'ui/LowBattery.ogg',
          'ui/Trusted.ogg',
          'ui/camera_click.ogg',
          'ui/camera_focus.ogg',
          'ui/VideoRecord.ogg',
          'ui/VideoStop.ogg',
          'ui/WirelessChargingStarted.ogg',
          // Notification sounds
          'notifications/Adara.ogg',
          'notifications/Altair.ogg',
          'notifications/Antares.ogg',
          'notifications/CyanMessage.ogg',
          'notifications/Doink.ogg'
        ],
        // Map sound types to actual sound files
        soundMap: {
          'click': 'ui/Effect_Tick.ogg',
          'open': 'ui/Dock.ogg',
          'close': 'ui/Undock.ogg',
          'minimize': 'ui/Undock.ogg',
          'focus': 'ui/Effect_Tick.ogg',
          'lock': 'ui/Lock.ogg',
          'unlock': 'ui/Unlock.ogg',
          'notification': 'notifications/Adara.ogg',
          'terminal-key': 'ui/KeypressStandard.ogg',
          'terminal-enter': 'ui/KeypressReturn.ogg',
          'terminal-error': 'ui/KeypressInvalid.ogg',
          'trash': 'ui/Undock.ogg',
          'camera': 'ui/camera_click.ogg',
          'message': 'notifications/CyanMessage.ogg',
          'alert': 'notifications/Antares.ogg',
          // Power sounds mapped to LineageOS sounds
          'powerOn': 'ui/Trusted.ogg',
          'boot': 'ui/Dock.ogg',
          'powerOff': 'ui/Undock.ogg'
        }
      };
      
      // Audio context for Web Audio API (fallback)
      let audioContext = null;
      
      // Cache for audio elements
      const audioCache = new Map();
      
      // Initialize audio context on first user interaction
      function getAudioContext() {
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        return audioContext;
      }
      
      // Check if sounds are installed in localStorage
      function areSoundsInstalled() {
        return localStorage.getItem(SOUND_CONFIG.storageKey) === 'true';
      }
      
      // Get sound from localStorage or return null
      function getSound(filename) {
        return localStorage.getItem(`sound_${filename}`);
      }
      
      // Download and store a single sound file
      async function downloadAndStoreSound(filename) {
        try {
          const url = `${SOUND_CONFIG.baseUrl}/${filename}`;
          console.log(`[Sound] Downloading: ${filename}`);
          
          const response = await fetch(url);
          if (!response.ok) {
            console.warn(`[Sound] Failed to fetch ${filename}: ${response.status}`);
            return false;
          }
          
          const arrayBuffer = await response.arrayBuffer();
          const base64 = arrayBufferToBase64(arrayBuffer);
          const dataUrl = `data:audio/ogg;base64,${base64}`;
          
          localStorage.setItem(`sound_${filename}`, dataUrl);
          console.log(` Cached sound: ${filename}`);
          return true;
        } catch (error) {
          console.warn(`[Sound] Failed to download: ${filename}`, error);
          return false;
        }
      }
      
      // Convert ArrayBuffer to Base64
      function arrayBufferToBase64(buffer) {
        let binary = '';
        const bytes = new Uint8Array(buffer);
        const len = bytes.byteLength;
        for (let i = 0; i < len; i++) {
          binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
      }
      
      // Install all sounds from GitHub
      async function installSoundsFromGitHub() {
        console.log('[Sound] Installing Lineage OS sounds from GitHub...');
        
        const results = await Promise.all(
          SOUND_CONFIG.files.map(file => downloadAndStoreSound(file))
        );
        
        const successCount = results.filter(r => r).length;
        console.log(`[Sound] Installed ${successCount}/${SOUND_CONFIG.files.length} sounds`);
        
        if (successCount > 0) {
          localStorage.setItem(SOUND_CONFIG.storageKey, 'true');
          return true;
        }
        return false;
      }
      
      // Play sound by type
      function playSound(type) {
        if (!state.soundEnabled) return;
        
        const filename = SOUND_CONFIG.soundMap[type];
        if (!filename) {
          // Fallback to synthesized sound
          playSynthSound(type);
          return;
        }
        
        const soundData = getSound(filename);
        if (soundData) {
          // Play from cached data
          playAudioFromDataUrl(soundData, type);
        } else {
          // Fallback to synthesized sound if not cached
          playSynthSound(type);
        }
      }
      
      // Play audio from data URL
      function playAudioFromDataUrl(dataUrl, type) {
        try {
          // Use cached audio element or create new one
          let audio = audioCache.get(type);
          if (!audio) {
            audio = new Audio();
            audioCache.set(type, audio);
          }
          
          audio.src = dataUrl;
          audio.volume = 0.5; // Adjust volume
          audio.currentTime = 0;
          
          const playPromise = audio.play();
          if (playPromise !== undefined) {
            playPromise.catch(e => {
              console.warn('[Sound] Playback failed, user interaction required:', e.message);
            });
          }
        } catch (error) {
          console.warn('[Sound] Error playing audio:', error);
          playSynthSound(type);
        }
      }
      
      // Fallback synthesized sounds using Web Audio API
      function playSynthSound(type) {
        try {
          const ctx = getAudioContext();
          const now = ctx.currentTime;
          const oscillator = ctx.createOscillator();
          const gainNode = ctx.createGain();
          
          oscillator.connect(gainNode);
          gainNode.connect(ctx.destination);
          
          switch(type) {
            case 'open':
              oscillator.frequency.setValueAtTime(300, now);
              oscillator.frequency.exponentialRampToValueAtTime(800, now + 0.1);
              gainNode.gain.setValueAtTime(0.15, now);
              gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
              oscillator.start(now);
              oscillator.stop(now + 0.15);
              break;
              
            case 'close':
              oscillator.frequency.setValueAtTime(800, now);
              oscillator.frequency.exponentialRampToValueAtTime(300, now + 0.1);
              gainNode.gain.setValueAtTime(0.15, now);
              gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
              oscillator.start(now);
              oscillator.stop(now + 0.15);
              break;
              
            case 'minimize':
              oscillator.frequency.setValueAtTime(600, now);
              oscillator.frequency.exponentialRampToValueAtTime(200, now + 0.08);
              gainNode.gain.setValueAtTime(0.12, now);
              gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
              oscillator.start(now);
              oscillator.stop(now + 0.1);
              break;
              
            case 'click':
            case 'focus':
              oscillator.type = 'sine';
              oscillator.frequency.setValueAtTime(800, now);
              oscillator.frequency.exponentialRampToValueAtTime(400, now + 0.03);
              gainNode.gain.setValueAtTime(0.1, now);
              gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
              oscillator.start(now);
              oscillator.stop(now + 0.05);
              break;
              
            case 'terminal-key':
              oscillator.type = 'sine';
              oscillator.frequency.setValueAtTime(600, now);
              gainNode.gain.setValueAtTime(0.06, now);
              gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.03);
              oscillator.start(now);
              oscillator.stop(now + 0.03);
              break;
              
            case 'terminal-enter':
              oscillator.frequency.setValueAtTime(700, now);
              oscillator.frequency.setValueAtTime(900, now + 0.06);
              gainNode.gain.setValueAtTime(0.08, now);
              gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
              oscillator.start(now);
              oscillator.stop(now + 0.12);
              break;
              
            case 'terminal-error':
              oscillator.type = 'square';
              oscillator.frequency.setValueAtTime(300, now);
              oscillator.frequency.setValueAtTime(250, now + 0.08);
              gainNode.gain.setValueAtTime(0.1, now);
              gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
              oscillator.start(now);
              oscillator.stop(now + 0.15);
              break;
              
            case 'trash':
              oscillator.type = 'sawtooth';
              oscillator.frequency.setValueAtTime(200, now);
              oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.15);
              gainNode.gain.setValueAtTime(0.12, now);
              gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
              oscillator.start(now);
              oscillator.stop(now + 0.2);
              break;
              
            default:
              oscillator.frequency.setValueAtTime(500, now);
              gainNode.gain.setValueAtTime(0.08, now);
              gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
              oscillator.start(now);
              oscillator.stop(now + 0.08);
          }
        } catch (e) {
          // Silent fail - audio not supported or blocked
        }
      }
      
      // Power and Boot Sound Effects - Uses LineageOS sounds when enabled, with synthesized fallback
      function playPowerSound(type) {
        if (!state.soundEnabled) return;
        
        // Check if LineageOS sounds are installed and try to use them first
        const filename = SOUND_CONFIG.soundMap[type];
        if (filename && areSoundsInstalled()) {
          const soundData = getSound(filename);
          if (soundData) {
            // Play LineageOS sound with slightly higher volume for power sounds
            try {
              const audio = new Audio(soundData);
              audio.volume = 0.7; // Higher volume for power sounds
              const playPromise = audio.play();
              if (playPromise !== undefined) {
                playPromise.catch(e => {
                  console.warn('[PowerSound] LineageOS sound playback failed, using synthesized:', e.message);
                  playSynthPowerSound(type);
                });
              }
              return; // Successfully started LineageOS sound
            } catch (error) {
              console.warn('[PowerSound] Error playing LineageOS sound, using synthesized:', error);
            }
          }
        }
        
        // Fallback to synthesized sounds
        playSynthPowerSound(type);
      }
      
      // Synthesized power sounds (fallback when LineageOS sounds not available)
      function playSynthPowerSound(type) {
        try {
          const ctx = getAudioContext();
          const now = ctx.currentTime;
          
          switch(type) {
            case 'powerOn':
              // Ascending chime - "power up" feel
              for (let i = 0; i < 3; i++) {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);
                
                osc.type = 'sine';
                const baseFreq = 300 + (i * 150);
                osc.frequency.setValueAtTime(baseFreq, now + i * 0.12);
                osc.frequency.exponentialRampToValueAtTime(baseFreq * 1.5, now + i * 0.12 + 0.15);
                
                gain.gain.setValueAtTime(0, now + i * 0.12);
                gain.gain.linearRampToValueAtTime(0.15 - i * 0.03, now + i * 0.12 + 0.05);
                gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.12 + 0.25);
                
                osc.start(now + i * 0.12);
                osc.stop(now + i * 0.12 + 0.25);
              }
              break;
              
            case 'boot':
              // Warm startup hum with rising tone
              const osc1 = ctx.createOscillator();
              const osc2 = ctx.createOscillator();
              const gain1 = ctx.createGain();
              const gain2 = ctx.createGain();
              
              osc1.connect(gain1);
              osc2.connect(gain2);
              gain1.connect(ctx.destination);
              gain2.connect(ctx.destination);
              
              // Base hum
              osc1.type = 'sine';
              osc1.frequency.setValueAtTime(80, now);
              osc1.frequency.exponentialRampToValueAtTime(120, now + 0.8);
              gain1.gain.setValueAtTime(0, now);
              gain1.gain.linearRampToValueAtTime(0.08, now + 0.1);
              gain1.gain.linearRampToValueAtTime(0.04, now + 0.6);
              gain1.gain.exponentialRampToValueAtTime(0.01, now + 0.8);
              
              // Higher harmonic sparkle
              osc2.type = 'triangle';
              osc2.frequency.setValueAtTime(400, now + 0.2);
              osc2.frequency.exponentialRampToValueAtTime(800, now + 0.7);
              gain2.gain.setValueAtTime(0, now);
              gain2.gain.setValueAtTime(0, now + 0.2);
              gain2.gain.linearRampToValueAtTime(0.06, now + 0.35);
              gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.8);
              
              osc1.start(now);
              osc2.start(now);
              osc1.stop(now + 0.8);
              osc2.stop(now + 0.8);
              break;
              
            case 'powerOff':
              // Descending fade - "power down" feel
              for (let i = 0; i < 3; i++) {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);
                
                osc.type = 'sine';
                const baseFreq = 600 - (i * 150);
                osc.frequency.setValueAtTime(baseFreq, now + i * 0.1);
                osc.frequency.exponentialRampToValueAtTime(baseFreq * 0.5, now + i * 0.1 + 0.2);
                
                gain.gain.setValueAtTime(0, now + i * 0.1);
                gain.gain.linearRampToValueAtTime(0.12 - i * 0.03, now + i * 0.1 + 0.03);
                gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.1 + 0.25);
                
                osc.start(now + i * 0.1);
                osc.stop(now + i * 0.1 + 0.25);
              }
              break;
          }
        } catch (e) {
          // Silent fail
        }
      }
      
      // UI Helper functions for sound management
      window.installSoundsUI = async function installSoundsUI() {
        const btn = event.target;
        const originalText = btn.innerHTML;
        btn.innerHTML = ' Downloading...';
        btn.style.opacity = '0.7';
        btn.style.pointerEvents = 'none';
        
        try {
          const success = await installSoundsFromGitHub();
          if (success) {
            btn.innerHTML = ' Installed!';
            playSound('notification');
            setTimeout(() => render(), 500);
          } else {
            btn.innerHTML = ' Failed';
            setTimeout(() => {
              btn.innerHTML = originalText;
              btn.style.opacity = '1';
              btn.style.pointerEvents = 'auto';
            }, 2000);
          }
        } catch (e) {
          console.error('[Sound] Install failed:', e);
          btn.innerHTML = ' Error';
          setTimeout(() => {
            btn.innerHTML = originalText;
            btn.style.opacity = '1';
            btn.style.pointerEvents = 'auto';
          }, 2000);
        }
      };
      
      window.reinstallSoundsUI = async function reinstallSoundsUI() {
        if (!confirm('Reinstall sound pack from GitHub? This will re-download all sound files.')) return;
        
        // Clear existing sounds
        SOUND_CONFIG.files.forEach(file => {
          localStorage.removeItem(`sound_${file}`);
        });
        localStorage.removeItem(SOUND_CONFIG.storageKey);
        audioCache.clear();
        
        // Reinstall
        await installSoundsFromGitHub();
        render();
      };
      
      window.clearSoundsUI = function clearSoundsUI() {
        if (!confirm('Remove all cached sounds? You can reinstall them later.')) return;
        
        // Clear all sound data
        SOUND_CONFIG.files.forEach(file => {
          localStorage.removeItem(`sound_${file}`);
        });
        localStorage.removeItem(SOUND_CONFIG.storageKey);
        audioCache.clear();
        
        render();
      };
      
      window.testSound = function testSound() {
        playSound('notification');
      };
      
      // Initialize sound system on load - downloads sounds from GitHub on first boot
      async function initSoundSystem() {
        console.log('[Sound] Initializing sound system...');
        console.log('[Sound] Sounds installed:', areSoundsInstalled());
        console.log('[Sound] Sounds enabled:', state.soundEnabled);
        
        // Always try to install sounds on first boot (except for file: protocol)
        if (!areSoundsInstalled() && !window.location.protocol.startsWith('file:')) {
          console.log('[Sound] First boot - downloading Lineage OS sounds from GitHub...');
          try {
            const success = await installSoundsFromGitHub();
            if (success) {
              console.log('[Sound] Lineage OS sounds installed successfully!');
            } else {
              console.log('[Sound] Download failed, will use synth sounds as fallback');
            }
          } catch (e) {
            console.warn('[Sound] Auto-install failed, using synth fallback:', e);
          }
        } else if (areSoundsInstalled()) {
          console.log('[Sound] Lineage OS sounds already installed');
        }
      }
      
      // Initialize all downloads on first load - sounds and cursors from GitHub
      async function initAllDownloads() {
        console.log('[Init] Starting first-boot downloads...');
        
        // Download sounds in parallel with cursors
        const soundPromise = initSoundSystem();
        
        // Also try to download cursors on first boot
        const cursorPromise = (async () => {
          if (!areCursorsInstalled() && !window.location.protocol.startsWith('file:')) {
            console.log('[Cursor] First boot - downloading custom cursors from GitHub...');
            try {
              const success = await installCursorsFromGitHub();
              if (success) {
                console.log('[Cursor] Custom cursors downloaded successfully!');
              }
            } catch (e) {
              console.warn('[Cursor] Cursor download failed, will use fallbacks:', e);
              installFallbackCursors();
            }
          }
        })();
        
        // Wait for both to complete
        await Promise.all([soundPromise, cursorPromise]);
        console.log('[Init] First-boot downloads complete');
      }
      
      // Note: initAllDownloads() is called after CURSOR_CONFIG is defined (below)

      window.clearAllData = function clearAllData() {
        if (confirm('Are you sure you want to clear all data? This cannot be undone.')) {
          localStorage.clear();
          location.reload();
        }
      };

      // IndexedDB helper for large file storage (avoids localStorage quota limits)
      // Fixed for better WebGL/3D content handling
      const fileDB = {
        dbName: 'FakePCFileSystem',
        storeName: 'files',
        _db: null, // Cache the database connection
        
        async open() {
          // Return cached connection if available and open
          if (this._db && this._db.objectStoreNames.contains(this.storeName)) {
            return this._db;
          }
          
          return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, 1);
            request.onerror = (e) => {
              console.error('IndexedDB open error:', e.target.error);
              reject(e.target.error);
            };
            request.onsuccess = (e) => {
              this._db = e.target.result;
              resolve(this._db);
            };
            request.onupgradeneeded = (e) => {
              const db = e.target.result;
              if (!db.objectStoreNames.contains(this.storeName)) {
                db.createObjectStore(this.storeName, { keyPath: 'name' });
              }
            };
          });
        },
        
        async save(name, content) {
          const db = await this.open();
          return new Promise((resolve, reject) => {
            const tx = db.transaction(this.storeName, 'readwrite');
            const store = tx.objectStore(this.storeName);
            const request = store.put({ name, content, timestamp: Date.now() });
            request.onerror = (e) => {
              console.error('IndexedDB save error:', e.target.error);
              reject(e.target.error);
            };
            tx.oncomplete = () => resolve();
            tx.onerror = (e) => {
              console.error('IndexedDB transaction error:', e.target.error);
              reject(e.target.error);
            };
          });
        },
        
        async get(name) {
          try {
            const db = await this.open();
            return new Promise((resolve, reject) => {
              const tx = db.transaction(this.storeName, 'readonly');
              const store = tx.objectStore(this.storeName);
              const request = store.get(name);
              request.onerror = (e) => {
                console.error('IndexedDB get error:', e.target.error);
                reject(e.target.error);
              };
              request.onsuccess = () => resolve(request.result?.content || null);
            });
          } catch (e) {
            console.error('IndexedDB get failed:', e);
            return null;
          }
        },
        
        async delete(name) {
          const db = await this.open();
          return new Promise((resolve, reject) => {
            const tx = db.transaction(this.storeName, 'readwrite');
            const store = tx.objectStore(this.storeName);
            const request = store.delete(name);
            request.onerror = (e) => {
              console.error('IndexedDB delete error:', e.target.error);
              reject(e.target.error);
            };
            tx.oncomplete = () => resolve();
          });
        }
      };

      // Function to inject fixes into Minecraft HTML content
      // This fixes localStorage security errors and modelTextures initialization issues
      function injectMinecraftFixes(htmlContent) {
        // Create a localStorage/sessionStorage shim that works in sandboxed contexts
        // Note: We use <\/script> to avoid breaking the outer script tag
        var storageShim = '<scr' + 'ipt>\n' +
'// Storage shim for sandboxed iframe - fixes SecurityError for localStorage access\n' +
'(function() {\n' +
'  "use strict";\n' +
'  var memoryStorage = {};\n' +
'  function createSafeStorage(originalStorage, storageName) {\n' +
'    var isAccessible = false;\n' +
'    try {\n' +
'      if (originalStorage) {\n' +
'        originalStorage.setItem("__test__", "1");\n' +
'        originalStorage.removeItem("__test__");\n' +
'        isAccessible = true;\n' +
'      }\n' +
'    } catch (e) {\n' +
'      isAccessible = false;\n' +
'    }\n' +
'    if (isAccessible) {\n' +
'      return originalStorage;\n' +
'    }\n' +
'    console.log("[Minecraft] Using in-memory storage fallback for " + storageName);\n' +
'    return {\n' +
'      _data: memoryStorage[storageName] || (memoryStorage[storageName] = {}),\n' +
'      getItem: function(key) { return this._data[key] !== undefined ? this._data[key] : null; },\n' +
'      setItem: function(key, value) { this._data[key] = String(value); },\n' +
'      removeItem: function(key) { delete this._data[key]; },\n' +
'      clear: function() { this._data = memoryStorage[storageName] = {}; },\n' +
'      get length() { return Object.keys(this._data).length; },\n' +
'      key: function(i) { return Object.keys(this._data)[i] || null; }\n' +
'    };\n' +
'  }\n' +
'  try {\n' +
'    var testLS = window.localStorage;\n' +
'  } catch (e) {\n' +
'    Object.defineProperty(window, "localStorage", {\n' +
'      get: function() { return createSafeStorage(null, "localStorage"); },\n' +
'      configurable: true\n' +
'    });\n' +
'  }\n' +
'  try {\n' +
'    var testSS = window.sessionStorage;\n' +
'  } catch (e) {\n' +
'    Object.defineProperty(window, "sessionStorage", {\n' +
'      get: function() { return createSafeStorage(null, "sessionStorage"); },\n' +
'      configurable: true\n' +
'    });\n' +
'  }\n' +
'})();\n' +
'<\/scr' + 'ipt>\n';

        // Fix for modelTextures initialization - ensure variables are defined before use
        var modelTexturesFix = '<scr' + 'ipt>\n' +
'// Pre-define modelTextures to prevent "Cannot access before initialization" error\n' +
'window.modelTextures = window.modelTextures || {};\n' +
'<\/scr' + 'ipt>\n';

        // Inject the fixes right after the opening <head> tag
        var fixedContent = htmlContent;
        
        // Insert storage shim first, then texture fix
        if (fixedContent.includes('<head>')) {
          fixedContent = fixedContent.replace('<head>', '<head>' + storageShim + modelTexturesFix);
        } else if (fixedContent.includes('<HEAD>')) {
          fixedContent = fixedContent.replace('<HEAD>', '<HEAD>' + storageShim + modelTexturesFix);
        } else {
          // No head tag, prepend to the content
          fixedContent = storageShim + modelTexturesFix + fixedContent;
        }
        
        return fixedContent;
      }

      // App Store Functions - Download minecraft.html to the fake PC (IndexedDB)
      window.installMinecraft = async function installMinecraft() {
        // Show downloading state
        const downloadBtn = document.querySelector('[onclick*="installMinecraft"]');
        if (downloadBtn) {
          downloadBtn.innerHTML = 'Downloading...';
          downloadBtn.style.opacity = '0.7';
          downloadBtn.style.pointerEvents = 'none';
        }
        
        try {
          const downloadUrl = 'https://raw.githubusercontent.com/Matko802/my-web-os-things/refs/heads/main/minecraft.html';
          const response = await fetch(downloadUrl);

          if (!response.ok) {
            throw new Error('Failed to download: ' + response.statusText);
          }

          const htmlContent = await response.text();
          
          // Validate the content is actually HTML
          if (!htmlContent.includes('<!DOCTYPE') && !htmlContent.includes('<html') && !htmlContent.includes('<body')) {
            throw new Error('Downloaded content does not appear to be valid HTML');
          }
          
          // Store the HTML content in IndexedDB (handles large files)
          await fileDB.save('minecraft.html', htmlContent);
          localStorage.setItem('installedApps', JSON.stringify([...new Set([...state.installedApps, 'minecraft'])]));
          
          // Update state
          if (!state.installedApps.includes('minecraft')) {
            state.installedApps.push('minecraft');
          }
          state.minecraftSource = 'indexedDB';
          
          // Apply fixes and store the content
          const fixedHtmlContent = injectMinecraftFixes(htmlContent);
          state.minecraftHtmlContent = fixedHtmlContent;
          
          // Revoke old blob URL if exists
          if (state.minecraftBlobUrl) {
            try {
              URL.revokeObjectURL(state.minecraftBlobUrl);
            } catch (e) {
              // Ignore revoke errors
            }
          }
          
          // Create blob URL as fallback with fixed content
          const blob = new Blob([fixedHtmlContent], { type: 'text/html;charset=utf-8' });
          state.minecraftBlobUrl = URL.createObjectURL(blob);
          
          // Update apps list
          apps = getApps();
          
          playSound('open');
          console.log('Minecraft installed to fake PC filesystem (IndexedDB)!');
          render();
          
        } catch (error) {
          console.error('Download failed:', error);
          alert('Download failed. Please try again.');
          if (downloadBtn) {
            downloadBtn.innerHTML = 'Download';
            downloadBtn.style.opacity = '1';
            downloadBtn.style.pointerEvents = 'auto';
          }
        }
      };
      
      // Uninstall Minecraft from the fake PC
      window.uninstallMinecraft = async function uninstallMinecraft() {
        if (!confirm('Are you sure you want to uninstall Minecraft?')) return;
        
        // Close any open Minecraft windows first
        const minecraftWindows = state.windows.filter(w => w.appId === 'minecraft');
        minecraftWindows.forEach(win => closeWindow(win.id));
        
        // Remove from IndexedDB
        await fileDB.delete('minecraft.html');
        // Also clean up old localStorage entry if exists
        localStorage.removeItem('fakePCFile_minecraft.html');
        
        // Update installed apps list
        state.installedApps = state.installedApps.filter(id => id !== 'minecraft');
        localStorage.setItem('installedApps', JSON.stringify(state.installedApps));
        
        // Clean up blob URL
        if (state.minecraftBlobUrl) {
          URL.revokeObjectURL(state.minecraftBlobUrl);
          state.minecraftBlobUrl = null;
        }
        
        state.minecraftSource = null;
        
        // Remove from pinned apps if pinned
        if (state.pinnedApps.includes('minecraft')) {
          state.pinnedApps = state.pinnedApps.filter(id => id !== 'minecraft');
          localStorage.setItem('pinnedApps', JSON.stringify(state.pinnedApps));
        }
        
        // Update apps list
        apps = getApps();
        
        playSound('close');
        console.log('Minecraft uninstalled from fake PC!');
        render();
      };
      
      // Check for installed apps from IndexedDB on startup
      window.checkInstalledApps = async function checkInstalledApps() {
        // Load installed apps from localStorage
        const savedInstalledApps = localStorage.getItem('installedApps');
        if (savedInstalledApps) {
          try {
            state.installedApps = JSON.parse(savedInstalledApps);
          } catch (e) {
            state.installedApps = [];
          }
        }
        
        try {
          // Check if minecraft.html exists in IndexedDB
          let minecraftFile = await fileDB.get('minecraft.html');
          
          // Migrate from localStorage if exists there but not in IndexedDB
          if (!minecraftFile) {
            const oldFile = localStorage.getItem('fakePCFile_minecraft.html');
            if (oldFile) {
              await fileDB.save('minecraft.html', oldFile);
              localStorage.removeItem('fakePCFile_minecraft.html');
              minecraftFile = oldFile;
              console.log('Migrated Minecraft from localStorage to IndexedDB');
            }
          }
          
          if (minecraftFile) {
            if (!state.installedApps.includes('minecraft')) {
              state.installedApps.push('minecraft');
              localStorage.setItem('installedApps', JSON.stringify(state.installedApps));
            }
            state.minecraftSource = 'indexedDB';
            
            // Store the HTML content directly for srcdoc usage
            // This avoids blob URL security restrictions with localStorage
            state.minecraftHtmlContent = injectMinecraftFixes(minecraftFile);
            
            // Also create blob URL as fallback
            if (state.minecraftBlobUrl) {
              try {
                URL.revokeObjectURL(state.minecraftBlobUrl);
              } catch (e) {
                // Ignore revoke errors
              }
            }
            const blob = new Blob([state.minecraftHtmlContent], { type: 'text/html;charset=utf-8' });
            state.minecraftBlobUrl = URL.createObjectURL(blob);
            
            console.log('Minecraft loaded from fake PC filesystem (IndexedDB)!');
          }
          else {
            // Make sure it's not in installed apps if file doesn't exist
            if (state.installedApps.includes('minecraft')) {
              state.installedApps = state.installedApps.filter(id => id !== 'minecraft');
              localStorage.setItem('installedApps', JSON.stringify(state.installedApps));
            }
          }
        } catch (e) {
          console.error('Error checking installed apps:', e);
          // Don't fail silently - ensure we can still use the OS
        }
        
        // Update apps list
        apps = getApps();
      };
      
      // Initialize app check (settings loaded at boot time now)
      checkInstalledApps();

      // Cache wallpaper images for offline use
      async function cacheWallpapers() {
        const wallpaperURLs = [
          'https://res.cloudinary.com/canonical/image/fetch/f_auto,q_auto,fl_sanitize,c_fill,w_1920/https%3A%2F%2Fubuntu.com%2Fwp-content%2Fuploads%2F196b%2FQuesting_Quokka_Wallpaper_Dark_1920x1080.png',
          'https://res.cloudinary.com/canonical/image/fetch/f_auto,q_auto,fl_sanitize,c_fill,w_1920/https%3A%2F%2Fubuntu.com%2Fwp-content%2Fuploads%2F2e6a%2FQuesting_Quokka_Wallpaper_Color_1920x1080.png'
        ];

        try {
          const cache = await caches.open('ubuntu-wallpapers-v1');
          
          // Check if images are already cached
          const cachedRequests = await cache.keys();
          const cachedURLs = cachedRequests.map(req => req.url);
          
          // Cache any missing wallpapers
          for (const url of wallpaperURLs) {
            if (!cachedURLs.some(cachedUrl => cachedUrl.includes(url))) {
              try {
                const response = await fetch(url, { mode: 'cors' });
                if (response.ok) {
                  await cache.put(url, response);
                  console.log('Cached wallpaper:', url.substring(0, 80) + '...');
                }
              } catch (error) {
                console.warn('Failed to cache wallpaper:', error);
              }
            }
          }
        } catch (error) {
          console.warn('Cache API not available:', error);
        }
      }

      // Enhanced setWallpaperFromURL to use cache
      const originalSetWallpaperFromURL = window.setWallpaperFromURL;
      window.setWallpaperFromURL = async function setWallpaperFromURL(url) {
        try {
          // Try to get from cache first
          const cache = await caches.open('ubuntu-wallpapers-v1');
          const cachedResponse = await cache.match(url);
          
          if (cachedResponse) {
            const blob = await cachedResponse.blob();
            const objectURL = URL.createObjectURL(blob);
            state.customWallpaper = objectURL;
            localStorage.setItem('customWallpaper', url); // Store original URL
            localStorage.setItem('customWallpaperBlob', objectURL); // Store blob URL
            
            // Update desktop background
            const desktopBg = document.querySelector('.desktop-bg');
            if (desktopBg) {
              desktopBg.style.backgroundImage = `url('${objectURL}')`;
              desktopBg.style.backgroundSize = 'cover';
              desktopBg.style.backgroundPosition = 'center';
            }
          } else {
            // Fallback to original function if not cached
            originalSetWallpaperFromURL(url);
          }
        } catch (error) {
          // Fallback to original function on error
          originalSetWallpaperFromURL(url);
        }
        
        // Update active state on wallpaper options
        document.querySelectorAll('.wallpaper-option').forEach(option => {
          if (option.style.backgroundImage.includes(url)) {
            option.classList.add('active');
          } else {
            option.classList.remove('active');
          }
        });
      };

      // Pre-load wallpapers on page load
      cacheWallpapers();

      // ==========================================
      // CUSTOM CURSOR SYSTEM - Download from GitHub and store in localStorage
      // Cursors are 87.5% bigger (scale: 1.875 = 1.5 * 1.25)
      // With embedded fallback cursors for offline/local file support
      // ==========================================
      const CURSOR_CONFIG = {
        baseUrl: 'https://raw.githubusercontent.com/Matko802/my-web-os-things/main/Cursors/',
        previewBaseUrl: 'https://raw.githubusercontent.com/Matko802/my-web-os-things/main/Cursors%20gif%20png/',
        // Files from GitHub repo - includes both .cur and .ani files
        files: [
          '01-normal-select.cur',
          '02-help-select.ani',
          '03-working-in-background.ani',
          '04-busy.ani',
          '05-precision-select.cur',
          '06-text-select.cur',
          '07-handwriting.cur',
          '08-unavailable.ani',
          '09-vertical-resize.cur',
          '10-horizontal-resize.cur',
          '11-diagonal-resize-1.cur',
          '12-diagonal-resize-2.cur',
          '13-move.cur',
          '14-alternate-select.cur',
          '15-link-select.cur',
        ],
        // Preview files (GIF for animated, PNG for static) from GitHub for display in settings/calibration
        previewFiles: {
          '01-normal-select': '01-normal-select.png',
          '02-help-select': '02-help-select.gif',
          '03-working-in-background': '03-working-in-background.gif',
          '04-busy': '04-busy.gif',
          '05-precision-select': '05-precision-select.png',
          '06-text-select': '06-text-select.png',
          '07-handwriting': '07-handwriting.png',
          '08-unavailable': '08-unavailable.gif',
          '09-vertical-resize': '09-vertical-resize.png',
          '10-horizontal-resize': '10-horizontal-resize.png',
          '11-diagonal-resize-1': '11-diagonal-resize-1.png',
          '12-diagonal-resize-2': '12-diagonal-resize-2.png',
          '13-move': '13-move.png',
          '14-alternate-select': '14-alternate-select.png',
          '15-link-select': '15-link-select.png',
        },
        storageKey: 'customCursorsInstalled',
        enabledKey: 'customCursorsEnabled',
        styleId: 'custom-cursor-styles',
        cursorScale: 1.875 // 87.5% bigger cursors (1.5 * 1.25 = 25% bigger than before)
      };
      
      // Initialize downloads immediately (don't wait) - MUST be after CURSOR_CONFIG is defined
      initAllDownloads();
      
      // Helper to get preview URL for a cursor file (uses GIF/PNG from GitHub)
      function getCursorPreviewUrl(cursorFile) {
        const baseName = cursorFile.replace(/\.(cur|ani)$/, '');
        const previewFile = CURSOR_CONFIG.previewFiles[baseName];
        if (previewFile) {
          return CURSOR_CONFIG.previewBaseUrl + previewFile;
        }
        return '';
      }
      
      // Embedded fallback cursors as base64 PNG (generated from simple shapes)
      // These are used when GitHub download fails (e.g., running as local file)
      const FALLBACK_CURSORS = {
        // Simple arrow cursor (white with black outline)
        '01-normal-select.cur': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAGbSURBVFiF7ZYxTsQwEEW/sxsqCo5AQcEBOAIHoKGg4gRcgYIDsAe4BRUlB6FANCwFRbQI8S1iJ7HjxN4lhXhSNPbM+P95nARY2NbsqwJgA+AAWAPvwCPwBHwCn8AXcL8NAKD7AjbAG/ACvAIvwBfwDmjXC2oCeBCBAC+AB+AeuAOu5xYA8C78twBHQAdcA3fALXA1q4BxiKMQiPAKuBwB55bQ1ASMQyiECK+Ac0voagLWIUZCiPASWLWErr4EjEMohAjPgZUT4dQEjEMohAhPgaUT4dQE7IboCYEQL4BFKDtNQNdvJvAdAvE8WDgRTk3AbogxCRE+BxZhKHSeQL4QCvEEWISy+kIskHl9YQ0wS0iE+ySYhbKyQC6QdRtC3IZnwSwUVRNwE6Ibgt+Ge8HMFVQTOI5QC8G/hvvALBRUEziO0A0hyg/BAJi5gmoCpxH0IdgLeAxmOq+awGmEbgjxApwCM51XTeA0Qk8I+Sk4Bmauv5rAbghNCLkJ+BBmMqea4OgI/xNCvgT7wazm1Sb4T8AfKDLQCjAdG3cAAAAASUVORK5CYII=',
        // Hand/pointer cursor
        '15-link-select.cur': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAHKSURBVFiF7ZZNTsQwDIW/NB0qFq2EC7BgxQFYsGLFCbgCC1ZwAK7AghUH4A5wC1asOAgLxKxggZoZFqiTJmn+ZpjRSK80Ss/x87Nd2xTsqjFXBcAKYA04AN6BO+AOuAcegEfgEXgAngvNAFsC1oBb4Bq4Am6AG+C6KADweAwB/oF/CXERXuGXRQkA3IoQvABXwFV4BVwXBQCeKDwmBC/ARXgFXBYFAJ4kfB0S4ht4AS7CK+C80ADgyeI3h0SEb+AFOAvnhQaA3xQ/nBJCXIAXYBbKDg0A3iT+ZkoIcQqch7JD0wH3EnKYEOIUOAtldQdcKEQtRCMEPwtloaw2wFNCHCSE2AAnYSg7NADcKkQ1BO/DSShTG+BdQtRD8LdQpm7A/YSohuCj4CCUqRvw2xBtIfinYC+UqQ54lJBqCDkK9kKZuoFwQihC8FGwF8rUBjwphByC7IW9UKZuILQQkhC8F/ZCmdqA0EJIQsgV2Atlcw0IjSAJwV7YC2V1B0IgSELIHtgLZXUHQiI0QvBe2AtldQdCIjRC8G54FMrqDoREaIRgV+xXKPsJfxDiIAQKZXUHQiI0QpBzPxTKHiM0IQoh+J8C+xXKFvYH+wHLBHFbHGKdUAAAAABJRU5ErkJggg==',
        // Text I-beam cursor
        '06-text-select.cur': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAACxSURBVFiF7dYxCoAwDAXQnxyhs3fw/kfwBCJu4uTgIogiWNoMif2QIYTyIT9tBfhvEqIq4KugKuArYTTgK6ExYCTgK2E0YBTgK2EsYBzgK2EcYDRgHGAsYD3gK2EcYBRgLGAsYBxgLGAsYDRgHGAcYCxgLGAcYDxgFGAsYCxgHGBMIQ8wplCFGFOoQowplCHGFIYQYwpdiDGFNsSYQhViTKEOMaagQIwp9CHGFLroA3wBZsQhvPsVXvUAAAAASUVORK5CYII=',
        // Crosshair cursor
        '05-precision-select.cur': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAACMSURBVFiF7daxCYAwEAXQnzgYuIFrOIcbuJU7OIG7OYcb2IsWgvE0iYL/wUEgXB5JTgD+m4SoCvgqqAr4ShgN+EpoDRgJ+EoYDRgF+EoYCxgH+EoYBxgNGAcYCxgLGAcYDxgFGAsYCxgHGFPIA4wp1CHGFO4QYwq3iDGFMsSYQhdijPIJcTbEl3kB30R8A9/a3CYAAAAASUVORK5CYII=',
        // Move cursor (4-way arrow)
        '13-move.cur': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAADpSURBVFiF7ZZBCsIwEEW/jQsuPIEn8P5X8ARu3HkCT+ANPIELd+JCXBS0LoyZJJMGodIPgzCd+U3yZ5IA/0xCVAN8FVQFfCWMBnwltAaMBHwljAaMAnwljAWMA3wljAOMAowFjAWMA4wDjAKMBYwFjAOMA4wCjAWMBYwDjCnkAcYU6hBjCneIMYVbxJhCGWJMoQsxptCGGFOoQowp1CHGFL4g8hT8JMRBCBTqDjgmhEKIV0AfYkyhDjGm0IUYUyhDtEMohNgCz8BxKFt0wB4hFEI8A0/D66sDtkMohNgCD8NDU3fAPiEk4J0/4APZzVEq8Z0VsQAAAABJRU5ErkJggg==',
        // Vertical resize cursor
        '09-vertical-resize.cur': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAACwSURBVFiF7daxCYAwEAXQnzgYuIFrOIcbuJU7OIG7OYcb2IsWgvE0iYL/wUEgXB5JTgD+m4SoCvgqqAr4ShgN+EpoDRgJ+EoYDRgF+EoYCxgH+EoYBxgNGAcYCxgLGAcYDxgFGAsYCxgHGFPIA4wp1CHGFO4QYwq3iDGFMsSYQhdijPIJcTbEl3kB30R8AdlT8Cy4G14WyuoO2A+hEOIZ2A9l6g44IIRCCD8Fz0KZ+oAvwBddqBsIANVs9QAAAABJRU5ErkJggg==',
        // Horizontal resize cursor
        '10-horizontal-resize.cur': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAACzSURBVFiF7daxCYAwEAXQnzgYuIFrOIcbuJU7OIG7OYcb2IsWgvE0iYL/wUEgXB5JTgD+m4SoCvgqqAr4ShgN+EpoDRgJ+EoYDRgF+EoYCxgH+EoYBxgNGAcYCxgLGAcYDxgFGAsYCxgHGFPIA4wp1CHGFO4QYwq3iDGFMsSYQhdiTOEBIYbArwjxFGwFM3UDHhFCEIJ/C66GsnoDHhVCEoKXYDuUqRvwqBCSELwR7IeyJ/sHyQl9XDoVAtIAAAAASUVORK5CYII=',
        // NW-SE diagonal resize
        '11-diagonal-resize-1.cur': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAC+SURBVFiF7daxCYAwEAXQnzgYuIFrOIcbuJU7OIG7OYcb2IsWgvE0iYL/wUEgXB5JTgD+m4SoCvgqqAr4ShgN+EpoDRgJ+EoYDRgF+EoYCxgH+EoYBxgNGAcYCxgLGAcYDxgFGAsYCxgHGFPIA4wp1CHGFO4QYwq3iDGFMsSYQhdijPIJIU7ACTgMZeoG3CWEQognYD+UqQ24TwhJCN6C3VCmNuBeISQhZAvshTJ1A+4VQhKCt2AvlD3ZPx3aYEQ0W0ygAAAAAElFTkSuQmCC',
        // NE-SW diagonal resize
        '12-diagonal-resize-2.cur': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAC7SURBVFiF7daxCYAwEAXQnzgYuIFrOIcbuJU7OIG7OYcb2IsWgvE0iYL/wUEgXB5JTgD+m4SoCvgqqAr4ShgN+EpoDRgJ+EoYDRgF+EoYCxgH+EoYBxgNGAcYCxgLGAcYDxgFGAsYCxgHGFPIA4wp1CHGFO4QYwq3iDGFMsSYQhdiTOEOIU7ACdgPZeoG3CWEJ4RvYD+UqQ24TwhJCPkW7IcydQPuFUISQvaC/VD2ZP8g+Q5ErzgpA9h7yAAAAABJRU5ErkJggg==',
        // Help cursor (arrow with ?)
        '02-help-select.ani': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAHISURBVFiF7ZZNTsQwDIW/NB0qFq2EC7BgxQFYsGLFCbgCC1ZwAK7AghUH4A5wC1asOAgLxKxggZoZFqiTJmn+ZpjRSK80Ss/x87Nd2xTsqjFXBcAKYA04AN6BO+AOuAcegEfgEXgAngvNAFsC1oBb4Bq4Am6AG+C6KADwmIQgfwi+A1fhFXBdFAB4kvhNSRD8LZQpG/DcIWoh+FsoU3fAvYSoh+B/wkkoUzfgQUIoQvArcBLK1A14lBCKEHwKnIQydQMeJYQiBBuhTN2ARwmhCCG3YC+UqRvwKCEUIXgrtkOZugEPEkIRgu+FvVCmbsCjhFCE4HthL5SpG/AgIRQh+F7YC2VqA0IiKELwVtgLZXUHQiIoQrAX9kKZugEPEkIRgr2wF8rUDXiUEIoQchXshbL/8AdBDkKQS+E/hPIv+K8JPAaBQtkP+LMI+xAohPIH+L8I+xAoBP8A/y/CPgQKwSeh7L/8L4I+BH8LfhPKfoL/izAe8L2wF8rUBtyH6InAf8L/wUwfgLuEqIVgLzgBZjqvmsC9hOiG4F44Dma6gGoCdwuhEIJrYDOYhYJqArcJoRCCXLEXzGRONQH7Ifgh+M9A9Y/8B94AWoRBKAPiAc0AAAAASUVORK5CYII=',
        // Progress/working cursor
        '03-working-in-background.ani': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAGLSURBVFiF7ZY9TsQwEIW/NA4FRaLgABQUHICGgoITcAUKDsAeYC9AQUnBAVhQEBqKaBGiIISfImQnsZ3EnmW3YCSpisfj9+IZewLsatdXBbAFsAbsAG/AA/AA3AP3wAPwCDwCj8Aj8FxqBtgWsAbcAtfAFXAD3ADXZQGAp1oI/ivEPXAVXgHXZQGAJ1r8xxDiLryiLGAdYkeIcQjeCXGfCOEuUBEwDsE7IS7DVYq6gHGIERD8TohJSN2AsRCjIPRdiGlIXcA4xIgQ8kwIeUg5gXGIUSH4mRCTkHICtxGSQohJCLkJ5wXMQtq6gNsQfRD8TrgVzFRe3YDbEL0Q/E7YC2Yqr2rAbYg+CL4X9oKZyqsacBuiFEKeC3vBTOXVDawJoQjB98JeMFN5dQPbhFCE4HthL5ipvKoBexBKIfheuBfMVF7VgG2EUgh+L2wFM5X7if8g6InA58J/wawnMEoIRQh+Au4Es1DuZ+6F0Ach/wV/C2Yu95P+IYRGCP4z8DuY5by/jf8AiNMGxVAfFdYAAAAASUVORK5CYII=',
        // Busy/wait cursor
        '04-busy.ani': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAFSSURBVFiF7ZaxSgQxEIa/5G53D7G4wgN4BQUt7OwtrLSysvMJfAULC9/AV7CwsrK1sbC4wgN4hZyHuE6yyWaTLHcHCgMDYTL5J5kkE+C/SYhugK+CroCvhNGAr4TegJGAr4TRgFGAr4SxgHGAr4RxgNGAcYCxgLGAcYBxgFGAsYCxgHGAMYU8wJhCHWJM4Q4xpnCLGFMoQ4wpdCHGFNoQYwp1iDGFOsSYwhciTsFPhTgOgUJdBxwSQiHES2AUytQNeEgIhRAvgFEoUxtwmBCKEP5dMAxl6gY8JIRC+HfBKJSpG/CQEL0Q/C4YhjJ1Ax4SoheC3wXDUKZuwENC9ELwu2AYytQNBEFohODvguNQpm7AQ0L0QvB3wTiUqQ14SIheCH4XjEOZugEPCaEQgu+FcShTNxAEoRGC/RQMQ9lP+EMgByHIXfifUPYToQ2h/ySsA3ADAC8AAAAASUVORK5CYII=',
        // Unavailable cursor (circle with line)
        '08-unavailable.ani': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAE2SURBVFiF7Za9TsQwDMe/NLlnQGJgYmJiYGJiYmRiYGRiYGBiYGJkYmRiYmJkYmdnZ+C9Y+CdE+d7uYOBn5QqTuz4F9t1Avw3CVENsFNQFbCTMBqwk9Ab0BOwk9AbMBKwk9AbMBKwkzASMBKwkzASMBqwk9AbMBKwkzAaMBKwk9AbMBKwkzAaMBKwk9AbMBIwEjCSMBKwkzAasJPQ9/AnhJiE4HfBQShTG7AT0heC74X9UKZuwE5I3wu+F/ZDmdqAOxE9L/iZ8BDK1AaEhKiF4OfCQyhTNxASohaC74X9UKY2ICREL4S/DfuhTN1ASIheCH4bHoQydQMhIXoh+G14EMrUDYSEqIXgt+FBKFMbEBKiFoKfhgehzE/4g0AOQpC74D+h7CdCG0L/SVgHYAYAnkUTxPXpbEQAAAAASUVORK5CYII=',
        // Handwriting cursor
        '07-handwriting.cur': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAADWSURBVFiF7ZaxCYAwEEV/4mBgAwdwDOdwAbdyByewdg4HsLcWLSxEC0FCThMF/4MDgRDu8S4JB/w3CVEN8FVQFfCVMBrwldAaMBLwlTAaMArwlTAWMA7wlTAOMAowFjAWMA4wDjAKMBYwFjAOMKaQBxhTqEOMKdwhxhRuEWMKZYgxhS7EmEIbYkyhDjGmUIcYU/hC+FMQ4nchxEsw03XA3xBKIeQh2A9l6gY8JoRCCH4I9kKZugEPhVAIIR+CvVCmNuChEAoh+NuwF8p8wh+EIAfBf4WyNxk5N0AexTz4AAAAAElFTkSuQmCC',
        // Alternate cursor
        '14-alternate-select.cur': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAACqSURBVFiF7daxCYAwEAXQnzgYuIFrOIcbuJU7OIG7OYcb2IsWgvE0iYL/wUEgXB5JTgD+m4SoCvgqqAr4ShgN+EpoDRgJ+EoYDRgF+EoYCxgH+EoYBxgNGAcYCxgLGAcYDxgFGAsYCxgHGFPIA4wp1CHGFO4QYwq3iDGFMsSYQhdiTKENMaZQhxhTqEPcbg7xDOyEMp9wQIhTCBTKfMIRIaahLPiAfwFvALVsPEQdfLIAAAAASUVORK5CYII='
      };
      
      // Custom cursor follower element for scaling
      let cursorFollower = null;
      let currentCursorImage = null;
      let currentCursorType = 'normal';
      
      // ANI cursor animation state
      let aniCursors = {}; // Store parsed ANI frames
      let aniAnimationFrame = null;
      let currentAniType = null;

      // Default hotspots (base 32px coordinates) - from your config
      const DEFAULT_HOTSPOTS = {
        normal: { x: 0.5, y: 0.5 },
        pointer: { x: 6.5, y: 2.5 },
        help: { x: 0.5, y: 0.5 },
        text: { x: 7.5, y: 7.5 },
        handwriting: { x: 16, y: 16 },
        crosshair: { x: 7.5, y: 7.5 },
        move: { x: 7.5, y: 7.5 },
        unavailable: { x: 4, y: 4 },
        nsResize: { x: 7.5, y: 7.5 },
        ewResize: { x: 8.5, y: 8.5 },
        nwseResize: { x: 7.5, y: 7.5 },
        neswResize: { x: 7.5, y: 7.5 },
        alternate: { x: 7.5, y: 3.5 },
        progress: { x: 0.5, y: 0.5 },
        busy: { x: 7.5, y: 7.5 },
      };

      // Map cursor types to filenames for preview
      const CURSOR_TYPE_TO_FILE = {
        normal: '01-normal-select.cur',
        pointer: '15-link-select.cur',
        help: '02-help-select.ani',
        text: '06-text-select.cur',
        handwriting: '07-handwriting.cur',
        crosshair: '05-precision-select.cur',
        move: '13-move.cur',
        unavailable: '08-unavailable.ani',
        nsResize: '09-vertical-resize.cur',
        ewResize: '10-horizontal-resize.cur',
        nwseResize: '11-diagonal-resize-1.cur',
        neswResize: '12-diagonal-resize-2.cur',
        alternate: '14-alternate-select.cur',
        progress: '03-working-in-background.ani',
        busy: '04-busy.ani',
      };
      
      // Install fallback cursors to localStorage (used when GitHub download fails)
      function installFallbackCursors() {
        console.log('[Cursor] Installing fallback embedded cursors...');
        let count = 0;
        for (const [filename, dataUrl] of Object.entries(FALLBACK_CURSORS)) {
          if (!localStorage.getItem(`cursor_${filename}`)) {
            localStorage.setItem(`cursor_${filename}`, dataUrl);
            count++;
          }
        }
        if (count > 0) {
          localStorage.setItem(CURSOR_CONFIG.storageKey, 'true');
          localStorage.setItem(CURSOR_CONFIG.enabledKey, 'true');
          console.log(`[Cursor] Installed ${count} fallback cursors`);
        }
        return count > 0;
      }
      
      // ==========================================
      // ANI (Animated Cursor) Parser
      // Parses Windows .ani files and extracts frames
      // Now with proper ICO/CUR binary parsing for offline support
      // ==========================================
      class ANIParser {
        static async parse(arrayBuffer) {
          const view = new DataView(arrayBuffer);
          let offset = 0;
          
          // Read RIFF header
          const riff = this.readString(view, offset, 4);
          if (riff !== 'RIFF') throw new Error('Not a valid RIFF file');
          offset += 4;
          
          const fileSize = view.getUint32(offset, true);
          offset += 4;
          
          const acon = this.readString(view, offset, 4);
          if (acon !== 'ACON') throw new Error('Not a valid ANI file');
          offset += 4;
          
          const frames = [];
          let frameRate = 60; // Default jiffies (1/60th second)
          let sequence = null;
          let rates = null;
          
          // Parse chunks
          while (offset < arrayBuffer.byteLength - 8) {
            const chunkId = this.readString(view, offset, 4);
            offset += 4;
            const chunkSize = view.getUint32(offset, true);
            offset += 4;
            
            if (chunkId === 'anih') {
              // Animation header
              const headerSize = view.getUint32(offset, true);
              const numFrames = view.getUint32(offset + 4, true);
              const numSteps = view.getUint32(offset + 8, true);
              frameRate = view.getUint32(offset + 16, true);
              offset += chunkSize;
            } else if (chunkId === 'rate') {
              // Frame rates
              rates = [];
              for (let i = 0; i < chunkSize / 4; i++) {
                rates.push(view.getUint32(offset + i * 4, true));
              }
              offset += chunkSize;
            } else if (chunkId === 'seq ') {
              // Sequence
              sequence = [];
              for (let i = 0; i < chunkSize / 4; i++) {
                sequence.push(view.getUint32(offset + i * 4, true));
              }
              offset += chunkSize;
            } else if (chunkId === 'LIST') {
              const listType = this.readString(view, offset, 4);
              offset += 4;
              
              if (listType === 'fram') {
                // Frame data
                let frameOffset = offset;
                const listEnd = offset + chunkSize - 4;
                
                while (frameOffset < listEnd) {
                  const iconId = this.readString(view, frameOffset, 4);
                  frameOffset += 4;
                  const iconSize = view.getUint32(frameOffset, true);
                  frameOffset += 4;
                  
                  if (iconId === 'icon') {
                    const iconData = new Uint8Array(arrayBuffer, frameOffset, iconSize);
                    frames.push(iconData);
                  }
                  frameOffset += iconSize;
                  // Align to word boundary
                  if (iconSize % 2 !== 0) frameOffset++;
                }
                offset = listEnd;
              } else {
                offset += chunkSize - 4;
              }
            } else {
              offset += chunkSize;
            }
            
            // Align to word boundary
            if (chunkSize % 2 !== 0) offset++;
          }
          
          // Convert frames to data URLs using proper ICO parsing
          const frameUrls = await Promise.all(frames.map(async (frameData) => {
            return await this.curDataToDataURL(frameData);
          }));
          
          return {
            frames: frameUrls.filter(f => f), // Filter out failed frames
            frameRate: frameRate,
            rates: rates,
            sequence: sequence
          };
        }
        
        static readString(view, offset, length) {
          let str = '';
          for (let i = 0; i < length; i++) {
            str += String.fromCharCode(view.getUint8(offset + i));
          }
          return str;
        }
        
        // Parse ICO/CUR format properly and render to canvas
        static async curDataToDataURL(curData) {
          try {
            const view = new DataView(curData.buffer, curData.byteOffset, curData.byteLength);
            
            // ICO/CUR header
            const reserved = view.getUint16(0, true);
            const type = view.getUint16(2, true); // 1 = ICO, 2 = CUR
            const count = view.getUint16(4, true);
            
            if (count === 0) return null;
            
            // Read first image directory entry (offset 6)
            const width = view.getUint8(6) || 256;
            const height = view.getUint8(7) || 256;
            const colorCount = view.getUint8(8);
            const planes = view.getUint16(10, true);
            const bitCount = view.getUint16(12, true);
            const imageSize = view.getUint32(14, true);
            const imageOffset = view.getUint32(18, true);
            
            // Check if it's a PNG embedded in ICO
            if (imageOffset + 8 <= curData.byteLength) {
              const pngSig = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];
              let isPng = true;
              for (let i = 0; i < 8; i++) {
                if (curData[imageOffset + i] !== pngSig[i]) {
                  isPng = false;
                  break;
                }
              }
              
              if (isPng) {
                // Extract PNG data and return as data URL
                const pngData = curData.slice(imageOffset, imageOffset + imageSize);
                const blob = new Blob([pngData], { type: 'image/png' });
                return await this.blobToDataURL(blob);
              }
            }
            
            // Parse BMP data (DIB format inside ICO)
            return await this.parseBMPFromICO(curData, imageOffset, width, height, bitCount);
            
          } catch (e) {
            console.warn('Failed to parse CUR frame:', e);
            // Fallback: return as raw data URL
            const blob = new Blob([curData], { type: 'image/x-icon' });
            return await this.blobToDataURL(blob);
          }
        }
        
        static async blobToDataURL(blob) {
          return new Promise((resolve) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.onerror = () => resolve(null);
            reader.readAsDataURL(blob);
          });
        }
        
        // Parse BMP/DIB data from ICO format
        static async parseBMPFromICO(data, offset, width, height, bitCount) {
          try {
            const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
            
            // DIB header starts at offset
            const headerSize = view.getUint32(offset, true);
            const dibWidth = view.getInt32(offset + 4, true);
            let dibHeight = view.getInt32(offset + 8, true);
            const dibPlanes = view.getUint16(offset + 12, true);
            const dibBitCount = view.getUint16(offset + 14, true) || bitCount || 32;
            const compression = view.getUint32(offset + 18, true);
            
            // Height in ICO is doubled (includes mask)
            const actualHeight = Math.abs(dibHeight) / 2 || height;
            const actualWidth = dibWidth || width;
            
            // Create canvas
            const canvas = document.createElement('canvas');
            canvas.width = actualWidth;
            canvas.height = actualHeight;
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(actualWidth, actualHeight);
            
            // Calculate row size (padded to 4 bytes)
            const rowSize = Math.ceil((actualWidth * dibBitCount) / 32) * 4;
            const pixelDataOffset = offset + headerSize;
            
            // Color table for indexed images
            let colorTable = [];
            if (dibBitCount <= 8) {
              const numColors = 1 << dibBitCount;
              for (let i = 0; i < numColors; i++) {
                const colorOffset = offset + headerSize + (i * 4);
                if (colorOffset + 4 <= data.byteLength) {
                  colorTable.push({
                    b: data[colorOffset],
                    g: data[colorOffset + 1],
                    r: data[colorOffset + 2],
                    a: 255
                  });
                }
              }
            }
            
            const colorTableSize = colorTable.length * 4;
            const bitmapOffset = pixelDataOffset + colorTableSize;
            
            // Parse pixels (BMP is bottom-up)
            for (let y = 0; y < actualHeight; y++) {
              const srcY = actualHeight - 1 - y; // Flip vertically
              const rowOffset = bitmapOffset + (srcY * rowSize);
              
              for (let x = 0; x < actualWidth; x++) {
                const dstIdx = (y * actualWidth + x) * 4;
                
                if (dibBitCount === 32) {
                  const pixelOffset = rowOffset + (x * 4);
                  if (pixelOffset + 4 <= data.byteLength) {
                    imageData.data[dstIdx] = data[pixelOffset + 2];     // R
                    imageData.data[dstIdx + 1] = data[pixelOffset + 1]; // G
                    imageData.data[dstIdx + 2] = data[pixelOffset];     // B
                    imageData.data[dstIdx + 3] = data[pixelOffset + 3]; // A
                  }
                } else if (dibBitCount === 24) {
                  const pixelOffset = rowOffset + (x * 3);
                  if (pixelOffset + 3 <= data.byteLength) {
                    imageData.data[dstIdx] = data[pixelOffset + 2];     // R
                    imageData.data[dstIdx + 1] = data[pixelOffset + 1]; // G
                    imageData.data[dstIdx + 2] = data[pixelOffset];     // B
                    imageData.data[dstIdx + 3] = 255;                    // A
                  }
                } else if (dibBitCount === 8 && colorTable.length > 0) {
                  const pixelOffset = rowOffset + x;
                  if (pixelOffset < data.byteLength) {
                    const colorIdx = data[pixelOffset];
                    const color = colorTable[colorIdx] || { r: 0, g: 0, b: 0, a: 255 };
                    imageData.data[dstIdx] = color.r;
                    imageData.data[dstIdx + 1] = color.g;
                    imageData.data[dstIdx + 2] = color.b;
                    imageData.data[dstIdx + 3] = color.a;
                  }
                } else if (dibBitCount === 4 && colorTable.length > 0) {
                  const pixelOffset = rowOffset + Math.floor(x / 2);
                  if (pixelOffset < data.byteLength) {
                    const byte = data[pixelOffset];
                    const colorIdx = (x % 2 === 0) ? (byte >> 4) : (byte & 0x0F);
                    const color = colorTable[colorIdx] || { r: 0, g: 0, b: 0, a: 255 };
                    imageData.data[dstIdx] = color.r;
                    imageData.data[dstIdx + 1] = color.g;
                    imageData.data[dstIdx + 2] = color.b;
                    imageData.data[dstIdx + 3] = color.a;
                  }
                } else if (dibBitCount === 1 && colorTable.length >= 2) {
                  const pixelOffset = rowOffset + Math.floor(x / 8);
                  if (pixelOffset < data.byteLength) {
                    const byte = data[pixelOffset];
                    const bit = 7 - (x % 8);
                    const colorIdx = (byte >> bit) & 1;
                    const color = colorTable[colorIdx];
                    imageData.data[dstIdx] = color.r;
                    imageData.data[dstIdx + 1] = color.g;
                    imageData.data[dstIdx + 2] = color.b;
                    imageData.data[dstIdx + 3] = color.a;
                  }
                }
              }
            }
            
            // Apply AND mask for transparency (if not 32-bit with alpha)
            if (dibBitCount < 32) {
              const maskRowSize = Math.ceil(actualWidth / 32) * 4;
              const maskOffset = bitmapOffset + (rowSize * actualHeight);
              
              for (let y = 0; y < actualHeight; y++) {
                const srcY = actualHeight - 1 - y;
                const rowOffset = maskOffset + (srcY * maskRowSize);
                
                for (let x = 0; x < actualWidth; x++) {
                  const byteOffset = rowOffset + Math.floor(x / 8);
                  if (byteOffset < data.byteLength) {
                    const bit = 7 - (x % 8);
                    const mask = (data[byteOffset] >> bit) & 1;
                    if (mask === 1) {
                      const dstIdx = (y * actualWidth + x) * 4;
                      imageData.data[dstIdx + 3] = 0; // Transparent
                    }
                  }
                }
              }
            }
            
            ctx.putImageData(imageData, 0, 0);
            return canvas.toDataURL('image/png');
            
          } catch (e) {
            console.warn('BMP parsing failed:', e);
            return null;
          }
        }
      }
      
      // Parse standalone CUR file (same ICO format)
      async function parseCURFile(arrayBuffer) {
        const data = new Uint8Array(arrayBuffer);
        return await ANIParser.curDataToDataURL(data);
      }
      
      // Start ANI animation for a cursor type
      function startAniAnimation(type, aniData) {
        stopAniAnimation();
        currentAniType = type;
        
        if (!aniData || !aniData.frames || aniData.frames.length === 0) return;
        
        let frameIndex = 0;
        const sequence = aniData.sequence || aniData.frames.map((_, i) => i);
        const rates = aniData.rates || aniData.frames.map(() => aniData.frameRate);
        
        function animate() {
          const seqIndex = frameIndex % sequence.length;
          const actualFrameIndex = sequence[seqIndex];
          const frameUrl = aniData.frames[actualFrameIndex];
          
          if (frameUrl && cursorFollower) {
            cursorFollower.style.backgroundImage = `url('${frameUrl}')`;
          }
          
          // ANI jiffies: 1 jiffy = 1/60th of a second = ~16.67ms
          // Typical animated cursor runs at about 5-10 jiffies per frame = ~83-167ms
          // If rate seems too low (fast animation), use a minimum of ~80ms
          const jiffyRate = rates[seqIndex] || aniData.frameRate || 6;
          const delay = Math.max(jiffyRate * (1000 / 60), 80); // Minimum 80ms per frame
          frameIndex++;
          
          aniAnimationFrame = setTimeout(animate, delay);
        }
        
        animate();
      }
      
      function stopAniAnimation() {
        if (aniAnimationFrame) {
          clearTimeout(aniAnimationFrame);
          aniAnimationFrame = null;
        }
        currentAniType = null;
      }

      // Live hotspots (can be modified by calibration)
      let liveHotspots = JSON.parse(JSON.stringify(DEFAULT_HOTSPOTS));

      function getCursorHotspot(type) {
        const hs = liveHotspots[type] || liveHotspots.normal;
        return {
          x: Math.round(hs.x * CURSOR_CONFIG.cursorScale),
          y: Math.round(hs.y * CURSOR_CONFIG.cursorScale),
        };
      }

      // ========== DEV CURSOR CALIBRATION (Ctrl+Shift+C) ==========
      let calibrationPanel = null;
      let calibrationWindowId = null;
      let selectedCalType = null; // No cursor selected by default in calibration
      let calibrationModeActive = false; // When true, forces the selected cursor everywhere
      let calibrationZoom = 2.5; // Default zoom level for preview
      let calibrationScrollPos = 0; // Preserve scroll position

      // Force update cursor to selected calibration type
      function forceCalibrationCursor() {
        if (!calibrationModeActive || !areCursorsEnabled() || !selectedCalType) return;
        
        const cursorFile = CURSOR_TYPE_TO_FILE[selectedCalType];
        if (!cursorFile) return;
        
        const cursorDataUrl = localStorage.getItem(`cursor_${cursorFile}`) || getCursor(cursorFile);
        const isAnimated = cursorFile && cursorFile.endsWith('.ani');
        
        setCursorFollowerType(selectedCalType);
        
        // Handle ANI cursors with animation
        if (isAnimated && aniCursors[selectedCalType]) {
          if (currentAniType !== selectedCalType) {
            startAniAnimation(selectedCalType, aniCursors[selectedCalType]);
          }
        } else {
          stopAniAnimation();
          updateCursorFollowerImage(cursorDataUrl);
        }
      }

      // Open/close calibration panel and manage forced cursor mode
      function setCalibrationMode(active) {
        calibrationModeActive = active;
        if (active) {
          forceCalibrationCursor();
        } else {
          // Revert to normal cursor behavior - trigger a fake mouseover to reset
          stopAniAnimation();
          const normal = getCursor('01-normal-select.cur');
          setCursorFollowerType('normal');
          updateCursorFollowerImage(normal);
        }
      }

      function updateCalibrationPreview() {
        const previewCursor = document.getElementById('cal-preview-cursor');
        const previewInfo = document.getElementById('cal-preview-info');
        const zoomLabel = document.getElementById('cal-zoom-label');
        if (!previewCursor || !previewInfo) return;

        // Handle null selectedCalType - show placeholder
        if (!selectedCalType) {
          previewCursor.style.cssText = `display: none;`;
          previewInfo.textContent = 'Select a cursor type to preview';
          if (zoomLabel) zoomLabel.textContent = `${calibrationZoom.toFixed(1)}x`;
          return;
        }

        const cursorFile = CURSOR_TYPE_TO_FILE[selectedCalType];
        const cursorDataUrl = localStorage.getItem(`cursor_${cursorFile}`) || '';
        const hs = liveHotspots[selectedCalType];
        if (!hs) return;
        
        // Use calibrationZoom for preview
        const scaledSize = Math.round(32 * CURSOR_CONFIG.cursorScale * calibrationZoom);
        const scaledX = Math.round(hs.x * CURSOR_CONFIG.cursorScale * calibrationZoom);
        const scaledY = Math.round(hs.y * CURSOR_CONFIG.cursorScale * calibrationZoom);

        // Use localStorage data URL for all cursors (more reliable), fallback to GitHub preview
        const isAnimated = cursorFile && cursorFile.endsWith('.ani');
        const storedCursor = localStorage.getItem(`cursor_${cursorFile}`) || getCursor(cursorFile);
        // Always fall back to getCursorPreviewUrl for GitHub preview if no local data
        const previewUrl = storedCursor || getCursorPreviewUrl(cursorFile);
        
        previewCursor.style.cssText = `
          position: absolute;
          display: block;
          width: ${scaledSize}px;
          height: ${scaledSize}px;
          background-image: url('${previewUrl}');
          background-size: ${scaledSize}px ${scaledSize}px;
          background-repeat: no-repeat;
          left: calc(50% - ${scaledX}px);
          top: calc(50% - ${scaledY}px);
          image-rendering: pixelated;
          image-rendering: crisp-edges;
          transition: all 0.15s ease;
        `;
        previewInfo.textContent = `${selectedCalType}: X=${hs.x.toFixed(1)}, Y=${hs.y.toFixed(1)} (scaled: ${(hs.x * CURSOR_CONFIG.cursorScale).toFixed(1)}, ${(hs.y * CURSOR_CONFIG.cursorScale).toFixed(1)})`;
        if (zoomLabel) zoomLabel.textContent = `${calibrationZoom.toFixed(1)}x`;
      }

      function createCalibrationPanel() {
        // If window exists, just toggle visibility
        if (calibrationWindowId !== null) {
          const existingWindow = state.windows.find(w => w.id === calibrationWindowId);
          if (existingWindow) {
            if (existingWindow.isMinimized) {
              existingWindow.isMinimized = false;
              render();
            }
            bringToFront(calibrationWindowId);
            setCalibrationMode(true);
            setTimeout(updateCalibrationPreview, 50);
            return;
          }
        }
        
        // Opening panel for first time - enable calibration mode
        setCalibrationMode(true);

        // Create as OS window
        const win = {
          id: state.nextId++,
          appId: 'cursor-calibration',
          title: ' Cursor Calibration',
          x: Math.max(50, (window.innerWidth - 680) / 2),
          y: Math.max(50, (window.innerHeight - 600) / 2),
          width: 680,
          height: 580,
          zIndex: state.nextZIndex++,
          isMinimized: false,
          isMaximized: false,
          isFullscreen: false,
          isOpening: true,
        };
        
        calibrationWindowId = win.id;
        state.windows.push(win);
        state.activeWindowId = win.id;
        render();
        
        // Setup calibration event listeners after render (content is now inline via getWindowContent)
        requestAnimationFrame(() => {
          const windowContent = document.querySelector(`[data-id="${win.id}"] .window-content`);
          if (!windowContent) return;
          
          // Setup event listeners
          setupCalibrationEvents(windowContent);
          
          // Initial preview
          updateCalibrationPreview();
        });
      }
      
      function getCalibrationContent() {
        const cursorTypes = Object.keys(DEFAULT_HOTSPOTS);
        
        // Fallback SVG icons for cursor types when images fail to load
        const CURSOR_FALLBACK_ICONS = {
          normal: '<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M4 4l12 16-4-4-4 8-2-10z"/></svg>',
          pointer: '<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M10 6v2h1v5l-2 2v2h6v-2l-2-2V8h1V6h-4m2-4a2 2 0 012 2 2 2 0 01-2 2 2 2 0 01-2-2 2 2 0 012-2m-6 6v10c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V8"/></svg>',
          help: '<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M4 4l8 12-2-2-2 5-1-7zM15 4a5 5 0 015 5c0 2-1 3-2 4l-1 1v2h-2v-3l2-2c.5-.5 1-1 1-2a3 3 0 00-6 0h-2a5 5 0 015-5m-2 14h2v2h-2v-2z"/></svg>',
          text: '<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M5 4v3h5v12h4V7h5V4H5z"/></svg>',
          handwriting: '<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>',
          crosshair: '<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><circle cx="12" cy="12" r="3" fill="none" stroke="currentColor" stroke-width="2"/><line x1="12" y1="2" x2="12" y2="8" stroke="currentColor" stroke-width="2"/><line x1="12" y1="16" x2="12" y2="22" stroke="currentColor" stroke-width="2"/><line x1="2" y1="12" x2="8" y2="12" stroke="currentColor" stroke-width="2"/><line x1="16" y1="12" x2="22" y2="12" stroke="currentColor" stroke-width="2"/></svg>',
          move: '<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M13 6v5h5V8l4 4-4 4v-3h-5v5h3l-4 4-4-4h3v-5H6v3l-4-4 4-4v3h5V6H8l4-4 4 4h-3z"/></svg>',
          unavailable: '<svg viewBox="0 0 24 24" fill="none" width="20" height="20"><circle cx="12" cy="12" r="9" stroke="currentColor" stroke-width="2"/><line x1="5" y1="5" x2="19" y2="19" stroke="currentColor" stroke-width="2"/></svg>',
          nsResize: '<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M12 2l5 5h-3v10h3l-5 5-5-5h3V7H7l5-5z"/></svg>',
          ewResize: '<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M2 12l5-5v3h10V7l5 5-5 5v-3H7v3l-5-5z"/></svg>',
          nwseResize: '<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M4 4h6v2H6.41L10 9.59 8.59 11 5 7.41V10H3V4h1m16 16h-6v-2h3.59L14 14.41 15.41 13 19 16.59V14h2v6h-1z"/></svg>',
          neswResize: '<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M20 4h-6v2h3.59L14 9.59 15.41 11 19 7.41V10h2V4h-1M4 20h6v-2H6.41L10 14.41 8.59 13 5 16.59V14H3v6h1z"/></svg>',
          alternate: '<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M4 4l12 16-4-4-4 8-2-10z"/><circle cx="18" cy="6" r="3"/></svg>',
          progress: '<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M4 4l8 12-2-2-2 5-1-7z"/><circle cx="17" cy="12" r="5" fill="none" stroke="currentColor" stroke-width="2" stroke-dasharray="10 5"/></svg>',
          busy: '<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><circle cx="12" cy="12" r="8" fill="none" stroke="currentColor" stroke-width="2" stroke-dasharray="15 10"><animateTransform attributeName="transform" type="rotate" from="0 12 12" to="360 12 12" dur="1s" repeatCount="indefinite"/></circle></svg>',
        };
        
        let cursorRows = '';
        cursorTypes.forEach(type => {
          const cursorFile = CURSOR_TYPE_TO_FILE[type];
          const storedCursor = localStorage.getItem(`cursor_${cursorFile}`) || getCursor(cursorFile);
          const previewUrl = storedCursor || getCursorPreviewUrl(cursorFile);
          const isAnimated = cursorFile && cursorFile.endsWith('.ani');
          const fallbackIcon = CURSOR_FALLBACK_ICONS[type] || '<span style="opacity:0.5">?</span>';
          const hs = liveHotspots[type];
          
          cursorRows += `
            <div class="cal-row${type === selectedCalType ? ' selected' : ''}" data-type="${type}" style="
              display: flex;
              align-items: center;
              justify-content: space-between;
              padding: 10px 12px;
              margin: 3px 0;
              border-radius: 8px;
              cursor: pointer;
              transition: all 0.15s ease;
            ">
              <div style="display: flex; align-items: center; gap: 12px; min-width: 140px;">
                <div style="width: 36px; height: 36px; background: hsl(var(--background)); border-radius: 8px; display: flex; align-items: center; justify-content: center; position: relative; border: 1px solid hsl(var(--border)); overflow: hidden;">
                  ${previewUrl ? `<img src="${previewUrl}" style="width: 22px; height: 22px; object-fit: contain; image-rendering: pixelated;" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';" /><div style="display: none; align-items: center; justify-content: center; color: hsl(var(--foreground));">${fallbackIcon}</div>` : `<div style="display: flex; align-items: center; justify-content: center; color: hsl(var(--foreground));">${fallbackIcon}</div>`}
                  ${isAnimated ? '<div style="position: absolute; bottom: 2px; right: 2px; width: 12px; height: 12px; background: hsl(var(--primary)); border-radius: 50%; font-size: 7px; display: flex; align-items: center; justify-content: center; color: hsl(var(--primary-foreground));"></div>' : ''}
                </div>
                <div style="display: flex; flex-direction: column; gap: 2px;">
                  <span style="font-size: 13px; color: hsl(var(--foreground)); font-weight: 500;">${type}</span>
                  ${isAnimated ? '<span style="font-size: 10px; color: hsl(var(--primary)); font-weight: 500;">animated</span>' : ''}
                </div>
              </div>
              <div style="display: flex; gap: 6px; align-items: center;">
                <div style="display: flex; align-items: center; gap: 4px; background: hsl(var(--background)); padding: 4px 8px; border-radius: 6px; border: 1px solid hsl(var(--border));">
                  <label style="font-size: 11px; color: hsl(var(--muted-foreground)); font-weight: 500;">X</label>
                  <input type="number" step="0.5" id="cal-${type}-x" value="${hs.x.toFixed(1)}" 
                    style="width: 52px; padding: 4px 6px; background: transparent; border: none; color: hsl(var(--foreground)); font-size: 12px; font-weight: 500; text-align: center; outline: none;" />
                </div>
                <div style="display: flex; align-items: center; gap: 4px; background: hsl(var(--background)); padding: 4px 8px; border-radius: 6px; border: 1px solid hsl(var(--border));">
                  <label style="font-size: 11px; color: hsl(var(--muted-foreground)); font-weight: 500;">Y</label>
                  <input type="number" step="0.5" id="cal-${type}-y" value="${hs.y.toFixed(1)}" 
                    style="width: 52px; padding: 4px 6px; background: transparent; border: none; color: hsl(var(--foreground)); font-size: 12px; font-weight: 500; text-align: center; outline: none;" />
                </div>
              </div>
            </div>
          `;
        });
        
        return `
          <style>
            .cal-content-wrapper {
              display: flex;
              flex-direction: column;
              height: 100%;
              background: hsl(var(--window-bg));
            }
            .cal-content-wrapper::-webkit-scrollbar { width: 12px; }
            .cal-content-wrapper::-webkit-scrollbar-track { background: transparent; }
            .cal-content-wrapper::-webkit-scrollbar-thumb { 
              background: rgba(128, 128, 128, 0.5);
              border-radius: 10px;
              border: 3px solid transparent;
              background-clip: padding-box;
            }
            .cal-content-wrapper::-webkit-scrollbar-thumb:hover { 
              background: rgba(128, 128, 128, 0.7);
              background-clip: padding-box;
            }
            .cal-list {
              scrollbar-width: thin;
              scrollbar-color: rgba(128, 128, 128, 0.5) transparent;
            }
            .cal-list::-webkit-scrollbar { width: 12px; }
            .cal-list::-webkit-scrollbar-track { background: transparent; }
            .cal-list::-webkit-scrollbar-thumb { 
              background: rgba(128, 128, 128, 0.5);
              border-radius: 10px;
              border: 3px solid transparent;
              background-clip: padding-box;
            }
            .cal-list::-webkit-scrollbar-thumb:hover { 
              background: rgba(128, 128, 128, 0.7);
              background-clip: padding-box;
            }
            .cal-row {
              background: hsl(var(--accent) / 0.3);
              border: 1px solid transparent;
            }
            .cal-row:hover {
              background: hsl(var(--accent) / 0.5);
              border-color: hsl(var(--border));
            }
            .cal-row.selected {
              background: hsl(var(--primary) / 0.15) !important;
              border-color: hsl(var(--primary) / 0.4) !important;
            }
            .cal-btn {
              padding: 8px 16px;
              border: none;
              border-radius: 8px;
              font-size: 12px;
              font-weight: 500;
              cursor: pointer;
              transition: all 0.15s ease;
            }
            .cal-btn:hover { transform: translateY(-1px); }
            .cal-btn:active { transform: scale(0.98); }
            .cal-btn-primary { background: hsl(var(--primary)); color: hsl(var(--primary-foreground)); }
            .cal-btn-success { background: hsl(142 76% 36%); color: hsl(0 0% 100%); }
            .cal-btn-secondary { background: hsl(var(--accent)); color: hsl(var(--foreground)); }
            .cal-zoom-btn {
              width: 28px;
              height: 28px;
              border-radius: 6px;
              border: 1px solid hsl(var(--border));
              background: hsl(var(--background));
              color: hsl(var(--foreground));
              font-size: 14px;
              font-weight: 600;
              cursor: pointer;
              display: flex;
              align-items: center;
              justify-content: center;
              transition: all 0.15s ease;
            }
            .cal-zoom-btn:hover { background: hsl(var(--accent)); }
          </style>
          
          <div class="cal-content-wrapper" style="padding: 0;">
            <!-- Preview Section -->
            <div style="padding: 16px; border-bottom: 1px solid hsl(var(--window-border)); background: hsl(var(--accent) / 0.2);">
              <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                <span style="font-size: 11px; color: hsl(var(--muted-foreground)); font-weight: 500; text-transform: uppercase; letter-spacing: 0.5px;">Preview</span>
                <div style="display: flex; align-items: center; gap: 6px;">
                  <button class="cal-zoom-btn" id="cal-zoom-out"></button>
                  <span id="cal-zoom-label" style="font-size: 11px; color: hsl(var(--muted-foreground)); min-width: 36px; text-align: center; font-weight: 500;">${calibrationZoom.toFixed(1)}x</span>
                  <button class="cal-zoom-btn" id="cal-zoom-in">+</button>
                </div>
              </div>
              <div id="cal-preview-box" style="
                position: relative;
                width: 100%;
                height: 160px;
                background: 
                  linear-gradient(to right, transparent calc(50% - 1px), hsl(0 70% 50% / 0.7) calc(50% - 1px), hsl(0 70% 50% / 0.7) calc(50% + 1px), transparent calc(50% + 1px)),
                  linear-gradient(to bottom, transparent calc(50% - 1px), hsl(0 70% 50% / 0.7) calc(50% - 1px), hsl(0 70% 50% / 0.7) calc(50% + 1px), transparent calc(50% + 1px)),
                  repeating-linear-gradient(0deg, hsl(var(--foreground) / 0.03) 0px, hsl(var(--foreground) / 0.03) 1px, transparent 1px, transparent 20px),
                  repeating-linear-gradient(90deg, hsl(var(--foreground) / 0.03) 0px, hsl(var(--foreground) / 0.03) 1px, transparent 1px, transparent 20px),
                  hsl(var(--background));
                border-radius: 10px;
                overflow: hidden;
                border: 1px solid hsl(var(--border));
              ">
                <div id="cal-preview-cursor"></div>
                <div style="position: absolute; left: 50%; top: 50%; width: 10px; height: 10px; background: hsl(0 70% 50% / 0.5); border-radius: 50%; transform: translate(-50%, -50%); z-index: 10; box-shadow: 0 0 0 2px hsl(0 70% 50% / 0.3);"></div>
              </div>
              <div id="cal-preview-info" style="font-size: 12px; color: hsl(var(--muted-foreground)); margin-top: 10px; text-align: center; font-family: 'JetBrains Mono', monospace;"></div>
            </div>
            
            <!-- Cursor List -->
            <div class="cal-list" id="cal-cursor-list" style="flex: 1; overflow-y: auto; padding: 12px 16px; max-height: 280px;">
              ${cursorRows}
            </div>
            
            <!-- Footer Actions -->
            <div style="padding: 12px 16px; border-top: 1px solid hsl(var(--window-border)); display: flex; gap: 8px; justify-content: flex-end; background: hsl(var(--accent) / 0.2);">
              <button class="cal-btn cal-btn-secondary" id="cal-reset">Reset All</button>
              <button class="cal-btn cal-btn-success" id="cal-copy">Copy Config</button>
              <button class="cal-btn cal-btn-primary" id="cal-apply">Apply</button>
            </div>
          </div>
        `;
      }
      
      function setupCalibrationEvents(container) {
        const cursorTypes = Object.keys(DEFAULT_HOTSPOTS);
        
        // Zoom controls
        const zoomIn = container.querySelector('#cal-zoom-in');
        const zoomOut = container.querySelector('#cal-zoom-out');
        
        if (zoomIn) {
          zoomIn.onclick = () => {
            calibrationZoom = Math.min(5, calibrationZoom + 0.5);
            updateCalibrationPreview();
          };
        }
        
        if (zoomOut) {
          zoomOut.onclick = () => {
            calibrationZoom = Math.max(1, calibrationZoom - 0.5);
            updateCalibrationPreview();
          };
        }
        
        // Cursor list - preserve scroll position
        const cursorList = container.querySelector('#cal-cursor-list');
        if (cursorList) {
          cursorList.scrollTop = calibrationScrollPos;
          cursorList.addEventListener('scroll', () => {
            calibrationScrollPos = cursorList.scrollTop;
          });
        }
        
        // Row click handlers
        container.querySelectorAll('.cal-row').forEach(row => {
          row.addEventListener('click', (e) => {
            if (e.target.tagName === 'INPUT') return;
            
            container.querySelectorAll('.cal-row').forEach(r => r.classList.remove('selected'));
            row.classList.add('selected');
            
            selectedCalType = row.dataset.type;
            updateCalibrationPreview();
            forceCalibrationCursor();
          });
        });
        
        // Input handlers for precise XY
        cursorTypes.forEach(type => {
          const xInput = container.querySelector(`#cal-${type}-x`);
          const yInput = container.querySelector(`#cal-${type}-y`);
          
          if (xInput && yInput) {
            const handleInput = () => {
              liveHotspots[type].x = parseFloat(xInput.value) || 0;
              liveHotspots[type].y = parseFloat(yInput.value) || 0;
              if (selectedCalType === type) {
                updateCalibrationPreview();
              }
            };
            
            xInput.addEventListener('input', handleInput);
            yInput.addEventListener('input', handleInput);
            
            // Arrow key fine-tuning
            [xInput, yInput].forEach(input => {
              input.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                  e.preventDefault();
                  const step = e.shiftKey ? 1 : 0.5;
                  const delta = e.key === 'ArrowUp' ? step : -step;
                  input.value = (parseFloat(input.value) + delta).toFixed(1);
                  handleInput();
                }
              });
            });
          }
        });
        
        // Button handlers
        const applyBtn = container.querySelector('#cal-apply');
        const copyBtn = container.querySelector('#cal-copy');
        const resetBtn = container.querySelector('#cal-reset');
        
        if (applyBtn) {
          applyBtn.onclick = () => {
            cursorTypes.forEach(type => {
              const xInput = container.querySelector(`#cal-${type}-x`);
              const yInput = container.querySelector(`#cal-${type}-y`);
              if (xInput && yInput) {
                liveHotspots[type].x = parseFloat(xInput.value) || 0;
                liveHotspots[type].y = parseFloat(yInput.value) || 0;
              }
            });
            updateCalibrationPreview();
            console.log('Hotspots applied:', JSON.stringify(liveHotspots, null, 2));
          };
        }
        
        if (copyBtn) {
          copyBtn.onclick = () => {
            const config = JSON.stringify(liveHotspots, null, 2);
            navigator.clipboard.writeText(config).then(() => {
              copyBtn.textContent = 'Copied!';
              setTimeout(() => { copyBtn.textContent = 'Copy Config'; }, 1500);
            });
          };
        }
        
        if (resetBtn) {
          resetBtn.onclick = () => {
            liveHotspots = JSON.parse(JSON.stringify(DEFAULT_HOTSPOTS));
            cursorTypes.forEach(type => {
              const xInput = container.querySelector(`#cal-${type}-x`);
              const yInput = container.querySelector(`#cal-${type}-y`);
              if (xInput && yInput) {
                xInput.value = liveHotspots[type].x.toFixed(1);
                yInput.value = liveHotspots[type].y.toFixed(1);
              }
            });
            updateCalibrationPreview();
          };
        }
        
        // Note: Row selection is handled by the selectedCalType variable and CSS class in the HTML
      }
      
      // Handle calibration window close
      window.addEventListener('windowClosed', (e) => {
        if (e.detail && e.detail.id === calibrationWindowId) {
          calibrationWindowId = null;
          setCalibrationMode(false);
        }
      });

      // Keyboard shortcut: Ctrl+Shift+C
      document.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.shiftKey && e.key === 'C') {
          e.preventDefault();
          createCalibrationPanel();
        }
        
        // F11 is now handled by capture-phase listener, no need to block here
      });

      function createCursorFollower() {
        if (cursorFollower) return;

        // Calculate actual size (base 32px * scale)
        const baseSize = 32;
        const scaledSize = Math.round(baseSize * CURSOR_CONFIG.cursorScale);

        cursorFollower = document.createElement('div');
        cursorFollower.id = 'cursor-follower';
        cursorFollower.style.cssText = `
          position: fixed;
          pointer-events: none;
          z-index: 999999999;
          width: ${scaledSize}px;
          height: ${scaledSize}px;
          background-size: ${scaledSize}px ${scaledSize}px;
          background-repeat: no-repeat;
          background-position: top left;
          display: none;
          left: -100px;
          top: -100px;
          image-rendering: pixelated;
          image-rendering: crisp-edges;
        `;
        document.body.appendChild(cursorFollower);

        console.log('Cursor follower created, size:', scaledSize);

        // Cursor position tracking.
        // NOTE: Some browsers stop firing mousemove while dragging native scrollbars.
        // We listen to multiple event types in capture-phase for maximum coverage.
        let lastClientX = 0;
        let lastClientY = 0;
        let scrollbarDragActive = false;

        const updateFollowerFromPoint = (x, y) => {
          lastClientX = x;
          lastClientY = y;

          if (!cursorFollower) return;

          // Don't show/update cursor if pointer is locked (e.g., in games)
          if (document.pointerLockElement) {
            cursorFollower.style.display = 'none';
            return;
          }

          const hs = getCursorHotspot(currentCursorType);
          cursorFollower.style.left = (x - hs.x) + 'px';
          cursorFollower.style.top = (y - hs.y) + 'px';

          // Show on first move if enabled
          if (areCursorsEnabled() && cursorFollower.style.display === 'none') {
            cursorFollower.style.display = 'block';
          }
        };

        const restoreCustomCursorIfEnabled = () => {
          if (!cursorFollower) return;
          if (areCursorsEnabled()) {
            document.body.classList.add('custom-cursors-enabled');
            // Reposition immediately in case hotspot/type changed while dragging
            updateFollowerFromPoint(lastClientX, lastClientY);
            if (!document.pointerLockElement) cursorFollower.style.display = 'block';
          }
        };

        const showNativeCursorTemporarily = () => {
          if (!cursorFollower) return;
          // Remove the class that hides the native cursor; otherwise user sees "no cursor".
          document.body.classList.remove('custom-cursors-enabled');
          cursorFollower.style.display = 'none';
        };

        const isOnAnyScrollbar = (e) => {
          const x = e.clientX;
          const y = e.clientY;

          // Viewport scrollbars
          const docEl = document.documentElement;
          const vGutter = Math.max(12, (window.innerWidth - docEl.clientWidth) || 16);
          const hGutter = Math.max(12, (window.innerHeight - docEl.clientHeight) || 16);
          if (x >= window.innerWidth - vGutter) return true;
          if (y >= window.innerHeight - hGutter) return true;

          // Scrollable element scrollbars
          let node = document.elementFromPoint(x, y);
          while (node && node !== document.body && node instanceof HTMLElement) {
            const style = getComputedStyle(node);
            const oy = style.overflowY;
            const ox = style.overflowX;
            const hasY = (oy === 'auto' || oy === 'scroll') && node.scrollHeight > node.clientHeight;
            const hasX = (ox === 'auto' || ox === 'scroll') && node.scrollWidth > node.clientWidth;

            if (hasY || hasX) {
              const rect = node.getBoundingClientRect();
              const gutterW = Math.max(12, (node.offsetWidth - node.clientWidth) || 16);
              const gutterH = Math.max(12, (node.offsetHeight - node.clientHeight) || 16);

              if (hasY && x >= rect.right - gutterW && x <= rect.right && y >= rect.top && y <= rect.bottom) {
                return true;
              }

              if (hasX && y >= rect.bottom - gutterH && y <= rect.bottom && x >= rect.left && x <= rect.right) {
                return true;
              }
            }

            node = node.parentElement;
          }

          return false;
        };

        const onMove = (e) => {
          if (!cursorFollower) return;
          if (scrollbarDragActive) return; // During native scrollbar drag we show native cursor
          if (typeof e.clientX !== 'number' || typeof e.clientY !== 'number') return;
          updateFollowerFromPoint(e.clientX, e.clientY);
        };

        // Track mouse/pointer position - align click hotspot to the mouse position
        document.addEventListener('mousemove', onMove, true);
        document.addEventListener('pointermove', onMove, true);
        document.addEventListener('dragover', onMove, true);

        // If user grabs a scrollbar while custom cursors are enabled, fall back to native cursor
        // (prevents the custom cursor from appearing frozen).
        document.addEventListener('mousedown', (e) => {
          if (!areCursorsEnabled()) return;
          if (document.pointerLockElement) return;

          // Always update last known position on down
          if (typeof e.clientX === 'number' && typeof e.clientY === 'number') {
            lastClientX = e.clientX;
            lastClientY = e.clientY;
          }

          if (isOnAnyScrollbar(e)) {
            scrollbarDragActive = true;
            showNativeCursorTemporarily();
          }
        }, true);

        window.addEventListener('mouseup', () => {
          if (!scrollbarDragActive) return;
          scrollbarDragActive = false;
          restoreCustomCursorIfEnabled();
        }, true);

        window.addEventListener('blur', () => {
          if (!scrollbarDragActive) return;
          scrollbarDragActive = false;
          restoreCustomCursorIfEnabled();
        });

        // Hide when leaving window
        document.addEventListener('mouseleave', () => {
          if (cursorFollower) cursorFollower.style.display = 'none';
        });

        document.addEventListener('mouseenter', () => {
          if (cursorFollower && areCursorsEnabled() && !document.pointerLockElement) {
            cursorFollower.style.display = 'block';
          }
        });

        // Hide cursor follower when pointer is locked (e.g., in games like Minecraft)
        document.addEventListener('pointerlockchange', () => {
          if (cursorFollower) {
            if (document.pointerLockElement) {
              // Pointer is locked - hide the custom cursor
              cursorFollower.style.display = 'none';
            } else {
              // Pointer is unlocked - show the custom cursor if enabled
              if (areCursorsEnabled()) {
                cursorFollower.style.display = 'block';
              }
            }
          }
        });

        // Ensure cursor keeps updating during scroll (scrollbar drag)
        document.addEventListener('scroll', () => {
          if (cursorFollower && areCursorsEnabled() && !document.pointerLockElement && !scrollbarDragActive) {
            if (cursorFollower.style.display === 'none') cursorFollower.style.display = 'block';
          }
        }, true);
      }

      function updateCursorFollowerImage(imageUrl) {
        if (!cursorFollower) createCursorFollower();
        if (imageUrl && imageUrl !== currentCursorImage) {
          currentCursorImage = imageUrl;
          cursorFollower.style.backgroundImage = `url('${imageUrl}')`;
          console.log('Cursor image updated');
        }
      }

      function setCursorFollowerType(type) {
        currentCursorType = type || 'normal';
      }

      function showCursorFollower(show) {
        if (!cursorFollower) createCursorFollower();
        // Don't show immediately - wait for mousemove to position it first
        if (!show) {
          cursorFollower.style.display = 'none';
        }
        // If show=true, it will be shown on first mousemove
      }

      // Get cursor data URL from localStorage or fallback
      // ALWAYS checks embedded fallback if localStorage is empty (fixes first-load in private windows)
      function getCursor(filename) {
        // First check localStorage
        const stored = localStorage.getItem(`cursor_${filename}`);
        if (stored) return stored;
        
        // Fallback to embedded cursors - this ensures cursors work even on first load
        // or in private browsing where localStorage might be restricted
        if (FALLBACK_CURSORS[filename]) {
          console.log(`[Cursor] Using embedded fallback for: ${filename}`);
          return FALLBACK_CURSORS[filename];
        }
        
        return '';
      }

      function pickCursor(primary, fallback) {
        return primary || fallback || '';
      }

      // Check if cursors are installed in localStorage
      function areCursorsInstalled() {
        return localStorage.getItem(CURSOR_CONFIG.storageKey) === 'true';
      }

      // Check if custom cursors are enabled
      // Default to FALSE (use native cursor) until user explicitly enables
      function areCursorsEnabled() {
        const enabled = localStorage.getItem(CURSOR_CONFIG.enabledKey);
        return enabled === 'true'; // Must be explicitly enabled
      }

      // Generate and inject cursor CSS using base64 data from localStorage or fallback
      // Uses cursor follower for 50% bigger cursors
      function injectCursorStyles() {
        // Remove existing style if present
        const existingStyle = document.getElementById(CURSOR_CONFIG.styleId);
        if (existingStyle) existingStyle.remove();

        if (!areCursorsEnabled()) {
          document.body.classList.remove('custom-cursors-enabled');
          showCursorFollower(false);
          return;
        }

        // Get cursors - getCursor now checks both localStorage AND embedded fallback
        // This ensures cursors work immediately even on first load in private windows
        const normal = getCursor('01-normal-select.cur');
        const help = getCursor('02-help-select.ani') || getCursor('02-help-select.cur');
        const progress = getCursor('03-working-in-background.ani') || getCursor('03-working-in-background.cur');
        const busy = getCursor('04-busy.ani') || getCursor('04-busy.cur');
        const crosshair = getCursor('05-precision-select.cur');
        const text = getCursor('06-text-select.cur');
        const handwriting = getCursor('07-handwriting.cur');
        const unavailable = getCursor('08-unavailable.ani') || getCursor('08-unavailable.cur');
        const nsResize = getCursor('09-vertical-resize.cur');
        const ewResize = getCursor('10-horizontal-resize.cur');
        const nwseResize = getCursor('11-diagonal-resize-1.cur');
        const neswResize = getCursor('12-diagonal-resize-2.cur');
        const move = getCursor('13-move.cur');
        const alternate = getCursor('14-alternate-select.cur');
        const pointer = getCursor('15-link-select.cur');

        // CRITICAL: If we still don't have a normal cursor, use embedded fallback directly
        const finalNormal = normal || FALLBACK_CURSORS['01-normal-select.cur'];
        
        if (!finalNormal) {
          console.error('[Cursor] CRITICAL: No cursor data found anywhere - this should never happen');
          // Don't hide native cursor if we have no replacement
          return;
        }
        
        console.log('[Cursor] Found cursor data, initializing cursor follower...');

        // Create cursor follower for scaled cursor display
        createCursorFollower();
        setCursorFollowerType('normal');
        updateCursorFollowerImage(finalNormal);
        showCursorFollower(true);

        // Setup cursor type detection for different elements
        // Use finalNormal as fallback for any missing cursors
        setupCursorTypeDetection({
          normal: finalNormal, 
          help: help || finalNormal, 
          progress: progress || finalNormal, 
          busy: busy || finalNormal, 
          crosshair: crosshair || finalNormal, 
          text: text || finalNormal,
          handwriting: handwriting || finalNormal, 
          unavailable: unavailable || finalNormal, 
          nsResize: nsResize || finalNormal, 
          ewResize: ewResize || finalNormal,
          nwseResize: nwseResize || finalNormal, 
          neswResize: neswResize || finalNormal, 
          move: move || finalNormal, 
          alternate: alternate || finalNormal, 
          pointer: pointer || finalNormal
        });

        const css = `
          /* Custom Cursor Styles - Hide native cursor, use scaled follower */
          .custom-cursors-enabled,
          .custom-cursors-enabled * {
            cursor: none !important;
          }
          
          /* Iframe cursor overlay - prevents iframe's internal cursor from showing */
          /* while still allowing all mouse events to pass through to the iframe */
          .custom-cursors-enabled .window-content iframe {
            cursor: none !important;
          }
          
          /* Add an invisible overlay on top of iframes when custom cursors are enabled */
          /* This overlay captures cursor styling but passes through all click/input events */
          .custom-cursors-enabled .browser-container::after,
          .custom-cursors-enabled .minecraft-container::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 1;
            cursor: none !important;
          }
          
          /* Ensure browser/minecraft containers are positioned for the overlay */
          .custom-cursors-enabled .browser-container,
          .custom-cursors-enabled .minecraft-container {
            position: relative;
          }
        `;

        const style = document.createElement('style');
        style.id = CURSOR_CONFIG.styleId;
        style.textContent = css;
        document.head.appendChild(style);

        document.body.classList.add('custom-cursors-enabled');
        console.log('Custom cursor styles injected - cursors are 50% bigger with ANI animation support');
      }

      // Cursor type detection for dynamic cursor changes
      function setupCursorTypeDetection(cursors) {
        const { normal, help, progress, busy, crosshair, text,
                handwriting, unavailable, nsResize, ewResize,
                nwseResize, neswResize, move, alternate, pointer } = cursors;

        // ANI cursor types that need animation
        const aniTypes = ['help', 'progress', 'busy', 'unavailable'];

        document.addEventListener('mouseover', (e) => {
          if (!areCursorsEnabled()) return;
          
          // Skip cursor detection if calibration mode is active - keep forced cursor
          if (calibrationModeActive) return;

          const target = e.target;
          let cursorImage = normal;
          let cursorType = 'normal';
          let isAniCursor = false;

          // Check element type and set appropriate cursor
          if (target.matches('a, button, [role="button"], [onclick], .dock-icon, .menubar button, .quick-settings-icon-btn, .settings-nav-item, .browser-bookmark, .wallpaper-option, .titlebar-btn, .toggle-switch, .launchpad-icon, .launchpad-item, .context-menu-item, .titlebar-button')) {
            cursorImage = pointer || normal;
            cursorType = 'pointer';
          } else if (target.matches('[data-cursor="help"], .cursor-help')) {
            cursorImage = help || pointer;
            cursorType = 'help';
            isAniCursor = true;
          } else if (target.matches('input[type="text"], input[type="search"], input[type="url"], input[type="email"], input[type="password"], textarea, .terminal-input, [contenteditable="true"]')) {
            cursorImage = text || normal;
            cursorType = 'text';
          } else if (target.matches('[data-cursor="handwriting"], .cursor-handwriting, canvas.drawing-canvas, canvas[data-drawing="true"]')) {
            cursorImage = handwriting || text;
            cursorType = 'handwriting';
          } else if (target.matches(':disabled, [aria-disabled="true"], .disabled')) {
            cursorImage = unavailable || normal;
            cursorType = 'unavailable';
            isAniCursor = true;
          } else if (target.matches('[aria-busy="true"], .loading, .is-loading, [data-cursor="busy"]')) {
            cursorImage = busy || progress;
            cursorType = 'busy';
            isAniCursor = true;
          } else if (target.matches('[data-cursor="progress"]')) {
            cursorImage = progress || busy;
            cursorType = 'progress';
            isAniCursor = true;
          } else if (target.matches('.resize-handle.n, .resize-handle.s')) {
            cursorImage = nsResize || normal;
            cursorType = 'nsResize';
          } else if (target.matches('.resize-handle.e, .resize-handle.w')) {
            cursorImage = ewResize || normal;
            cursorType = 'ewResize';
          } else if (target.matches('.resize-handle.nw, .resize-handle.se')) {
            cursorImage = nwseResize || normal;
            cursorType = 'nwseResize';
          } else if (target.matches('.resize-handle.ne, .resize-handle.sw')) {
            cursorImage = neswResize || normal;
            cursorType = 'neswResize';
          } else if (target.matches('.titlebar')) {
            cursorImage = move || normal;
            cursorType = 'move';
          } else if (target.matches('input[type="range"]')) {
            cursorImage = ewResize || normal;
            cursorType = 'ewResize';
          } else if (target.matches('.crosshair, [data-cursor="crosshair"]')) {
            cursorImage = crosshair || normal;
            cursorType = 'crosshair';
          } else if (target.matches('[data-cursor="alternate"], .cursor-alternate')) {
            cursorImage = alternate || pointer;
            cursorType = 'alternate';
          }

          setCursorFollowerType(cursorType);
          
          // Handle ANI cursors with animation
          if (isAniCursor && aniCursors[cursorType]) {
            if (currentAniType !== cursorType) {
              startAniAnimation(cursorType, aniCursors[cursorType]);
            }
          } else {
            stopAniAnimation();
            updateCursorFollowerImage(cursorImage);
          }
        });
      }

      // Download cursor file and store as base64 in localStorage
      // Handles both .cur and .ani files - parses them into PNG for browser compatibility
      async function downloadAndStoreCursor(filename) {
        console.log(`[Cursor] Attempting to download: ${filename}`);
        try {
          const url = CURSOR_CONFIG.baseUrl + filename;
          console.log(`[Cursor] Fetching from: ${url}`);
          
          const response = await fetch(url);
          console.log(`[Cursor] Response status: ${response.status}`);
          
          if (!response.ok) throw new Error(`Failed to fetch ${filename}: ${response.status}`);
          
          const arrayBuffer = await response.arrayBuffer();
          console.log(`[Cursor] Downloaded ${filename}: ${arrayBuffer.byteLength} bytes`);
          
          const isAni = filename.endsWith('.ani');
          
          if (isAni) {
            // Parse ANI file and store parsed frames as PNG data URLs
            try {
              console.log(`[Cursor] Parsing ANI file: ${filename}`);
              const aniData = await ANIParser.parse(arrayBuffer);
              if (aniData.frames.length > 0) {
                // Store the first frame as the static fallback (already PNG data URL)
                localStorage.setItem(`cursor_${filename}`, aniData.frames[0]);
                // Store full ANI data for animation
                localStorage.setItem(`cursor_ani_${filename}`, JSON.stringify(aniData));
                console.log(` Parsed ANI cursor ${filename}: ${aniData.frames.length} frames`);
                return true;
              }
              console.warn(`[Cursor] ANI file ${filename} has no frames`);
              return false;
            } catch (parseError) {
              console.warn(`[Cursor] Failed to parse ANI file ${filename}:`, parseError);
              return false;
            }
          } else {
            // Parse CUR file into PNG data URL for browser compatibility
            try {
              console.log(`[Cursor] Parsing CUR file: ${filename}`);
              const pngDataUrl = await parseCURFile(arrayBuffer);
              if (pngDataUrl) {
                localStorage.setItem(`cursor_${filename}`, pngDataUrl);
                console.log(` Parsed CUR cursor ${filename}`);
                return true;
              }
              console.warn(`[Cursor] CUR file ${filename} produced no data`);
              return false;
            } catch (parseError) {
              console.warn(`[Cursor] Failed to parse CUR file ${filename}:`, parseError);
              return false;
            }
          }
        } catch (error) {
          console.warn(`[Cursor] Failed to download cursor: ${filename}`, error);
          return false;
        }
      }
      
      // Load ANI cursor data from localStorage into memory
      function loadAniCursors() {
        const aniFiles = CURSOR_CONFIG.files.filter(f => f.endsWith('.ani'));
        const typeToFile = {
          'help': '02-help-select.ani',
          'progress': '03-working-in-background.ani',
          'busy': '04-busy.ani',
          'unavailable': '08-unavailable.ani'
        };
        
        Object.entries(typeToFile).forEach(([type, filename]) => {
          const aniDataStr = localStorage.getItem(`cursor_ani_${filename}`);
          if (aniDataStr) {
            try {
              aniCursors[type] = JSON.parse(aniDataStr);
              console.log(`Loaded ANI cursor for ${type}: ${aniCursors[type].frames.length} frames`);
            } catch (e) {
              console.warn(`Failed to parse stored ANI data for ${type}:`, e);
            }
          }
        });
      }

      // Download all cursors from GitHub
      async function installCursorsFromGitHub() {
        console.log('Installing custom cursors from GitHub (with ANI support)...');
        
        const results = await Promise.all(
          CURSOR_CONFIG.files.map(file => downloadAndStoreCursor(file))
        );
        
        const successCount = results.filter(r => r).length;
        console.log(`Installed ${successCount}/${CURSOR_CONFIG.files.length} cursors`);
        
        if (successCount > 0) {
          localStorage.setItem(CURSOR_CONFIG.storageKey, 'true');
          localStorage.setItem(CURSOR_CONFIG.enabledKey, 'true');
          loadAniCursors(); // Load ANI data into memory
          injectCursorStyles();
          return true;
        }
        return false;
      }

      // Toggle custom cursors on/off
      window.toggleCustomCursors = async function toggleCustomCursors() {
        const currentState = areCursorsEnabled();
        const newState = !currentState;
        
        if (newState) {
          // User is enabling custom cursors
          console.log('[Cursor] User enabled custom cursors');
          
          // Check if cursors are already installed
          if (!areCursorsInstalled()) {
            console.log('[Cursor] Cursors not installed, downloading...');
            // Try to install from GitHub first
            const success = await installCursorsFromGitHub();
            if (!success) {
              console.log('[Cursor] GitHub download failed, using fallback cursors');
              installFallbackCursors();
            }
          }
          
          localStorage.setItem(CURSOR_CONFIG.enabledKey, 'true');
          loadAniCursors();
          injectCursorStyles();
        } else {
          // User is disabling custom cursors
          console.log('[Cursor] User disabled custom cursors');
          localStorage.setItem(CURSOR_CONFIG.enabledKey, 'false');
          injectCursorStyles(); // This will remove custom cursor styles
        }
        
        return newState;
      };

      // Reinstall cursors from GitHub
      window.reinstallCursors = async function reinstallCursors() {
        // Clear existing cursor data (both .cur and .ani)
        CURSOR_CONFIG.files.forEach(file => {
          localStorage.removeItem(`cursor_${file}`);
          localStorage.removeItem(`cursor_ani_${file}`);
        });
        localStorage.removeItem(CURSOR_CONFIG.storageKey);
        aniCursors = {}; // Clear ANI cursor cache
        stopAniAnimation();
        
        // Reinstall
        return await installCursorsFromGitHub();
      };
      
      // UI Helper: Toggle cursors with visual feedback (downloads if not installed)
      window.toggleCustomCursorsUI = async function toggleCustomCursorsUI(toggleEl) {
        const statusText = document.getElementById('cursor-status-text');
        const currentState = areCursorsEnabled();
        const newState = !currentState;
        
        if (newState) {
          // Enabling custom cursors
          toggleEl.classList.add('active');
          if (statusText) statusText.textContent = ' Downloading cursors...';
          
          // Check if cursors need to be installed
          if (!areCursorsInstalled()) {
            console.log('[Cursor] Downloading cursors...');
            try {
              const success = await installCursorsFromGitHub();
              if (success) {
                if (statusText) statusText.textContent = ' Custom cursors active';
                localStorage.setItem(CURSOR_CONFIG.enabledKey, 'true');
                loadAniCursors();
                injectCursorStyles();
              } else {
                // Try fallback
                installFallbackCursors();
                localStorage.setItem(CURSOR_CONFIG.enabledKey, 'true');
                loadAniCursors();
                injectCursorStyles();
                if (statusText) statusText.textContent = ' Using fallback cursors';
              }
            } catch (e) {
              console.error('[Cursor] Install failed:', e);
              installFallbackCursors();
              localStorage.setItem(CURSOR_CONFIG.enabledKey, 'true');
              loadAniCursors();
              injectCursorStyles();
              if (statusText) statusText.textContent = ' Using fallback cursors';
            }
          } else {
            // Already installed, just enable
            localStorage.setItem(CURSOR_CONFIG.enabledKey, 'true');
            loadAniCursors();
            injectCursorStyles();
            if (statusText) statusText.textContent = ' Custom cursors active';
          }
          
          setTimeout(() => render(), 300);
        } else {
          // Disabling custom cursors
          toggleEl.classList.remove('active');
          localStorage.setItem(CURSOR_CONFIG.enabledKey, 'false');
          injectCursorStyles(); // This removes the custom cursor styles
          if (statusText) statusText.textContent = ' Using default cursor';
          setTimeout(() => render(), 300);
        }
      };
      
      // UI Helper: Install cursors with visual feedback (legacy, kept for compatibility)
      window.installCursorsUI = async function installCursorsUI() {
        const btn = event.target;
        const originalText = btn.innerHTML;
        btn.innerHTML = ' Downloading...';
        btn.style.opacity = '0.7';
        btn.style.pointerEvents = 'none';
        
        try {
          const success = await installCursorsFromGitHub();
          if (success) {
            btn.innerHTML = ' Installed!';
            setTimeout(() => render(), 500);
          } else {
            btn.innerHTML = ' Failed';
            setTimeout(() => {
              btn.innerHTML = originalText;
              btn.style.opacity = '1';
              btn.style.pointerEvents = 'auto';
            }, 2000);
          }
        } catch (e) {
          console.error('Install failed:', e);
          btn.innerHTML = ' Error';
          setTimeout(() => {
            btn.innerHTML = originalText;
            btn.style.opacity = '1';
            btn.style.pointerEvents = 'auto';
          }, 2000);
        }
      };
      
      // UI Helper: Reinstall cursors with visual feedback
      window.reinstallCursorsUI = async function reinstallCursorsUI() {
        if (!confirm('Reinstall cursors from GitHub? This will re-download all cursor files.')) return;
        
        const btn = event.target;
        btn.innerHTML = ' Downloading...';
        btn.style.opacity = '0.7';
        
        try {
          await window.reinstallCursors();
          btn.innerHTML = ' Done!';
          setTimeout(() => render(), 500);
        } catch (e) {
          console.error('Reinstall failed:', e);
          btn.innerHTML = ' Error';
          setTimeout(() => render(), 2000);
        }
      };
      
      // UI Helper: Clear all cursor data
      window.clearCursorsUI = function clearCursorsUI() {
        if (!confirm('Remove all custom cursors? You can reinstall them later.')) return;
        
        // Clear all cursor data
        CURSOR_CONFIG.files.forEach(file => {
          localStorage.removeItem(`cursor_${file}`);
          localStorage.removeItem(`cursor_ani_${file}`);
        });
        localStorage.removeItem(CURSOR_CONFIG.storageKey);
        localStorage.removeItem(CURSOR_CONFIG.enabledKey);
        aniCursors = {};
        stopAniAnimation();
        
        // Remove cursor styles
        const existingStyle = document.getElementById(CURSOR_CONFIG.styleId);
        if (existingStyle) existingStyle.remove();
        document.body.classList.remove('custom-cursors-enabled');
        showCursorFollower(false);
        
        render();
      };

      // Check if running from local file (file:// protocol)
      function isLocalFile() {
        return window.location.protocol === 'file:';
      }

      // Initialize cursor system
      async function initCursorSystem() {
        console.log('[Cursor] Initializing cursor system...');
        console.log('[Cursor] Cursors enabled:', areCursorsEnabled());
        console.log('[Cursor] Cursors installed:', areCursorsInstalled());
        
        // If custom cursors are not enabled, use default browser cursor
        if (!areCursorsEnabled()) {
          console.log('[Cursor] Custom cursors disabled - using default browser cursor');
          // Make sure any existing custom cursor styles are removed
          const existingStyle = document.getElementById(CURSOR_CONFIG.styleId);
          if (existingStyle) existingStyle.remove();
          document.body.classList.remove('custom-cursors-enabled');
          showCursorFollower(false);
          return;
        }
        
        console.log('[Cursor] Custom cursors enabled - initializing...');
        
        // If cursors are enabled but not installed, install them
        if (!areCursorsInstalled()) {
          console.log('[Cursor] Cursors not installed, downloading...');
          
          // For file:// protocol, use fallbacks only
          if (isLocalFile()) {
            console.log('[Cursor] Running as local file - using embedded fallback cursors');
            installFallbackCursors();
          } else {
            // Try GitHub download
            const success = await installCursorsFromGitHub();
            if (!success) {
              console.log('[Cursor] GitHub download failed, using fallback cursors');
              installFallbackCursors();
            }
          }
        }
        
        // Apply the cursors
        loadAniCursors();
        injectCursorStyles();
      }

      // Initialize cursors - wrapped in try/catch for safety
      (async function() {
        try {
          await initCursorSystem();
        } catch (e) {
          console.error('[Cursor] Init error:', e);
          // If cursors are enabled and init failed, try fallback
          if (areCursorsEnabled()) {
            try {
              installFallbackCursors();
              loadAniCursors();
              injectCursorStyles();
            } catch (e2) {
              console.error('[Cursor] Fallback also failed:', e2);
            }
          }
        }
      })();

      // Expose render functions globally for use throughout the application
      window.render = render;
      window.renderWindows = renderWindows;
      window.renderShell = renderShell;
      window.generateWindowsHTML = generateWindowsHTML;
      window.generateDockHTML = generateDockHTML;
      window.generateSingleWindowHTML = generateSingleWindowHTML;
      window.computeWindowState = computeWindowState;
      window.patchWindow = patchWindow;
      
      console.log('Starting init...');
      try {
        init();
        console.log('Init completed successfully');
        console.log('Split render system loaded with DOM diffing + vdom batching: render(), renderWindows(), renderShell(), vdom available');
        
        // Load settings from IndexedDB BEFORE starting OS boot
        loadLockscreenSettingsFromDB().then(() => {
          console.log('[Boot] Settings loaded, starting OS...');
          startOS();
        }).catch(e => {
          console.error('Settings load error:', e);
          startOS(); // Start anyway even if settings fail
        });
      } catch (e) {
        console.error('Init error:', e);
      }
    </script>
  </body>
</html>
