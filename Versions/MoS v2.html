<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <!-- Nerd Fonts - JetBrainsMono -->
    <link href="https://cdn.jsdelivr.net/gh/ryanoasis/nerd-fonts@v3.4.0/patched-fonts/JetBrainsMono/Ligatures/Regular/JetBrainsMonoNerdFont-Regular.ttf" rel="preload" as="font" type="font/ttf" crossorigin>
    <style>
      @font-face {
        font-family: 'JetBrainsMono Nerd Font';
        src: url('https://cdn.jsdelivr.net/gh/ryanoasis/nerd-fonts@v3.4.0/patched-fonts/JetBrainsMono/Ligatures/Regular/JetBrainsMonoNerdFont-Regular.ttf') format('truetype');
        font-weight: 400;
        font-style: normal;
        font-display: swap;
      }
      @font-face {
        font-family: 'JetBrainsMono Nerd Font';
        src: url('https://cdn.jsdelivr.net/gh/ryanoasis/nerd-fonts@v3.4.0/patched-fonts/JetBrainsMono/Ligatures/Bold/JetBrainsMonoNerdFont-Bold.ttf') format('truetype');
        font-weight: 700;
        font-style: normal;
        font-display: swap;
      }
    </style>
    <title>M OS - Modern Desktop</title>
    <meta name="description" content="M OS - A modern, sleek web desktop experience with draggable windows, dock, and apps." />
    <meta name="author" content="M OS" />

    <meta property="og:title" content="M OS - Modern Desktop" />
    <meta property="og:description" content="Experience M OS - a futuristic desktop in your browser" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="/" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="M OS - Modern Desktop" />
    <meta name="twitter:description" content="Experience M OS - a futuristic desktop with elegant design." />
    <link rel="canonical" href="/" />

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
      }
      
      /* Theme transitions only on specific UI elements - NOT globally to avoid flicker */
      .desktop-bg,
      .menubar,
      .dock,
      .window,
      .titlebar,
      .quick-settings,
      .settings-section,
      .toggle-switch,
      .dock-icon {
        transition: background-color 0.3s ease,
                    border-color 0.3s ease,
                    box-shadow 0.3s ease;
      }

      /* M OS Light Theme - DEFAULT */
      :root {
        --background: 220 15% 94%;
        --foreground: 220 20% 10%;
        --window-bg: 0 0% 100%;
        --window-border: 220 15% 85%;
        --titlebar-bg: 220 15% 97%;
        --dock-bg: 0 0% 100%;
        --menubar-bg: 220 15% 97%;
        --primary: 175 80% 40%;
        --primary-glow: 175 80% 50%;
        --muted-foreground: 220 10% 50%;
        --accent: 220 15% 92%;
        --accent-hover: 220 15% 88%;
        --quick-settings-bg: 0 0% 100%;
        --quick-settings-item-bg: 220 15% 95%;
        --gradient-accent: linear-gradient(135deg, hsl(175 80% 40%), hsl(200 80% 50%));
        --shadow-color: 220 15% 70%;
      }

      /* M OS Dark Theme */
      .dark {
        --background: 225 20% 8%;
        --foreground: 220 15% 95%;
        --window-bg: 225 18% 12%;
        --window-border: 225 15% 18%;
        --titlebar-bg: 225 18% 10%;
        --dock-bg: 225 18% 12%;
        --menubar-bg: 225 18% 10%;
        --primary: 175 80% 45%;
        --primary-glow: 175 80% 55%;
        --accent: 225 15% 15%;
        --accent-hover: 225 15% 20%;
        --quick-settings-bg: 225 18% 10%;
        --quick-settings-item-bg: 225 15% 14%;
        --gradient-accent: linear-gradient(135deg, hsl(175 80% 45%), hsl(200 80% 55%));
        --shadow-color: 225 20% 5%;
      }
      
      /* M Logo - Premium styling with theme inversion */
      .m-logo-circle {
        background: white;
        transition: background-color 0.3s ease, color 0.3s ease;
      }
      .m-logo-letter {
        color: black;
        transition: color 0.3s ease;
      }
      
      /* Light mode - invert to black circle with white M */
      :root:not(.dark) .m-logo-circle {
        background: hsl(220 20% 10%);
      }
      :root:not(.dark) .m-logo-letter {
        color: white;
      }
      
      /* M OS specific styles - remove macOS overrides */
      
      body {
        font-family: 'Space Grotesk', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        overflow: hidden;
        width: 100vw;
        height: 100vh;
        background: hsl(var(--background));
        color: hsl(var(--foreground));
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      body.no-animations *,
      body.no-animations *::before,
      body.no-animations *::after {
        animation-duration: 0s !important;
        animation-delay: 0s !important;
        transition-duration: 0s !important;
        transition-delay: 0s !important;
      }

      * {
        -webkit-tap-highlight-color: transparent;
      }

      input, textarea {
        caret-color: hsl(var(--foreground));
        user-select: text;
        -webkit-user-select: text;
        -moz-user-select: text;
        -ms-user-select: text;
        font-family: 'Space Grotesk', sans-serif;
      }

      .desktop {
        width: 100vw;
        height: 100vh;
        position: relative;
        overflow: hidden;
      }

      .desktop-bg {
        position: absolute;
        inset: 0;
        background: linear-gradient(135deg, hsl(225 25% 12%) 0%, hsl(200 30% 8%) 50%, hsl(175 25% 10%) 100%);
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        transition: opacity 0.6s ease-in-out;
      }
      
      /* Secondary background layer for crossfade effect */
      .desktop-bg-next {
        position: absolute;
        inset: 0;
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        opacity: 0;
        transition: opacity 0.6s ease-in-out;
        pointer-events: none;
      }
      
      .desktop-bg-next.visible {
        opacity: 1;
      }
      
      .dark .desktop-bg {
        background: linear-gradient(135deg, hsl(225 25% 8%) 0%, hsl(200 30% 5%) 50%, hsl(175 25% 8%) 100%);
      }
      
      :root .desktop-bg {
        background: linear-gradient(135deg, hsl(220 20% 92%) 0%, hsl(200 25% 88%) 50%, hsl(175 20% 90%) 100%);
      }
      
      /* Window transparency support */
      .window-transparent .window {
        background: hsl(var(--window-bg) / var(--window-opacity, 1)) !important;
        backdrop-filter: blur(var(--window-blur, 0px)) !important;
      }
      .window-transparent .window .titlebar {
        background: hsl(var(--titlebar-bg) / var(--window-opacity, 1)) !important;
      }

      .settings-container {
        display: flex;
        height: 100%;
        overflow: hidden;
      }

      .settings-sidebar {
        width: 240px;
        background: hsl(var(--accent) / 0.3);
        border-right: 1px solid hsl(var(--window-border));
        overflow-y: auto;
        flex-shrink: 0;
        scrollbar-width: thin;
        scrollbar-color: rgba(128, 128, 128, 0.5) transparent;
      }

      .settings-sidebar::-webkit-scrollbar {
        width: 8px;
      }

      .settings-sidebar::-webkit-scrollbar-track {
        background: transparent;
      }

      .settings-sidebar::-webkit-scrollbar-thumb {
        background: rgba(128, 128, 128, 0.5);
        border-radius: 10px;
        border: 2px solid transparent;
        background-clip: padding-box;
      }

      .settings-sidebar::-webkit-scrollbar-thumb:hover {
        background: rgba(128, 128, 128, 0.7);
        background-clip: padding-box;
      }

      .settings-search {
        padding: 12px;
        border-bottom: 1px solid hsl(var(--window-border));
      }

      .settings-search input {
        width: 100%;
        padding: 6px 10px;
        background: hsl(var(--background));
        border: 1px solid hsl(var(--border));
        border-radius: 6px;
        font-size: 13px;
        color: hsl(var(--foreground));
        outline: none;
        transition: all 0.2s;
      }

      .settings-search input::placeholder {
        color: hsl(var(--muted-foreground));
      }

      .settings-search input:focus {
        border-color: hsl(var(--primary));
        box-shadow: 0 0 0 2px hsl(var(--primary) / 0.1);
      }

      .settings-nav-item {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 8px 12px;
        margin: 2px 8px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 13px;
        color: hsl(var(--foreground));
        transition: all 0.15s;
        user-select: none;
      }

      .settings-nav-item:hover {
        background: hsl(var(--accent) / 0.5);
      }

      .settings-nav-item.active {
        background: hsl(var(--primary));
        color: white;
        font-weight: 500;
      }

      .settings-nav-item svg {
        width: 18px;
        height: 18px;
        flex-shrink: 0;
      }

      .settings-content {
        flex: 1;
        padding: 32px;
        overflow-y: auto;
        scrollbar-width: auto;
        scrollbar-color: auto;
      }

      .settings-content::-webkit-scrollbar {
        width: 15px;
      }

      .settings-content::-webkit-scrollbar-track {
        background: transparent;
      }

      .settings-content::-webkit-scrollbar-thumb {
        background: rgba(128, 128, 128, 0.5);
        border-radius: 10px;
        border: 3px solid transparent;
        background-clip: padding-box;
      }

      .settings-content::-webkit-scrollbar-thumb:hover {
        background: rgba(128, 128, 128, 0.7);
        background-clip: padding-box;
      }

      .settings-section {
        margin-bottom: 32px;
        padding-bottom: 24px;
        border-bottom: 1px solid hsl(var(--window-border));
        transition: border-color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .settings-section:last-child {
        border-bottom: none;
      }

      .settings-title {
        font-size: 18px;
        font-weight: 600;
        margin-bottom: 16px;
        color: hsl(var(--foreground));
        transition: color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .settings-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 0;
      }

      .settings-label {
        font-size: 14px;
        color: hsl(var(--foreground));
        transition: color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .settings-description {
        font-size: 12px;
        color: hsl(var(--muted-foreground));
        margin-top: 4px;
        transition: color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .toggle-switch {
        position: relative;
        width: 44px;
        height: 24px;
        background: hsl(var(--accent));
        border-radius: 12px;
        cursor: pointer;
        transition: background 0.25s cubic-bezier(0.34, 1.56, 0.64, 1),
                    box-shadow 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
        will-change: background, box-shadow;
        transform: translateZ(0);
        -webkit-transform: translateZ(0);
      }

      .toggle-switch:hover {
        box-shadow: 0 0 0 3px hsl(var(--primary) / 0.15);
      }

      .toggle-switch:active .toggle-switch-thumb {
        transform: translateX(0) scale(1.1);
      }

      .toggle-switch.active:active .toggle-switch-thumb {
        transform: translateX(20px) scale(1.1);
      }

      .toggle-switch.active {
        background: hsl(var(--primary));
        box-shadow: none;
      }

      .toggle-switch-thumb {
        position: absolute;
        top: 2px;
        left: 2px;
        width: 20px;
        height: 20px;
        background: white;
        border-radius: 10px;
        transition: transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1),
                    box-shadow 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        will-change: transform;
        transform: translateZ(0);
        -webkit-transform: translateZ(0);
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
      }

      .toggle-switch.active .toggle-switch-thumb {
        transform: translateX(20px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25);
      }

      .wallpaper-upload-btn {
        padding: 8px 16px;
        background: hsl(var(--primary));
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .wallpaper-upload-btn:hover {
        transform: scale(1.05);
        box-shadow: 0 4px 12px hsl(var(--primary) / 0.3);
      }

      .wallpaper-upload-btn:active {
        transform: scale(0.98);
      }

      .wallpaper-preview {
        margin-top: 12px;
        width: 100%;
        height: 120px;
        border-radius: 8px;
        background-size: cover;
        background-position: center;
        border: 1px solid hsl(var(--window-border));
        transition: border-color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .wallpaper-actions {
        display: flex;
        gap: 8px;
        margin-top: 12px;
      }

      .wallpaper-reset-btn {
        padding: 6px 12px;
        background: hsl(var(--accent));
        color: hsl(var(--foreground));
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 13px;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .wallpaper-reset-btn:hover {
        background: hsl(var(--accent) / 0.8);
      }
      
      .wallpaper-reset-btn.destructive {
        background: #ef4444;
        color: white;
      }
      
      .wallpaper-reset-btn.destructive:hover {
        background: #dc2626;
        transform: scale(1.02);
        box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
      }
      
      .wallpaper-reset-btn.destructive:active {
        transform: scale(0.98);
      }

      /* macOS-style slider thumb */
      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: white;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(0, 0, 0, 0.1);
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease;
      }
      input[type="range"]::-webkit-slider-thumb:hover {
        transform: scale(1.1);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.35), 0 0 0 1px rgba(0, 0, 0, 0.15);
      }
      input[type="range"]::-webkit-slider-thumb:active {
        transform: scale(1.05);
      }
      input[type="range"]::-moz-range-thumb {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: white;
        border: none;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(0, 0, 0, 0.1);
        cursor: pointer;
      }

      .wallpaper-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
        gap: 16px;
        margin-top: 16px;
      }

      .wallpaper-option {
        position: relative;
        width: 100%;
        aspect-ratio: 16 / 9;
        border-radius: 8px;
        background-size: cover;
        background-position: center;
        border: 2px solid hsl(var(--window-border));
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        overflow: hidden;
      }

      .wallpaper-option:hover {
        border-color: hsl(var(--primary));
        transform: scale(1.05);
        box-shadow: 0 8px 24px hsl(var(--primary) / 0.2);
      }

      .wallpaper-option:active {
        transform: scale(0.98);
      }

      .wallpaper-option.active {
        border-color: hsl(var(--primary));
        box-shadow: 0 0 0 3px hsl(var(--primary) / 0.3);
      }

      .wallpaper-option-label {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        background: linear-gradient(to top, rgba(0,0,0,0.7), transparent);
        color: white;
        padding: 8px 12px;
        font-size: 12px;
        font-weight: 500;
      }

      /* M OS Menubar - 28px height with smaller buttons */
      .menubar {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        height: 28px;
        background: hsl(var(--menubar-bg) / 0.85);
        backdrop-filter: blur(20px) saturate(150%);
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 12px;
        z-index: 20000;
        font-size: 12px;
        font-weight: 500;
        user-select: none;
        border-bottom: 1px solid hsl(var(--window-border) / 0.5);
      }
      
      .dark .menubar {
        background: hsl(var(--menubar-bg) / 0.9);
        border-bottom: 1px solid hsl(var(--window-border) / 0.3);
      }
      
      .menubar-center {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        font-size: 12px;
        font-weight: 600;
        color: hsl(var(--foreground));
        letter-spacing: 0.02em;
      }

      .menubar-left,
      .menubar-right {
        display: flex;
        align-items: center;
        gap: 2px;
      }

      .menubar button {
        background: none;
        border: none;
        color: hsl(var(--foreground));
        cursor: pointer;
        padding: 2px 8px;
        border-radius: 4px;
        transition: all 0.15s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 500;
        font-family: 'Space Grotesk', sans-serif;
        font-size: 12px;
        height: 22px;
        line-height: 1;
      }

      .menubar button:hover {
        background: hsl(var(--accent));
      }
      
      .menubar button:active {
        background: hsl(var(--accent-hover));
        transform: scale(0.98);
      }
      
      /* M OS Control Center */
      .quick-settings {
        position: fixed;
        top: 34px;
        right: 12px;
        width: 320px;
        background: hsl(var(--quick-settings-bg) / 0.95);
        backdrop-filter: blur(30px) saturate(150%);
        border-radius: 16px;
        padding: 16px;
        z-index: 10001;
        box-shadow: 0 12px 40px hsl(var(--shadow-color) / 0.3), 0 0 0 1px hsl(var(--window-border) / 0.5);
        opacity: 0;
        transform: translateY(-12px) scale(0.95);
        pointer-events: none;
        transition: opacity 0.25s cubic-bezier(0.16, 1, 0.3, 1),
                    transform 0.25s cubic-bezier(0.16, 1, 0.3, 1);
      }
      
      .dark .quick-settings {
        box-shadow: 0 12px 40px rgba(0,0,0,0.5), 0 0 0 1px hsl(var(--window-border) / 0.3);
      }
      
      .quick-settings.active {
        opacity: 1;
        transform: translateY(0) scale(1);
        pointer-events: auto;
      }
      
      .quick-settings.closing {
        opacity: 0;
        transform: translateY(-8px) scale(0.97);
        pointer-events: none;
      }
      
      /* Staggered animation for quick settings items */
      .quick-settings.active .quick-settings-volume {
        animation: qsItemIn 0.3s cubic-bezier(0.16, 1, 0.3, 1) 0.05s both;
      }
      
      .quick-settings.active .quick-settings-icons {
        animation: qsItemIn 0.3s cubic-bezier(0.16, 1, 0.3, 1) 0.1s both;
      }
      
      .quick-settings.active .quick-settings-option {
        animation: qsItemIn 0.3s cubic-bezier(0.16, 1, 0.3, 1) 0.15s both;
      }
      
      @keyframes qsItemIn {
        from {
          opacity: 0;
          transform: translateY(-8px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      
      .quick-settings-volume {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px;
        background: hsl(var(--quick-settings-item-bg));
        border-radius: 8px;
        margin-bottom: 12px;
        transition: background-color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }
      
      .quick-settings-volume svg {
        width: 20px;
        height: 20px;
        color: hsl(var(--foreground));
        flex-shrink: 0;
        transition: color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }
      
      .volume-slider {
        flex: 1;
        height: 4px;
        background: hsl(var(--accent));
        border-radius: 2px;
        position: relative;
        cursor: pointer;
        transition: background-color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }
      
      .volume-slider-fill {
        position: absolute;
        left: 0;
        top: 0;
        height: 100%;
        background: hsl(var(--ubuntu-orange));
        border-radius: 2px;
        width: 60%;
      }
      
      .volume-slider-thumb {
        position: absolute;
        right: 0;
        top: 50%;
        transform: translate(50%, -50%);
        width: 16px;
        height: 16px;
        background: hsl(var(--foreground));
        border-radius: 50%;
        box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        transition: background-color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }
      
      /* Icon Grid for Control Center */
      .quick-settings-icons {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
        margin-bottom: 12px;
      }
      
      .quick-settings-icon-btn {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 6px;
        padding: 16px 8px;
        background: hsl(var(--quick-settings-item-bg));
        border-radius: 12px;
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
        border: none;
        color: hsl(var(--foreground));
      }
      
      .quick-settings-icon-btn:hover {
        background: hsl(var(--accent));
        transform: scale(1.05);
      }
      
      .quick-settings-icon-btn:active {
        transform: scale(0.95);
      }
      
      .quick-settings-icon-btn.active {
        background: hsl(var(--primary));
        color: hsl(var(--primary-foreground, white));
      }
      
      .quick-settings-icon-btn.active:hover {
        background: hsl(var(--primary) / 0.85);
      }
      
      .quick-settings-icon-btn.destructive {
        background: #c01c28;
        color: white;
      }
      
      .quick-settings-icon-btn.destructive:hover {
        background: #a01722;
        transform: scale(1.05);
      }
      
      .quick-settings-icon-btn svg {
        width: 22px;
        height: 22px;
        transition: color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }
      
      .quick-settings-icon-btn span {
        font-size: 11px;
        font-weight: 500;
        text-align: center;
        line-height: 1.2;
      }
      
      .quick-settings-toggle {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 14px 16px;
        background: hsl(var(--ubuntu-orange));
        border-radius: 8px;
        margin-bottom: 8px;
        cursor: pointer;
        transition: all 0.2s;
      }
      
      .quick-settings-toggle:hover {
        transform: scale(1.02);
      }
      
      .quick-settings-toggle:active {
        transform: scale(0.98);
      }
      
      .quick-settings-toggle-label {
        display: flex;
        align-items: center;
        gap: 10px;
        color: white;
        font-weight: 500;
        font-size: 14px;
      }
      
      .quick-settings-toggle-label svg {
        width: 20px;
        height: 20px;
      }
      
      .quick-settings-option {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px;
        background: hsl(var(--quick-settings-item-bg));
        border-radius: 8px;
        margin-bottom: 8px;
        transition: background-color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }
      
      .quick-settings-option-label {
        color: hsl(var(--foreground));
        font-size: 13px;
        transition: color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }
      
      .quick-settings-option-value {
        color: hsl(var(--muted-foreground));
        font-size: 12px;
        transition: color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }
      
      /* Notification Panel */
      .notification-panel {
        position: fixed;
        top: 34px;
        right: 12px;
        width: 380px;
        max-height: calc(100vh - 100px);
        background: hsl(var(--quick-settings-bg) / 0.95);
        backdrop-filter: blur(30px) saturate(150%);
        border-radius: 16px;
        z-index: 10001;
        box-shadow: 0 12px 40px hsl(var(--shadow-color) / 0.3), 0 0 0 1px hsl(var(--window-border) / 0.5);
        opacity: 0;
        transform: translateY(-12px) scale(0.95);
        pointer-events: none;
        transition: opacity 0.25s cubic-bezier(0.16, 1, 0.3, 1),
                    transform 0.25s cubic-bezier(0.16, 1, 0.3, 1);
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }
      
      .dark .notification-panel {
        box-shadow: 0 12px 40px rgba(0,0,0,0.5), 0 0 0 1px hsl(var(--window-border) / 0.3);
      }
      
      .notification-panel.active {
        opacity: 1;
        transform: translateY(0) scale(1);
        pointer-events: auto;
      }
      
      .notification-panel.closing {
        opacity: 0;
        transform: translateY(-8px) scale(0.97);
        pointer-events: none;
      }
      
      /* Clock Section - Top of Panel */
      .notification-clock-section {
        padding: 20px 16px;
        background: hsl(var(--quick-settings-item-bg) / 0.3);
        animation: notifSectionIn 0.35s cubic-bezier(0.16, 1, 0.3, 1) 0.05s both;
      }
      
      .notification-clock-main {
        text-align: center;
      }
      
      .notification-clock-time {
        font-size: 48px;
        font-weight: 300;
        color: hsl(var(--foreground));
        line-height: 1;
        font-variant-numeric: tabular-nums;
        letter-spacing: -1px;
      }
      
      .notification-clock-date {
        font-size: 14px;
        color: hsl(var(--muted-foreground));
        margin-top: 6px;
      }
      
      @keyframes notifSectionIn {
        from {
          opacity: 0;
          transform: translateY(-8px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      
      /* Calendar Section */
      .notification-calendar-section {
        padding: 12px 16px 16px;
        background: hsl(var(--quick-settings-item-bg) / 0.5);
        border-top: 1px solid hsl(var(--window-border) / 0.3);
        animation: notifSectionIn 0.35s cubic-bezier(0.16, 1, 0.3, 1) 0.1s both;
      }
      
      .notification-calendar-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 12px;
      }
      
      .notification-calendar-month {
        font-size: 14px;
        font-weight: 500;
        color: hsl(var(--foreground));
      }
      
      .notification-calendar-nav {
        display: flex;
        gap: 4px;
      }
      
      .notification-calendar-nav button {
        padding: 6px;
        background: transparent;
        border: none;
        border-radius: 6px;
        color: hsl(var(--foreground));
        cursor: pointer;
        transition: all 0.15s ease;
      }
      
      .notification-calendar-nav button:hover {
        background: hsl(var(--accent));
        transform: scale(1.1);
      }
      
      .notification-calendar-nav button:active {
        transform: scale(0.95);
      }
      
      .notification-calendar-nav button svg {
        width: 14px;
        height: 14px;
      }
      
      .notification-calendar-weekdays {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
        gap: 2px;
        margin-bottom: 4px;
      }
      
      .notification-calendar-weekday {
        text-align: center;
        font-size: 11px;
        font-weight: 500;
        color: hsl(var(--muted-foreground));
        padding: 4px;
      }
      
      .notification-calendar-days {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
        gap: 2px;
      }
      
      .notification-calendar-day {
        aspect-ratio: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        color: hsl(var(--foreground));
        border-radius: 50%;
        cursor: pointer;
        transition: all 0.15s ease;
      }
      
      .notification-calendar-day:hover {
        background: hsl(var(--accent));
        transform: scale(1.1);
      }
      
      .notification-calendar-day.other-month {
        color: hsl(var(--muted-foreground) / 0.4);
      }
      
      .notification-calendar-day.today {
        background: hsl(var(--primary));
        color: white;
        font-weight: 600;
        box-shadow: 0 2px 8px hsl(var(--primary) / 0.4);
      }
      
      .notification-calendar-day.today:hover {
        background: hsl(var(--primary) / 0.8);
      }
      
      /* Focus Timer Footer */
      .notification-footer {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 16px;
        border-top: 1px solid hsl(var(--window-border) / 0.3);
        animation: notifSectionIn 0.35s cubic-bezier(0.16, 1, 0.3, 1) 0.15s both;
      }
      
      .notification-footer-timer {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      
      .notification-footer-timer-btn {
        width: 28px;
        height: 28px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: hsl(var(--accent) / 0.5);
        border: none;
        border-radius: 6px;
        color: hsl(var(--foreground));
        cursor: pointer;
        transition: all 0.15s ease;
      }
      
      .notification-footer-timer-btn:hover {
        background: hsl(var(--accent));
        transform: scale(1.1);
      }
      
      .notification-footer-timer-btn:active {
        transform: scale(0.9);
      }
      
      .notification-footer-timer-btn svg {
        width: 14px;
        height: 14px;
      }
      
      .notification-footer-timer-value {
        font-size: 13px;
        font-weight: 500;
        color: hsl(var(--foreground));
        min-width: 50px;
        text-align: center;
        font-variant-numeric: tabular-nums;
      }
      
      .notification-footer-focus {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 14px;
        background: hsl(var(--primary));
        border: none;
        border-radius: 8px;
        color: white;
        font-size: 12px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
      }
      
      .notification-footer-focus:hover {
        background: hsl(var(--primary) / 0.85);
        transform: scale(1.03);
        box-shadow: 0 4px 12px hsl(var(--primary) / 0.3);
      }
      
      .notification-footer-focus:active {
        transform: scale(0.97);
      }
      
      .notification-footer-focus.active {
        background: #dc2626;
      }
      
      .notification-footer-focus.active:hover {
        background: #b91c1c;
        box-shadow: 0 4px 12px rgba(220, 38, 38, 0.3);
      }
      
      .notification-footer-focus svg {
        width: 14px;
        height: 14px;
      }
      
      /* Notifications Section */
      .notification-section {
        border-top: 1px solid hsl(var(--window-border) / 0.3);
        animation: notifSectionIn 0.35s cubic-bezier(0.16, 1, 0.3, 1) 0.2s both;
      }
      
      .notification-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 16px;
      }
      
      .notification-header-title {
        font-size: 13px;
        font-weight: 600;
        color: hsl(var(--foreground));
      }
      
      .notification-header-actions {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      
      .notification-header-btn {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 5px 10px;
        background: hsl(var(--accent) / 0.5);
        border: none;
        border-radius: 6px;
        color: hsl(var(--foreground));
        font-size: 11px;
        cursor: pointer;
        transition: all 0.15s ease;
      }
      
      .notification-header-btn:hover {
        background: hsl(var(--accent));
        transform: scale(1.02);
      }
      
      .notification-header-btn:active {
        transform: scale(0.98);
      }
      
      .notification-header-btn svg {
        width: 12px;
        height: 12px;
      }
      
      .notification-list {
        overflow-y: auto;
        padding: 0 12px 12px;
        max-height: 200px;
      }
      
      .notification-list::-webkit-scrollbar {
        width: 5px;
      }
      
      .notification-list::-webkit-scrollbar-track {
        background: transparent;
      }
      
      .notification-list::-webkit-scrollbar-thumb {
        background: hsl(var(--muted-foreground) / 0.3);
        border-radius: 3px;
      }
      
      .notification-item {
        display: flex;
        gap: 10px;
        padding: 10px;
        background: hsl(var(--quick-settings-item-bg));
        border-radius: 10px;
        margin-bottom: 6px;
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
        animation: notifItemIn 0.25s cubic-bezier(0.16, 1, 0.3, 1) both;
      }
      
      .notification-item:last-child {
        margin-bottom: 0;
      }
      
      .notification-item:hover {
        background: hsl(var(--accent));
        transform: translateX(4px);
      }
      
      @keyframes notifItemIn {
        from {
          opacity: 0;
          transform: translateX(-12px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }
      
      .notification-icon {
        width: 32px;
        height: 32px;
        border-radius: 8px;
        background: hsl(var(--primary) / 0.15);
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
      }
      
      .notification-icon svg {
        width: 16px;
        height: 16px;
        color: hsl(var(--primary));
      }
      
      .notification-icon img {
        width: 100%;
        height: 100%;
        border-radius: 8px;
        object-fit: cover;
      }
      
      .notification-content {
        flex: 1;
        min-width: 0;
      }
      
      .notification-app {
        font-size: 10px;
        color: hsl(var(--muted-foreground));
        margin-bottom: 2px;
        display: flex;
        align-items: center;
        gap: 6px;
      }
      
      .notification-time {
        font-size: 10px;
        color: hsl(var(--muted-foreground) / 0.7);
      }
      
      .notification-title {
        font-size: 12px;
        font-weight: 500;
        color: hsl(var(--foreground));
        margin-bottom: 2px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      
      .notification-body {
        font-size: 11px;
        color: hsl(var(--muted-foreground));
        line-height: 1.3;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }
      
      .notification-empty {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 30px 20px;
        color: hsl(var(--muted-foreground));
      }
      
      .notification-empty svg {
        width: 36px;
        height: 36px;
        margin-bottom: 10px;
        opacity: 0.4;
      }
      
      .notification-empty span {
        font-size: 13px;
      }
      

      .menubar button svg {
        width: 16px;
        height: 16px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        transition: color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .menubar-icon svg {
        width: 16px;
        height: 16px;
        transition: color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }
      
      .theme-toggle-icon {
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                    opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                    color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        will-change: transform, opacity;
      }
      
      .theme-toggle-icon:hover {
        transform: scale(1.15);
      }
      
      .theme-toggle-icon:active {
        transform: scale(0.9);
      }
      
      .theme-toggle-icon.transitioning {
        animation: themeIconRotate 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      }
      
      /* Quick Settings theme icon specific styles */
      .qs-theme-icon {
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .qs-theme-icon svg {
        width: 22px;
        height: 22px;
      }
      
      .qs-theme-icon.transitioning {
        animation: themeIconRotate 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      }
      
      @keyframes themeIconRotate {
        0% {
          transform: rotate(0deg) scale(1);
          opacity: 1;
        }
        50% {
          transform: rotate(180deg) scale(0.7);
          opacity: 0.3;
        }
        100% {
          transform: rotate(360deg) scale(1);
          opacity: 1;
        }
      }
      
      /* Theme switch pulse/glow animation - DISABLED */
      @keyframes themePulse {
        0%, 50%, 100% {
          box-shadow: none;
        }
      }
      
      .theme-pulse-active {
        animation: none;
      }
      
      /* Full screen glow overlay for theme switch - DISABLED */
      .theme-transition-overlay {
        display: none;
        pointer-events: none;
      }
      
      .theme-transition-overlay.active {
        animation: none;
        display: none;
      }
      
      @keyframes overlayPulse {
        0%, 40%, 100% {
          opacity: 0;
          background: none;
        }
      }

      .menubar,
      .titlebar,
      .dock,
      .dock-icon {
        user-select: none;
        -webkit-user-select: none;
      }

      .window-content {
        user-select: text;
        -webkit-user-select: text;
      }

      .desktop,
      .menubar,
      .dock-container {
        -webkit-touch-callout: none;
        -webkit-tap-highlight-color: transparent;
      }

      .window.fullscreen {
        top: 0 !important;
        left: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        border-radius: 0 !important;
        z-index: 10001 !important;
      }
      
      .window.fullscreen .titlebar {
        display: none;
      }
      
      .window.fullscreen .window-content {
        padding: 0;
        height: 100%;
      }
      
      /* Ensure iframes in fullscreen can receive keyboard focus and events */
      .window.fullscreen iframe {
        width: 100%;
        height: 100%;
        border: none;
        outline: none;
      }
      
      .window.fullscreen .browser-container,
      .window.fullscreen .minecraft-container {
        height: 100%;
        display: flex;
        flex-direction: column;
      }
      
      .window.fullscreen .browser-container iframe,
      .window.fullscreen .minecraft-container iframe {
        flex: 1;
        min-height: 0;
      }
      
      /* Hide browser toolbar in fullscreen to give more space to the game/content */
      .window.fullscreen .browser-toolbar,
      .window.fullscreen .browser-tabs-container,
      .window.fullscreen .browser-bookmarks-bar {
        display: none;
      }
      
      /* Minecraft-specific optimizations for 3D performance */
      .minecraft-container {
        position: relative;
        contain: strict;
        isolation: isolate;
      }
      
      .minecraft-container iframe {
        /* Disable CSS transitions on the iframe to prevent 3D render interruptions */
        transition: none !important;
        /* Force GPU layer */
        transform: translateZ(0);
        will-change: contents;
      }
      
      /* Iframe click interceptor - prevents iframe from blocking OS UI interactions */
      .iframe-click-interceptor {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 10;
        background: transparent;
        display: none;
        cursor: default;
      }
      
      /* Show interceptor when window is inactive (not focused) */
      .window.inactive .iframe-click-interceptor {
        display: block;
      }
      
      /* Windows layer - contains all app windows with pointer-events isolated */
      .windows-layer {
        position: absolute;
        inset: 0;
        z-index: 100;
        pointer-events: none; /* Container doesn't capture events */
      }
      
      /* Individual windows get pointer-events back */
      .windows-layer .window {
        pointer-events: auto;
      }
      
      /* System UI layer - dock and menubar are ABOVE windows layer */
      .dock-container,
      .menubar {
        pointer-events: auto !important;
        position: fixed !important;
      }
      
      /* Ensure desktop shortcuts are always clickable */
      .desktop-shortcut {
        pointer-events: auto !important;
      }
      
      /* Exit fullscreen button overlay - always visible in fullscreen mode */
      .fullscreen-exit-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 40px;
        height: 40px;
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        color: white;
        cursor: pointer;
        z-index: 100000;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        transition: opacity 0.3s ease;
        pointer-events: auto;
      }
      
      .window.fullscreen:hover .fullscreen-exit-btn,
      .fullscreen-exit-btn:hover {
        opacity: 1;
      }
      
      .fullscreen-exit-btn:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: scale(1.05);
      }
      
      .fullscreen-exit-btn:active {
        transform: scale(0.95);
      }
      
      .fullscreen-exit-btn svg {
        width: 20px;
        height: 20px;
        stroke: currentColor;
        stroke-width: 2;
        fill: none;
      }
      
      /* Force the exit button to be above the iframe */
      .window.fullscreen .minecraft-container,
      .window.fullscreen .browser-container {
        position: relative;
      }

      .window.maximized {
        border-radius: 0 !important;
      }

      .window.maximizing, .window.restoring {
        will-change: transform, top, left, width, height, border-radius;
      }

      .dock-container {
        position: fixed;
        z-index: 19999;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }
      
      /* Default to LEFT for Ubuntu style */
      .dock-container.dock-left,
      .dock-container:not(.dock-bottom):not(.dock-right) {
        left: 8px;
        top: 50%;
        transform: translateY(-50%);
      }
      
      .dock-container.dock-bottom {
        bottom: 4px;
        left: 50%;
        transform: translateX(-50%);
        display: inline-flex;
        justify-content: center;
      }
      
      .dock-container.dock-right {
        right: 8px;
        top: 50%;
        transform: translateY(-50%);
      }

      /* M OS Dock */
      .dock {
        background: hsl(var(--dock-bg) / 0.85);
        backdrop-filter: blur(25px) saturate(150%);
        padding: 8px 12px;
        border-radius: 14px;
        box-shadow: 0 8px 32px hsl(var(--shadow-color) / 0.2), 0 0 0 1px hsl(var(--window-border) / 0.5);
        border: none;
        display: inline-flex;
        gap: 6px;
        transition: all 0.3s ease;
        position: relative;
        width: auto;
        height: 64px;
        align-items: center;
        overflow: visible;
      }
      
      .dark .dock {
        background: hsl(var(--dock-bg) / 0.9);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), 0 0 0 1px hsl(var(--window-border) / 0.3);
      }
      
      .dock-bottom .dock {
        flex-direction: row;
        align-items: center;
        padding: 6px 10px;
        width: auto;
        height: 60px;
        min-width: min-content;
        overflow: visible;
      }
      
      .dock-left .dock,
      .dock-container:not(.dock-bottom):not(.dock-right) .dock {
        flex-direction: column;
        align-items: center;
        padding: 6px 10px;
        height: auto;
        min-height: min-content;
      }
      
      .dock-right .dock {
        flex-direction: column;
        align-items: center;
        padding: 6px 10px;
        height: auto;
        min-height: min-content;
      }

      .dock-icon {
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: grab;
        transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275),
                    opacity 0.2s ease,
                    width 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275),
                    height 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        position: relative;
        will-change: transform;
        transform: translate3d(0, 0, 0);
        user-select: none;
        -webkit-user-select: none;
        -webkit-user-drag: none;
        flex-shrink: 0;
        margin: 0;
        transform-origin: center bottom;
      }
      
      /* Appearing animation for new dock icons */
      .dock-icon.appearing {
        animation: dockIconAppear 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      }
      
      @keyframes dockIconAppear {
        from {
          transform: scale(0.3) translate3d(0, 0, 0);
          opacity: 0;
        }
        to {
          transform: scale(1) translate3d(0, 0, 0);
          opacity: 1;
        }
      }
      
      /* Dock icon sizing - dynamic based on scale and magnification */
      /* Bottom dock expands horizontally only, icons move up */
      .dock-bottom .dock-icon {
        width: calc(48px * var(--dock-scale, 1) * var(--icon-magnify, 1));
        height: calc(48px * var(--dock-scale, 1));
        transition: width 0.3s cubic-bezier(0.34, 1.56, 0.64, 1),
                    height 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      }
      
      /* Left/Right dock icons */
      .dock-left .dock-icon,
      .dock-right .dock-icon,
      .dock-container:not(.dock-bottom):not(.dock-right) .dock-icon {
        width: calc(48px * var(--dock-scale, 1) * var(--icon-magnify, 1));
        height: calc(48px * var(--dock-scale, 1) * var(--icon-magnify, 1));
        transition: width 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), 
                    height 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      }
      
      .dock-icon:active {
        cursor: grabbing;
      }
      
      .dock-icon.dragging {
        opacity: 0.85;
        z-index: 1000;
        cursor: grabbing;
        filter: brightness(1.1);
        transition: opacity 0.15s ease, filter 0.15s ease;
      }
      
      .dock-icon.drag-over {
        transform: translate3d(0, calc(-8px * var(--dock-scale, 1)), 0) scale3d(1.05, 1.05, 1);
      }
      
      .dock-icon.slide-left {
        transform: translateX(calc(-64px * var(--dock-scale, 1)));
        transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      }
      
      .dock-icon.slide-right {
        transform: translateX(calc(64px * var(--dock-scale, 1)));
        transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      }
      
      /* All dock icon SVGs scale uniformly */
      .dock-icon svg {
        width: calc(40px * var(--dock-scale, 1) * var(--icon-magnify, 1));
        height: calc(40px * var(--dock-scale, 1) * var(--icon-magnify, 1));
        color: white;
        transition: width 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), 
                    height 0.3s cubic-bezier(0.34, 1.56, 0.64, 1),
                    transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      }
      
      .dock-divider {
        background: #464646;
        flex-shrink: 0;
      }
      
      .dock-bottom .dock-divider {
        width: 1px;
        height: calc(40px * var(--dock-scale, 1));
        margin: 0 4px;
        transition: height 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      }
      
      .dock-left .dock-divider,
      .dock-right .dock-divider,
      .dock-container:not(.dock-bottom):not(.dock-right) .dock-divider {
        width: calc(40px * var(--dock-scale, 1) * var(--icon-magnify, 1));
        height: 1px;
        margin: 4px 0;
        transition: width 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      }

      .dock-tooltip {
        position: absolute;
        top: -50px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(50, 50, 60, 0.75);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        color: white;
        padding: 6px 14px;
        border-radius: 8px;
        font-size: 13px;
        font-weight: 500;
        white-space: nowrap;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s cubic-bezier(0.16, 1, 0.3, 1), transform 0.2s cubic-bezier(0.16, 1, 0.3, 1);
        will-change: opacity, transform;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5), 0 0 8px rgba(255, 255, 255, 0.15);
        box-shadow: 0 2px 12px rgba(0, 0, 0, 0.25), inset 0 1px 0 rgba(255, 255, 255, 0.15);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .dock-icon:hover .dock-tooltip {
        opacity: 1;
        transform: translateX(-50%) translateY(-4px);
      }
      
      /* Hide dock tooltips when dragging windows */
      body.window-dragging .dock-tooltip,
      body.window-dragging .dock-icon:hover .dock-tooltip {
        opacity: 0 !important;
        pointer-events: none !important;
      }

      .context-menu {
        position: fixed;
        background: hsl(var(--window-bg));
        border-radius: 8px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        padding: 4px;
        z-index: 99999;
        min-width: 180px;
        backdrop-filter: blur(20px);
        animation: contextMenuAppear 0.15s cubic-bezier(0.16, 1, 0.3, 1);
        transform-origin: top center;
        transition: background-color 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                    box-shadow 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      @keyframes contextMenuAppear {
        from {
          opacity: 0;
          transform: translate3d(0, -4px, 0) scale3d(0.96, 0.96, 1);
        }
        to {
          opacity: 1;
          transform: translate3d(0, 0, 0) scale3d(1, 1, 1);
        }
      }

      .context-menu-item {
        padding: 8px 12px;
        cursor: pointer;
        border-radius: 4px;
        font-size: 13px;
        transition: background 0.15s cubic-bezier(0.16, 1, 0.3, 1),
                    color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .context-menu-item:hover {
        background: hsl(var(--accent));
      }

      .context-menu-divider {
        height: 1px;
        background: hsl(var(--window-border));
        margin: 4px 0;
        transition: background-color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      /* Context Menu Right-Click Menu */
      .menubar-context-menu {
        position: fixed;
        background: hsl(var(--window-bg));
        border-radius: 8px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        padding: 4px;
        z-index: 100000;
        min-width: 200px;
        backdrop-filter: blur(20px);
        animation: contextMenuAppear 0.15s cubic-bezier(0.16, 1, 0.3, 1);
        transform-origin: top left;
      }

      .menubar-context-menu-header {
        padding: 8px 12px;
        font-size: 11px;
        font-weight: 600;
        color: hsl(var(--muted-foreground));
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }

      /* Context Menu Customization Mode */
      .menubar.customize-mode {
        border: 2px dashed hsl(var(--primary));
        background: hsl(var(--menubar-bg) / 0.95);
      }
      
      .menubar.customize-mode .context-menu-element {
        border: 1px dashed hsl(var(--primary) / 0.5);
        border-radius: 4px;
        cursor: move;
        transition: all 0.15s ease;
        padding: 2px 6px;
        margin: 0 2px;
      }
      
      .menubar.customize-mode .context-menu-element:hover {
        background: hsl(var(--primary) / 0.2);
        border-color: hsl(var(--primary));
      }
      
      .menubar.customize-mode .context-menu-element.dragging {
        opacity: 0.5;
        border-color: hsl(var(--primary));
        background: hsl(var(--primary) / 0.3);
      }
      
      .menubar.customize-mode .context-menu-element.drag-over {
        background: hsl(var(--primary) / 0.4);
        transform: scale(1.05);
      }
      
      .context-menu-customize-bar {
        position: fixed;
        top: 32px;
        left: 50%;
        transform: translateX(-50%);
        background: hsl(var(--window-bg) / 0.95);
        backdrop-filter: blur(20px);
        border-radius: 12px;
        padding: 12px 20px;
        display: flex;
        align-items: center;
        gap: 16px;
        z-index: 10002;
        box-shadow: 0 8px 32px hsl(var(--shadow-color) / 0.4);
        border: 1px solid hsl(var(--window-border));
        animation: slideDown 0.2s cubic-bezier(0.16, 1, 0.3, 1);
      }
      
      .context-menu-customize-bar span {
        font-size: 13px;
        font-weight: 500;
        color: hsl(var(--foreground));
      }
      
      .context-menu-customize-bar button {
        padding: 6px 14px;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.15s ease;
        border: none;
      }
      
      .context-menu-customize-bar .done-btn {
        background: hsl(var(--primary));
        color: white;
      }
      
      .context-menu-customize-bar .done-btn:hover {
        background: hsl(var(--primary) / 0.85);
        transform: scale(1.02);
      }
      
      .context-menu-customize-bar .reset-btn {
        background: hsl(var(--accent));
        color: hsl(var(--foreground));
      }
      
      .context-menu-customize-bar .reset-btn:hover {
        background: hsl(var(--accent-hover));
      }
      
      .context-menu-drop-zone {
        min-width: 40px;
        min-height: 20px;
        display: flex;
        align-items: center;
        gap: 2px;
        padding: 0 4px;
        position: relative;
      }
      
      .drop-zone-label {
        font-size: 10px;
        color: hsl(var(--muted-foreground) / 0.7);
        text-transform: uppercase;
        letter-spacing: 0.05em;
        padding: 2px 8px;
      }
      
      .context-menu-drop-zone.empty {
        border: 1px dashed hsl(var(--muted-foreground) / 0.3);
        border-radius: 4px;
      }
      
      .context-menu-drop-zone.drag-over {
        background: hsl(var(--primary) / 0.1);
        border-color: hsl(var(--primary));
      }
      
      .context-menu-element-label {
        position: absolute;
        top: -18px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 9px;
        color: hsl(var(--primary));
        background: hsl(var(--background));
        padding: 1px 4px;
        border-radius: 2px;
        white-space: nowrap;
        opacity: 0;
        transition: opacity 0.15s;
        pointer-events: none;
      }
      
      .menubar.customize-mode .context-menu-element:hover .context-menu-element-label {
        opacity: 1;
      }
      
      .context-menu-item.active {
        background: hsl(var(--primary) / 0.2);
        color: hsl(var(--primary));
      }
      
      .context-menu-item.destructive {
        color: #ef4444;
      }
      
      .context-menu-item.destructive:hover {
        background: rgba(239, 68, 68, 0.15);
      }
      
      .context-menu-separator {
        height: 1px;
        background: hsl(var(--window-border));
        margin: 4px 0;
      }
      
      .hidden-elements-list {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-left: 16px;
        padding-left: 16px;
        border-left: 1px solid hsl(var(--window-border));
      }
      
      .hidden-elements-list span.label {
        font-size: 11px;
        color: hsl(var(--muted-foreground));
      }
      
      .hidden-element-btn {
        padding: 4px 10px;
        background: hsl(var(--accent));
        border: 1px dashed hsl(var(--primary) / 0.4);
        border-radius: 6px;
        font-size: 11px;
        color: hsl(var(--foreground));
        cursor: pointer;
        transition: all 0.15s ease;
      }
      
      .hidden-element-btn:hover {
        background: hsl(var(--primary) / 0.2);
        border-color: hsl(var(--primary));
        transform: scale(1.02);
      }
      
      .menubar-center {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        align-items: center;
        gap: 2px;
      }


      .launchpad-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(20px) saturate(120%);
        z-index: 99998;
        display: flex;
        flex-direction: column;
        opacity: 0;
        animation: launchpadFadeIn 0.3s cubic-bezier(0.16, 1, 0.3, 1) forwards;
      }

      .launchpad-overlay.closing {
        animation: launchpadFadeOut 0.3s cubic-bezier(0.4, 0, 1, 1) forwards !important;
        pointer-events: none;
      }

      @keyframes launchpadFadeIn {
        from {
          opacity: 0;
          backdrop-filter: blur(0px) saturate(100%);
        }
        to {
          opacity: 1;
          backdrop-filter: blur(20px) saturate(120%);
        }
      }

      @keyframes launchpadFadeOut {
        from {
          opacity: 1;
          backdrop-filter: blur(20px) saturate(120%);
        }
        to {
          opacity: 0;
          backdrop-filter: blur(0px) saturate(100%);
        }
      }

      .launchpad-search-container {
        display: flex;
        justify-content: center;
        padding: 40px 20px 20px;
        opacity: 0;
        transform: translateY(-30px);
        animation: slideDown 0.4s cubic-bezier(0.16, 1, 0.3, 1) 0.05s forwards;
      }

      .launchpad-overlay.closing .launchpad-search-container {
        animation: slideUp 0.25s cubic-bezier(0.4, 0, 1, 1) forwards !important;
      }

      @keyframes slideDown {
        from {
          opacity: 0;
          transform: translateY(-30px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @keyframes slideUp {
        from {
          opacity: 1;
          transform: translateY(0);
        }
        to {
          opacity: 0;
          transform: translateY(-30px);
        }
      }

      .launchpad-search {
        width: 100%;
        max-width: 600px;
        padding: 12px 20px;
        background: rgba(255, 255, 255, 0.15);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        color: white;
        font-size: 18px;
        outline: none;
        backdrop-filter: blur(10px);
        transition: all 0.2s ease;
      }

      .launchpad-search::placeholder {
        color: rgba(255, 255, 255, 0.6);
      }

      .launchpad-search:focus {
        background: rgba(255, 255, 255, 0.2);
        border-color: rgba(255, 255, 255, 0.4);
      }

      .launchpad-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
        gap: 40px;
        padding: 20px 80px 80px;
        height: 100%;
        overflow-y: auto;
        align-content: start;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        max-width: 1400px;
        margin: 0 auto;
        width: 100%;
        opacity: 0;
        transform: scale(0.9);
        animation: scaleIn 0.45s cubic-bezier(0.16, 1, 0.3, 1) 0.1s forwards;
      }

      .launchpad-overlay.closing .launchpad-grid {
        animation: scaleOut 0.25s cubic-bezier(0.4, 0, 1, 1) forwards !important;
      }

      @keyframes scaleIn {
        from {
          opacity: 0;
          transform: scale(0.9);
        }
        to {
          opacity: 1;
          transform: scale(1);
        }
      }

      @keyframes scaleOut {
        from {
          opacity: 1;
          transform: scale(1);
        }
        to {
          opacity: 0;
          transform: scale(0.9);
        }
      }

      .launchpad-grid::-webkit-scrollbar,
      .window-content::-webkit-scrollbar,
      .terminal-content::-webkit-scrollbar {
        width: 8px;
      }

      .launchpad-grid::-webkit-scrollbar-track,
      .window-content::-webkit-scrollbar-track,
      .terminal-content::-webkit-scrollbar-track {
        background: transparent;
      }

      .launchpad-grid::-webkit-scrollbar-thumb,
      .window-content::-webkit-scrollbar-thumb,
      .terminal-content::-webkit-scrollbar-thumb {
        background: hsl(var(--foreground) / 0);
        border-radius: 4px;
        transition: background 0.2s cubic-bezier(0.16, 1, 0.3, 1);
      }

      .launchpad-grid:hover::-webkit-scrollbar-thumb,
      .window-content:hover::-webkit-scrollbar-thumb,
      .terminal-content:hover::-webkit-scrollbar-thumb {
        background: hsl(var(--foreground) / 0.2);
      }
      
      .terminal-content:hover::-webkit-scrollbar-thumb {
        background: rgba(0, 255, 0, 0.2);
      }

      .launchpad-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        padding: 12px;
        border-radius: 12px;
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
        will-change: transform, background-color;
        transform: translate3d(0, 0, 0);
      }

      .launchpad-item:hover {
        background: rgba(255, 255, 255, 0.15);
        transform: translate3d(0, 0, 0) scale3d(1.08, 1.08, 1);
      }

      .launchpad-item:active {
        transform: translate3d(0, 0, 0) scale3d(0.95, 0.95, 1);
      }

      /* M OS Windows - GPU Accelerated */
      .window {
        position: fixed;
        background: hsl(var(--window-bg));
        border-radius: 10px;
        box-shadow: 0 8px 32px hsl(var(--shadow-color) / 0.2), 0 0 0 1px hsl(var(--window-border));
        display: flex;
        flex-direction: column;
        overflow: hidden;
        will-change: auto;
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
        transform: translateZ(0);
        -webkit-transform: translateZ(0);
        border: none;
        contain: layout style;
      }
      
      /* Only enable will-change during animations */
      .window.animating,
      .window.maximizing,
      .window.restoring,
      .window.snapping {
        will-change: transform, opacity, left, top, width, height;
      }
      
      /* Dragging window - no transitions, pure GPU */
      .window.dragging {
        transition: none !important;
        will-change: transform;
        cursor: grabbing;
      }
      
      /* Inactive window styles - only grey out titlebar buttons and text */
      .window.inactive .titlebar-button {
        opacity: 0.4;
      }
      
      .window.inactive .titlebar-title {
        opacity: 0.4;
      }
      
      .dark .window {
        box-shadow: 0 12px 48px rgba(0, 0, 0, 0.4), 0 0 0 1px hsl(var(--window-border));
      }

      .window.snapped,
      .window.maximizing,
      .window.maximized,
      .window.snapping {
        box-shadow: none !important;
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
        transform: translate3d(0, 0, 0);
      }
      
      .window.maximized,
      .window.snapped {
        box-shadow: none;
        border-radius: 0 !important;
      }
      
      .window.maximizing,
      .window.snapping,
      .window.restoring {
        will-change: left, top, width, height, border-radius;
        transition: left 0.3s cubic-bezier(0.16, 1, 0.3, 1),
                    top 0.3s cubic-bezier(0.16, 1, 0.3, 1),
                    width 0.3s cubic-bezier(0.16, 1, 0.3, 1),
                    height 0.3s cubic-bezier(0.16, 1, 0.3, 1),
                    border-radius 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      }

      .window.appearing {
        animation: windowAppear 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      }

      @keyframes windowAppear {
        from {
          opacity: 0;
          transform: scale3d(0.95, 0.95, 1) translateY(8px);
        }
        to {
          opacity: 1;
          transform: scale3d(1, 1, 1) translateY(0);
        }
      }

      /* M OS Titlebar */
      .titlebar {
        height: 40px;
        background: hsl(var(--titlebar-bg));
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 12px;
        cursor: move;
        user-select: none;
        border-bottom: 1px solid hsl(var(--window-border) / 0.5);
        position: relative;
      }

      .titlebar-buttons {
        display: flex;
        gap: 6px;
        position: absolute;
        left: 12px;
        right: auto;
      }

      /* M OS Window Controls - Modern circular buttons */
      .titlebar-button {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        border: none;
        cursor: pointer;
        transition: all 0.15s ease;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        background: hsl(var(--foreground) / 0.15);
      }

      .titlebar-button::before {
        content: '';
        position: absolute;
        opacity: 0.8;
        transition: opacity 0.15s ease;
      }

      .titlebar-button:hover {
        transform: scale(1.15);
      }
      
      .titlebar-button:hover::before {
        opacity: 1;
      }

      .titlebar-button:active {
        transform: scale(0.95);
      }

      /* Default order: close, maximize, minimize */
      .titlebar-button.close {
        order: 1;
      }
      
      .titlebar-button.maximize {
        order: 2;
      }
      
      .titlebar-button.minimize {
        order: 3;
      }
      
      /* Mirrored order: minimize, maximize, close (inverted) */
      .mirrored-controls .titlebar-button.minimize {
        order: 1;
      }
      
      .mirrored-controls .titlebar-button.maximize {
        order: 2;
      }
      
      .mirrored-controls .titlebar-button.close {
        order: 3;
      }
      
      .titlebar-button.minimize::before {
        width: 8px;
        height: 2px;
        background: hsl(var(--foreground));
        border-radius: 1px;
      }
      
      .titlebar-button.minimize:hover {
        background: hsl(45 90% 55%);
      }
      
      .titlebar-button.minimize:hover::before {
        background: hsl(45 20% 15%);
      }

      .titlebar-button.maximize::before {
        width: 6px;
        height: 6px;
        border: 1.5px solid hsl(var(--foreground));
        border-radius: 1px;
      }
      
      .window.maximized .titlebar-button.maximize::before,
      .window.fullscreen .titlebar-button.maximize::before {
        width: 5px;
        height: 5px;
        border: 1.5px solid hsl(var(--foreground));
        box-shadow: 2px -2px 0 0 hsl(var(--foreground));
        transform: translate(-1px, 1px);
      }
      
      .titlebar-button.maximize:hover {
        background: hsl(140 70% 45%);
      }
      
      .titlebar-button.maximize:hover::before {
        border-color: hsl(140 20% 15%);
      }
      
      .window.maximized .titlebar-button.maximize:hover::before,
      .window.fullscreen .titlebar-button.maximize:hover::before {
        border-color: hsl(140 20% 15%);
        box-shadow: 2px -2px 0 0 hsl(140 20% 15%);
      }

      .titlebar-button.close::before {
        content: '';
        font-size: 12px;
        font-weight: 600;
        color: hsl(var(--foreground));
        line-height: 1;
        opacity: 0.8;
      }
      
      .titlebar-button.close:hover {
        background: hsl(0 70% 55%);
      }
      
      .titlebar-button.close:hover::before {
        color: white;
        opacity: 1;
      }

      .titlebar-title {
        font-size: 13px;
        font-weight: 600;
        color: hsl(var(--foreground));
        letter-spacing: 0.01em;
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
      }

      /* Fullscreen button - appears on right side when window is maximized */
      .titlebar-fullscreen-btn {
        position: absolute;
        right: 16px;
        left: auto;
        display: none;
        align-items: center;
        justify-content: center;
        width: 24px;
        height: 24px;
        border-radius: 6px;
        background: hsl(var(--accent));
        border: 1px solid hsl(var(--window-border));
        cursor: pointer;
        transition: all 0.15s cubic-bezier(0.16, 1, 0.3, 1);
        opacity: 0.8;
      }

      .titlebar-fullscreen-btn:hover {
        background: hsl(var(--primary));
        opacity: 1;
        transform: scale(1.05);
      }

      .titlebar-fullscreen-btn:active {
        transform: scale(0.95);
      }

      .titlebar-fullscreen-btn svg {
        width: 14px;
        height: 14px;
        stroke: hsl(var(--foreground));
        stroke-width: 2;
        fill: none;
      }

      .titlebar-fullscreen-btn:hover svg {
        stroke: white;
      }

      /* Show fullscreen button only when window is maximized */
      .window.maximized .titlebar-fullscreen-btn {
        display: flex;
      }

      /* Mirrored layout - window buttons on right, fullscreen on left */
      .mirrored-controls .titlebar-buttons {
        left: auto !important;
        right: 12px !important;
      }
      
      .mirrored-controls .titlebar-fullscreen-btn {
        left: 12px !important;
        right: auto !important;
      }
      
      /* Warp animations - only trigger when class is added */
      .titlebar-buttons.animating-to-right {
        animation: warpToRight 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
      }
      
      .titlebar-buttons.animating-to-left {
        animation: warpToLeft 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
      }
      
      .titlebar-fullscreen-btn.animating-to-left {
        animation: warpToLeft 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
      }
      
      .titlebar-fullscreen-btn.animating-to-right {
        animation: warpToRight 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
      }
      
      @keyframes warpToRight {
        0% {
          transform: translateX(-80px) scale(0.7);
          opacity: 0;
        }
        60% {
          transform: translateX(8px) scale(1.08);
          opacity: 1;
        }
        100% {
          transform: translateX(0) scale(1);
          opacity: 1;
        }
      }
      
      @keyframes warpToLeft {
        0% {
          transform: translateX(80px) scale(0.7);
          opacity: 0;
        }
        60% {
          transform: translateX(-8px) scale(1.08);
          opacity: 1;
        }
        100% {
          transform: translateX(0) scale(1);
          opacity: 1;
        }
      }

      .window-content {
        flex: 1;
        overflow: auto;
        padding: 0;
        display: flex;
        flex-direction: column;
        transition: background-color 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                    color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        scrollbar-width: thin;
        scrollbar-color: rgba(128, 128, 128, 0.5) transparent;
      }

      .window-content::-webkit-scrollbar {
        width: 12px;
      }

      .window-content::-webkit-scrollbar-track {
        background: transparent;
      }

      .window-content::-webkit-scrollbar-thumb {
        background: rgba(128, 128, 128, 0.5);
        border-radius: 10px;
        border: 3px solid transparent;
        background-clip: padding-box;
      }

      .window-content::-webkit-scrollbar-thumb:hover {
        background: rgba(128, 128, 128, 0.7);
        background-clip: padding-box;
      }

      .resize-handle {
        position: absolute;
        z-index: 10;
      }
      
      .resize-handle.se { bottom: 0; right: 0; width: 16px; height: 16px; cursor: se-resize; }
      .resize-handle.sw { bottom: 0; left: 0; width: 16px; height: 16px; cursor: sw-resize; }
      .resize-handle.ne { top: 0; right: 0; width: 16px; height: 16px; cursor: ne-resize; }
      .resize-handle.nw { top: 0; left: 0; width: 16px; height: 16px; cursor: nw-resize; }
      .resize-handle.n { top: 0; left: 0; right: 0; height: 4px; cursor: n-resize; }
      .resize-handle.s { bottom: 0; left: 0; right: 0; height: 4px; cursor: s-resize; }
      .resize-handle.e { top: 0; bottom: 0; right: 0; width: 4px; cursor: e-resize; }
      .resize-handle.w { top: 0; bottom: 0; left: 0; width: 4px; cursor: w-resize; }

      .terminal-content {
        background: #000;
        color: #0f0;
        font-family: 'JetBrainsMono Nerd Font', 'JetBrains Mono', 'Courier New', monospace;
        padding: 0;
        height: 100%;
        overflow-y: auto;
        font-size: 14px;
        line-height: 1.5;
        user-select: text;
        -webkit-user-select: text;
        -moz-user-select: text;
        -ms-user-select: text;
      }

      .terminal-content::selection,
      .terminal-content *::selection {
        background: rgba(0, 255, 0, 0.3);
        color: #0f0;
      }

      .terminal-content::-moz-selection,
      .terminal-content *::-moz-selection {
        background: rgba(0, 255, 0, 0.3);
        color: #0f0;
      }

      .terminal-input::selection {
        background: rgba(0, 255, 0, 0.4);
        color: #0f0;
      }

      .terminal-input::-moz-selection {
        background: rgba(0, 255, 0, 0.4);
        color: #0f0;
      }

      .terminal-input-line {
        display: flex;
        gap: 8px;
      }

      .terminal-input {
        background: transparent;
        border: none;
        color: #0f0;
        font-family: 'JetBrainsMono Nerd Font', 'JetBrains Mono', 'Courier New', monospace;
        font-size: 14px;
        outline: none;
        flex: 1;
      }

      /* ========== BROWSER COMPONENT - REFACTORED ========== */
      
      /* Main browser container - creates stacking context */
      .browser-container {
        position: relative;
        isolation: isolate;
        display: flex;
        flex-direction: column;
        height: 100%;
        min-height: 100%;
        background: hsl(var(--window-bg));
        overflow: hidden;
      }
      
      /* Browser header section - contains tabs, bookmarks, toolbar */
      .browser-header {
        position: relative;
        z-index: 100;
        flex-shrink: 0;
        display: flex;
        flex-direction: column;
        background: hsl(var(--titlebar-bg));
      }

      /* Browser Tabs Container */
      .browser-tabs-container {
        position: relative;
        display: flex;
        align-items: center;
        background: hsl(var(--titlebar-bg));
        border-bottom: 1px solid hsl(var(--window-border));
        padding: 4px 8px 0 8px;
        gap: 2px;
        transition: background-color 0.3s ease;
      }
      
      /* Browser Toolbar */
      .browser-toolbar {
        position: relative;
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 12px;
        background: hsl(var(--titlebar-bg));
        border-bottom: 1px solid hsl(var(--window-border));
        transition: background-color 0.3s ease;
        z-index: 101;
        pointer-events: auto;
      }

      .browser-nav-buttons {
        display: flex;
        gap: 4px;
        pointer-events: auto;
        position: relative;
        z-index: 10;
      }

      .browser-nav-button {
        width: 32px;
        height: 32px;
        border: none;
        border-radius: 6px;
        background: hsl(var(--accent));
        color: hsl(var(--foreground));
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background 0.15s ease, transform 0.15s ease;
        pointer-events: auto;
        position: relative;
        z-index: 10;
      }

      .browser-nav-button:hover {
        background: hsl(var(--accent-hover));
        transform: scale(1.05);
      }
      
      .browser-nav-button:active {
        transform: scale(0.95);
      }

      .browser-nav-button svg {
        width: 18px;
        height: 18px;
        pointer-events: none;
      }

      .browser-address-bar {
        flex: 1;
        display: flex;
        align-items: center;
        background: hsl(var(--background));
        border-radius: 8px;
        padding: 0 12px;
        height: 32px;
        transition: background-color 0.3s ease;
      }

      .browser-address-bar svg {
        width: 16px;
        height: 16px;
        margin-right: 8px;
        color: hsl(var(--muted-foreground));
        flex-shrink: 0;
        pointer-events: none;
      }

      .browser-address-input {
        flex: 1;
        border: none;
        background: transparent;
        outline: none;
        font-size: 13px;
        color: hsl(var(--foreground));
        min-width: 0;
      }
      
      .browser-address-input::placeholder {
        color: hsl(var(--muted-foreground));
      }
      
      /* Browser Bookmarks Bar */
      .browser-bookmarks-bar {
        position: relative;
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 6px 12px;
        background: hsl(var(--titlebar-bg) / 0.5);
        border-bottom: 1px solid hsl(var(--window-border));
        overflow-x: auto;
        font-size: 12px;
        scrollbar-width: none;
      }
      
      .browser-bookmarks-bar::-webkit-scrollbar {
        display: none;
      }

      /* Browser content area - contains iframe */
      .browser-content-wrapper {
        position: relative;
        z-index: 1;
        flex: 1;
        min-height: 0;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      /* Browser iframe */
      .browser-iframe {
        position: relative;
        flex: 1;
        width: 100%;
        height: 100%;
        border: none;
        background: #fff;
        /* Ensure the iframe never overlays the browser chrome */
        z-index: 1;
      }
      
      /* Iframe click blocker overlay - prevents iframe from stealing clicks */
      .browser-iframe-blocker {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 50;
        background: transparent;
        display: none;
        cursor: default;
      }
      
      /* Show blocker when browser UI is being interacted with */
      .browser-container.ui-active .browser-iframe-blocker {
        display: block;
      }

      .browser-tab {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 12px;
        background: hsl(var(--accent) / 0.5);
        border-radius: 8px 8px 0 0;
        cursor: pointer;
        min-width: 120px;
        max-width: 200px;
        transition: all 0.15s cubic-bezier(0.16, 1, 0.3, 1);
        font-size: 13px;
        color: hsl(var(--muted-foreground));
        border: 1px solid transparent;
        border-bottom: none;
        position: relative;
      }

      .browser-tab:hover {
        background: hsl(var(--accent) / 0.8);
      }

      .browser-tab.active {
        background: hsl(var(--window-bg));
        color: hsl(var(--foreground));
        border-color: hsl(var(--window-border));
        border-bottom: none;
      }

      .browser-tab-loading {
        width: 14px;
        height: 14px;
        border: 2px solid hsl(var(--muted-foreground) / 0.3);
        border-top-color: hsl(var(--primary));
        border-radius: 50%;
        animation: tab-spin 0.8s linear infinite;
        flex-shrink: 0;
      }

      @keyframes tab-spin {
        to { transform: rotate(360deg); }
      }

      .browser-tab-favicon {
        width: 14px;
        height: 14px;
        flex-shrink: 0;
        object-fit: contain;
      }

      .browser-tab-title {
        flex: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .browser-tab-close {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0.6;
        transition: all 0.15s;
      }

      .browser-tab-close:hover {
        opacity: 1;
        background: hsl(var(--destructive) / 0.2);
        color: hsl(var(--destructive));
      }

      /* Per-tab iframe container */
      .browser-tab-iframes {
        position: relative;
        flex: 1;
        min-height: 0;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .browser-tab-iframe-wrapper {
        position: absolute;
        inset: 0;
        display: none;
      }

      .browser-tab-iframe-wrapper.active {
        display: flex;
        position: relative;
        flex: 1;
      }

      .browser-tab-iframe-wrapper iframe {
        flex: 1;
        width: 100%;
        height: 100%;
        border: none;
        background: #fff;
      }

      .browser-new-tab-btn {
        width: 32px;
        height: 32px;
        border-radius: 6px;
        border: none;
        background: hsl(var(--accent));
        color: hsl(var(--foreground));
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.15s cubic-bezier(0.16, 1, 0.3, 1);
      }

      .browser-new-tab-btn:hover {
        background: hsl(var(--accent) / 1.2);
        transform: scale3d(1.05, 1.05, 1);
      }

      /* Browser Bookmarks Bar - duplicate removed, using definition in browser header section */

      .browser-bookmark {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 4px 10px;
        background: hsl(var(--accent));
        border-radius: 6px;
        cursor: pointer;
        white-space: nowrap;
        transition: all 0.15s cubic-bezier(0.16, 1, 0.3, 1);
        color: hsl(var(--foreground));
      }

      .browser-bookmark:hover {
        background: hsl(var(--accent) / 1.2);
        transform: scale3d(1.02, 1.02, 1);
      }

      /* Vertical Tabs Mode */
      .browser-container.vertical-tabs {
        flex-direction: row;
      }
      
      .browser-container.vertical-tabs .browser-header {
        flex-direction: row;
      }
      
      .browser-container.vertical-tabs .browser-sidebar {
        width: 220px;
        display: flex;
        flex-direction: column;
        border-right: 1px solid hsl(var(--window-border));
        background: hsl(var(--titlebar-bg));
      }
      
      .browser-container.vertical-tabs .browser-tabs-container {
        flex-direction: column;
        overflow-y: auto;
        overflow-x: hidden;
        flex: 1;
        padding: 8px;
        gap: 4px;
      }
      
      .browser-container.vertical-tabs .browser-tab {
        min-width: unset;
        max-width: unset;
        width: 100%;
        border-radius: 8px;
        border: 1px solid transparent;
      }
      
      .browser-container.vertical-tabs .browser-tab.active {
        background: hsl(var(--primary) / 0.15);
        border-color: hsl(var(--primary) / 0.3);
      }
      
      .browser-container.vertical-tabs .browser-new-tab-btn {
        width: 100%;
        margin-top: 4px;
      }
      
      .browser-container.vertical-tabs .browser-main {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-width: 0;
      }
      
      .browser-container.vertical-tabs .browser-toolbar-wrapper {
        display: flex;
        flex-direction: column;
      }
      
      /* History Panel */
      .browser-history-panel {
        position: absolute;
        top: 0;
        right: 0;
        width: 320px;
        height: 100%;
        background: hsl(var(--window-bg));
        border-left: 1px solid hsl(var(--window-border));
        z-index: 100;
        display: flex;
        flex-direction: column;
        box-shadow: -4px 0 20px rgba(0, 0, 0, 0.1);
      }
      
      .browser-history-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 16px;
        border-bottom: 1px solid hsl(var(--window-border));
        background: hsl(var(--titlebar-bg));
      }
      
      .browser-history-header h3 {
        font-size: 14px;
        font-weight: 600;
        color: hsl(var(--foreground));
        margin: 0;
      }
      
      .browser-history-list {
        flex: 1;
        overflow-y: auto;
        padding: 8px;
      }
      
      .browser-history-item {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px 12px;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.15s;
        color: hsl(var(--foreground));
      }
      
      .browser-history-item:hover {
        background: hsl(var(--accent));
      }
      
      .browser-history-item-icon {
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: hsl(var(--muted-foreground));
      }
      
      .browser-history-item-text {
        flex: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        font-size: 13px;
      }
      
      .browser-history-item-time {
        font-size: 11px;
        color: hsl(var(--muted-foreground));
      }
      
      .browser-history-empty {
        text-align: center;
        padding: 40px 20px;
        color: hsl(var(--muted-foreground));
        font-size: 13px;
      }

      /* Browser Home Page */
      .browser-home {
        flex: 1;
        padding: 40px;
        overflow-y: auto;
        background: hsl(var(--background));
        transition: background-color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        scrollbar-width: thin;
        scrollbar-color: rgba(128, 128, 128, 0.5) transparent;
      }

      .browser-home::-webkit-scrollbar {
        width: 12px;
      }

      .browser-home::-webkit-scrollbar-track {
        background: transparent;
      }

      .browser-home::-webkit-scrollbar-thumb {
        background: rgba(128, 128, 128, 0.5);
        border-radius: 10px;
        border: 3px solid transparent;
        background-clip: padding-box;
      }

      .browser-home::-webkit-scrollbar-thumb:hover {
        background: rgba(128, 128, 128, 0.7);
        background-clip: padding-box;
      }

      .browser-home-title {
        font-size: 24px;
        font-weight: 600;
        margin-bottom: 30px;
        color: hsl(var(--foreground));
        transition: color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      /* M Search Engine Styles */
      .m-search-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 60px 20px 40px;
        max-width: 680px;
        margin: 0 auto;
      }

      .m-search-logo {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 40px;
      }

      .m-search-logo-circle {
        width: 64px;
        height: 64px;
        border-radius: 16px;
        background: linear-gradient(135deg, hsl(var(--primary)), hsl(200 80% 50%));
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 8px 32px hsl(var(--primary) / 0.3);
      }

      .m-search-logo-letter {
        font-size: 36px;
        font-weight: 700;
        color: white;
      }

      .m-search-logo-text {
        font-size: 42px;
        font-weight: 300;
        color: hsl(var(--foreground));
        letter-spacing: -1px;
      }

      .m-search-form {
        width: 100%;
        position: relative;
        margin-bottom: 24px;
      }

      .m-search-input-wrapper {
        position: relative;
        width: 100%;
      }

      .m-search-input {
        width: 100%;
        padding: 18px 60px 18px 24px;
        font-size: 17px;
        border: 2px solid hsl(var(--border));
        border-radius: 28px;
        background: hsl(var(--background));
        color: hsl(var(--foreground));
        outline: none;
        transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
      }

      .m-search-input:focus {
        border-color: hsl(var(--primary));
        box-shadow: 0 8px 40px hsl(var(--primary) / 0.15), 0 0 0 4px hsl(var(--primary) / 0.1);
      }

      .m-search-input::placeholder {
        color: hsl(var(--muted-foreground));
      }

      .m-search-btn {
        position: absolute;
        right: 8px;
        top: 50%;
        transform: translateY(-50%);
        width: 44px;
        height: 44px;
        border-radius: 50%;
        background: linear-gradient(135deg, hsl(var(--primary)), hsl(200 80% 50%));
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
        box-shadow: 0 4px 12px hsl(var(--primary) / 0.3);
      }

      .m-search-btn:hover {
        transform: translateY(-50%) scale(1.08);
        box-shadow: 0 6px 20px hsl(var(--primary) / 0.4);
      }

      .m-search-btn:active {
        transform: translateY(-50%) scale(0.95);
      }

      .m-search-btn svg {
        width: 20px;
        height: 20px;
        color: white;
      }

      .m-search-suggestions {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        justify-content: center;
        margin-bottom: 40px;
      }

      .m-search-suggestion {
        padding: 8px 16px;
        background: hsl(var(--accent));
        border: 1px solid hsl(var(--border));
        border-radius: 20px;
        font-size: 13px;
        color: hsl(var(--foreground));
        cursor: pointer;
        transition: all 0.2s;
      }

      .m-search-suggestion:hover {
        background: hsl(var(--primary) / 0.1);
        border-color: hsl(var(--primary) / 0.3);
        transform: translateY(-2px);
      }

      .m-search-divider {
        width: 100%;
        height: 1px;
        background: hsl(var(--border));
        margin: 20px 0;
      }

      .m-search-section-title {
        font-size: 14px;
        font-weight: 600;
        color: hsl(var(--muted-foreground));
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 20px;
        text-align: center;
      }

      /* Search Results Page */
      .m-search-results {
        flex: 1;
        padding: 20px;
        overflow-y: auto;
        background: hsl(var(--background));
      }

      .m-search-results-header {
        display: flex;
        align-items: center;
        gap: 16px;
        padding: 16px 20px;
        border-bottom: 1px solid hsl(var(--border));
        background: hsl(var(--background));
      }

      .m-search-results-logo {
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
      }

      .m-search-results-logo-circle {
        width: 32px;
        height: 32px;
        border-radius: 8px;
        background: linear-gradient(135deg, hsl(var(--primary)), hsl(200 80% 50%));
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .m-search-results-logo-letter {
        font-size: 18px;
        font-weight: 700;
        color: white;
      }

      .m-search-results-input {
        flex: 1;
        max-width: 600px;
        padding: 12px 20px;
        font-size: 15px;
        border: 1px solid hsl(var(--border));
        border-radius: 24px;
        background: hsl(var(--accent) / 0.3);
        color: hsl(var(--foreground));
        outline: none;
        transition: all 0.2s;
      }

      .m-search-results-input:focus {
        border-color: hsl(var(--primary));
        background: hsl(var(--background));
      }

      .m-search-results-list {
        max-width: 700px;
        padding: 20px 0;
      }

      .m-search-result-item {
        padding: 16px 0;
        border-bottom: 1px solid hsl(var(--border) / 0.5);
      }

      .m-search-result-url {
        font-size: 12px;
        color: hsl(var(--muted-foreground));
        margin-bottom: 4px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .m-search-result-url img {
        width: 16px;
        height: 16px;
        border-radius: 2px;
      }

      .m-search-result-title {
        font-size: 18px;
        color: hsl(175 80% 45%);
        margin-bottom: 6px;
        cursor: pointer;
        text-decoration: none;
        display: block;
      }

      .m-search-result-title:hover {
        text-decoration: underline;
      }

      .m-search-result-snippet {
        font-size: 14px;
        color: hsl(var(--foreground) / 0.8);
        line-height: 1.5;
      }

      .m-search-loading {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 60px 20px;
        gap: 16px;
      }

      .m-search-loading-spinner {
        width: 40px;
        height: 40px;
        border: 3px solid hsl(var(--border));
        border-top-color: hsl(var(--primary));
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
      }

      @keyframes spin {
        to { transform: rotate(360deg); }
      }

      .m-search-loading-text {
        font-size: 14px;
        color: hsl(var(--muted-foreground));
      }

      .m-search-error {
        padding: 40px 20px;
        text-align: center;
        color: hsl(var(--muted-foreground));
      }

      .m-search-powered {
        font-size: 11px;
        color: hsl(var(--muted-foreground));
        text-align: center;
        margin-top: 8px;
      }

      .browser-sites-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
        gap: 24px;
        max-width: 900px;
      }

      .browser-site-card {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
        padding: 20px;
        background: hsl(var(--card));
        border: 1px solid hsl(var(--border));
        border-radius: 12px;
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
      }

      .browser-site-card:hover {
        transform: translateY(-4px) scale3d(1.02, 1.02, 1);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
        border-color: hsl(var(--primary) / 0.5);
      }

      .browser-site-card.show-actions .browser-site-remove {
        display: flex;
      }

      .browser-site-icon {
        width: 56px;
        height: 56px;
        background: hsl(var(--primary) / 0.1);
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 32px;
        transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
      }

      .browser-site-card:hover .browser-site-icon {
        background: hsl(var(--primary) / 0.2);
        transform: scale3d(1.1, 1.1, 1);
      }

      .browser-site-add {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
        padding: 20px;
        background: hsl(var(--muted) / 0.3);
        border: 2px dashed hsl(var(--border));
        border-radius: 12px;
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
      }

      .browser-site-add:hover {
        background: hsl(var(--muted) / 0.5);
        border-color: hsl(var(--primary) / 0.5);
        transform: translateY(-2px);
      }

      .browser-site-add-icon {
        width: 56px;
        height: 56px;
        background: hsl(var(--primary) / 0.1);
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 32px;
        color: hsl(var(--primary));
      }

      .browser-site-title {
        font-size: 13px;
        color: hsl(var(--foreground));
        text-align: center;
        transition: color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        max-width: 100%;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .browser-site-remove {
        position: absolute;
        top: 8px;
        right: 8px;
        width: 24px;
        height: 24px;
        background: hsl(var(--destructive));
        border-radius: 50%;
        display: none;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        color: white;
        font-size: 14px;
        z-index: 10;
      }

      /* Add Site Dialog */
      .add-site-dialog-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        backdrop-filter: blur(4px);
      }

      .add-site-dialog {
        background: hsl(var(--background));
        border: 1px solid hsl(var(--border));
        border-radius: 12px;
        padding: 24px;
        width: 400px;
        max-width: 90vw;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      }

      .add-site-dialog h3 {
        font-size: 18px;
        font-weight: 600;
        margin: 0 0 20px 0;
        color: hsl(var(--foreground));
      }

      .add-site-form {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .add-site-input-group {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .add-site-label {
        font-size: 13px;
        font-weight: 500;
        color: hsl(var(--foreground));
      }

      .add-site-input {
        padding: 10px 12px;
        background: hsl(var(--input));
        border: 1px solid hsl(var(--border));
        border-radius: 8px;
        font-size: 14px;
        color: hsl(var(--foreground));
        outline: none;
        transition: all 0.2s;
      }

      .add-site-input:focus {
        border-color: hsl(var(--primary));
        box-shadow: 0 0 0 3px hsl(var(--primary) / 0.1);
      }

      .add-site-buttons {
        display: flex;
        gap: 12px;
        justify-content: flex-end;
        margin-top: 8px;
      }

      .add-site-button {
        padding: 10px 20px;
        border: none;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
      }

      .add-site-button-cancel {
        background: hsl(var(--secondary));
        color: hsl(var(--secondary-foreground));
      }

      .add-site-button-cancel:hover {
        background: hsl(var(--secondary) / 0.8);
      }

      .add-site-button-submit {
        background: hsl(var(--primary));
        color: white;
      }

      .add-site-button-submit:hover {
        background: hsl(var(--primary) / 0.9);
      }

      /* Edit/Delete Icons on Bookmarks */
      .browser-bookmark {
        position: relative;
      }

      .browser-bookmark-actions {
        position: absolute;
        top: 50%;
        right: 8px;
        transform: translateY(-50%);
        display: none;
        gap: 4px;
        align-items: center;
      }

      .browser-bookmark.show-actions .browser-bookmark-actions {
        display: flex;
      }

      .browser-bookmark-action {
        width: 20px;
        height: 20px;
        border-radius: 4px;
        background: hsl(var(--background));
        border: 1px solid hsl(var(--border));
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.15s;
      }

      .browser-bookmark-action:hover {
        background: hsl(var(--primary));
        border-color: hsl(var(--primary));
        color: white;
      }

      .browser-bookmark-action svg {
        width: 12px;
        height: 12px;
      }

      /* Edit icons on saved sites */
      .browser-site-edit {
        position: absolute;
        top: 8px;
        right: 36px;
        width: 24px;
        height: 24px;
        background: hsl(var(--primary));
        border-radius: 50%;
        display: none;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        color: white;
        font-size: 12px;
        z-index: 10;
      }

      .browser-site-card.show-actions .browser-site-edit {
        display: flex;
      }

      .youtube-container {
        display: flex;
        flex-direction: column;
        flex: 1;
        background: #0f0f0f;
        overflow: hidden;
      }

      .youtube-header {
        display: flex;
        align-items: center;
        gap: 20px;
        padding: 12px 24px;
        background: #0f0f0f;
        border-bottom: 1px solid #272727;
      }

      .youtube-logo {
        display: flex;
        align-items: center;
        gap: 8px;
        color: #ff0000;
        font-size: 18px;
        font-weight: bold;
      }

      .youtube-logo span {
        color: white;
      }

      .youtube-search {
        flex: 1;
        max-width: 600px;
        display: flex;
        gap: 0;
      }

      .youtube-search input {
        flex: 1;
        padding: 10px 16px;
        background: #121212;
        border: 1px solid #303030;
        border-right: none;
        border-radius: 20px 0 0 20px;
        color: white;
        font-size: 14px;
        outline: none;
      }

      .youtube-search input:focus {
        border-color: #1c62b9;
      }

      .youtube-search button {
        width: 64px;
        background: #222;
        border: 1px solid #303030;
        border-left: none;
        border-radius: 0 20px 20px 0;
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .youtube-search button:hover {
        background: #303030;
      }

      .youtube-search button svg {
        width: 20px;
        height: 20px;
      }

      .youtube-content {
        display: flex;
        height: calc(100% - 60px);
        overflow: hidden;
      }

      .youtube-sidebar {
        width: 200px;
        background: #0f0f0f;
        padding: 12px 8px;
        overflow-y: auto;
        border-right: 1px solid #272727;
        scrollbar-width: thin;
        scrollbar-color: rgba(128, 128, 128, 0.5) transparent;
      }

      .youtube-sidebar::-webkit-scrollbar {
        width: 8px;
      }

      .youtube-sidebar::-webkit-scrollbar-track {
        background: transparent;
      }

      .youtube-sidebar::-webkit-scrollbar-thumb {
        background: rgba(128, 128, 128, 0.5);
        border-radius: 10px;
        border: 2px solid transparent;
        background-clip: padding-box;
      }

      .youtube-sidebar::-webkit-scrollbar-thumb:hover {
        background: rgba(128, 128, 128, 0.7);
        background-clip: padding-box;
      }

      .youtube-nav-item {
        display: flex;
        align-items: center;
        gap: 16px;
        padding: 12px 16px;
        color: white;
        cursor: pointer;
        border-radius: 8px;
        transition: background 0.2s;
        font-size: 14px;
      }

      .youtube-nav-item:hover {
        background: #272727;
      }

      .youtube-nav-item.active {
        background: #272727;
      }

      .youtube-nav-item svg {
        width: 20px;
        height: 20px;
      }

      .youtube-videos {
        flex: 1;
        padding: 24px;
        overflow-y: auto;
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        gap: 24px;
        align-content: start;
        scrollbar-width: thin;
        scrollbar-color: rgba(128, 128, 128, 0.5) transparent;
      }

      .youtube-videos::-webkit-scrollbar {
        width: 12px;
      }

      .youtube-videos::-webkit-scrollbar-track {
        background: transparent;
      }

      .youtube-videos::-webkit-scrollbar-thumb {
        background: rgba(128, 128, 128, 0.5);
        border-radius: 10px;
        border: 3px solid transparent;
        background-clip: padding-box;
      }

      .youtube-videos::-webkit-scrollbar-thumb:hover {
        background: rgba(128, 128, 128, 0.7);
        background-clip: padding-box;
      }

      .youtube-video-card {
        cursor: pointer;
        transition: transform 0.2s;
      }

      .youtube-video-card:hover {
        transform: scale(1.02);
      }

      .youtube-thumbnail {
        position: relative;
        width: 100%;
        aspect-ratio: 16/9;
        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        border-radius: 12px;
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }

      .youtube-play-icon {
        font-size: 48px;
        color: white;
        opacity: 0.9;
      }

      .youtube-duration {
        position: absolute;
        bottom: 8px;
        right: 8px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: 600;
      }

      .youtube-video-info h3 {
        color: white;
        font-size: 14px;
        font-weight: 500;
        margin-bottom: 8px;
        line-height: 1.4;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }

      .youtube-channel {
        color: #aaa;
        font-size: 13px;
        margin-bottom: 4px;
      }

      .youtube-stats {
        color: #aaa;
        font-size: 12px;
      }

      /* Window Snap Indicator */
      .snap-indicator {
        position: fixed;
        pointer-events: none;
        background: hsl(var(--primary) / 0.2);
        border: 2px solid hsl(var(--primary) / 0.6);
        border-radius: 8px;
        z-index: 50;
        opacity: 0;
        transition: opacity 0.2s cubic-bezier(0.4, 0, 0.2, 1),
                    left 0.15s cubic-bezier(0.4, 0, 0.2, 1),
                    top 0.15s cubic-bezier(0.4, 0, 0.2, 1),
                    width 0.15s cubic-bezier(0.4, 0, 0.2, 1),
                    height 0.15s cubic-bezier(0.4, 0, 0.2, 1),
                    border-radius 0.15s cubic-bezier(0.4, 0, 0.2, 1);
        will-change: opacity, left, top, width, height;
      }

      .snap-indicator.active {
        opacity: 1;
      }
      
      .snap-indicator.dragging {
        transition: opacity 0.2s cubic-bezier(0.4, 0, 0.2, 1),
                    left 0.08s cubic-bezier(0.4, 0, 0.2, 1),
                    top 0.08s cubic-bezier(0.4, 0, 0.2, 1),
                    width 0.08s cubic-bezier(0.4, 0, 0.2, 1),
                    height 0.08s cubic-bezier(0.4, 0, 0.2, 1),
                    border-radius 0.08s cubic-bezier(0.4, 0, 0.2, 1);
      }
      
      /* Window snap animation */
      .window.snapping {
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
      }
      
      /* Ensure snap/maximize animations still run even when global animations are disabled */
      body.no-animations .window.snapping,
      body.no-animations .window.maximizing,
      body.no-animations .window.restoring {
        transition-duration: 0.3s !important;
        transition-delay: 0s !important;
        animation-duration: 0.3s !important;
        animation-delay: 0s !important;
      }
      
      /* Disable transitions during drag */
      .window.dragging {
        transition: none !important;
      }
      
      /* Borderless fullscreen styles */
      .window.fullscreen {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        border-radius: 0 !important;
        z-index: 99999 !important;
        box-shadow: none !important;
      }
      
      .window.fullscreen .window-content {
        height: 100% !important;
        border-radius: 0 !important;
      }
      
      /* Fullscreen overlay UI - shows on hover */
      .fullscreen-overlay-ui {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        z-index: 100000;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      
      .window.fullscreen .fullscreen-overlay-ui.visible {
        opacity: 1;
      }
      
      /* Invisible hover zone at top to trigger UI */
      .fullscreen-hover-zone {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 60px;
        z-index: 99999;
        pointer-events: auto;
      }
      
      .fullscreen-exit-btn {
        position: absolute;
        top: 12px;
        right: 12px;
        display: flex;
        align-items: center;
        gap: 8px;
        background: rgba(0, 0, 0, 0.75);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 10px;
        padding: 10px 16px;
        color: white;
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
        pointer-events: auto;
        user-select: none;
        transition: all 0.2s ease;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
      }
      
      .fullscreen-exit-btn:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: scale(1.05);
      }
      
      .fullscreen-exit-btn:active {
        transform: scale(0.98);
      }
      
      .fullscreen-hint {
        position: absolute;
        top: 12px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border-radius: 8px;
        padding: 8px 16px;
        color: rgba(255, 255, 255, 0.7);
        font-size: 12px;
        white-space: nowrap;
        pointer-events: none;
      }
      
      /* Hide menubar and dock when any window is fullscreen */
      body:has(.window.fullscreen) .menubar,
      body:has(.window.fullscreen) .dock-container {
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease;
      }
      
      /* Custom Cursor Styles - Dynamically injected from localStorage */
      /* The actual cursor URLs will be injected via JavaScript using base64 data */
      
      /* ============= BOOT SCREEN STYLES ============= */
      .boot-screen {
        position: fixed;
        inset: 0;
        background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0f0f1a 100%);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 999999;
        opacity: 1;
        transition: opacity 0.8s ease-out;
      }
      
      .boot-screen.fade-out {
        opacity: 0;
        pointer-events: none;
      }
      
      .boot-logo {
        width: 120px;
        height: 120px;
        background: linear-gradient(135deg, #00d4aa 0%, #00a8cc 100%);
        border-radius: 28px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 64px;
        font-weight: 700;
        color: white;
        font-family: 'Space Grotesk', sans-serif;
        box-shadow: 0 20px 60px rgba(0, 212, 170, 0.3);
        animation: bootLogoPulse 2s ease-in-out infinite;
      }
      
      @keyframes bootLogoPulse {
        0%, 100% { transform: scale(1); box-shadow: 0 20px 60px rgba(0, 212, 170, 0.3); }
        50% { transform: scale(1.05); box-shadow: 0 25px 80px rgba(0, 212, 170, 0.5); }
      }
      
      .boot-title {
        margin-top: 24px;
        font-size: 32px;
        font-weight: 600;
        color: white;
        font-family: 'Space Grotesk', sans-serif;
        letter-spacing: 0.05em;
      }
      
      .boot-loader {
        margin-top: 48px;
        width: 200px;
        height: 4px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 2px;
        overflow: hidden;
      }
      
      .boot-loader-bar {
        width: 0%;
        height: 100%;
        background: linear-gradient(90deg, #00d4aa 0%, #00a8cc 100%);
        border-radius: 2px;
        transition: width 0.3s ease;
      }
      
      .boot-status {
        margin-top: 16px;
        font-size: 13px;
        color: rgba(255, 255, 255, 0.5);
        font-family: 'JetBrains Mono', monospace;
      }
      
      /* ============= FIRST-BOOT SETUP STYLES ============= */
      .setup-screen {
        position: fixed;
        inset: 0;
        background: hsl(var(--background));
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 999998;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.5s ease;
      }
      
      .setup-screen.active {
        opacity: 1;
        pointer-events: auto;
      }
      
      .setup-container {
        width: 100%;
        max-width: 440px;
        padding: 40px;
        background: hsl(var(--window-bg));
        border: 1px solid hsl(var(--window-border));
        border-radius: 28px;
        box-shadow: 0 20px 60px hsl(var(--shadow-color) / 0.3);
      }
      
      .setup-header {
        text-align: center;
        margin-bottom: 32px;
      }
      
      .setup-logo {
        width: 80px;
        height: 80px;
        background: hsl(var(--foreground));
        border-radius: 22px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 42px;
        font-weight: 700;
        color: hsl(var(--background));
        margin-bottom: 16px;
        box-shadow: 0 8px 24px hsl(var(--shadow-color) / 0.3);
      }
      
      .setup-title {
        font-size: 28px;
        font-weight: 600;
        color: hsl(var(--foreground));
        margin-bottom: 8px;
      }
      
      .setup-subtitle {
        font-size: 14px;
        color: hsl(var(--muted-foreground));
      }
      
      .setup-step {
        display: none;
      }
      
      .setup-step.active {
        display: block;
        animation: setupFadeIn 0.3s ease;
      }
      
      @keyframes setupFadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
      }
      
      .setup-field {
        margin-bottom: 20px;
      }
      
      .setup-label {
        display: block;
        font-size: 13px;
        font-weight: 500;
        color: hsl(var(--foreground) / 0.8);
        margin-bottom: 8px;
      }
      
      .setup-input {
        width: 100%;
        padding: 14px 16px;
        background: hsl(var(--accent) / 0.5);
        border: 1px solid hsl(var(--window-border));
        border-radius: 14px;
        font-size: 15px;
        color: hsl(var(--foreground));
        outline: none;
        transition: all 0.2s;
        font-family: 'Space Grotesk', sans-serif;
      }
      
      .setup-input:focus {
        border-color: hsl(var(--primary));
        background: hsl(var(--primary) / 0.05);
        box-shadow: 0 0 0 3px hsl(var(--primary) / 0.15);
      }
      
      .setup-input::placeholder {
        color: hsl(var(--muted-foreground) / 0.5);
      }
      
      .setup-hint {
        font-size: 12px;
        color: hsl(var(--muted-foreground));
        margin-top: 6px;
      }
      
      .setup-options {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
        margin-bottom: 20px;
      }
      
      .setup-option {
        padding: 16px;
        background: hsl(var(--accent) / 0.5);
        border: 2px solid hsl(var(--window-border));
        border-radius: 16px;
        cursor: pointer;
        transition: all 0.2s;
        text-align: center;
      }
      
      .setup-option:hover {
        background: hsl(var(--accent));
        border-color: hsl(var(--foreground) / 0.3);
      }
      
      .setup-option.selected {
        background: hsl(var(--primary) / 0.15);
        border-color: hsl(var(--primary));
      }
      
      .setup-option-icon {
        font-size: 32px;
        margin-bottom: 8px;
      }
      
      .setup-option-label {
        font-size: 13px;
        font-weight: 500;
        color: hsl(var(--foreground));
      }
      
      .setup-cursor-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
        margin-bottom: 20px;
      }
      
      .setup-cursor-option {
        aspect-ratio: 1.5;
        background: hsl(var(--accent) / 0.5);
        border: 2px solid hsl(var(--window-border));
        border-radius: 16px;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 8px;
        padding: 12px;
      }
      
      .setup-cursor-option:hover {
        background: hsl(var(--accent));
        border-color: hsl(var(--foreground) / 0.3);
      }
      
      .setup-cursor-option.selected {
        background: hsl(var(--primary) / 0.15);
        border-color: hsl(var(--primary));
      }
      
      .setup-cursor-preview {
        font-size: 28px;
      }
      
      .setup-cursor-name {
        font-size: 11px;
        color: hsl(var(--muted-foreground));
        text-align: center;
      }
      
      .setup-buttons {
        display: flex;
        gap: 12px;
        margin-top: 24px;
      }
      
      .setup-btn {
        flex: 1;
        padding: 14px 24px;
        border: none;
        border-radius: 14px;
        font-size: 15px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
        font-family: 'Space Grotesk', sans-serif;
      }
      
      .setup-btn-secondary {
        background: hsl(var(--accent));
        color: hsl(var(--foreground));
      }
      
      .setup-btn-secondary:hover {
        background: hsl(var(--accent-hover));
      }
      
      .setup-btn-primary {
        background: hsl(var(--foreground));
        color: hsl(var(--background));
      }
      
      .setup-btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 24px hsl(var(--shadow-color) / 0.4);
      }
      
      .setup-btn-primary:active {
        transform: translateY(0);
      }
      
      .setup-progress {
        display: flex;
        justify-content: center;
        gap: 8px;
        margin-top: 24px;
      }
      
      .setup-progress-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: hsl(var(--foreground) / 0.2);
        transition: all 0.2s;
      }
      
      .setup-progress-dot.active {
        background: hsl(var(--primary));
        width: 24px;
        border-radius: 4px;
      }
      
      .setup-progress-dot.completed {
        background: hsl(var(--primary) / 0.5);
      }
      
      /* ============= LOCKSCREEN STYLES ============= */
      .lockscreen {
        position: fixed;
        inset: 0;
        background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0f0f1a 100%);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 999997;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }
      
      .lockscreen.active {
        opacity: 1;
        pointer-events: auto;
      }
      
      /* Screensaver mode - just clock and wallpaper */
      .lockscreen.screensaver .lockscreen-content {
        transform: translateY(-20%);
      }
      
      .lockscreen.screensaver .lockscreen-avatar,
      .lockscreen.screensaver .lockscreen-username,
      .lockscreen.screensaver .lockscreen-password-container,
      .lockscreen.screensaver .lockscreen-unlock-btn,
      .lockscreen.screensaver .lockscreen-error,
      .lockscreen.screensaver .lockscreen-hint {
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }
      
      .lockscreen.screensaver .lockscreen-time {
        font-size: 120px;
      }
      
      .lockscreen-bg {
        position: absolute;
        inset: 0;
        background-size: cover;
        background-position: center;
        filter: blur(30px) brightness(0.4);
        transform: scale(1.1);
      }
      
      .lockscreen-content {
        position: relative;
        z-index: 1;
        text-align: center;
      }
      
      .lockscreen-time {
        font-size: 96px;
        font-weight: 200;
        color: white;
        font-family: 'Space Grotesk', sans-serif;
        letter-spacing: -2px;
        line-height: 1;
        text-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      }
      
      .lockscreen-date {
        font-size: 24px;
        color: rgba(255, 255, 255, 0.7);
        margin-top: 8px;
        font-weight: 300;
      }
      
      .lockscreen-avatar {
        width: 96px;
        height: 96px;
        background: linear-gradient(135deg, #00d4aa 0%, #00a8cc 100%);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 42px;
        font-weight: 600;
        color: white;
        margin: 48px auto 16px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      }
      
      .lockscreen-username {
        font-size: 22px;
        font-weight: 500;
        color: white;
        margin-bottom: 24px;
      }
      
      .lockscreen-password-container {
        position: relative;
        width: 280px;
        margin: 0 auto;
      }
      
      .lockscreen-password {
        width: 100%;
        padding: 16px 48px 16px 20px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 28px;
        font-size: 16px;
        color: white;
        outline: none;
        transition: all 0.2s;
        font-family: 'Space Grotesk', sans-serif;
        text-align: center;
      }
      
      .lockscreen-password:focus {
        border-color: #00d4aa;
        background: rgba(0, 212, 170, 0.1);
        box-shadow: 0 0 0 3px rgba(0, 212, 170, 0.2);
      }
      
      .lockscreen-password::placeholder {
        color: rgba(255, 255, 255, 0.4);
      }
      
      .lockscreen-submit {
        position: absolute;
        right: 6px;
        top: 50%;
        transform: translateY(-50%);
        width: 36px;
        height: 36px;
        background: linear-gradient(135deg, #00d4aa 0%, #00a8cc 100%);
        border: none;
        border-radius: 50%;
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
      }
      
      .lockscreen-submit:hover {
        transform: translateY(-50%) scale(1.1);
      }
      
      .lockscreen-submit svg {
        width: 18px;
        height: 18px;
      }
      
      .lockscreen-error {
        margin-top: 16px;
        font-size: 14px;
        color: #ff6b6b;
        opacity: 0;
        transition: opacity 0.3s;
      }
      
      .lockscreen-error.visible {
        opacity: 1;
        animation: lockscreenShake 0.4s ease;
      }
      
      @keyframes lockscreenShake {
        0%, 100% { transform: translateX(0); }
        25% { transform: translateX(-8px); }
        50% { transform: translateX(8px); }
        75% { transform: translateX(-4px); }
      }
      
      .lockscreen-hint {
        position: absolute;
        bottom: 48px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 13px;
        color: rgba(255, 255, 255, 0.4);
      }
      
      /* No password lockscreen */
      .lockscreen-unlock-btn {
        margin-top: 24px;
        padding: 14px 32px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 28px;
        color: white;
        font-size: 15px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        font-family: 'Space Grotesk', sans-serif;
      }
      
      .lockscreen-unlock-btn:hover {
        background: rgba(255, 255, 255, 0.15);
        transform: translateY(-2px);
      }
      
      /* ============= UPDATE NOTIFICATION STYLES ============= */
      .update-toast {
        position: fixed;
        bottom: 24px;
        right: 24px;
        background: hsl(var(--window-bg) / 0.95);
        backdrop-filter: blur(20px);
        border: 1px solid hsl(var(--window-border));
        border-radius: 16px;
        padding: 16px 20px;
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.3);
        z-index: 999990;
        display: flex;
        align-items: center;
        gap: 16px;
        max-width: 360px;
        opacity: 0;
        transform: translateY(20px);
        pointer-events: none;
        transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      }
      
      .update-toast.visible {
        opacity: 1;
        transform: translateY(0);
        pointer-events: auto;
      }
      
      .update-toast-icon {
        width: 40px;
        height: 40px;
        background: linear-gradient(135deg, #00d4aa 0%, #00a8cc 100%);
        border-radius: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
      }
      
      .update-toast-icon svg {
        width: 22px;
        height: 22px;
        color: white;
      }
      
      .update-toast-content {
        flex: 1;
      }
      
      .update-toast-title {
        font-size: 14px;
        font-weight: 600;
        color: hsl(var(--foreground));
        margin-bottom: 4px;
      }
      
      .update-toast-message {
        font-size: 12px;
        color: hsl(var(--muted-foreground));
      }
      
      .update-toast-actions {
        display: flex;
        gap: 8px;
      }
      
      .update-toast-btn {
        padding: 8px 16px;
        border: none;
        border-radius: 8px;
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
      }
      
      .update-toast-btn-dismiss {
        background: hsl(var(--accent));
        color: hsl(var(--foreground));
      }
      
      .update-toast-btn-dismiss:hover {
        background: hsl(var(--accent-hover));
      }
      
      .update-toast-btn-update {
        background: linear-gradient(135deg, #00d4aa 0%, #00a8cc 100%);
        color: white;
      }
      
      .update-toast-btn-update:hover {
        transform: scale(1.05);
        box-shadow: 0 4px 12px rgba(0, 212, 170, 0.3);
      }
    </style>
  </head>
  <body>
    <!-- Boot Screen -->
    <div id="boot-screen" class="boot-screen">
      <div class="boot-logo">M</div>
      <div class="boot-title">M OS</div>
      <div class="boot-loader">
        <div class="boot-loader-bar" id="boot-loader-bar"></div>
      </div>
      <div class="boot-status" id="boot-status">Initializing...</div>
    </div>
    
    <!-- First-Boot Setup Screen -->
    <div id="setup-screen" class="setup-screen">
      <div class="setup-container">
        <div class="setup-header">
          <div class="setup-logo">M</div>
          <h1 class="setup-title">Welcome to M OS</h1>
          <p class="setup-subtitle">Let's set up your new desktop</p>
        </div>
        
        <!-- Step 1: Username -->
        <div class="setup-step active" data-step="1">
          <div class="setup-field">
            <label class="setup-label">What's your name?</label>
            <input type="text" class="setup-input" id="setup-username" placeholder="Enter your name" autocomplete="off" maxlength="32">
            <p class="setup-hint">This will be displayed on the lockscreen</p>
          </div>
        </div>
        
        <!-- Step 2: Password (optional) -->
        <div class="setup-step" data-step="2">
          <div class="setup-field">
            <label class="setup-label">Set a password (optional)</label>
            <input type="password" class="setup-input" id="setup-password" placeholder="Enter password" autocomplete="new-password">
            <p class="setup-hint">Leave empty to skip password protection</p>
          </div>
          <div class="setup-field">
            <label class="setup-label">Confirm password</label>
            <input type="password" class="setup-input" id="setup-password-confirm" placeholder="Confirm password" autocomplete="new-password">
          </div>
        </div>
        
        <!-- Step 3: Theme -->
        <div class="setup-step" data-step="3">
          <label class="setup-label">Choose your theme</label>
          <div class="setup-options">
            <div class="setup-option" data-theme="light" onclick="selectSetupTheme('light')">
              <div class="setup-option-icon"></div>
              <div class="setup-option-label">Light</div>
            </div>
            <div class="setup-option selected" data-theme="dark" onclick="selectSetupTheme('dark')">
              <div class="setup-option-icon"></div>
              <div class="setup-option-label">Dark</div>
            </div>
          </div>
        </div>
        
        <!-- Step 4: Cursor -->
        <div class="setup-step" data-step="4">
          <label class="setup-label">Choose your cursor style</label>
          <div class="setup-cursor-grid">
            <div class="setup-cursor-option selected" data-cursor="default" onclick="selectSetupCursor('default')">
              <div class="setup-cursor-preview"></div>
              <div class="setup-cursor-name">Default</div>
            </div>
            <div class="setup-cursor-option" data-cursor="custom" onclick="selectSetupCursor('custom')">
              <div class="setup-cursor-preview"></div>
              <div class="setup-cursor-name">M OS Custom</div>
            </div>
          </div>
          <p class="setup-hint">You can change this later in Settings</p>
        </div>
        
        <div class="setup-buttons">
          <button class="setup-btn setup-btn-secondary" id="setup-back-btn" onclick="setupPrevStep()" style="display: none;">Back</button>
          <button class="setup-btn setup-btn-primary" id="setup-next-btn" onclick="setupNextStep()">Continue</button>
        </div>
        
        <div class="setup-progress">
          <div class="setup-progress-dot active" data-dot="1"></div>
          <div class="setup-progress-dot" data-dot="2"></div>
          <div class="setup-progress-dot" data-dot="3"></div>
          <div class="setup-progress-dot" data-dot="4"></div>
        </div>
      </div>
    </div>
    
    <!-- Lockscreen -->
    <div id="lockscreen" class="lockscreen">
      <div class="lockscreen-bg" id="lockscreen-bg"></div>
      <div class="lockscreen-content">
        <div class="lockscreen-time" id="lockscreen-time">00:00</div>
        <div class="lockscreen-date" id="lockscreen-date">Monday, January 1</div>
        <div class="lockscreen-avatar" id="lockscreen-avatar">U</div>
        <div class="lockscreen-username" id="lockscreen-username">User</div>
        <div class="lockscreen-password-container" id="lockscreen-password-container">
          <input type="password" class="lockscreen-password" id="lockscreen-password" placeholder="Enter password">
          <button class="lockscreen-submit" onclick="unlockScreen()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polyline points="9 18 15 12 9 6"></polyline>
            </svg>
          </button>
        </div>
        <button class="lockscreen-unlock-btn" id="lockscreen-unlock-btn" onclick="unlockScreen()" style="display: none;">
          Click to unlock
        </button>
        <div class="lockscreen-error" id="lockscreen-error">Incorrect password</div>
      </div>
      <div class="lockscreen-hint">Press Enter to unlock</div>
    </div>
    
    <!-- Update Toast -->
    <div id="update-toast" class="update-toast">
      <div class="update-toast-icon">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
          <polyline points="7 10 12 15 17 10"/>
          <line x1="12" y1="15" x2="12" y2="3"/>
        </svg>
      </div>
      <div class="update-toast-content">
        <div class="update-toast-title">Update Available</div>
        <div class="update-toast-message" id="update-toast-message">A new version is available</div>
      </div>
      <div class="update-toast-actions">
        <button class="update-toast-btn update-toast-btn-dismiss" onclick="dismissUpdate()">Later</button>
        <button class="update-toast-btn update-toast-btn-update" onclick="applyUpdate()">Update</button>
      </div>
    </div>
    
    <div id="root"></div>

    <script>
      console.log('Script starting...');
      const state = {
        windows: [],
        nextId: 1,
        nextZIndex: 100,
        isDark: false,
        dragging: null,
        resizing: null,
        pinnedApps: [],
        contextMenu: null,
        menubarContextMenu: null, // Context menu right-click menu {x, y}
        contextMenuCustomizeMode: false, // Track if context menu customization mode is active
        contextMenuLayout: JSON.parse(localStorage.getItem('contextMenuLayout') || 'null') || {
          // Default layout - each element has id, position (left/center/right), order
          // Enhanced with more panel applets like Linux Mint/KDE
          elements: [
            { id: 'logo', position: 'left', order: 0, visible: true },
            { id: 'menus', position: 'left', order: 1, visible: true },
            { id: 'separator1', position: 'center', order: 0, visible: false },
            { id: 'workspaces', position: 'center', order: 1, visible: false },
            { id: 'clock', position: 'center', order: 2, visible: true },
            { id: 'separator2', position: 'right', order: 0, visible: false },
            { id: 'systray', position: 'right', order: 1, visible: true },
            { id: 'battery', position: 'right', order: 2, visible: false },
            { id: 'notifications', position: 'right', order: 3, visible: true },
            { id: 'quicksettings', position: 'right', order: 4, visible: false }
          ]
        },
        // Workspace state for virtual desktops
        currentWorkspace: 1,
        totalWorkspaces: 4,
        // Notification state
        notificationCount: 0,
        notifications: JSON.parse(localStorage.getItem('mosNotifications') || '[]'),
        showNotificationPanel: false,
        calendarExpanded: true,
        calendarMonth: new Date().getMonth(),
        calendarYear: new Date().getFullYear(),
        focusTimerMinutes: 30,
        contextMenuDragElement: null, // Currently dragged element id
        currentTime: new Date(),
        terminalHistory: JSON.parse(localStorage.getItem('terminalHistory') || '{}'), // Store terminal output history per window
        inputValues: {}, // Store input values per window
        commandHistory: JSON.parse(localStorage.getItem('commandHistory') || '[]'), // All commands typed
        commandHistoryIndex: -1, // Current position in command history navigation
        customWallpaper: localStorage.getItem('customWallpaper') || null, // Custom wallpaper URL
        customWallpapers: JSON.parse(localStorage.getItem('customWallpapers') || '[]'), // Array of {id, dark, light, name} objects
        activeCustomWallpaper: parseInt(localStorage.getItem('activeCustomWallpaper') || '-2'), // Index of active custom wallpaper (-2 for default Tahoe)
        customCursor: localStorage.getItem('customCursor') || null, // Custom cursor URL
        cursorPack: JSON.parse(localStorage.getItem('cursorPack') || 'null'), // Cursor pack with multiple cursors
        scrollPositions: {}, // Store scroll positions per window
        isScrolling: false, // Track if user is actively scrolling
        scrollTimeout: null, // Timeout for scroll debouncing
        dockPosition: localStorage.getItem('dockPosition') || 'bottom', // Dock position: bottom (macOS style)
        dockSize: 'small', // Dock icon size fixed to small
        dockScale: parseFloat(localStorage.getItem('dockScale') || '1.0'), // Dock scale multiplier (0.5 to 2.0)
        animationsEnabled: localStorage.getItem('animationsEnabled') !== 'false', // Enable/disable animations
        soundEnabled: localStorage.getItem('soundEnabled') !== 'false', // Enable/disable sound effects
        browserUrls: {}, // Store current URL for each browser window
        browserHistory: {}, // Store navigation history for each browser window
        browserHistoryIndex: {}, // Store current position in history for each browser window
        browserTabs: {}, // Store tabs for each browser window {windowId: [{id, title, url, active, loading}]}
        browserTabIframes: {}, // Store preserved iframes per tab {windowId: {tabId: iframeElement}}
        browserBookmarks: JSON.parse(localStorage.getItem('browserBookmarks') || '["https://google.com", "https://youtube.com", "https://github.com", "https://twitter.com"]'),
        browserSavedSites: JSON.parse(localStorage.getItem('browserSavedSites') || '[]'),
        browserSearchHistory: JSON.parse(localStorage.getItem('browserSearchHistory') || '[]'), // Search history
        browserVerticalTabs: localStorage.getItem('browserVerticalTabs') === 'true', // Vertical tabs toggle
        showBrowserHistory: false, // Show history panel
        showAddSiteDialog: false,
        showEditBookmarkDialog: false,
        editingBookmarkIndex: null,
        showEditSiteDialog: false,
        editingSiteIndex: null,
        activeBookmarkIndex: null, // Track which bookmark is showing actions
        activeSiteIndex: null, // Track which saved site is showing actions
        showLaunchpad: false, // Track if launchpad is visible
        accentColor: localStorage.getItem('accentColor') || '#007AFF', // macOS blue accent
        launchpadSearch: '', // Search query for launchpad
        windowStates: JSON.parse(localStorage.getItem('windowStates') || '{}'), // Track maximize state per appId
        settingsTab: localStorage.getItem('settingsTab') || 'appearance', // Active settings tab
        settingsSearchQuery: '', // Search query for settings sidebar
        snapZone: null, // Track snap zone: 'left', 'right', 'top', 'top-left', 'top-right'
        isSnappingWindow: false, // Prevent re-renders from killing snap animations
        showQuickSettings: false, // Track if quick settings panel is visible
        themeTransitioning: false, // Track if theme icon is animating
        // Window customization - defaults: 35% transparency (0.65 opacity), 20px blur
        windowOpacity: parseFloat(localStorage.getItem('windowOpacity') || '0.65'), // 0.5 to 1.0
        windowBlur: parseInt(localStorage.getItem('windowBlur') || '20'), // 0 to 20
        systemFont: localStorage.getItem('systemFont') || 'SF Pro Display', // System font family
        // OS Theme - always macOS
        osTheme: 'macos',
        dockStyle: 'macos',
        menubarStyle: 'macos',
        windowStyle: 'macos',
        // App Store state
        installedApps: [], // Array of installed app IDs (detected at runtime from local files)
        minecraftSource: null, // 'local' if minecraft.html exists in same folder
        // Window controls layout
        mirroredControls: localStorage.getItem('mirroredControls') === 'true', // If true, window buttons on right, fullscreen on left
        activeWindowId: null, // Track currently active/focused window
        // Quick Settings toggles
        wifiEnabled: localStorage.getItem('wifiEnabled') !== 'false',
        bluetoothEnabled: localStorage.getItem('bluetoothEnabled') === 'true',
        shareEnabled: localStorage.getItem('shareEnabled') === 'true',
        focusEnabled: localStorage.getItem('focusEnabled') === 'true',
        // Task Manager refresh interval
        taskManagerInterval: null,
        taskManagerWindowId: null,
        // Background Processes System - apps running in background like real OS
        backgroundProcesses: JSON.parse(localStorage.getItem('backgroundProcesses') || '{}'), // {appId: {state, data, startTime}}
        processStartTimes: {}, // Track when each process started
        // Render throttling
        renderQueued: false,
        lastRenderTime: 0,
        // Boot/Setup/Lock state
        bootComplete: false,
        setupComplete: localStorage.getItem('mos_setup_complete') === 'true',
        isLocked: false,
      };
      
      // ============= M OS VERSION & UPDATE SYSTEM =============
      const MOS_VERSION = 'MoS v1';
      const MOS_UPDATE_REPO = 'https://api.github.com/repos/Matko802/my-web-os-things/contents/Versions';
      const MOS_RAW_BASE = 'https://raw.githubusercontent.com/Matko802/my-web-os-things/main/Versions/';
      let pendingUpdateVersion = null;
      let pendingUpdateCode = null;
      
      // Get current installed version
      function getInstalledVersion() {
        return localStorage.getItem('mos_version') || MOS_VERSION;
      }
      
      // Set installed version
      function setInstalledVersion(version) {
        localStorage.setItem('mos_version', version);
      }
      
      // Parse version number from "MoS vX" format
      function parseVersionNumber(versionStr) {
        const match = versionStr.match(/MoS v(\d+)/i);
        return match ? parseInt(match[1], 10) : 0;
      }
      
      // Check for updates from GitHub
      async function checkForUpdates() {
        console.log('[Update] Checking for updates...');
        try {
          const response = await fetch(MOS_UPDATE_REPO);
          if (!response.ok) {
            console.log('[Update] Failed to fetch versions:', response.status);
            return null;
          }
          
          const files = await response.json();
          const currentVersion = parseVersionNumber(getInstalledVersion());
          let latestVersion = currentVersion;
          let latestFile = null;
          
          // Find the highest version number
          for (const file of files) {
            if (file.type === 'file' && file.name.endsWith('.html')) {
              const fileVersion = parseVersionNumber(file.name);
              if (fileVersion > latestVersion) {
                latestVersion = fileVersion;
                latestFile = file.name;
              }
            }
          }
          
          if (latestFile && latestVersion > currentVersion) {
            console.log('[Update] New version available:', latestFile);
            return { version: 'MoS v' + latestVersion, file: latestFile };
          }
          
          console.log('[Update] Already on latest version:', getInstalledVersion());
          return null;
        } catch (e) {
          console.error('[Update] Error checking for updates:', e);
          return null;
        }
      }
      
      // Download update from GitHub
      async function downloadUpdate(versionInfo) {
        console.log('[Update] Downloading:', versionInfo.file);
        try {
          const response = await fetch(MOS_RAW_BASE + versionInfo.file);
          if (!response.ok) {
            console.error('[Update] Failed to download:', response.status);
            return null;
          }
          
          const code = await response.text();
          console.log('[Update] Downloaded', code.length, 'bytes');
          return code;
        } catch (e) {
          console.error('[Update] Download error:', e);
          return null;
        }
      }
      
      // Show update notification toast
      function showUpdateToast(version) {
        const toast = document.getElementById('update-toast');
        const message = document.getElementById('update-toast-message');
        if (toast && message) {
          message.textContent = version + ' is available';
          toast.classList.add('visible');
        }
      }
      
      // Dismiss update notification
      window.dismissUpdate = function() {
        const toast = document.getElementById('update-toast');
        if (toast) {
          toast.classList.remove('visible');
        }
      };
      
      // Apply pending update
      window.applyUpdate = function() {
        if (pendingUpdateCode && pendingUpdateVersion) {
          console.log('[Update] Applying update to', pendingUpdateVersion);
          localStorage.setItem('mos_updated_code', pendingUpdateCode);
          setInstalledVersion(pendingUpdateVersion);
          window.location.reload();
        }
      };
      
      // Toggle auto-update setting
      window.toggleAutoUpdate = function() {
        const current = localStorage.getItem('mos_auto_update') === 'true';
        localStorage.setItem('mos_auto_update', !current ? 'true' : 'false');
        renderWindows();
      };
      
      // Manual check for updates from settings
      window.manualCheckForUpdates = async function() {
        state.isCheckingUpdate = true;
        renderWindows();
        
        const statusEl = document.getElementById('update-status-text');
        const btn = document.getElementById('check-updates-btn');
        
        if (btn) {
          btn.disabled = true;
          btn.innerHTML = ' Checking...';
        }
        
        try {
          const update = await checkForUpdates();
          localStorage.setItem('mos_last_update_check', Date.now().toString());
          
          if (update) {
            const code = await downloadUpdate(update);
            if (code) {
              pendingUpdateVersion = update.version;
              pendingUpdateCode = code;
              if (statusEl) statusEl.textContent = ' Update found: ' + update.version;
              showUpdateToast(update.version);
            }
          } else {
            if (statusEl) statusEl.textContent = ' You are on the latest version';
          }
        } catch (e) {
          console.error('[Update] Manual check error:', e);
          if (statusEl) statusEl.textContent = ' Failed to check for updates';
        }
        
        state.isCheckingUpdate = false;
        if (btn) {
          btn.disabled = false;
          btn.innerHTML = ' Check for Updates';
        }
        renderWindows();
      };
      
      // Upload lockscreen wallpaper
      window.uploadLockscreenWallpaper = function() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*';
        input.onchange = function(e) {
          const file = e.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = function(event) {
              localStorage.setItem('mos_lockscreen_wallpaper', event.target.result);
              renderWindows();
            };
            reader.readAsDataURL(file);
          }
        };
        input.click();
      };
      
      // Clear lockscreen wallpaper
      window.clearLockscreenWallpaper = function() {
        localStorage.removeItem('mos_lockscreen_wallpaper');
        renderWindows();
      };
      
      // Check and apply stored update on load
      function checkStoredUpdate() {
        const storedCode = localStorage.getItem('mos_updated_code');
        if (storedCode) {
          console.log('[Update] Found stored update, executing...');
          // Clear stored code to prevent infinite loop
          // Note: The stored code will become the new OS
          document.open();
          document.write(storedCode);
          document.close();
          return true;
        }
        return false;
      }
      
      // ============= SIMPLE PASSWORD HASHING =============
      function simpleHash(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash; // Convert to 32bit integer
        }
        // Add some salt and convert to hex
        const salt = 'mos_salt_2024';
        let saltedHash = hash;
        for (let i = 0; i < salt.length; i++) {
          saltedHash = ((saltedHash << 5) - saltedHash) + salt.charCodeAt(i);
          saltedHash = saltedHash & saltedHash;
        }
        return Math.abs(saltedHash).toString(16);
      }
      
      // ============= BOOT SCREEN SYSTEM =============
      let bootProgress = 0;
      let bootInterval = null;
      
      function updateBootProgress(progress, status) {
        const bar = document.getElementById('boot-loader-bar');
        const statusEl = document.getElementById('boot-status');
        if (bar) bar.style.width = progress + '%';
        if (statusEl) statusEl.textContent = status;
      }
      
      function runBootSequence() {
        return new Promise((resolve) => {
          const bootScreen = document.getElementById('boot-screen');
          if (!bootScreen) {
            resolve();
            return;
          }
          
          const bootSteps = [
            { progress: 10, status: 'Loading system files...' },
            { progress: 25, status: 'Initializing kernel...' },
            { progress: 40, status: 'Loading drivers...' },
            { progress: 55, status: 'Mounting filesystems...' },
            { progress: 70, status: 'Starting services...' },
            { progress: 85, status: 'Loading desktop environment...' },
            { progress: 100, status: 'Ready' }
          ];
          
          let stepIndex = 0;
          bootInterval = setInterval(() => {
            if (stepIndex < bootSteps.length) {
              const step = bootSteps[stepIndex];
              updateBootProgress(step.progress, step.status);
              stepIndex++;
            } else {
              clearInterval(bootInterval);
              setTimeout(() => {
                bootScreen.classList.add('fade-out');
                setTimeout(() => {
                  bootScreen.style.display = 'none';
                  state.bootComplete = true;
                  resolve();
                }, 800);
              }, 300);
            }
          }, 200);
        });
      }
      
      // ============= FIRST-BOOT SETUP SYSTEM =============
      let setupStep = 1;
      let setupData = {
        username: '',
        password: '',
        theme: 'dark',
        cursor: 'default'
      };
      
      function showSetupScreen() {
        const setupScreen = document.getElementById('setup-screen');
        if (setupScreen) {
          setupScreen.classList.add('active');
          // Focus first input after animation
          setTimeout(() => {
            const input = document.getElementById('setup-username');
            if (input) input.focus();
          }, 300);
        }
      }
      
      function hideSetupScreen() {
        const setupScreen = document.getElementById('setup-screen');
        if (setupScreen) {
          setupScreen.classList.remove('active');
        }
      }
      
      function updateSetupStep(step) {
        setupStep = step;
        
        // Update step visibility
        document.querySelectorAll('.setup-step').forEach(el => {
          el.classList.remove('active');
          if (parseInt(el.dataset.step) === step) {
            el.classList.add('active');
          }
        });
        
        // Update progress dots
        document.querySelectorAll('.setup-progress-dot').forEach(el => {
          const dotStep = parseInt(el.dataset.dot);
          el.classList.remove('active', 'completed');
          if (dotStep === step) {
            el.classList.add('active');
          } else if (dotStep < step) {
            el.classList.add('completed');
          }
        });
        
        // Update buttons
        const backBtn = document.getElementById('setup-back-btn');
        const nextBtn = document.getElementById('setup-next-btn');
        
        if (backBtn) {
          backBtn.style.display = step > 1 ? 'block' : 'none';
        }
        
        if (nextBtn) {
          nextBtn.textContent = step === 4 ? 'Get Started' : 'Continue';
        }
        
        // Focus appropriate input
        setTimeout(() => {
          if (step === 1) {
            const input = document.getElementById('setup-username');
            if (input) input.focus();
          } else if (step === 2) {
            const input = document.getElementById('setup-password');
            if (input) input.focus();
          }
        }, 100);
      }
      
      window.setupNextStep = function() {
        // Validate current step
        if (setupStep === 1) {
          const username = document.getElementById('setup-username').value.trim();
          if (!username) {
            document.getElementById('setup-username').focus();
            return;
          }
          setupData.username = username;
        } else if (setupStep === 2) {
          const password = document.getElementById('setup-password').value;
          const confirm = document.getElementById('setup-password-confirm').value;
          if (password && password !== confirm) {
            document.getElementById('setup-password-confirm').focus();
            return;
          }
          setupData.password = password;
        }
        
        if (setupStep < 4) {
          updateSetupStep(setupStep + 1);
        } else {
          // Complete setup
          completeSetup();
        }
      };
      
      window.setupPrevStep = function() {
        if (setupStep > 1) {
          updateSetupStep(setupStep - 1);
        }
      };
      
      window.selectSetupTheme = function(theme) {
        setupData.theme = theme;
        document.querySelectorAll('.setup-option').forEach(el => {
          el.classList.toggle('selected', el.dataset.theme === theme);
        });
      };
      
      window.selectSetupCursor = function(cursor) {
        setupData.cursor = cursor;
        document.querySelectorAll('.setup-cursor-option').forEach(el => {
          el.classList.toggle('selected', el.dataset.cursor === cursor);
        });
      };
      
      function completeSetup() {
        // Save user data
        localStorage.setItem('mos_username', setupData.username);
        if (setupData.password) {
          localStorage.setItem('mos_password_hash', simpleHash(setupData.password));
        } else {
          localStorage.removeItem('mos_password_hash');
        }
        
        // Apply theme
        if (setupData.theme === 'dark') {
          document.documentElement.classList.add('dark');
          localStorage.setItem('theme', 'dark');
          state.isDark = true;
        } else {
          document.documentElement.classList.remove('dark');
          localStorage.setItem('theme', 'light');
          state.isDark = false;
        }
        
        // Apply cursor preference
        if (setupData.cursor === 'custom') {
          localStorage.setItem(CURSOR_CONFIG.enabledKey, 'true');
        } else {
          localStorage.setItem(CURSOR_CONFIG.enabledKey, 'false');
        }
        
        // Mark setup as complete
        localStorage.setItem('mos_setup_complete', 'true');
        state.setupComplete = true;
        
        // Hide setup and show desktop
        hideSetupScreen();
        
        // Refresh cursor system
        if (setupData.cursor === 'custom') {
          injectCursorStyles();
        }
        
        render();
      }
      
      // Handle Enter key in setup inputs
      document.addEventListener('keydown', function(e) {
        const setupScreen = document.getElementById('setup-screen');
        if (setupScreen && setupScreen.classList.contains('active')) {
          if (e.key === 'Enter') {
            e.preventDefault();
            setupNextStep();
          } else if (e.key === 'Escape' && setupStep > 1) {
            e.preventDefault();
            setupPrevStep();
          }
        }
      });
      
      // ============= LOCKSCREEN SYSTEM =============
      let lockscreenClockInterval = null;
      let lockscreenIdleTimeout = null;
      let lockscreenIdleTimer = null;
      const LOCKSCREEN_IDLE_TIMEOUT = 15000; // 15 seconds
      
      function updateLockscreenClock() {
        const timeEl = document.getElementById('lockscreen-time');
        const dateEl = document.getElementById('lockscreen-date');
        
        if (timeEl && dateEl) {
          const now = new Date();
          timeEl.textContent = now.toLocaleTimeString('en-US', {
            hour: '2-digit',
            minute: '2-digit',
            hour12: false
          });
          dateEl.textContent = now.toLocaleDateString('en-US', {
            weekday: 'long',
            month: 'long',
            day: 'numeric'
          });
        }
      }
      
      // Enter screensaver mode on lockscreen
      function enterScreensaverMode() {
        const lockscreen = document.getElementById('lockscreen');
        if (lockscreen && lockscreen.classList.contains('active')) {
          lockscreen.classList.add('screensaver');
        }
      }
      
      // Exit screensaver mode
      function exitScreensaverMode() {
        const lockscreen = document.getElementById('lockscreen');
        if (lockscreen) {
          lockscreen.classList.remove('screensaver');
          // Reset idle timer
          resetLockscreenIdleTimer();
          // Focus password input again
          const input = document.getElementById('lockscreen-password');
          const hasPassword = !!localStorage.getItem('mos_password_hash');
          if (input && hasPassword) {
            setTimeout(() => input.focus(), 100);
          }
        }
      }
      
      // Reset the idle timer
      function resetLockscreenIdleTimer() {
        if (lockscreenIdleTimer) {
          clearTimeout(lockscreenIdleTimer);
        }
        const lockscreen = document.getElementById('lockscreen');
        if (lockscreen && lockscreen.classList.contains('active')) {
          lockscreenIdleTimer = setTimeout(enterScreensaverMode, LOCKSCREEN_IDLE_TIMEOUT);
        }
      }
      
      // Setup lockscreen idle detection
      function setupLockscreenIdleDetection() {
        const lockscreen = document.getElementById('lockscreen');
        if (lockscreen) {
          ['mousemove', 'mousedown', 'keydown', 'touchstart'].forEach(event => {
            lockscreen.addEventListener(event, () => {
              if (lockscreen.classList.contains('screensaver')) {
                exitScreensaverMode();
              } else {
                resetLockscreenIdleTimer();
              }
            });
          });
        }
      }
      
      function showLockscreen() {
        const lockscreen = document.getElementById('lockscreen');
        const username = localStorage.getItem('mos_username') || 'User';
        const hasPassword = !!localStorage.getItem('mos_password_hash');
        
        if (lockscreen) {
          // Set username and avatar
          const usernameEl = document.getElementById('lockscreen-username');
          const avatarEl = document.getElementById('lockscreen-avatar');
          const passwordContainer = document.getElementById('lockscreen-password-container');
          const unlockBtn = document.getElementById('lockscreen-unlock-btn');
          
          if (usernameEl) usernameEl.textContent = username;
          if (avatarEl) avatarEl.textContent = username.charAt(0).toUpperCase();
          
          // Show password input or unlock button based on password existence
          if (hasPassword) {
            if (passwordContainer) passwordContainer.style.display = 'block';
            if (unlockBtn) unlockBtn.style.display = 'none';
          } else {
            if (passwordContainer) passwordContainer.style.display = 'none';
            if (unlockBtn) unlockBtn.style.display = 'inline-block';
          }
          
          // Set background - check for custom wallpaper
          const bg = document.getElementById('lockscreen-bg');
          const customWallpaper = localStorage.getItem('mos_lockscreen_wallpaper');
          if (bg) {
            if (customWallpaper) {
              bg.style.backgroundImage = 'url(' + customWallpaper + ')';
              bg.style.background = '';
              bg.style.backgroundSize = 'cover';
              bg.style.backgroundPosition = 'center';
              bg.style.filter = 'blur(30px) brightness(0.4)';
              bg.style.transform = 'scale(1.1)';
            } else {
              bg.style.backgroundImage = '';
              bg.style.background = 'linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0f0f1a 100%)';
            }
          }
          
          lockscreen.classList.add('active');
          lockscreen.classList.remove('screensaver');
          state.isLocked = true;
          
          // Update clock
          updateLockscreenClock();
          lockscreenClockInterval = setInterval(updateLockscreenClock, 1000);
          
          // Start idle timer
          resetLockscreenIdleTimer();
          
          // Focus password input
          setTimeout(() => {
            const input = document.getElementById('lockscreen-password');
            if (input && hasPassword) input.focus();
          }, 100);
        }
      }
      
      function hideLockscreen() {
        const lockscreen = document.getElementById('lockscreen');
        if (lockscreen) {
          lockscreen.classList.remove('active');
          lockscreen.classList.remove('screensaver');
          state.isLocked = false;
          
          if (lockscreenClockInterval) {
            clearInterval(lockscreenClockInterval);
            lockscreenClockInterval = null;
          }
          
          if (lockscreenIdleTimer) {
            clearTimeout(lockscreenIdleTimer);
            lockscreenIdleTimer = null;
          }
          
          // Clear password input
          const input = document.getElementById('lockscreen-password');
          if (input) input.value = '';
        }
      }
      
      window.unlockScreen = function() {
        const passwordHash = localStorage.getItem('mos_password_hash');
        
        if (!passwordHash) {
          // No password set, just unlock
          hideLockscreen();
          return;
        }
        
        const input = document.getElementById('lockscreen-password');
        const errorEl = document.getElementById('lockscreen-error');
        
        if (input && errorEl) {
          const enteredHash = simpleHash(input.value);
          
          if (enteredHash === passwordHash) {
            hideLockscreen();
          } else {
            // Show error with shake animation
            errorEl.classList.add('visible');
            input.value = '';
            input.focus();
            
            // Hide error after delay
            setTimeout(() => {
              errorEl.classList.remove('visible');
            }, 2000);
          }
        }
      };
      
      // Handle Enter key on lockscreen
      document.addEventListener('keydown', function(e) {
        const lockscreen = document.getElementById('lockscreen');
        if (lockscreen && lockscreen.classList.contains('active')) {
          if (e.key === 'Enter') {
            e.preventDefault();
            unlockScreen();
          }
        }
      });
      
      // Lock screen function (can be called from UI)
      window.lockScreen = function() {
        showLockscreen();
      };
      
      // ============= BOOT ORCHESTRATION =============
      async function startOS() {
        console.log('[Boot] Starting M OS...');
        
        // Check for stored update first
        if (checkStoredUpdate()) {
          return; // Page will reload with new code
        }
        
        // Apply saved cursor preference immediately before boot screen shows
        const savedCursor = localStorage.getItem(CURSOR_CONFIG.enabledKey);
        if (savedCursor === 'true') {
          // Cursor will be applied by the cursor system
        }
        
        // Run boot animation
        await runBootSequence();
        
        // Check if first boot (setup not complete)
        if (!state.setupComplete) {
          console.log('[Boot] First boot - showing setup');
          showSetupScreen();
          return;
        }
        
        // Check if password is set - show lockscreen
        const hasPassword = !!localStorage.getItem('mos_password_hash');
        if (hasPassword) {
          console.log('[Boot] Password set - showing lockscreen');
          showLockscreen();
          setupLockscreenIdleDetection();
        }
        
        // Check for updates in background only if auto-update is enabled
        const autoUpdateEnabled = localStorage.getItem('mos_auto_update') === 'true';
        if (autoUpdateEnabled) {
          setTimeout(async () => {
            const update = await checkForUpdates();
            localStorage.setItem('mos_last_update_check', Date.now().toString());
            if (update) {
              const code = await downloadUpdate(update);
              if (code) {
                pendingUpdateVersion = update.version;
                pendingUpdateCode = code;
                showUpdateToast(update.version);
              }
            }
          }, 2000);
        }
      }

      // Force-remove the Window List from the top bar (also clears any persisted layout overrides)
      (function sanitizeContextMenuLayout() {
        try {
          const layout = state.contextMenuLayout;
          if (!layout || !Array.isArray(layout.elements)) return;

          const before = layout.elements.length;
          layout.elements = layout.elements.filter(e => e?.id !== 'windowlist');

          if (layout.elements.length !== before) {
            localStorage.setItem('contextMenuLayout', JSON.stringify(layout));
          }
        } catch (e) {
          // no-op
        }
      })();

      // Store preserved iframes outside render to prevent recreating them on re-render
      // This MUST be declared before getWindowContent to be accessible from it
      const preservedIframes = new Map();
      
      // Store preserved Task Manager content to prevent refresh on window focus/render
      const preservedTaskManagerContent = new Map();

      // ============= Virtual DOM Batching Layer =============
      // Batches multiple state changes before committing to the real DOM
      // Uses requestAnimationFrame for optimal timing and prevents layout thrashing
      
      const vdom = {
        // Pending state changes queue
        pendingChanges: [],
        
        // Batch frame request ID
        batchFrameId: null,
        
        // Track what needs to be updated
        dirty: {
          windows: false,
          shell: false,
          full: false,
          // Granular window updates
          windowPatches: new Map(), // windowId -> {props to update}
        },
        
        // Batch timing
        lastCommitTime: 0,
        minBatchInterval: 16, // ~60fps
        
        // Queue a state change with optional render type
        // renderType: 'windows' | 'shell' | 'full' | 'none'
        queue(changes, renderType = 'windows') {
          // Apply changes to state immediately (for reads to work)
          if (typeof changes === 'function') {
            changes(state);
          } else if (typeof changes === 'object') {
            Object.assign(state, changes);
          }
          
          // Mark what's dirty
          if (renderType === 'full') {
            this.dirty.full = true;
          } else if (renderType === 'shell') {
            this.dirty.shell = true;
          } else if (renderType === 'windows') {
            this.dirty.windows = true;
          }
          // 'none' means no render needed
          
          // Schedule batch commit
          this.scheduleBatch();
        },
        
        // Queue a window-specific update (more granular)
        queueWindowUpdate(windowId, updates) {
          const existing = this.dirty.windowPatches.get(windowId) || {};
          this.dirty.windowPatches.set(windowId, { ...existing, ...updates });
          this.dirty.windows = true;
          this.scheduleBatch();
        },
        
        // Schedule the batch commit on next animation frame
        scheduleBatch() {
          if (this.batchFrameId !== null) return; // Already scheduled
          
          this.batchFrameId = requestAnimationFrame((timestamp) => {
            this.commit(timestamp);
          });
        },
        
        // Cancel pending batch (useful during drag operations)
        cancelBatch() {
          if (this.batchFrameId !== null) {
            cancelAnimationFrame(this.batchFrameId);
            this.batchFrameId = null;
          }
        },
        
        // Commit all pending changes to the real DOM
        commit(timestamp) {
          this.batchFrameId = null;
          
          // Skip if we're dragging/resizing (let dedicated handlers manage)
          // Note: dragState/resizeState are declared later, use typeof check
          if ((typeof dragState !== 'undefined' && dragState) || 
              (typeof resizeState !== 'undefined' && resizeState)) {
            // Still process dirty flags after drag ends
            return;
          }
          
          // Determine what to render
          if (this.dirty.full) {
            render();
          } else {
            // Apply granular window patches first
            if (this.dirty.windowPatches.size > 0) {
              this.applyWindowPatches();
            }
            
            // Then do broader updates if needed
            if (this.dirty.windows) {
              renderWindows();
            }
            if (this.dirty.shell) {
              renderShell();
            }
          }
          
          // Reset dirty flags
          this.resetDirty();
          this.lastCommitTime = timestamp;
        },
        
        // Apply granular window patches without full renderWindows
        applyWindowPatches() {
          this.dirty.windowPatches.forEach((updates, windowId) => {
            const windowEl = document.querySelector('.window[data-id="' + windowId + '"]');
            if (!windowEl) return;
            
            const win = state.windows.find(w => w.id === parseInt(windowId, 10));
            if (!win) return;
            
            // Apply position/size updates directly
            if (updates.x !== undefined || updates.y !== undefined) {
              windowEl.style.left = (updates.x ?? win.x) + 'px';
              windowEl.style.top = (updates.y ?? win.y) + 'px';
            }
            if (updates.width !== undefined || updates.height !== undefined) {
              windowEl.style.width = (updates.width ?? win.width) + 'px';
              windowEl.style.height = (updates.height ?? win.height) + 'px';
            }
            if (updates.zIndex !== undefined) {
              windowEl.style.zIndex = updates.zIndex;
            }
            
            // Apply class updates
            if (updates.isMaximized !== undefined) {
              if (updates.isMaximized) {
                windowEl.classList.add('maximized');
              } else {
                windowEl.classList.remove('maximized');
              }
            }
            if (updates.isMinimized !== undefined) {
              windowEl.style.display = updates.isMinimized ? 'none' : '';
            }
          });
        },
        
        // Reset all dirty flags
        resetDirty() {
          this.dirty.windows = false;
          this.dirty.shell = false;
          this.dirty.full = false;
          this.dirty.windowPatches.clear();
        },
        
        // Force immediate commit (bypasses batching)
        flush() {
          this.cancelBatch();
          this.commit(performance.now());
        },
        
        // Batch multiple operations together
        batch(callback) {
          // Temporarily disable auto-scheduling
          const wasScheduled = this.batchFrameId !== null;
          this.cancelBatch();
          
          // Run all operations
          callback();
          
          // Now schedule a single commit
          this.scheduleBatch();
        }
      };
      
      // Proxy wrapper for state to auto-queue updates
      // Usage: vdom.setState({ key: value }) or vdom.setState(s => s.key = value)
      vdom.setState = function(changes, renderType = 'windows') {
        this.queue(changes, renderType);
      };
      
      // Convenience methods for common operations
      vdom.updateWindow = function(windowId, updates) {
        const win = state.windows.find(w => w.id === windowId);
        if (win) {
          Object.assign(win, updates);
          this.queueWindowUpdate(windowId, updates);
        }
      };
      
      vdom.bringToFront = function(windowId) {
        const win = state.windows.find(w => w.id === windowId);
        if (win) {
          win.zIndex = ++state.nextZIndex;
          state.activeWindowId = windowId;
          this.queueWindowUpdate(windowId, { zIndex: win.zIndex });
        }
      };
      
      // Expose globally
      window.vdom = vdom;

      const icons = {
        // Finder - White folder icon with blue gradient background
        Files: `<svg viewBox="0 0 64 64" fill="none">
          <defs>
            <linearGradient id="finderBgGrad" x1="0%" y1="0%" x2="0%" y2="100%">
              <stop offset="0%" stop-color="#5AC8FA"/>
              <stop offset="100%" stop-color="#007AFF"/>
            </linearGradient>
            <linearGradient id="folderGrad" x1="0%" y1="0%" x2="0%" y2="100%">
              <stop offset="0%" stop-color="#FFFFFF"/>
              <stop offset="100%" stop-color="#E8E8ED"/>
            </linearGradient>
            <linearGradient id="folderTabGrad" x1="0%" y1="0%" x2="0%" y2="100%">
              <stop offset="0%" stop-color="#FAFAFA"/>
              <stop offset="100%" stop-color="#E5E5EA"/>
            </linearGradient>
          </defs>
          <rect x="4" y="4" width="56" height="56" rx="14" fill="url(#finderBgGrad)"/>
          <!-- Folder back -->
          <path d="M14 24 L14 46 Q14 48 16 48 L48 48 Q50 48 50 46 L50 24 Q50 22 48 22 L14 22 Q14 22 14 24 Z" fill="url(#folderGrad)" opacity="0.9"/>
          <!-- Folder tab -->
          <path d="M14 22 L14 20 Q14 18 16 18 L26 18 Q28 18 29 20 L31 22 L14 22 Z" fill="url(#folderTabGrad)"/>
          <!-- Folder front -->
          <path d="M12 26 L12 48 Q12 50 14 50 L50 50 Q52 50 52 48 L52 26 Q52 24 50 24 L14 24 Q12 24 12 26 Z" fill="url(#folderGrad)"/>
          <!-- Folder shine -->
          <path d="M12 26 L52 26 L52 28 L12 28 Z" fill="white" opacity="0.5"/>
        </svg>`,
        
        // Terminal - Black with green prompt
        Terminal: `<svg viewBox="0 0 64 64" fill="none">
          <defs>
            <linearGradient id="termGrad" x1="0%" y1="0%" x2="0%" y2="100%">
              <stop offset="0%" stop-color="#464646"/>
              <stop offset="100%" stop-color="#1a1a1a"/>
            </linearGradient>
          </defs>
          <rect x="4" y="4" width="56" height="56" rx="14" fill="url(#termGrad)"/>
          <path d="M18 22 L28 32 L18 42" stroke="#4ADE80" stroke-width="3.5" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
          <line x1="32" y1="42" x2="46" y2="42" stroke="#4ADE80" stroke-width="3.5" stroke-linecap="round"/>
        </svg>`,
        
        // Safari - Compass on blue
        Browser: `<svg viewBox="0 0 64 64" fill="none">
          <defs>
            <linearGradient id="safariGrad" x1="0%" y1="0%" x2="0%" y2="100%">
              <stop offset="0%" stop-color="#5AC8FA"/>
              <stop offset="100%" stop-color="#007AFF"/>
            </linearGradient>
          </defs>
          <rect x="4" y="4" width="56" height="56" rx="14" fill="url(#safariGrad)"/>
          <circle cx="32" cy="32" r="18" fill="white"/>
          <circle cx="32" cy="32" r="16" fill="none" stroke="#E5E5E5" stroke-width="0.5"/>
          <!-- Compass tick marks -->
          <g stroke="#888" stroke-width="1">
            <line x1="32" y1="15" x2="32" y2="18"/>
            <line x1="32" y1="46" x2="32" y2="49"/>
            <line x1="15" y1="32" x2="18" y2="32"/>
            <line x1="46" y1="32" x2="49" y2="32"/>
          </g>
          <!-- Compass needle -->
          <polygon points="32,16 36,32 32,36 28,32" fill="#FF3B30"/>
          <polygon points="32,48 28,32 32,28 36,32" fill="#FF3B30" opacity="0.4"/>
          <polygon points="32,16 28,32 32,28" fill="#FF6961"/>
          <polygon points="32,48 36,32 32,36" fill="#FFAAAA"/>
          <circle cx="32" cy="32" r="3" fill="white" stroke="#ccc" stroke-width="0.5"/>
        </svg>`,
        
        // Mail - Blue with white envelope
        Mail: `<svg viewBox="0 0 64 64" fill="none">
          <defs>
            <linearGradient id="mailGrad" x1="0%" y1="0%" x2="0%" y2="100%">
              <stop offset="0%" stop-color="#5AC8FA"/>
              <stop offset="100%" stop-color="#007AFF"/>
            </linearGradient>
          </defs>
          <rect x="4" y="4" width="56" height="56" rx="14" fill="url(#mailGrad)"/>
          <rect x="12" y="20" width="40" height="26" rx="3" fill="white"/>
          <path d="M12 22 L32 36 L52 22" stroke="#007AFF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
          <path d="M12 44 L26 34" stroke="#007AFF" stroke-width="1.5" stroke-linecap="round" opacity="0.3"/>
          <path d="M52 44 L38 34" stroke="#007AFF" stroke-width="1.5" stroke-linecap="round" opacity="0.3"/>
        </svg>`,
        
        // Music - Red gradient with music note
        Music: `<svg viewBox="0 0 64 64" fill="none">
          <defs>
            <linearGradient id="musicGrad" x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%" stop-color="#FC3C44"/>
              <stop offset="100%" stop-color="#FF2D55"/>
            </linearGradient>
          </defs>
          <rect x="4" y="4" width="56" height="56" rx="14" fill="url(#musicGrad)"/>
          <ellipse cx="24" cy="42" rx="7" ry="6" fill="white"/>
          <ellipse cx="44" cy="38" rx="7" ry="6" fill="white"/>
          <path d="M31 42 L31 18 L51 14 L51 38" stroke="white" stroke-width="4" fill="none"/>
          <path d="M31 22 L51 18" stroke="white" stroke-width="4"/>
        </svg>`,
        
        // System Preferences - Gray cog wheel
        Settings: `<svg viewBox="0 0 64 64" fill="none">
          <defs>
            <linearGradient id="settingsGrad" x1="0%" y1="0%" x2="0%" y2="100%">
              <stop offset="0%" stop-color="#8E8E93"/>
              <stop offset="100%" stop-color="#636366"/>
            </linearGradient>
          </defs>
          <rect x="4" y="4" width="56" height="56" rx="14" fill="url(#settingsGrad)"/>
          <!-- Cog wheel with proper teeth -->
          <g fill="white">
            <!-- Center hub -->
            <circle cx="32" cy="32" r="10"/>
            <!-- Teeth (8 teeth evenly spaced) -->
            <rect x="29" y="10" width="6" height="10" rx="2"/>
            <rect x="29" y="44" width="6" height="10" rx="2"/>
            <rect x="10" y="29" width="10" height="6" rx="2"/>
            <rect x="44" y="29" width="10" height="6" rx="2"/>
            <!-- Diagonal teeth -->
            <rect x="29" y="10" width="6" height="10" rx="2" transform="rotate(45 32 32)"/>
            <rect x="29" y="10" width="6" height="10" rx="2" transform="rotate(90 32 32)"/>
            <rect x="29" y="10" width="6" height="10" rx="2" transform="rotate(135 32 32)"/>
            <rect x="29" y="10" width="6" height="10" rx="2" transform="rotate(180 32 32)"/>
            <rect x="29" y="10" width="6" height="10" rx="2" transform="rotate(225 32 32)"/>
            <rect x="29" y="10" width="6" height="10" rx="2" transform="rotate(270 32 32)"/>
            <rect x="29" y="10" width="6" height="10" rx="2" transform="rotate(315 32 32)"/>
          </g>
          <!-- Inner circle (hole) -->
          <circle cx="32" cy="32" r="5" fill="#636366"/>
        </svg>`,
        
        // Launchpad - Gray with grid dots
        Finder: `<svg viewBox="0 0 64 64" fill="none">
          <defs>
            <linearGradient id="launchGrad" x1="0%" y1="0%" x2="0%" y2="100%">
              <stop offset="0%" stop-color="#636366"/>
              <stop offset="100%" stop-color="#3A3A3C"/>
            </linearGradient>
          </defs>
          <rect x="4" y="4" width="56" height="56" rx="14" fill="url(#launchGrad)"/>
          <g fill="white">
            <circle cx="20" cy="20" r="5"/>
            <circle cx="32" cy="20" r="5"/>
            <circle cx="44" cy="20" r="5"/>
            <circle cx="20" cy="32" r="5"/>
            <circle cx="32" cy="32" r="5"/>
            <circle cx="44" cy="32" r="5"/>
            <circle cx="20" cy="44" r="5"/>
            <circle cx="32" cy="44" r="5"/>
            <circle cx="44" cy="44" r="5"/>
          </g>
        </svg>`,
        
        // Photos - Colorful flower/pinwheel
        Camera: `<svg viewBox="0 0 64 64" fill="none">
          <defs>
            <linearGradient id="photosGrad" x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%" stop-color="#FF6B6B"/>
              <stop offset="25%" stop-color="#FF9500"/>
              <stop offset="50%" stop-color="#FFD60A"/>
              <stop offset="75%" stop-color="#30D158"/>
              <stop offset="100%" stop-color="#5AC8FA"/>
            </linearGradient>
          </defs>
          <rect x="4" y="4" width="56" height="56" rx="14" fill="white"/>
          <!-- Flower petals -->
          <ellipse cx="32" cy="20" rx="8" ry="12" fill="#FF3B30"/>
          <ellipse cx="42" cy="26" rx="8" ry="12" fill="#FF9500" transform="rotate(60 42 26)"/>
          <ellipse cx="42" cy="38" rx="8" ry="12" fill="#FFCC00" transform="rotate(120 42 38)"/>
          <ellipse cx="32" cy="44" rx="8" ry="12" fill="#34C759"/>
          <ellipse cx="22" cy="38" rx="8" ry="12" fill="#5AC8FA" transform="rotate(60 22 38)"/>
          <ellipse cx="22" cy="26" rx="8" ry="12" fill="#AF52DE" transform="rotate(120 22 26)"/>
          <circle cx="32" cy="32" r="6" fill="white"/>
        </svg>`,
        
        // FaceTime - Green with video camera
        Video: `<svg viewBox="0 0 64 64" fill="none">
          <defs>
            <linearGradient id="facetimeGrad" x1="0%" y1="0%" x2="0%" y2="100%">
              <stop offset="0%" stop-color="#34C759"/>
              <stop offset="100%" stop-color="#30B350"/>
            </linearGradient>
          </defs>
          <rect x="4" y="4" width="56" height="56" rx="14" fill="url(#facetimeGrad)"/>
          <rect x="12" y="22" width="28" height="20" rx="4" fill="white"/>
          <path d="M42 26 L52 20 L52 44 L42 38 Z" fill="white"/>
        </svg>`,
        
        // Notes/Documents - Yellow notepad
        Document: `<svg viewBox="0 0 64 64" fill="none">
          <defs>
            <linearGradient id="notesGrad" x1="0%" y1="0%" x2="0%" y2="100%">
              <stop offset="0%" stop-color="#FFD60A"/>
              <stop offset="100%" stop-color="#FFCC00"/>
            </linearGradient>
          </defs>
          <rect x="4" y="4" width="56" height="56" rx="14" fill="url(#notesGrad)"/>
          <rect x="14" y="12" width="36" height="40" rx="3" fill="white"/>
          <g stroke="#FFD60A" stroke-width="1.5">
            <line x1="20" y1="22" x2="44" y2="22"/>
            <line x1="20" y1="28" x2="44" y2="28"/>
            <line x1="20" y1="34" x2="44" y2="34"/>
            <line x1="20" y1="40" x2="36" y2="40"/>
          </g>
        </svg>`,
        
        // Downloads - Blue with arrow
        Download: `<svg viewBox="0 0 64 64" fill="none">
          <defs>
            <linearGradient id="downGrad" x1="0%" y1="0%" x2="0%" y2="100%">
              <stop offset="0%" stop-color="#5AC8FA"/>
              <stop offset="100%" stop-color="#007AFF"/>
            </linearGradient>
          </defs>
          <rect x="4" y="4" width="56" height="56" rx="14" fill="url(#downGrad)"/>
          <path d="M32 14 L32 40" stroke="white" stroke-width="4" stroke-linecap="round"/>
          <path d="M20 32 L32 44 L44 32" stroke="white" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
          <line x1="16" y1="50" x2="48" y2="50" stroke="white" stroke-width="4" stroke-linecap="round"/>
        </svg>`,
        
        // Messages - Green bubble
        Messages: `<svg viewBox="0 0 64 64" fill="none">
          <defs>
            <linearGradient id="messagesGrad" x1="0%" y1="0%" x2="0%" y2="100%">
              <stop offset="0%" stop-color="#65D36E"/>
              <stop offset="100%" stop-color="#2DC84D"/>
            </linearGradient>
          </defs>
          <rect x="4" y="4" width="56" height="56" rx="14" fill="url(#messagesGrad)"/>
          <path d="M12 32 Q12 16 32 16 Q52 16 52 32 Q52 46 38 48 L32 54 L30 48 Q12 46 12 32 Z" fill="white"/>
        </svg>`,
        
        // Maps
        Maps: `<svg viewBox="0 0 64 64" fill="none">
          <defs>
            <linearGradient id="mapsGrad" x1="0%" y1="0%" x2="0%" y2="100%">
              <stop offset="0%" stop-color="#4CD964"/>
              <stop offset="50%" stop-color="#5AC8FA"/>
              <stop offset="100%" stop-color="#007AFF"/>
            </linearGradient>
          </defs>
          <rect x="4" y="4" width="56" height="56" rx="14" fill="url(#mapsGrad)"/>
          <path d="M16 52 L16 16 L28 22 L40 14 L48 20 L48 52 L36 46 L24 54 Z" fill="white" opacity="0.9"/>
          <path d="M24 22 L24 50" stroke="#34C759" stroke-width="2"/>
          <path d="M36 18 L36 46" stroke="#FF3B30" stroke-width="2"/>
        </svg>`,
        
        // Calendar
        Calendar: `<svg viewBox="0 0 64 64" fill="none">
          <rect x="4" y="4" width="56" height="56" rx="14" fill="white"/>
          <rect x="4" y="4" width="56" height="18" rx="14 14 0 0" fill="#FF3B30"/>
          <text x="32" y="18" fill="white" font-size="10" font-weight="600" text-anchor="middle" font-family="SF Pro Display, -apple-system, sans-serif">WED</text>
          <text x="32" y="46" fill="#1a1a1a" font-size="28" font-weight="300" text-anchor="middle" font-family="SF Pro Display, -apple-system, sans-serif">22</text>
        </svg>`,
        
        // App Store
        AppStore: `<svg viewBox="0 0 64 64" fill="none">
          <defs>
            <linearGradient id="appstoreGrad" x1="0%" y1="0%" x2="0%" y2="100%">
              <stop offset="0%" stop-color="#5AC8FA"/>
              <stop offset="100%" stop-color="#007AFF"/>
            </linearGradient>
          </defs>
          <rect x="4" y="4" width="56" height="56" rx="14" fill="url(#appstoreGrad)"/>
          <text x="32" y="44" fill="white" font-size="32" font-weight="400" text-anchor="middle" font-family="SF Pro Display, -apple-system, sans-serif">A</text>
        </svg>`,
        
        // Podcasts
        Podcasts: `<svg viewBox="0 0 64 64" fill="none">
          <defs>
            <linearGradient id="podcastsGrad" x1="0%" y1="0%" x2="0%" y2="100%">
              <stop offset="0%" stop-color="#AF52DE"/>
              <stop offset="100%" stop-color="#8944AB"/>
            </linearGradient>
          </defs>
          <rect x="4" y="4" width="56" height="56" rx="14" fill="url(#podcastsGrad)"/>
          <circle cx="32" cy="26" r="8" fill="white"/>
          <path d="M28 34 L28 50 Q28 52 32 52 Q36 52 36 50 L36 34" fill="white"/>
          <path d="M18 30 Q18 14 32 14 Q46 14 46 30" stroke="white" stroke-width="3" fill="none" stroke-linecap="round"/>
          <path d="M22 32 Q22 20 32 20 Q42 20 42 32" stroke="white" stroke-width="3" fill="none" stroke-linecap="round"/>
        </svg>`,
        
        // Contacts
        Contacts: `<svg viewBox="0 0 64 64" fill="none">
          <defs>
            <linearGradient id="contactsGrad" x1="0%" y1="0%" x2="0%" y2="100%">
              <stop offset="0%" stop-color="#C9A77C"/>
              <stop offset="100%" stop-color="#A67C52"/>
            </linearGradient>
          </defs>
          <rect x="4" y="4" width="56" height="56" rx="14" fill="url(#contactsGrad)"/>
          <circle cx="32" cy="26" r="10" fill="white"/>
          <ellipse cx="32" cy="52" rx="16" ry="12" fill="white"/>
        </svg>`,
        
        // Trash
        Trash: `<svg viewBox="0 0 64 64" fill="none">
          <defs>
            <linearGradient id="trashGrad" x1="0%" y1="0%" x2="0%" y2="100%">
              <stop offset="0%" stop-color="#8E8E93"/>
              <stop offset="100%" stop-color="#636366"/>
            </linearGradient>
          </defs>
          <rect x="4" y="4" width="56" height="56" rx="14" fill="url(#trashGrad)"/>
          <path d="M20 22 L44 22 L42 50 L22 50 Z" fill="white"/>
          <rect x="18" y="18" width="28" height="4" rx="2" fill="white"/>
          <rect x="28" y="14" width="8" height="4" rx="1" fill="white"/>
          <g stroke="#8E8E93" stroke-width="2">
            <line x1="27" y1="28" x2="27" y2="44"/>
            <line x1="32" y1="28" x2="32" y2="44"/>
            <line x1="37" y1="28" x2="37" y2="44"/>
          </g>
        </svg>`,
        
        Sun: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="5"/><path d="M12 1v2m0 18v2M4.22 4.22l1.42 1.42m12.72 12.72l1.42 1.42M1 12h2m18 0h2M4.22 19.78l1.42-1.42m12.72-12.72l1.42-1.42" stroke-linecap="round"/></svg>`,
        Moon: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>`,
        WiFi: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 12.55a11 11 0 0 1 14.08 0"/><path d="M1.42 9a16 16 0 0 1 21.16 0"/><path d="M8.53 16.11a6 6 0 0 1 6.95 0"/><circle cx="12" cy="20" r="1" fill="currentColor"/></svg>`,
        Battery: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="1" y="6" width="18" height="12" rx="2" ry="2"/><path d="M23 10v4"/><rect x="3" y="8" width="14" height="8" fill="currentColor"/></svg>`,
        Volume: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></svg>`,
        MLogo: `<svg viewBox="0 0 64 64" fill="none"><defs><linearGradient id="mGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#8B5CF6"/><stop offset="100%" stop-color="#6D28D9"/></linearGradient></defs><rect x="4" y="4" width="56" height="56" rx="14" fill="url(#mGrad)"/><path d="M20 42V22h4l8 12 8-12h4v20h-4V28l-8 12-8-12v14h-4z" fill="white"/></svg>`,
        UbuntuLogo: `<svg viewBox="0 0 64 64" fill="none"><rect x="4" y="4" width="56" height="56" rx="14" fill="#E95420"/><g transform="translate(32,32)"><circle cx="0" cy="0" r="6" fill="white"/><circle cx="-13" cy="0" r="5" fill="white"/><circle cx="7" cy="-11" r="5" fill="white"/><circle cx="7" cy="11" r="5" fill="white"/><path d="M-8 0 H-2" stroke="white" stroke-width="3" stroke-linecap="round"/><path d="M2 -5 L6 -9" stroke="white" stroke-width="3" stroke-linecap="round"/><path d="M2 5 L6 9" stroke="white" stroke-width="3" stroke-linecap="round"/></g></svg>`,
        TaskManager: `<svg viewBox="0 0 64 64" fill="none">
          <defs>
            <linearGradient id="taskGrad" x1="0%" y1="0%" x2="0%" y2="100%">
              <stop offset="0%" stop-color="#10B981"/>
              <stop offset="100%" stop-color="#059669"/>
            </linearGradient>
          </defs>
          <rect x="4" y="4" width="56" height="56" rx="14" fill="url(#taskGrad)"/>
          <!-- CPU/Chart bars -->
          <rect x="14" y="38" width="8" height="12" rx="2" fill="white" opacity="0.9"/>
          <rect x="24" y="28" width="8" height="22" rx="2" fill="white" opacity="0.9"/>
          <rect x="34" y="18" width="8" height="32" rx="2" fill="white" opacity="0.9"/>
          <rect x="44" y="24" width="8" height="26" rx="2" fill="white" opacity="0.9"/>
          <!-- Top line graph -->
          <path d="M12 22 L22 18 L32 14 L42 16 L52 12" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
        </svg>`,
        Minecraft: `<svg viewBox="0 0 64 64" fill="none">
          <defs>
            <linearGradient id="mcGrad" x1="0%" y1="0%" x2="0%" y2="100%">
              <stop offset="0%" stop-color="#7CB342"/>
              <stop offset="100%" stop-color="#558B2F"/>
            </linearGradient>
          </defs>
          <rect x="4" y="4" width="56" height="56" rx="14" fill="url(#mcGrad)"/>
          <!-- Creeper face -->
          <rect x="18" y="18" width="10" height="10" fill="#1a1a1a"/>
          <rect x="36" y="18" width="10" height="10" fill="#1a1a1a"/>
          <rect x="28" y="28" width="8" height="6" fill="#1a1a1a"/>
          <rect x="24" y="34" width="16" height="4" fill="#1a1a1a"/>
          <rect x="24" y="38" width="6" height="8" fill="#1a1a1a"/>
          <rect x="34" y="38" width="6" height="8" fill="#1a1a1a"/>
        </svg>`,
      };

      // Base apps (always available)
      const baseApps = [
        { id: 'files', name: 'Files', icon: 'Files' },
        { id: 'terminal', name: 'Terminal', icon: 'Terminal' },
        { id: 'browser', name: 'Browser', icon: 'Browser', supportsFullscreen: true },
        { id: 'mail', name: 'Mail', icon: 'Mail' },
        { id: 'music', name: 'Music', icon: 'Music' },
        { id: 'settings', name: 'Settings', icon: 'Settings' },
        { id: 'photos', name: 'Photos', icon: 'Camera' },
        { id: 'videos', name: 'Videos', icon: 'Video' },
        { id: 'documents', name: 'Documents', icon: 'Document' },
        { id: 'downloads', name: 'Downloads', icon: 'Download' },
        { id: 'appstore', name: 'App Store', icon: 'AppStore' },
        { id: 'taskmanager', name: 'Task Manager', icon: 'TaskManager' },
        { id: 'finder', name: 'Launchpad', icon: 'Finder', isPermanent: true },
      ];
      
      // Installable apps (only show after installation)
      const installableApps = {
        minecraft: { id: 'minecraft', name: 'Minecraft', icon: 'Minecraft', supportsFullscreen: true }
      };
      
      // Function to get all available apps (base + installed)
      function getApps() {
        const installedAppsList = state.installedApps.map(id => installableApps[id]).filter(Boolean);
        return [...baseApps.slice(0, -1), ...installedAppsList, baseApps[baseApps.length - 1]]; // Keep finder at end
      }
      
      // For backwards compatibility, create a getter
      let apps = getApps();

      // ============= Context Menu (Top Bar) Customization Functions =============
      
      // Render individual context menu elements
      function renderContextMenuElement(elementId, isCustomizeMode) {
        const elementLabels = {
          logo: 'Logo',
          menus: 'Menu Items',
          quicksettings: 'Quick Settings',
          clock: 'Clock',
          windowlist: 'Window List',
          workspaces: 'Workspaces',
          separator1: 'Separator',
          separator2: 'Separator',
          systray: 'System Tray',
          battery: 'Battery',
          notifications: 'Notifications'
        };
        
        const dragAttrs = isCustomizeMode ? `
          draggable="true"
          ondragstart="window.handleContextMenuDragStart(event, '${elementId}')"
          ondragend="window.handleContextMenuDragEnd(event)"
          ondragover="window.handleContextMenuDragOver(event, '${elementId}')"
          ondrop="window.handleContextMenuDrop(event, '${elementId}')"
          onclick="event.stopPropagation(); window.showElementPositionMenu(event, '${elementId}')"
        ` : '';
        
        const wrapperClass = isCustomizeMode ? 'context-menu-element' : '';
        const labelHTML = isCustomizeMode ? `<span class="context-menu-element-label">${elementLabels[elementId] || elementId}</span>` : '';
        
        switch(elementId) {
          case 'logo':
            return `
              <div class="${wrapperClass}" data-element-id="logo" ${dragAttrs} style="display: flex; align-items: center; position: relative;">
                ${labelHTML}
                <div class="m-logo-circle" style="display: flex; align-items: center; justify-content: center; width: 18px; height: 18px; border-radius: 50%; margin-right: 10px;">
                  <span class="m-logo-letter" style="font-size: 11px; font-weight: 600; letter-spacing: 0.02em; font-family: 'Space Grotesk', sans-serif;">M</span>
                </div>
              </div>
            `;
          case 'menus':
            return `
              <div class="${wrapperClass}" data-element-id="menus" ${dragAttrs} style="display: flex; align-items: center; gap: 2px; position: relative;">
                ${labelHTML}
                <button style="font-weight: 600;">Files</button>
                <button>Edit</button>
                <button>View</button>
                <button>Tools</button>
                <button>Help</button>
              </div>
            `;
          case 'windowlist':
            // Window list showing open windows like KDE/GNOME taskbar - same behavior as dock
            const openWindows = state.windows.filter(w => !w.isMinimized);
            const minimizedWindows = state.windows.filter(w => w.isMinimized);
            const maxZIndex = state.windows.length > 0 ? Math.max(...state.windows.map(w => w.zIndex || 0)) : 0;
            return `
              <div class="${wrapperClass}" data-element-id="windowlist" ${dragAttrs} style="display: flex; align-items: center; gap: 4px; position: relative; margin-left: 8px;">
                ${labelHTML}
                ${openWindows.length === 0 && minimizedWindows.length === 0 ? '' : openWindows.map(w => {
                  const app = apps.find(a => a.id === w.appId);
                  const isTopWindow = w.zIndex === maxZIndex;
                  const isActive = state.activeWindowId === w.id;
                  return `
                    <button onclick="window.handleWindowListClick(${w.id})" 
                            style="padding: 4px 10px; display: flex; align-items: center; gap: 6px; border-radius: 6px; font-size: 11px; ${isActive ? 'background: hsl(var(--primary) / 0.2); border: 1px solid hsl(var(--primary) / 0.3);' : ''}"
                            title="${w.title}${isTopWindow ? ' (click to minimize)' : ' (click to focus)'}">
                      <span style="width: 14px; height: 14px; display: flex; align-items: center; justify-content: center;">
                        ${app && icons[app.icon] ? icons[app.icon].replace(/width="[^"]*"/g, 'width="14"').replace(/height="[^"]*"/g, 'height="14"') : ''}
                      </span>
                      <span style="max-width: 80px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${w.title}</span>
                    </button>
                  `;
                }).join('')}
                ${minimizedWindows.map(w => {
                  const app = apps.find(a => a.id === w.appId);
                  return `
                    <button onclick="window.restoreWindowById(${w.id})" 
                            style="padding: 4px 10px; display: flex; align-items: center; gap: 6px; border-radius: 6px; font-size: 11px; opacity: 0.6;"
                            title="${w.title} (minimized - click to restore)">
                      <span style="width: 14px; height: 14px; display: flex; align-items: center; justify-content: center;">
                        ${app && icons[app.icon] ? icons[app.icon].replace(/width="[^"]*"/g, 'width="14"').replace(/height="[^"]*"/g, 'height="14"') : ''}
                      </span>
                      <span style="max-width: 80px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${w.title}</span>
                    </button>
                  `;
                }).join('')}
              </div>
            `;
          case 'workspaces':
            // Virtual desktop/workspace switcher like KDE
            return `
              <div class="${wrapperClass}" data-element-id="workspaces" ${dragAttrs} style="display: flex; align-items: center; gap: 4px; position: relative;">
                ${labelHTML}
                ${[1, 2, 3, 4].map(ws => `
                  <button onclick="window.switchWorkspace(${ws})" 
                          style="padding: 2px 8px; min-width: 24px; font-size: 11px; font-weight: ${state.currentWorkspace === ws ? '700' : '500'}; ${state.currentWorkspace === ws ? 'background: hsl(var(--primary)); color: white;' : ''} border-radius: 4px;">
                    ${ws}
                  </button>
                `).join('')}
              </div>
            `;
          case 'separator1':
          case 'separator2':
            // Separator/spacer
            return `
              <div class="${wrapperClass}" data-element-id="${elementId}" ${dragAttrs} style="display: flex; align-items: center; position: relative; padding: 0 4px;">
                ${labelHTML}
                <div style="width: 1px; height: 16px; background: hsl(var(--foreground) / 0.2);"></div>
              </div>
            `;
          case 'systray':
            // System tray - combined WiFi, Power, Volume button
            return `
              <div class="${wrapperClass}" data-element-id="systray" ${dragAttrs} style="display: flex; align-items: center; position: relative;">
                ${labelHTML}
                <button onclick="${isCustomizeMode ? '' : 'window.toggleQuickSettings()'}" style="padding: 6px 10px; display: flex; align-items: center; gap: 8px; border-radius: 8px;" title="Quick Settings">
                  <span class="menubar-icon">${icons.WiFi}</span>
                  <span class="menubar-icon">${icons.Volume}</span>
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                    <path d="M18.36 6.64a9 9 0 1 1-12.73 0"/>
                    <line x1="12" y1="2" x2="12" y2="12"/>
                  </svg>
                </button>
              </div>
            `;
          case 'battery':
            // Battery indicator
            const batteryLevel = 85; // Mock battery level
            return `
              <div class="${wrapperClass}" data-element-id="battery" ${dragAttrs} style="display: flex; align-items: center; gap: 4px; position: relative;">
                ${labelHTML}
                <button style="padding: 4px 6px; display: flex; align-items: center; gap: 4px; font-size: 11px;" title="Battery ${batteryLevel}%">
                  <span class="menubar-icon">${icons.Battery}</span>
                  <span style="font-weight: 500;">${batteryLevel}%</span>
                </button>
              </div>
            `;
          case 'notifications':
            // Notification indicator
            const hasNotifications = state.notificationCount > 0;
            return `
              <div class="${wrapperClass}" data-element-id="notifications" ${dragAttrs} style="display: flex; align-items: center; position: relative;">
                ${labelHTML}
                <button onclick="window.toggleNotifications()" style="padding: 4px; position: relative;" title="Notifications">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                    <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"/>
                    <path d="M13.73 21a2 2 0 0 1-3.46 0"/>
                  </svg>
                  ${hasNotifications ? `<span style="position: absolute; top: 0; right: 0; width: 8px; height: 8px; background: hsl(var(--primary)); border-radius: 50%; border: 2px solid hsl(var(--menubar-bg));"></span>` : ''}
                </button>
              </div>
            `;
          case 'quicksettings':
            return `
              <div class="${wrapperClass}" data-element-id="quicksettings" ${dragAttrs} style="position: relative;">
                ${labelHTML}
                <button onclick="${isCustomizeMode ? '' : 'window.toggleQuickSettings()'}" style="padding: 6px 10px; display: flex; align-items: center; gap: 6px; border-radius: 8px;" title="Quick Settings">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                    <path d="M18.36 6.64a9 9 0 1 1-12.73 0"/>
                    <line x1="12" y1="2" x2="12" y2="12"/>
                  </svg>
                </button>
              </div>
            `;
          case 'clock':
            return `
              <div class="${wrapperClass}" data-element-id="clock" ${dragAttrs} style="position: relative;">
                ${labelHTML}
                <button style="padding: 6px 14px; font-weight: 600; font-size: 12px; letter-spacing: 0.02em;">
                  ${state.currentTime.toLocaleString('en-US', {
                    weekday: 'short',
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false
                  }).replace(',', '')}
                </button>
              </div>
            `;
          default:
            return '';
        }
      }
      
      // Render the full context menu bar
      function renderContextMenuBar() {
        const layout = state.contextMenuLayout;
        const isCustomizeMode = state.contextMenuCustomizeMode;
        
        // Group elements by position
        const leftElements = layout.elements
          .filter(e => e.position === 'left' && e.visible)
          .sort((a, b) => a.order - b.order);
        const centerElements = layout.elements
          .filter(e => e.position === 'center' && e.visible)
          .sort((a, b) => a.order - b.order);
        const rightElements = layout.elements
          .filter(e => e.position === 'right' && e.visible)
          .sort((a, b) => a.order - b.order);
        
        const dropZoneAttrs = isCustomizeMode ? `
          ondragover="event.preventDefault(); event.currentTarget.classList.add('drag-over');"
          ondragleave="event.currentTarget.classList.remove('drag-over');"
        ` : '';
        
        return `
          <div class="menubar-left context-menu-drop-zone ${isCustomizeMode && leftElements.length === 0 ? 'empty' : ''}" 
               data-position="left" 
               ondrop="window.handleContextMenuDropZone(event, 'left')" ${dropZoneAttrs}>
            ${isCustomizeMode && leftElements.length === 0 ? '<span class="drop-zone-label">Left</span>' : ''}
            ${leftElements.map(e => renderContextMenuElement(e.id, isCustomizeMode)).join('')}
          </div>
          
          <div class="menubar-center context-menu-drop-zone ${isCustomizeMode && centerElements.length === 0 ? 'empty' : ''}" 
               data-position="center" 
               ondrop="window.handleContextMenuDropZone(event, 'center')" ${dropZoneAttrs}
               style="${centerElements.length === 0 && !isCustomizeMode ? 'display: none;' : ''}">
            ${isCustomizeMode && centerElements.length === 0 ? '<span class="drop-zone-label">Center</span>' : ''}
            ${centerElements.map(e => renderContextMenuElement(e.id, isCustomizeMode)).join('')}
          </div>
          
          <div class="menubar-right context-menu-drop-zone ${isCustomizeMode && rightElements.length === 0 ? 'empty' : ''}" 
               data-position="right" 
               ondrop="window.handleContextMenuDropZone(event, 'right')" ${dropZoneAttrs}>
            ${isCustomizeMode && rightElements.length === 0 ? '<span class="drop-zone-label">Right</span>' : ''}
            ${rightElements.map(e => renderContextMenuElement(e.id, isCustomizeMode)).join('')}
          </div>
        `;
      }
      
      // Context menu drag and drop handlers
      window.handleContextMenuDragStart = function(event, elementId) {
        state.contextMenuDragElement = elementId;
        event.currentTarget.classList.add('dragging');
        event.dataTransfer.effectAllowed = 'move';
        event.dataTransfer.setData('text/plain', elementId);
      };
      
      window.handleContextMenuDragEnd = function(event) {
        state.contextMenuDragElement = null;
        event.currentTarget.classList.remove('dragging');
        document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
      };
      
      window.handleContextMenuDragOver = function(event, targetElementId) {
        event.preventDefault();
        if (state.contextMenuDragElement && state.contextMenuDragElement !== targetElementId) {
          event.currentTarget.classList.add('drag-over');
        }
      };
      
      window.handleContextMenuDrop = function(event, targetElementId) {
        event.preventDefault();
        event.currentTarget.classList.remove('drag-over');
        
        if (!state.contextMenuDragElement || state.contextMenuDragElement === targetElementId) return;
        
        const layout = state.contextMenuLayout;
        const draggedElement = layout.elements.find(e => e.id === state.contextMenuDragElement);
        const targetElement = layout.elements.find(e => e.id === targetElementId);
        
        if (draggedElement && targetElement && draggedElement.position === targetElement.position) {
          // Swap orders within same position
          const tempOrder = draggedElement.order;
          draggedElement.order = targetElement.order;
          targetElement.order = tempOrder;
          
          localStorage.setItem('contextMenuLayout', JSON.stringify(layout));
          render();
        }
        
        state.contextMenuDragElement = null;
      };
      
      window.handleContextMenuDropZone = function(event, position) {
        event.preventDefault();
        event.currentTarget.classList.remove('drag-over');
        
        if (!state.contextMenuDragElement) return;
        
        const layout = state.contextMenuLayout;
        const draggedElement = layout.elements.find(e => e.id === state.contextMenuDragElement);
        
        if (draggedElement) {
          // Move element to new position
          const elementsInPosition = layout.elements.filter(e => e.position === position);
          const maxOrder = elementsInPosition.length > 0 ? Math.max(...elementsInPosition.map(e => e.order)) : -1;
          
          draggedElement.position = position;
          draggedElement.order = maxOrder + 1;
          
          // Recalculate orders to remove gaps
          ['left', 'center', 'right'].forEach(pos => {
            const elements = layout.elements.filter(e => e.position === pos).sort((a, b) => a.order - b.order);
            elements.forEach((e, i) => e.order = i);
          });
          
          localStorage.setItem('contextMenuLayout', JSON.stringify(layout));
          render();
        }
        
        state.contextMenuDragElement = null;
      };
      
      // Show position selector menu for an element
      window.showElementPositionMenu = function(event, elementId) {
        event.preventDefault();
        event.stopPropagation();
        
        const element = state.contextMenuLayout.elements.find(e => e.id === elementId);
        if (!element) return;
        
        const menuHTML = `
          <div class="menubar-context-menu" style="left: ${event.clientX}px; top: ${event.clientY}px; z-index: 100001;" onclick="event.stopPropagation()">
            <div class="menubar-context-menu-header">Move "${elementId}" to:</div>
            <div class="context-menu-item ${element.position === 'left' ? 'active' : ''}" onclick="window.moveContextMenuElement('${elementId}', 'left')">
               Left
            </div>
            <div class="context-menu-item ${element.position === 'center' ? 'active' : ''}" onclick="window.moveContextMenuElement('${elementId}', 'center')">
               Center
            </div>
            <div class="context-menu-item ${element.position === 'right' ? 'active' : ''}" onclick="window.moveContextMenuElement('${elementId}', 'right')">
               Right
            </div>
            <div class="context-menu-separator"></div>
            <div class="context-menu-item destructive" onclick="window.removeContextMenuElement('${elementId}')">
               Remove
            </div>
          </div>
        `;
        
        // Remove existing menus
        document.querySelectorAll('.menubar-context-menu').forEach(el => el.remove());
        
        // Add new menu
        document.body.insertAdjacentHTML('beforeend', menuHTML);
        
        // Auto-close on outside click
        setTimeout(() => {
          const handler = (e) => {
            if (!e.target.closest('.menubar-context-menu')) {
              document.querySelectorAll('.menubar-context-menu').forEach(el => el.remove());
              document.removeEventListener('click', handler);
            }
          };
          document.addEventListener('click', handler);
        }, 10);
      };
      
      window.moveContextMenuElement = function(elementId, newPosition) {
        const layout = state.contextMenuLayout;
        const element = layout.elements.find(e => e.id === elementId);
        
        if (element) {
          const elementsInPosition = layout.elements.filter(e => e.position === newPosition);
          const maxOrder = elementsInPosition.length > 0 ? Math.max(...elementsInPosition.map(e => e.order)) : -1;
          
          element.position = newPosition;
          element.order = maxOrder + 1;
          
          // Recalculate orders
          ['left', 'center', 'right'].forEach(pos => {
            const elements = layout.elements.filter(e => e.position === pos).sort((a, b) => a.order - b.order);
            elements.forEach((e, i) => e.order = i);
          });
          
          localStorage.setItem('contextMenuLayout', JSON.stringify(layout));
        }
        
        document.querySelectorAll('.menubar-context-menu').forEach(el => el.remove());
        render();
      };
      
      // Enter/exit customize mode
      window.enterContextMenuCustomizeMode = function() {
        state.contextMenuCustomizeMode = true;
        render();
      };
      
      window.exitContextMenuCustomizeMode = function() {
        state.contextMenuCustomizeMode = false;
        render();
      };
      
      window.resetContextMenuLayout = function() {
        state.contextMenuLayout = {
          elements: [
            { id: 'logo', position: 'left', order: 0, visible: true },
            { id: 'menus', position: 'left', order: 1, visible: true },
            { id: 'windowlist', position: 'left', order: 2, visible: false },
            { id: 'separator1', position: 'center', order: 0, visible: false },
            { id: 'workspaces', position: 'center', order: 1, visible: false },
            { id: 'clock', position: 'center', order: 2, visible: true },
            { id: 'separator2', position: 'right', order: 0, visible: false },
            { id: 'systray', position: 'right', order: 1, visible: true },
            { id: 'battery', position: 'right', order: 2, visible: false },
            { id: 'notifications', position: 'right', order: 3, visible: true },
            { id: 'quicksettings', position: 'right', order: 4, visible: false }
          ]
        };
        localStorage.setItem('contextMenuLayout', JSON.stringify(state.contextMenuLayout));
        render();
      };
      
      // Remove element from context menu bar (hide it)
      window.removeContextMenuElement = function(elementId) {
        const layout = state.contextMenuLayout;
        const element = layout.elements.find(e => e.id === elementId);
        if (element) {
          element.visible = false;
          localStorage.setItem('contextMenuLayout', JSON.stringify(layout));
          render();
        }
      };
      
      // Add element back to context menu bar
      window.addContextMenuElement = function(elementId, position = 'left') {
        const layout = state.contextMenuLayout;
        let element = layout.elements.find(e => e.id === elementId);
        if (!element) {
          // Element doesn't exist yet, add it
          element = { id: elementId, position: position, order: 0, visible: true };
          layout.elements.push(element);
        }
        element.visible = true;
        element.position = position;
        const elementsInPosition = layout.elements.filter(e => e.position === position && e.visible);
        element.order = elementsInPosition.length > 0 ? Math.max(...elementsInPosition.map(e => e.order)) + 1 : 0;
        localStorage.setItem('contextMenuLayout', JSON.stringify(layout));
        render();
      };
      
      // Show right-click context menu on the menubar
      window.showContextMenuRightClick = function(event) {
        event.preventDefault();
        state.menubarContextMenu = { x: event.clientX, y: event.clientY };
        render();
      };
      
      // ============= Workspace Functions =============
      window.switchWorkspace = function(workspaceNumber) {
        state.currentWorkspace = workspaceNumber;
        localStorage.setItem('currentWorkspace', workspaceNumber);
        render();
      };
      
      // ============= Notification Functions =============
      let notificationClockInterval = null;
      
      function updateNotificationClock() {
        const clockEl = document.getElementById('notification-clock-time');
        if (clockEl) {
          const now = new Date();
          clockEl.textContent = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false });
        }
      }
      
      window.toggleNotifications = function() {
        const notifPanel = document.querySelector('.notification-panel');
        
        if (state.showNotificationPanel) {
          // Closing - add closing class for animation
          if (notificationClockInterval) {
            clearInterval(notificationClockInterval);
            notificationClockInterval = null;
          }
          if (notifPanel) {
            notifPanel.classList.add('closing');
            notifPanel.classList.remove('active');
            setTimeout(() => {
              state.showNotificationPanel = false;
              render();
            }, 200);
          } else {
            state.showNotificationPanel = false;
            render();
          }
        } else {
          // Opening - close quick settings first
          state.showQuickSettings = false;
          state.showNotificationPanel = true;
          render();
          // Start clock update interval
          notificationClockInterval = setInterval(updateNotificationClock, 1000);
        }
      };
      
      window.addNotification = function(appName, title, message, icon = null) {
        const notification = {
          id: Date.now(),
          app: appName,
          title: title,
          message: message,
          icon: icon,
          time: new Date().toISOString()
        };
        state.notifications.unshift(notification);
        state.notificationCount = state.notifications.length;
        localStorage.setItem('mosNotifications', JSON.stringify(state.notifications));
        playSound('notification');
        render();
        return notification.id;
      };
      
      window.removeNotification = function(id) {
        state.notifications = state.notifications.filter(n => n.id !== id);
        state.notificationCount = state.notifications.length;
        localStorage.setItem('mosNotifications', JSON.stringify(state.notifications));
        render();
      };
      
      window.clearNotifications = function() {
        state.notifications = [];
        state.notificationCount = 0;
        localStorage.setItem('mosNotifications', JSON.stringify([]));
        render();
      };
      
      window.changeCalendarMonth = function(delta) {
        state.calendarMonth += delta;
        if (state.calendarMonth > 11) {
          state.calendarMonth = 0;
          state.calendarYear++;
        } else if (state.calendarMonth < 0) {
          state.calendarMonth = 11;
          state.calendarYear--;
        }
        render();
      };
      
      window.toggleCalendar = function() {
        state.calendarExpanded = !state.calendarExpanded;
        render();
      };
      
      window.adjustFocusTimer = function(delta) {
        state.focusTimerMinutes = Math.max(5, Math.min(120, state.focusTimerMinutes + delta));
        render();
      };
      
      window.toggleFocusMode = function() {
        state.focusEnabled = !state.focusEnabled;
        localStorage.setItem('focusEnabled', state.focusEnabled);
        if (state.focusEnabled) {
          window.addNotification('System', 'Focus Mode', `Focus mode enabled for ${state.focusTimerMinutes} minutes`);
        } else {
          window.addNotification('System', 'Focus Mode', 'Focus mode disabled');
        }
        render();
      };
      
      // Load notification count on startup
      state.notificationCount = state.notifications.length;
      
      // ============= Quick Settings Toggle Functions =============
      window.toggleWifi = function() {
        state.wifiEnabled = !state.wifiEnabled;
        localStorage.setItem('wifiEnabled', state.wifiEnabled);
        render();
      };
      
      window.toggleBluetooth = function() {
        state.bluetoothEnabled = !state.bluetoothEnabled;
        localStorage.setItem('bluetoothEnabled', state.bluetoothEnabled);
        render();
      };
      
      window.toggleShare = function() {
        state.shareEnabled = !state.shareEnabled;
        localStorage.setItem('shareEnabled', state.shareEnabled);
        render();
      };
      
      window.toggleFocus = function() {
        state.focusEnabled = !state.focusEnabled;
        localStorage.setItem('focusEnabled', state.focusEnabled);
        render();
      };
      
      // ============= End Panel Functions =============

      // Helper function to calculate dock dimensions based on scale
      function getDockDimensions() {
        const scale = state.dockScale || 1.0;
        const baseIconSize = 48;
        const basePadding = 6;
        const baseGap = 4; // Gap between icons
        const sidePadding = 10; // Left/right padding in dock
        
        // Calculate total number of dock icons
        const pinnedCount = state.pinnedApps.length;
        const unpinnedOpenApps = apps.filter(app => 
          !state.pinnedApps.includes(app.id) && 
          state.windows.some(w => w.appId === app.id)
        );
        const unpinnedCount = unpinnedOpenApps.length;
        const finderCount = 1; // Always present
        
        // Number of dividers (one before unpinned section if exists, one before finder)
        const dividerCount = (unpinnedCount > 0 ? 1 : 0) + 1;
        
        const totalIcons = pinnedCount + unpinnedCount + finderCount;
        
        return {
          iconSize: Math.round(baseIconSize * scale),
          padding: Math.round(basePadding * scale),
          gap: Math.round(baseGap * scale),
          // Calculate dock space for different positions
          // Bottom: padding-top + icon-height + padding-bottom + spacing + border
          getBottomSpace: () => {
            return 4 + // bottom spacing from edge
                   Math.round(basePadding * scale) + // top padding
                   Math.round(baseIconSize * scale) + // icon height
                   Math.round(basePadding * scale) + // bottom padding
                   8; // extra spacing
          },
          // Side: left/right spacing + padding + icon width + padding + border-radius
          getSideSpace: () => {
            return 8 + // left/right spacing from edge
                   Math.round(sidePadding * scale) + // side padding
                   Math.round(baseIconSize * scale) + // icon width
                   Math.round(sidePadding * scale) + // side padding
                   8; // extra spacing
          }
        };
      }


      function init() {
        localStorage.removeItem('windows');
        localStorage.removeItem('openWindows');

        // Debug: log loaded window states
        console.log('Loaded windowStates from localStorage:', state.windowStates);

        // Apply custom cursor if set
        if (state.customCursor) {
          document.body.style.cursor = `url('${state.customCursor}') 0 0, auto`;
        }

        // Load pinned apps from localStorage with proper validation
        const savedPinned = localStorage.getItem('pinnedApps');
        if (savedPinned) {
          try {
            const parsed = JSON.parse(savedPinned);
            // Validate that all saved apps still exist in the apps array
            const validPinned = parsed.filter(id => apps.find(app => app.id === id));
            state.pinnedApps = validPinned.length > 0 ? validPinned : ['finder', 'files', 'terminal', 'browser', 'mail', 'music'];
            // Save cleaned up version
            localStorage.setItem('pinnedApps', JSON.stringify(state.pinnedApps));
          } catch (e) {
            state.pinnedApps = ['finder', 'files', 'terminal', 'browser', 'mail', 'music'];
            localStorage.setItem('pinnedApps', JSON.stringify(state.pinnedApps));
          }
        } else {
          state.pinnedApps = ['finder', 'files', 'terminal', 'browser', 'mail', 'music'];
          localStorage.setItem('pinnedApps', JSON.stringify(state.pinnedApps));
        }

        const theme = localStorage.getItem('theme');
        if (theme === 'dark' || !theme) {
          // Default to dark mode like Ubuntu
          state.isDark = true;
          document.documentElement.classList.add('dark');
          if (!theme) localStorage.setItem('theme', 'dark');
        } else {
          state.isDark = false;
          document.documentElement.classList.remove('dark');
        }

        // Apply OS theme class - always macOS
        document.documentElement.classList.add('macos');

        // Define built-in wallpapers with external URLs (macOS only)
        const builtInWallpapers = {
          '-2': { // Tahoe
            light: 'https://raw.githubusercontent.com/Matko802/my-web-os-things/refs/heads/main/26-Tahoe-Light-1080x1920.png',
            dark: 'https://raw.githubusercontent.com/Matko802/my-web-os-things/refs/heads/main/26-Tahoe-Dark-1080x1920.png',
            name: 'Tahoe'
          },
          '-3': { // macOS Sonoma (default)
            light: 'https://512pixels.net/downloads/macos-wallpapers-thumbs/14-0-Sonoma-L.jpg',
            dark: 'https://512pixels.net/downloads/macos-wallpapers-thumbs/14-0-Sonoma-D.jpg',
            name: 'Sonoma'
          }
        };
        
        // Set initial wallpaper based on theme
        const savedWallpaper = localStorage.getItem('customWallpaper');
        const activeCustomIdx = parseInt(localStorage.getItem('activeCustomWallpaper') || '-2');
        
        if (activeCustomIdx >= 0 && state.customWallpapers[activeCustomIdx]) {
          // Use active custom wallpaper
          const customWallpaper = state.customWallpapers[activeCustomIdx];
          const wallpaperURL = state.isDark ? customWallpaper.dark : customWallpaper.light;
          state.customWallpaper = wallpaperURL;
        } else if (activeCustomIdx < 0 && builtInWallpapers[activeCustomIdx]) {
          // Use built-in wallpaper from localStorage or URL
          const wallpaper = builtInWallpapers[activeCustomIdx];
          const wallpaperURL = state.isDark ? wallpaper.dark : wallpaper.light;
          state.customWallpaper = savedWallpaper || wallpaperURL;
          if (!savedWallpaper) {
            localStorage.setItem('customWallpaper', wallpaperURL);
          }
        } else {
          // Default to Tahoe
          const defaultIdx = '-2';
          const wallpaperURL = state.isDark ? builtInWallpapers[defaultIdx].dark : builtInWallpapers[defaultIdx].light;
          state.customWallpaper = savedWallpaper || wallpaperURL;
          if (!savedWallpaper) {
            localStorage.setItem('customWallpaper', wallpaperURL);
            localStorage.setItem('activeCustomWallpaper', defaultIdx);
          }
        }

        // Apply no-animations class if animations are disabled
        if (!state.animationsEnabled) {
          document.body.classList.add('no-animations');
        }

        // Note: Minecraft installation is detected at runtime, not persisted

        // Initialize accent color
        const savedAccentColor = localStorage.getItem('accentColor');
        if (savedAccentColor) {
          const hexToHSL = (hex) => {
            const r = parseInt(hex.slice(1, 3), 16) / 255;
            const g = parseInt(hex.slice(3, 5), 16) / 255;
            const b = parseInt(hex.slice(5, 7), 16) / 255;
            
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
              h = s = 0;
            } else {
              const d = max - min;
              s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
              
              switch (max) {
                case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                case g: h = ((b - r) / d + 2) / 6; break;
                case b: h = ((r - g) / d + 4) / 6; break;
              }
            }
            
            h = Math.round(h * 360);
            s = Math.round(s * 100);
            l = Math.round(l * 100);
            
            return `${h} ${s}% ${l}%`;
          };
          
          const hslColor = hexToHSL(savedAccentColor);
          document.documentElement.style.setProperty('--primary', hslColor);
          document.documentElement.style.setProperty('--ubuntu-orange', hslColor);
        } else {
          // Set default accent color - macOS blue
          const defaultAccent = '#007AFF';
          state.accentColor = defaultAccent;
          localStorage.setItem('accentColor', defaultAccent);
          const hexToHSLDefault = (hex) => {
            const r = parseInt(hex.slice(1, 3), 16) / 255;
            const g = parseInt(hex.slice(3, 5), 16) / 255;
            const b = parseInt(hex.slice(5, 7), 16) / 255;
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            if (max === min) { h = s = 0; }
            else {
              const d = max - min;
              s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
              switch (max) {
                case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                case g: h = ((b - r) / d + 2) / 6; break;
                case b: h = ((r - g) / d + 4) / 6; break;
              }
            }
            return `${Math.round(h * 360)} ${Math.round(s * 100)}% ${Math.round(l * 100)}%`;
          };
          const hslDefault = hexToHSLDefault(defaultAccent);
          document.documentElement.style.setProperty('--primary', hslDefault);
          document.documentElement.style.setProperty('--ubuntu-orange', hslDefault);
        }
        
        // Initialize component style classes
        if (typeof updateComponentClasses === 'function') {
          updateComponentClasses();
        } else {
          // Fallback: apply default classes
          const root = document.documentElement;
          root.classList.add('macos-dock');
          root.classList.add('macos-menubar');
          root.classList.add('macos-windows');
        }
        
        // Apply window effects
        document.documentElement.style.setProperty('--window-opacity', state.windowOpacity);
        document.documentElement.style.setProperty('--window-blur', state.windowBlur + 'px');
        
        // Apply system font
        if (state.systemFont && state.systemFont !== 'Ubuntu') {
          document.body.style.fontFamily = `'${state.systemFont}', 'Segoe UI', Roboto, sans-serif`;
        }


        // Handle window resize for borderless fullscreen windows
        window.addEventListener('resize', function() {
          // Update fullscreen windows to match new screen size
          state.windows.forEach(win => {
            if (win.isFullscreen) {
              const windowEl = document.getElementById(`window-${win.id}`);
              if (windowEl) {
                windowEl.style.width = '100vw';
                windowEl.style.height = '100vh';
                windowEl.style.top = '0';
                windowEl.style.left = '0';
              }
            }
          });
          // Also update maximized windows
          state.windows.forEach(win => {
            if (win.isMaximized) {
              const windowEl = document.getElementById(`window-${win.id}`);
              if (windowEl) {
                const dockPosition = state.dockPosition || 'bottom';
                const menubarHeight = 28;
                const dockDims = getDockDimensions();
                const dockSpaceBottom = dockPosition === 'bottom' ? dockDims.getBottomSpace() : 0;
                const dockSpaceSide = (dockPosition === 'left' || dockPosition === 'right') ? dockDims.getSideSpace() : 0;
                const targetWidth = window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0);
                const targetHeight = window.innerHeight - menubarHeight - dockSpaceBottom;
                const targetLeft = dockPosition === 'left' ? dockSpaceSide : 0;
                windowEl.style.width = `${targetWidth}px`;
                windowEl.style.height = `${targetHeight}px`;
                windowEl.style.top = `${menubarHeight}px`;
                windowEl.style.left = `${targetLeft}px`;
              }
            }
          });
        });

        setInterval(() => {
          state.currentTime = new Date();
          updateTime();
        }, 1000);

        document.addEventListener('contextmenu', (e) => {
          // Allow menubar context menu
          if (e.target.closest('.menubar')) {
            e.preventDefault();
            const menubar = e.target.closest('.menubar');
            const menubarRect = menubar.getBoundingClientRect();
            // Position the context menu at click position, but ensure it stays on screen
            let x = e.clientX;
            let y = e.clientY;
            // Prevent menu from going off-screen (menu is ~180px wide, ~120px tall)
            if (x + 180 > window.innerWidth) x = window.innerWidth - 190;
            if (y + 120 > window.innerHeight) y = window.innerHeight - 130;
            if (x < 10) x = 10;
            if (y < 10) y = 10;
            state.menubarContextMenu = { x, y };
            state.contextMenu = null; // Close any dock context menu
            render();
            return;
          }
          e.preventDefault();
        });
        document.addEventListener('click', (e) => {
          // If a window snap animation is in progress, skip this click's re-render
          // so the animation isn't killed by a full DOM rebuild.
          if (state.isSnappingWindow) return;
          
          // Skip render() during active window/dock dragging to eliminate flicker
          if (dragState || dockDragState || resizeState) return;
          
          // Don't clear context menu or re-render if user has text selected
          const selection = window.getSelection();
          const hasSelection = selection && selection.toString().length > 0;
          
          if (!hasSelection && !e.target.closest('.context-menu') && !e.target.closest('.dock-icon') && !e.target.closest('.menubar-context-menu')) {
            state.contextMenu = null;
            state.menubarContextMenu = null;
            // Close quick settings if clicking outside (with animation)
            if (!e.target.closest('.quick-settings') && !e.target.closest('[onclick*="toggleQuickSettings"]') && !e.target.closest('.notification-panel')) {
              if (state.showQuickSettings) {
                const quickSettingsEl = document.querySelector('.quick-settings');
                if (quickSettingsEl) {
                  quickSettingsEl.classList.add('closing');
                  quickSettingsEl.classList.remove('active');
                  setTimeout(() => {
                    state.showQuickSettings = false;
                    render();
                  }, 200);
                  return; // Don't render immediately
                }
              }
            }
            // Close notification panel if clicking outside (with animation)
            if (!e.target.closest('.notification-panel') && !e.target.closest('[onclick*="toggleNotifications"]') && !e.target.closest('.quick-settings')) {
              if (state.showNotificationPanel) {
                const notifPanel = document.querySelector('.notification-panel');
                if (notifPanel) {
                  notifPanel.classList.add('closing');
                  notifPanel.classList.remove('active');
                  setTimeout(() => {
                    state.showNotificationPanel = false;
                    render();
                  }, 200);
                  return;
                }
              }
            }
            // Clear active bookmark/site actions when clicking elsewhere
            if (!e.target.closest('.browser-bookmark') && !e.target.closest('.browser-site-card')) {
              state.activeBookmarkIndex = null;
              state.activeSiteIndex = null;
            }
            render();
          }
        });

        // Listen for fullscreen changes to update maximized windows
        document.addEventListener('fullscreenchange', () => {
          // When entering/exiting fullscreen, update all maximized windows
          const maximizedWindows = state.windows.filter(w => w.isMaximized && !w.isMinimized);
          maximizedWindows.forEach(win => {
            const windowEl = document.getElementById(`window-${win.id}`);
            if (windowEl) {
              const dockPosition = state.dockPosition || 'bottom';
              const menubarHeight = 28;
              const dockDims = getDockDimensions();
              
              const dockSpaceBottom = dockPosition === 'bottom' ? dockDims.getBottomSpace() : 0;
              const dockSpaceSide = (dockPosition === 'left' || dockPosition === 'right') ? dockDims.getSideSpace() : 0;
              const targetWidth = window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0);
              const targetHeight = window.innerHeight - menubarHeight - dockSpaceBottom;
              const targetLeft = dockPosition === 'left' ? dockSpaceSide : 0;
              const targetTop = menubarHeight;
              
              windowEl.style.top = `${targetTop}px`;
              windowEl.style.left = `${targetLeft}px`;
              windowEl.style.width = `${targetWidth}px`;
              windowEl.style.height = `${targetHeight}px`;
            }
          });
        });

        // Global F11 handler - use capture phase to intercept before iframes
        // This will work even when focus is inside an iframe
        document.addEventListener('keydown', (e) => {
          if (e.key === 'F11') {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            
            // Toggle browser fullscreen for the entire desktop OS
            if (!document.fullscreenElement) {
              document.documentElement.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
              });
            } else {
              document.exitFullscreen().catch(err => {
                console.error(`Error attempting to exit fullscreen: ${err.message}`);
              });
            }
            return false;
          }
        }, true); // capture: true to intercept before iframes
        
        window.addEventListener('keydown', (e) => {
          
          // Block common browser keybinds when in fullscreen mode to make OS usable
          if (document.fullscreenElement) {
            const key = e.key.toLowerCase();
            const isCtrl = e.ctrlKey || e.metaKey;
            const isAlt = e.altKey;
            const isShift = e.shiftKey;
            
            // Block Ctrl+key combinations that browsers use
            if (isCtrl && !isAlt) {
              const blockedCtrlKeys = [
                't', // new tab
                'w', // close tab
                'n', // new window
                'r', // reload
                'p', // print
                's', // save
                'f', // find
                'g', // find next
                'h', // history
                'j', // downloads
                'k', // search (some browsers)
                'l', // address bar
                'd', // bookmark
                'b', // bookmarks bar
                'o', // open file
                'u', // view source
                'q', // quit
                '+', // zoom in
                '-', // zoom out
                '=', // zoom in (alternative)
                '0', // reset zoom
                'tab', // switch tabs
              ];
              
              // Ctrl+Shift combinations
              const blockedCtrlShiftKeys = [
                't', // reopen closed tab
                'n', // incognito window
                'w', // close window
                'j', // downloads
                'i', // developer tools
                'c', // developer tools
                'delete', // clear browsing data
                'tab', // switch tabs reverse
                'b', // bookmarks manager
                'o', // bookmarks manager
                'm', // user profiles
                'p', // print preview
              ];
              
              if (isShift) {
                if (blockedCtrlShiftKeys.includes(key)) {
                  e.preventDefault();
                  e.stopPropagation();
                  return;
                }
              } else {
                if (blockedCtrlKeys.includes(key)) {
                  // Allow Ctrl+C, Ctrl+V, Ctrl+X, Ctrl+A, Ctrl+Z for normal text operations in input fields
                  const isInputField = e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable;
                  const allowedInInputs = ['c', 'v', 'x', 'a', 'z', 'y'];
                  if (isInputField && allowedInInputs.includes(key)) {
                    return; // Allow these in input fields
                  }
                  e.preventDefault();
                  e.stopPropagation();
                  return;
                }
              }
            }
            
            // Block Alt+key combinations
            if (isAlt && !isCtrl) {
              const blockedAltKeys = [
                'home', // home page
                'arrowleft', // back
                'arrowright', // forward
                'd', // address bar
                'f4', // close window
                'f', // file menu
                'e', // edit menu
                'v', // view menu
                'h', // help menu
                't', // tools menu
              ];
              
              if (blockedAltKeys.includes(key)) {
                e.preventDefault();
                e.stopPropagation();
                return;
              }
            }
            
            // Block function keys that browsers use
            const blockedFunctionKeys = [
              'f1', // help
              'f3', // find
              'f5', // reload
              'f6', // address bar
              'f7', // caret browsing
              'f10', // menu bar
              'f12', // developer tools
            ];
            
            if (blockedFunctionKeys.includes(key)) {
              e.preventDefault();
              e.stopPropagation();
              return;
            }
          }
          
          // Track Ctrl+Alt key state for launchpad (only opens on release)
          if (!state.ctrlAltState) {
            state.ctrlAltState = { ctrlDown: false, altDown: false, usedForShortcut: false };
          }
          
          // Track key presses
          if (e.key === 'Control') state.ctrlAltState.ctrlDown = true;
          if (e.key === 'Alt') state.ctrlAltState.altDown = true;
          
          // Handle Ctrl+Alt+; or Ctrl+Alt+` to open Task Manager (bypasses launchpad)
          if (e.ctrlKey && e.altKey && (e.key === ';' || e.key === '`' || e.key === 'Backquote')) {
            // Don't trigger if user is typing in an input field
            if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
              e.preventDefault();
              state.ctrlAltState.usedForShortcut = true; // Mark that we used this combo for a shortcut
              // Open Task Manager
              window.toggleWindow('taskmanager');
            }
            return;
          }
          
          // Don't interfere with input fields (except for launchpad search Escape)
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            // Handle Escape for launchpad search or fullscreen exit
            if (e.key === 'Escape') {
              if (state.showLaunchpad) {
                window.closeLaunchpad();
                return;
              }
              const fullscreenWindow = state.windows.find((w) => w.isFullscreen);
              if (fullscreenWindow) {
                toggleFullscreen(fullscreenWindow.id);
              }
            }
            return;
          }
          
          if (e.key === 'Escape') {
            // Close launchpad first if open
            if (state.showLaunchpad) {
              window.closeLaunchpad();
              return;
            }
            // Otherwise check for fullscreen window
            const fullscreenWindow = state.windows.find((w) => w.isFullscreen);
            if (fullscreenWindow) {
              toggleFullscreen(fullscreenWindow.id);
            }
          }
        }, true);
        
        // Handle keyup for Ctrl+Alt release to open launchpad
        window.addEventListener('keyup', (e) => {
          if (!state.ctrlAltState) {
            state.ctrlAltState = { ctrlDown: false, altDown: false, usedForShortcut: false };
          }
          
          const wasCtrlAltHeld = state.ctrlAltState.ctrlDown && state.ctrlAltState.altDown;
          const usedForShortcut = state.ctrlAltState.usedForShortcut;
          
          // Track key releases
          if (e.key === 'Control') state.ctrlAltState.ctrlDown = false;
          if (e.key === 'Alt') state.ctrlAltState.altDown = false;
          
          // If both Ctrl and Alt were held and now one is released, and wasn't used for a shortcut
          if (wasCtrlAltHeld && !usedForShortcut && (e.key === 'Control' || e.key === 'Alt')) {
            // Don't trigger if user is typing in an input field
            if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
              e.preventDefault();
              state.showLaunchpad = !state.showLaunchpad;
              render();
              // Focus the search input after render when opening
              if (state.showLaunchpad) {
                setTimeout(() => {
                  const searchInput = document.querySelector('.launchpad-search');
                  if (searchInput) {
                    searchInput.focus();
                  }
                }, 50);
              }
            }
          }
          
          // Reset shortcut flag when both keys are released
          if (!state.ctrlAltState.ctrlDown && !state.ctrlAltState.altDown) {
            state.ctrlAltState.usedForShortcut = false;
          }
        }, true);

        render();
      }

      window.toggleTheme = function toggleTheme() {
        console.log('Theme toggle clicked! Current state:', state.isDark);
        state.isDark = !state.isDark;
        console.log('New theme state:', state.isDark ? 'dark' : 'light');
        
        // Create and trigger the pulse/glow overlay animation
        let overlay = document.querySelector('.theme-transition-overlay');
        if (!overlay) {
          overlay = document.createElement('div');
          overlay.className = 'theme-transition-overlay';
          document.body.appendChild(overlay);
        }
        overlay.style.setProperty('--pulse-color', state.accentColor + '40');
        overlay.classList.remove('active');
        void overlay.offsetWidth; // Force reflow
        overlay.classList.add('active');
        setTimeout(() => overlay.classList.remove('active'), 500);
        
        // Apply theme change immediately
        if (state.isDark) {
          document.documentElement.classList.add('dark');
          localStorage.setItem('theme', 'dark');
          // Set wallpaper based on active custom or default
          const builtInWallpapers = {
            '-2': { 
              light: 'https://raw.githubusercontent.com/Matko802/my-web-os-things/refs/heads/main/26-Tahoe-Light-1080x1920.png',
              dark: 'https://raw.githubusercontent.com/Matko802/my-web-os-things/refs/heads/main/26-Tahoe-Dark-1080x1920.png'
            },
            '-3': { 
              light: 'https://512pixels.net/downloads/macos-wallpapers-thumbs/14-0-Sonoma-L.jpg',
              dark: 'https://512pixels.net/downloads/macos-wallpapers-thumbs/14-0-Sonoma-D.jpg'
            },
          };
          
          if (state.activeCustomWallpaper >= 0 && state.customWallpapers[state.activeCustomWallpaper]) {
            const customWallpaper = state.customWallpapers[state.activeCustomWallpaper];
            window.setWallpaperFromURL(customWallpaper.dark);
          } else if (state.activeCustomWallpaper < 0 && builtInWallpapers[state.activeCustomWallpaper]) {
            window.setWallpaperFromURL(builtInWallpapers[state.activeCustomWallpaper].dark);
          } else {
            window.setWallpaperFromURL(builtInWallpapers['-2'].dark);
          }
        } else {
          document.documentElement.classList.remove('dark');
          localStorage.setItem('theme', 'light');
          // Set wallpaper based on active custom or default
          const builtInWallpapers = {
            '-2': { 
              light: 'https://raw.githubusercontent.com/Matko802/my-web-os-things/refs/heads/main/26-Tahoe-Light-1080x1920.png',
              dark: 'https://raw.githubusercontent.com/Matko802/my-web-os-things/refs/heads/main/26-Tahoe-Dark-1080x1920.png'
            },
            '-3': { 
              light: 'https://512pixels.net/downloads/macos-wallpapers-thumbs/14-0-Sonoma-L.jpg',
              dark: 'https://512pixels.net/downloads/macos-wallpapers-thumbs/14-0-Sonoma-D.jpg'
            },
          };
          
          if (state.activeCustomWallpaper >= 0 && state.customWallpapers[state.activeCustomWallpaper]) {
            const customWallpaper = state.customWallpapers[state.activeCustomWallpaper];
            window.setWallpaperFromURL(customWallpaper.light);
          } else if (state.activeCustomWallpaper < 0 && builtInWallpapers[state.activeCustomWallpaper]) {
            window.setWallpaperFromURL(builtInWallpapers[state.activeCustomWallpaper].light);
          } else {
            window.setWallpaperFromURL(builtInWallpapers['-2'].light);
          }
        }
        
        // Update ALL theme icons with spinning animation (menubar + Quick Settings)
        const themeIcons = document.querySelectorAll('.theme-toggle-icon');
        themeIcons.forEach(themeIcon => {
          themeIcon.classList.add('transitioning');
          
          // Switch icon halfway through the rotation for smooth transition
          setTimeout(() => {
            themeIcon.innerHTML = state.isDark ? icons.Moon : icons.Sun;
          }, 300); // Halfway through the 600ms spinning animation
          
          // Remove transitioning class after animation completes
          setTimeout(() => {
            themeIcon.classList.remove('transitioning');
          }, 600);
        });
        
        // Update Quick Settings button active state
        const qsThemeBtn = document.querySelector('.quick-settings-icon-btn .qs-theme-icon');
        if (qsThemeBtn) {
          const btn = qsThemeBtn.closest('.quick-settings-icon-btn');
          if (btn) {
            if (state.isDark) {
              btn.classList.add('active');
            } else {
              btn.classList.remove('active');
            }
          }
        }
        
        // Update all toggle switches in settings to match new state
        const toggleSwitches = document.querySelectorAll('.toggle-switch');
        toggleSwitches.forEach(toggle => {
          const onclickStr = toggle.getAttribute('onclick');
          if (onclickStr && onclickStr.includes('toggleTheme')) {
            if (state.isDark) {
              toggle.classList.add('active');
            } else {
              toggle.classList.remove('active');
            }
          }
        });

        // Delay render to allow smooth CSS color transitions to complete first
        setTimeout(() => {
          render();
        }, 350);
      };
      
      window.toggleQuickSettings = function toggleQuickSettings() {
        const quickSettingsEl = document.querySelector('.quick-settings');
        
        if (state.showQuickSettings) {
          // Closing - add closing class for animation
          if (quickSettingsEl) {
            quickSettingsEl.classList.add('closing');
            quickSettingsEl.classList.remove('active');
            setTimeout(() => {
              state.showQuickSettings = false;
              render();
            }, 200);
          } else {
            state.showQuickSettings = false;
            render();
          }
        } else {
          // Opening
          state.showQuickSettings = true;
          render();
        }
      };

      // Helper functions to get effective style for each component - always macOS
      window.getEffectiveDockStyle = function() {
        return 'macos';
      };
      
      window.getEffectiveMenubarStyle = function() {
        return 'macos';
      };
      
      window.getEffectiveWindowStyle = function() {
        return 'macos';
      };
      
      // Functions to set component styles
      window.setComponentStyle = function(component, style) {
        if (component === 'dock') {
          state.dockStyle = style;
          localStorage.setItem('dockStyle', style);
        } else if (component === 'menubar') {
          state.menubarStyle = style;
          localStorage.setItem('menubarStyle', style);
        } else if (component === 'window') {
          state.windowStyle = style;
          localStorage.setItem('windowStyle', style);
        }
        
        // Update CSS classes
        updateComponentClasses();
        render();
      };
      
      function updateComponentClasses() {
        const root = document.documentElement;
        
        // Remove all component-specific classes
        root.classList.remove('macos-dock', 'macos-menubar', 'macos-windows', 'window-transparent');
        
        // Add macOS classes
        root.classList.add('macos-dock');
        root.classList.add('macos-menubar');
        root.classList.add('macos-windows');
        
        // Add transparency class if enabled
        if (state.windowOpacity < 1 || state.windowBlur > 0) {
          root.classList.add('window-transparent');
        }
        
        // Apply CSS custom properties
        root.style.setProperty('--window-opacity', state.windowOpacity);
        root.style.setProperty('--window-blur', state.windowBlur + 'px');
      }
      
      // Window customization functions
      window.setWindowOpacity = function(opacity) {
        state.windowOpacity = parseFloat(opacity);
        localStorage.setItem('windowOpacity', opacity);
        document.documentElement.style.setProperty('--window-opacity', opacity);
        updateComponentClasses();
        render();
      };
      
      window.setWindowBlur = function(blur) {
        state.windowBlur = parseInt(blur);
        localStorage.setItem('windowBlur', blur);
        document.documentElement.style.setProperty('--window-blur', blur + 'px');
        updateComponentClasses();
        render();
      };
      
      window.resetWindowEffects = function() {
        // Reset to defaults: 35% transparency (0.65 opacity), 20px blur
        state.windowOpacity = 0.65;
        state.windowBlur = 20;
        localStorage.setItem('windowOpacity', '0.65');
        localStorage.setItem('windowBlur', '20');
        document.documentElement.style.setProperty('--window-opacity', '0.65');
        document.documentElement.style.setProperty('--window-blur', '20px');
        updateComponentClasses();
        render();
      };
      
      window.setSystemFont = function(font) {
        state.systemFont = font;
        localStorage.setItem('systemFont', font);
        document.body.style.fontFamily = `'${font}', 'Segoe UI', Roboto, sans-serif`;
        render();
      };

      window.switchSettingsTab = function switchSettingsTab(tab) {
        state.settingsTab = tab;
        localStorage.setItem('settingsTab', tab);
        render();
      };

      window.setAccentColor = function setAccentColor(color) {
        state.accentColor = color;
        localStorage.setItem('accentColor', color);
        
        // Convert hex to HSL for CSS variable
        const hexToHSL = (hex) => {
          const r = parseInt(hex.slice(1, 3), 16) / 255;
          const g = parseInt(hex.slice(3, 5), 16) / 255;
          const b = parseInt(hex.slice(5, 7), 16) / 255;
          
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          let h, s, l = (max + min) / 2;
          
          if (max === min) {
            h = s = 0;
          } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            
            switch (max) {
              case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
              case g: h = ((b - r) / d + 2) / 6; break;
              case b: h = ((r - g) / d + 4) / 6; break;
            }
          }
          
          h = Math.round(h * 360);
          s = Math.round(s * 100);
          l = Math.round(l * 100);
          
          return `${h} ${s}% ${l}%`;
        };
        
        // Update CSS variable
        const root = document.documentElement;
        const hslColor = hexToHSL(color);
        root.style.setProperty('--primary', hslColor);
        root.style.setProperty('--ubuntu-orange', hslColor);
        
        render();
      };

      window.showCustomColorPicker = function showCustomColorPicker() {
        const input = document.createElement('input');
        input.type = 'color';
        input.value = state.accentColor;
        input.style.position = 'absolute';
        input.style.opacity = '0';
        input.style.pointerEvents = 'none';
        document.body.appendChild(input);
        
        input.addEventListener('change', (e) => {
          window.setAccentColor(e.target.value);
          document.body.removeChild(input);
        });
        
        input.click();
      };


      window.filterSettingsItems = function filterSettingsItems(query) {
        state.settingsSearchQuery = query;
        
        // Update only the settings sidebar content instead of full re-render
        const settingsSidebar = document.querySelector('.settings-sidebar > div:last-child');
        if (settingsSidebar) {
          const activeTab = state.settingsTab || 'appearance';
          
          const settingsItems = [
            { id: 'general', label: 'General', icon: '<circle cx="12" cy="12" r="3"/><path d="M12 1v6m0 6v6m9-9h-6m-6 0H3"/>' },
            { id: 'appearance', label: 'Appearance', icon: '<circle cx="12" cy="12" r="10"/><path d="M12 2a10 10 0 0 1 0 20"/>' },
            { id: 'control-centre', label: 'Control Centre', icon: '<circle cx="12" cy="12" r="3"/><circle cx="19" cy="5" r="2"/><circle cx="5" cy="19" r="2"/><path d="M10.4 10.4 7 7m7.6 7.6 3.4 3.4"/>' },
            { id: 'desktop-dock', label: 'Desktop & Dock', icon: '<rect x="2" y="3" width="20" height="14" rx="2"/><path d="M8 21h8M12 17v4"/>' },
            { id: 'notifications', label: 'Notifications', icon: '<path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9M13.73 21a2 2 0 0 1-3.46 0"/>' },
            { id: 'sound', label: 'Sound', icon: '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/>' },
            { id: 'mouse', label: 'Mouse & Cursor', icon: '<path d="M12 2v6m-2-2 2-2 2 2M12 22v-6m-2 2 2 2 2-2"/><path d="M6 12H2m4-2-2 2 2 2M22 12h-4m2-2-2 2 2 2"/>' },
            { id: 'system', label: 'System', icon: '<rect x="4" y="4" width="16" height="16" rx="2"/><rect x="9" y="9" width="6" height="6"/><path d="M9 1v2M15 1v2M9 21v2M15 21v2M1 9h2M1 15h2M21 9h2M21 15h2"/>' }
          ];
          
          const filteredItems = settingsItems.filter(item => 
            item.label.toLowerCase().includes(query.toLowerCase())
          );
          
          settingsSidebar.innerHTML = `
            ${filteredItems.map(item => `
              <div class="settings-nav-item ${activeTab === item.id ? 'active' : ''}" onclick="event.stopPropagation(); window.switchSettingsTab('${item.id}')">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  ${item.icon}
                </svg>
                <span>${item.label}</span>
              </div>
            `).join('')}
            ${filteredItems.length === 0 ? '<div style="padding: 12px; text-align: center; color: rgba(255,255,255,0.5); font-size: 13px;">No results found</div>' : ''}
          `;
        }
      };

      function getSettingsContent(activeTab) {
        switch (activeTab) {
          case 'general':
            return `
              <div class="settings-section">
                <h2 style="font-size: 28px; font-weight: 700; margin-bottom: 24px; color: hsl(var(--foreground));">General</h2>
                <div class="settings-item">
                  <div>
                    <div class="settings-label">About This Computer</div>
                    <div class="settings-description">MOS Web Desktop v1.0.0</div>
                  </div>
                </div>
              </div>
            `;
            
          case 'appearance':
            return `
              <div class="settings-section" style="max-width: 700px; margin: 0 auto;">
                <h2 style="font-size: 20px; font-weight: 600; margin-bottom: 16px; color: hsl(var(--foreground));">Style</h2>
                <div style="background: hsl(var(--accent) / 0.4); border-radius: 16px; padding: 24px; margin-bottom: 32px;">
                  <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px; max-width: 450px; margin: 0 auto;">
                    <div 
                      onclick="event.stopPropagation(); if (state.isDark) window.toggleTheme();"
                      style="position: relative; aspect-ratio: 16/10; border-radius: 12px; overflow: hidden; cursor: pointer; border: 3px solid ${!state.isDark ? state.accentColor : 'hsl(var(--foreground) / 0.2)'}; background: linear-gradient(135deg, #5AC8FA 0%, #007AFF 100%); display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; box-shadow: ${!state.isDark ? '0 0 20px ' + state.accentColor + '40' : 'none'};"
                      onmouseover="if (state.isDark) this.style.borderColor='hsl(var(--foreground) / 0.4)';"
                      onmouseout="if (state.isDark) this.style.borderColor='hsl(var(--foreground) / 0.2)';"
                    >
                      <div style="width: 60%; height: 70%; background: white; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15);"></div>
                      ${!state.isDark ? '<div style="position: absolute; top: 8px; right: 8px; background: ' + state.accentColor + '; color: white; width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: bold; box-shadow: 0 2px 8px rgba(0,0,0,0.3);"></div>' : ''}
                      <div style="position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%); font-size: 14px; font-weight: 600; color: white; text-shadow: 0 1px 3px rgba(0,0,0,0.3);">Light</div>
                    </div>
                    <div 
                      onclick="event.stopPropagation(); if (!state.isDark) window.toggleTheme();"
                      style="position: relative; aspect-ratio: 16/10; border-radius: 12px; overflow: hidden; cursor: pointer; border: 3px solid ${state.isDark ? state.accentColor : 'hsl(var(--foreground) / 0.2)'}; background: #2d2d2d; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; box-shadow: ${state.isDark ? '0 0 20px ' + state.accentColor + '40' : 'none'};"
                      onmouseover="if (!state.isDark) this.style.borderColor='hsl(var(--foreground) / 0.4)';"
                      onmouseout="if (!state.isDark) this.style.borderColor='hsl(var(--foreground) / 0.2)';"
                    >
                      <div style="width: 60%; height: 70%; background: #1a1a1a; border-radius: 8px; border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 4px 12px rgba(0,0,0,0.3);"></div>
                      ${state.isDark ? '<div style="position: absolute; top: 8px; right: 8px; background: ' + state.accentColor + '; color: white; width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: bold; box-shadow: 0 2px 8px rgba(0,0,0,0.3);"></div>' : ''}
                      <div style="position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%); font-size: 14px; font-weight: 600; color: rgba(255,255,255,0.9); text-shadow: 0 1px 3px rgba(0,0,0,0.3);">Dark</div>
                    </div>
                  </div>
                </div>
                
                <h2 style="font-size: 20px; font-weight: 600; margin-bottom: 16px; color: hsl(var(--foreground));">Accent Color</h2>
                <div style="background: hsl(var(--accent) / 0.4); border-radius: 16px; padding: 24px; margin-bottom: 32px;">
                  <div style="display: flex; flex-wrap: wrap; gap: 16px; justify-content: center; max-width: 500px; margin: 0 auto; align-items: center;">
                    ${['#007AFF', '#3584E4', '#26A269', '#33D17A', '#F6D32D', '#E95420', '#E01B24', '#9141AC', '#613583', '#5E5C64'].map(color => `
                      <div 
                        onclick="event.stopPropagation(); window.setAccentColor('${color}');"
                        style="width: 36px; height: 36px; border-radius: 50%; background: ${color}; cursor: pointer; transition: all 0.2s ease; border: 3px solid ${color === state.accentColor ? 'white' : 'transparent'}; box-shadow: ${color === state.accentColor ? '0 0 0 2px ' + color : 'none'};"
                        onmouseover="this.style.transform='scale(1.15)';"
                        onmouseout="this.style.transform='scale(1)';"
                      ></div>
                    `).join('')}
                    <div 
                      onclick="event.stopPropagation(); window.showCustomColorPicker();"
                      style="width: 36px; height: 36px; border-radius: 50%; background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%); cursor: pointer; transition: all 0.2s ease; border: 3px solid ${!['#007AFF', '#3584E4', '#26A269', '#33D17A', '#F6D32D', '#E95420', '#E01B24', '#9141AC', '#613583', '#5E5C64'].includes(state.accentColor) ? 'white' : 'transparent'}; box-shadow: ${!['#007AFF', '#3584E4', '#26A269', '#33D17A', '#F6D32D', '#E95420', '#E01B24', '#9141AC', '#613583', '#5E5C64'].includes(state.accentColor) ? '0 0 0 2px ' + state.accentColor : 'none'}; position: relative;"
                      onmouseover="this.style.transform='scale(1.15)';"
                      onmouseout="this.style.transform='scale(1)';"
                      title="Custom Color"
                    >
                      <div style="position: absolute; inset: 4px; border-radius: 50%; background: ${state.accentColor}; display: ${!['#007AFF', '#3584E4', '#26A269', '#33D17A', '#F6D32D', '#E95420', '#E01B24', '#9141AC', '#613583', '#5E5C64'].includes(state.accentColor) ? 'block' : 'none'};"></div>
                      <div style="position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 18px; text-shadow: 0 1px 2px rgba(0,0,0,0.5);">+</div>
                    </div>
                  </div>
                </div>
                
                <h2 style="font-size: 20px; font-weight: 600; margin-bottom: 16px; color: hsl(var(--foreground)); display: flex; justify-content: space-between; align-items: center;">
                  <span>Window Effects</span>
                  <button 
                    onclick="event.stopPropagation(); window.resetWindowEffects()"
                    style="background: hsl(var(--accent)); border: none; color: hsl(var(--foreground)); font-size: 13px; font-weight: 500; cursor: pointer; padding: 6px 14px; border-radius: 6px; transition: all 0.2s ease;"
                    onmouseover="this.style.background='hsl(var(--accent) / 0.7)';"
                    onmouseout="this.style.background='hsl(var(--accent))';"
                  >Reset</button>
                </h2>
                <div style="background: hsl(var(--accent) / 0.4); border-radius: 16px; padding: 24px; margin-bottom: 32px;">
                  <div style="display: flex; flex-direction: column; gap: 24px;">
                    <!-- Window Transparency -->
                    <div style="display: flex; align-items: center; gap: 16px;">
                      <span style="font-size: 14px; font-weight: 500; color: hsl(var(--foreground)); min-width: 140px;">Transparency</span>
                      <div style="flex: 1; position: relative; height: 28px; display: flex; align-items: center;">
                        <div style="position: absolute; left: 0; right: 0; height: 4px; background: hsl(var(--foreground) / 0.15); border-radius: 2px;"></div>
                        <div class="slider-fill-transparency" style="position: absolute; left: 0; height: 4px; background: ${state.accentColor}; border-radius: 2px; width: ${(1 - state.windowOpacity) * 200}%;"></div>
                        <input type="range" min="0.5" max="1" step="0.05" value="${state.windowOpacity}"
                          oninput="event.stopPropagation(); 
                            var fill = this.parentElement.querySelector('.slider-fill-transparency');
                            var label = this.parentElement.parentElement.querySelector('span:last-child');
                            fill.style.width = ((1 - this.value) * 200) + '%';
                            label.textContent = Math.round((1 - this.value) * 100) + '%';
                            window.setWindowOpacity(this.value);"
                          style="position: absolute; left: 0; right: 0; width: 100%; height: 28px; -webkit-appearance: none; background: transparent; cursor: pointer; margin: 0; direction: rtl;"
                        />
                      </div>
                      <span style="font-size: 13px; color: hsl(var(--muted-foreground)); min-width: 45px; text-align: right;">${Math.round((1 - state.windowOpacity) * 100)}%</span>
                    </div>
                    
                    <!-- Background Blur -->
                    <div style="display: flex; align-items: center; gap: 16px;">
                      <span style="font-size: 14px; font-weight: 500; color: hsl(var(--foreground)); min-width: 140px;">Background Blur</span>
                      <div style="flex: 1; position: relative; height: 28px; display: flex; align-items: center;">
                        <div style="position: absolute; left: 0; right: 0; height: 4px; background: hsl(var(--foreground) / 0.15); border-radius: 2px;"></div>
                        <div class="slider-fill-blur" style="position: absolute; left: 0; height: 4px; background: ${state.accentColor}; border-radius: 2px; width: ${state.windowBlur * 5}%;"></div>
                        <input type="range" min="0" max="20" step="1" value="${state.windowBlur}"
                          oninput="event.stopPropagation();
                            var fill = this.parentElement.querySelector('.slider-fill-blur');
                            var label = this.parentElement.parentElement.querySelector('span:last-child');
                            fill.style.width = (this.value * 5) + '%';
                            label.textContent = this.value + 'px';
                            window.setWindowBlur(this.value);"
                          style="position: absolute; left: 0; right: 0; width: 100%; height: 28px; -webkit-appearance: none; background: transparent; cursor: pointer; margin: 0;"
                        />
                      </div>
                      <span style="font-size: 13px; color: hsl(var(--muted-foreground)); min-width: 45px; text-align: right;">${state.windowBlur}px</span>
                    </div>
                  </div>
                </div>
                
                <h2 style="font-size: 20px; font-weight: 600; margin-bottom: 16px; color: hsl(var(--foreground));">System Font</h2>
                <div style="background: hsl(var(--accent) / 0.4); border-radius: 16px; padding: 24px; margin-bottom: 32px;">
                  <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px;">
                    ${['Ubuntu', 'Inter', 'SF Pro', 'Roboto', 'Open Sans', 'Montserrat'].map(font => `
                      <button 
                        onclick="event.stopPropagation(); window.setSystemFont('${font}')"
                        style="padding: 12px 16px; font-size: 13px; border-radius: 8px; border: 2px solid ${state.systemFont === font ? state.accentColor : 'transparent'}; cursor: pointer; transition: all 0.2s; background: hsl(var(--background) / 0.5); color: hsl(var(--foreground)); font-family: '${font}', sans-serif;"
                      >${font}</button>
                    `).join('')}
                  </div>
                </div>
                
                <h2 style="font-size: 20px; font-weight: 600; margin-bottom: 8px; color: hsl(var(--foreground)); display: flex; justify-content: space-between; align-items: center;">
                  <span>Background</span>
                  ${state.customWallpapers.length < 50 ? `
                    <button 
                      onclick="event.stopPropagation(); window.showAddWallpaperDialog()"
                      style="background: none; border: none; color: hsl(var(--primary)); font-size: 14px; font-weight: 500; cursor: pointer; padding: 6px 12px; border-radius: 6px; transition: all 0.2s ease;"
                      onmouseover="this.style.background='hsl(var(--accent))';"
                      onmouseout="this.style.background='none';"
                    >+ Add Picture...</button>
                  ` : ''}
                </h2>
                <div style="background: hsl(var(--accent) / 0.4); border-radius: 16px; padding: 24px;">
                  <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px;">
                    ${state.customWallpapers.map((wallpaper, index) => {
                      const isActive = state.activeCustomWallpaper === index;
                      return `
                        <div 
                          class="wallpaper-thumbnail ${isActive ? 'active' : ''}"
                          style="position: relative; aspect-ratio: 16/10; border-radius: 12px; overflow: hidden; cursor: pointer; border: 3px solid ${isActive ? '#E95420' : 'transparent'}; transition: all 0.2s ease;"
                          onclick="event.stopPropagation(); window.setActiveWallpaper(${index})"
                        >
                          <div style="position: absolute; inset: 0; display: flex;">
                            <div style="width: 50%; height: 100%; position: relative; overflow: hidden;">
                              <img src="${wallpaper.light}" style="position: absolute; left: 0; top: 0; width: 200%; height: 100%; object-fit: cover;" />
                            </div>
                            <div style="width: 50%; height: 100%; position: relative; overflow: hidden;">
                              <img src="${wallpaper.dark}" style="position: absolute; left: -100%; top: 0; width: 200%; height: 100%; object-fit: cover;" />
                            </div>
                          </div>
                          ${isActive ? `
                            <div style="position: absolute; bottom: 6px; right: 6px; background: ${state.accentColor}; color: white; padding: 4px 8px; border-radius: 6px; font-size: 16px; font-weight: 600; z-index: 1;"></div>
                          ` : ''}
                          <button 
                            class="wallpaper-delete-btn"
                            onclick="event.stopPropagation(); window.deleteWallpaperPair(${index})"
                            style="position: absolute; top: 6px; right: 6px; background: rgba(0,0,0,0.6); backdrop-filter: blur(4px); color: white; border: none; border-radius: 6px; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; cursor: pointer; opacity: 0; transition: opacity 0.2s; font-size: 14px; z-index: 1;"
                            onmouseover="this.style.opacity='1'; this.style.background='rgba(220,38,38,0.9)';"
                            onmouseout="this.style.opacity='0'; this.style.background='rgba(0,0,0,0.6)';"
                          ></button>
                        </div>
                      `;
                    }).join('')}
                    
                    
                    <!-- Tahoe wallpaper -->
                    <div 
                      class="wallpaper-thumbnail ${state.activeCustomWallpaper === -2 ? 'active' : ''}"
                      style="position: relative; aspect-ratio: 16/10; border-radius: 12px; overflow: hidden; cursor: pointer; border: 3px solid ${state.activeCustomWallpaper === -2 ? state.accentColor : 'transparent'}; transition: all 0.2s ease;"
                      onclick="event.stopPropagation(); window.setActiveWallpaper(-2)"
                    >
                      <div style="position: absolute; inset: 0; display: flex;">
                        <div style="width: 50%; height: 100%; position: relative; overflow: hidden;">
                          <img src="https://raw.githubusercontent.com/Matko802/my-web-os-things/refs/heads/main/26-Tahoe-Light-1080x1920.png" style="position: absolute; left: 0; top: 0; width: 200%; height: 100%; object-fit: cover;" />
                        </div>
                        <div style="width: 50%; height: 100%; position: relative; overflow: hidden;">
                          <img src="https://raw.githubusercontent.com/Matko802/my-web-os-things/refs/heads/main/26-Tahoe-Dark-1080x1920.png" style="position: absolute; left: -100%; top: 0; width: 200%; height: 100%; object-fit: cover;" />
                        </div>
                      </div>
                      ${state.activeCustomWallpaper === -2 ? `
                        <div style="position: absolute; bottom: 6px; right: 6px; background: ${state.accentColor}; color: white; padding: 4px 8px; border-radius: 6px; font-size: 16px; font-weight: 600; z-index: 1;"></div>
                      ` : ''}
                    </div>
                  </div>
                  
                  ${state.customWallpapers.length > 0 ? `
                    <div style="margin-top: 16px; padding: 10px 12px; background: hsl(var(--background) / 0.3); border-radius: 8px; font-size: 12px; color: hsl(var(--muted-foreground));">
                       Custom wallpapers adapt to dark/light mode. Toggle styles to see both versions.
                    </div>
                  ` : ''}
                </div>
              </div>
              
              <style>
                .wallpaper-thumbnail:hover {
                  transform: translateY(-2px);
                }
                .wallpaper-thumbnail:hover .wallpaper-delete-btn {
                  opacity: 1 !important;
                }
              </style>
            `;
            
          case 'control-centre':
            return `
              <div class="settings-section">
                <h2 style="font-size: 28px; font-weight: 700; margin-bottom: 24px; color: hsl(var(--foreground));">Control Centre</h2>
                <div class="settings-item">
                  <div>
                    <div class="settings-label">Quick Settings</div>
                    <div class="settings-description">Access frequently used settings from the menu bar</div>
                  </div>
                </div>
              </div>
            `;
            
          case 'desktop-dock':
            return `
              <div class="settings-section">
                <h2 style="font-size: 28px; font-weight: 700; margin-bottom: 24px; color: hsl(var(--foreground));">Desktop & Dock</h2>
                <div class="settings-item">
                  <div>
                    <div class="settings-label">Dock Position</div>
                    <div class="settings-description">Choose where the dock appears</div>
                  </div>
                  <select class="settings-select" onchange="event.stopPropagation(); window.handleDockPosition(this.value)" style="padding: 8px 12px; background: hsl(var(--accent)); border: 1px solid hsl(var(--border)); border-radius: 6px; color: hsl(var(--foreground)); font-size: 14px;">
                    <option value="bottom" ${state.dockPosition === 'bottom' ? 'selected' : ''}>Bottom</option>
                    <option value="left" ${state.dockPosition === 'left' ? 'selected' : ''}>Left</option>
                    <option value="right" ${state.dockPosition === 'right' ? 'selected' : ''}>Right</option>
                  </select>
                </div>
                <div class="settings-item" style="flex-direction: column; align-items: stretch; padding: 16px 0;">
                  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                    <div>
                      <div class="settings-label">Dock Size</div>
                      <div class="settings-description">Adjust the size of dock icons (${Math.round((state.dockScale || 1.0) * 100)}%)</div>
                    </div>
                    <span style="font-size: 14px; font-weight: 600; color: hsl(var(--primary)); min-width: 50px; text-align: right;">${Math.round((state.dockScale || 1.0) * 100)}%</span>
                  </div>
                  <input type="range" min="0.5" max="2.0" step="0.1" value="${state.dockScale || 1.0}" oninput="event.stopPropagation(); window.handleDockScale(this.value)" style="width: 100%; height: 6px; border-radius: 3px; background: hsl(var(--accent)); outline: none; -webkit-appearance: none; appearance: none; cursor: pointer;">
                  <style>
                    input[type=range]::-webkit-slider-thumb {
                      -webkit-appearance: none;
                      appearance: none;
                      width: 18px;
                      height: 18px;
                      border-radius: 50%;
                      background: hsl(var(--primary));
                      cursor: pointer;
                      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                    }
                    input[type=range]::-moz-range-thumb {
                      width: 18px;
                      height: 18px;
                      border-radius: 50%;
                      background: hsl(var(--primary));
                      cursor: pointer;
                      border: none;
                      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                    }
                  </style>
                </div>
                <div class="settings-item">
                  <div>
                    <div class="settings-label">Mirror Window Controls</div>
                    <div class="settings-description">Place window buttons on right, fullscreen button on left</div>
                  </div>
                  <div class="toggle-switch ${state.mirroredControls ? 'active' : ''}" onclick="event.stopPropagation(); window.toggleMirroredControls()">
                    <div class="toggle-switch-thumb"></div>
                  </div>
                </div>
              </div>
            `;
            
          case 'wallpaper':
            return `
              <div class="settings-section">
                <h2 style="font-size: 24px; font-weight: 600; margin-bottom: 20px; color: hsl(var(--foreground));">Background</h2>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 12px; margin-bottom: 24px;">
                  ${state.customWallpapers.map((wallpaper, index) => {
                    const isActive = state.activeCustomWallpaper === index;
                    return `
                      <div 
                        class="wallpaper-thumbnail ${isActive ? 'active' : ''}"
                        style="position: relative; aspect-ratio: 16/10; border-radius: 12px; overflow: hidden; cursor: pointer; border: 3px solid ${isActive ? 'hsl(var(--primary))' : 'transparent'}; transition: all 0.2s ease;"
                        onclick="event.stopPropagation(); window.setActiveWallpaper(${index})"
                      >
                        <div style="position: absolute; inset: 0; display: flex;">
                          <div style="width: 50%; height: 100%; position: relative; overflow: hidden;">
                            <img src="${wallpaper.light}" style="position: absolute; left: 0; top: 0; width: 200%; height: 100%; object-fit: cover;" />
                          </div>
                          <div style="width: 50%; height: 100%; position: relative; overflow: hidden;">
                            <img src="${wallpaper.dark}" style="position: absolute; left: -100%; top: 0; width: 200%; height: 100%; object-fit: cover;" />
                          </div>
                        </div>
                        ${isActive ? `
                          <div style="position: absolute; bottom: 6px; left: 6px; background: hsl(var(--primary)); color: hsl(var(--primary-foreground)); padding: 3px 8px; border-radius: 6px; font-size: 11px; font-weight: 500; z-index: 1;">
                            
                          </div>
                        ` : ''}
                        <button 
                          class="wallpaper-delete-btn"
                          onclick="event.stopPropagation(); window.deleteWallpaperPair(${index})"
                          style="position: absolute; top: 6px; right: 6px; background: rgba(0,0,0,0.6); backdrop-filter: blur(4px); color: white; border: none; border-radius: 6px; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; cursor: pointer; opacity: 0; transition: opacity 0.2s; font-size: 14px; z-index: 1;"
                          onmouseover="this.style.opacity='1'; this.style.background='rgba(220,38,38,0.9)';"
                          onmouseout="this.style.opacity='0'; this.style.background='rgba(0,0,0,0.6)';"
                        ></button>
                      </div>
                    `;
                  }).join('')}
                  
                  <!-- Tahoe wallpaper -->
                  <div style="display: flex; flex-direction: column; gap: 6px;">
                    <div 
                      class="wallpaper-thumbnail ${state.activeCustomWallpaper === -2 ? 'active' : ''}"
                      style="position: relative; aspect-ratio: 16/10; border-radius: 12px; overflow: hidden; cursor: pointer; border: 3px solid ${state.activeCustomWallpaper === -2 ? 'hsl(var(--primary))' : 'transparent'}; transition: all 0.2s ease;"
                      onclick="event.stopPropagation(); window.setActiveWallpaper(-2)"
                    >
                      <div style="position: absolute; inset: 0; display: flex;">
                        <div style="width: 50%; height: 100%; position: relative; overflow: hidden;">
                          <img src="https://raw.githubusercontent.com/Matko802/my-web-os-things/refs/heads/main/26-Tahoe-Light-1080x1920.png" style="position: absolute; left: 0; top: 0; width: 200%; height: 100%; object-fit: cover;" />
                        </div>
                        <div style="width: 50%; height: 100%; position: relative; overflow: hidden;">
                          <img src="https://raw.githubusercontent.com/Matko802/my-web-os-things/refs/heads/main/26-Tahoe-Dark-1080x1920.png" style="position: absolute; left: -100%; top: 0; width: 200%; height: 100%; object-fit: cover;" />
                        </div>
                      </div>
                      ${state.activeCustomWallpaper === -2 ? `
                        <div style="position: absolute; bottom: 6px; left: 6px; background: hsl(var(--primary)); color: hsl(var(--primary-foreground)); padding: 3px 8px; border-radius: 6px; font-size: 11px; font-weight: 500; z-index: 1;">
                          
                        </div>
                      ` : ''}
                    </div>
                    <div style="text-align: center; font-size: 11px; color: hsl(var(--muted-foreground)); font-weight: 500;">Tahoe</div>
                  </div>
                  
                  <div style="display: flex; flex-direction: column; gap: 6px;">
                    <div 
                      class="wallpaper-thumbnail ${state.activeCustomWallpaper === -3 ? 'active' : ''}"
                      style="position: relative; aspect-ratio: 16/10; border-radius: 12px; overflow: hidden; cursor: pointer; border: 3px solid ${state.activeCustomWallpaper === -3 ? 'hsl(var(--primary))' : 'transparent'}; transition: all 0.2s ease;"
                      onclick="event.stopPropagation(); window.setActiveWallpaper(-3)"
                    >
                      <div style="position: absolute; inset: 0; display: flex;">
                        <div style="width: 50%; height: 100%; position: relative; overflow: hidden;">
                          <img src="https://512pixels.net/downloads/macos-wallpapers-thumbs/14-0-Sonoma-L.jpg" style="position: absolute; left: 0; top: 0; width: 200%; height: 100%; object-fit: cover;" />
                        </div>
                        <div style="width: 50%; height: 100%; position: relative; overflow: hidden;">
                          <img src="https://512pixels.net/downloads/macos-wallpapers-thumbs/14-0-Sonoma-D.jpg" style="position: absolute; left: -100%; top: 0; width: 200%; height: 100%; object-fit: cover;" />
                        </div>
                      </div>
                      ${state.activeCustomWallpaper === -3 ? `
                        <div style="position: absolute; bottom: 6px; left: 6px; background: hsl(var(--primary)); color: hsl(var(--primary-foreground)); padding: 3px 8px; border-radius: 6px; font-size: 11px; font-weight: 500; z-index: 1;">
                          
                        </div>
                      ` : ''}
                    </div>
                    <div style="text-align: center; font-size: 11px; color: hsl(var(--muted-foreground)); font-weight: 500;">Sonoma</div>
                  </div>
                  
                  ${state.customWallpapers.length < 50 ? `
                    <div 
                      class="wallpaper-add-btn"
                      style="aspect-ratio: 16/10; border-radius: 12px; border: 2px dashed hsl(var(--border)); display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s ease; background: hsl(var(--accent) / 0.3);"
                      onclick="event.stopPropagation(); window.showAddWallpaperDialog()"
                      onmouseover="this.style.background='hsl(var(--accent) / 0.5)'; this.style.borderColor='hsl(var(--primary))';"
                      onmouseout="this.style.background='hsl(var(--accent) / 0.3)'; this.style.borderColor='hsl(var(--border))';"
                    >
                      <div style="font-size: 24px; margin-bottom: 4px; color: hsl(var(--muted-foreground));">+</div>
                      <div style="font-size: 11px; color: hsl(var(--muted-foreground)); font-weight: 500;">Add Picture...</div>
                    </div>
                  ` : ''}
                </div>
                
                ${state.customWallpapers.length > 0 ? `
                  <div style="margin-top: 16px; padding: 10px 12px; background: hsl(var(--accent) / 0.5); border-radius: 8px; font-size: 12px; color: hsl(var(--muted-foreground));">
                     Custom wallpapers adapt to dark/light mode. Toggle in Appearance to see both versions.
                  </div>
                ` : ''}
              </div>
              
              <style>
                .wallpaper-thumbnail:hover {
                  transform: translateY(-2px);
                }
                .wallpaper-thumbnail:hover .wallpaper-delete-btn {
                  opacity: 1 !important;
                }
              </style>
            `;
            
          case 'notifications':
            return `
              <div class="settings-section">
                <h2 style="font-size: 28px; font-weight: 700; margin-bottom: 24px; color: hsl(var(--foreground));">Notifications</h2>
                <div class="settings-item">
                  <div>
                    <div class="settings-label">Notification Centre</div>
                    <div class="settings-description">Shows your notifications in the top-right corner</div>
                  </div>
                </div>
              </div>
            `;
            
          case 'sound':
            const soundsInstalled = localStorage.getItem('lineageSoundsInstalled') === 'true';
            const soundsEnabled = state.soundEnabled;
            const totalSounds = SOUND_CONFIG.files.length;
            const installedSounds = SOUND_CONFIG.files.filter(f => localStorage.getItem(`sound_${f}`)).length;
            
            return `
              <div class="settings-section">
                <h2 style="font-size: 28px; font-weight: 700; margin-bottom: 24px; color: hsl(var(--foreground));">Sound</h2>
                <div class="settings-item">
                  <div>
                    <div class="settings-label">Sound Effects</div>
                    <div class="settings-description">Play system sounds</div>
                  </div>
                  <div class="toggle-switch ${soundsEnabled ? 'active' : ''}" onclick="event.stopPropagation(); window.toggleSound()">
                    <div class="toggle-switch-thumb"></div>
                  </div>
                </div>
                
                <!-- Lineage OS Sound Theme -->
                <div class="settings-item" style="flex-direction: column; align-items: flex-start; margin-top: 20px;">
                  <div style="width: 100%;">
                    <div class="settings-label" style="font-size: 16px; font-weight: 600;">Lineage OS Sound Theme</div>
                    <div class="settings-description">High-quality system sounds cached locally for offline use</div>
                    
                    ${soundsInstalled ? `
                      <div style="margin-top: 12px; padding: 12px; background: hsl(175 80% 45% / 0.15); border: 1px solid hsl(175 80% 45% / 0.3); border-radius: 10px;">
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                          <span style="font-size: 18px;"></span>
                          <span style="font-weight: 600; color: hsl(175 80% 45%);">Sound Pack Installed</span>
                        </div>
                        <div style="font-size: 12px; color: hsl(var(--muted-foreground));">
                          ${installedSounds}/${totalSounds} sounds cached in localStorage
                        </div>
                        <div style="display: flex; gap: 8px; margin-top: 12px; flex-wrap: wrap;">
                          <button onclick="event.stopPropagation(); window.testSound()" style="padding: 8px 14px; background: hsl(var(--primary)); color: white; border: none; border-radius: 6px; font-size: 12px; cursor: pointer; font-family: inherit;">
                             Test Sound
                          </button>
                          <button onclick="event.stopPropagation(); window.reinstallSoundsUI()" style="padding: 8px 14px; background: hsl(var(--accent)); color: hsl(var(--foreground)); border: none; border-radius: 6px; font-size: 12px; cursor: pointer; font-family: inherit;">
                             Reinstall
                          </button>
                          <button onclick="event.stopPropagation(); window.clearSoundsUI()" style="padding: 8px 14px; background: transparent; color: hsl(var(--muted-foreground)); border: 1px solid hsl(var(--border)); border-radius: 6px; font-size: 12px; cursor: pointer; font-family: inherit;">
                             Remove
                          </button>
                        </div>
                      </div>
                    ` : `
                      <div style="margin-top: 12px; padding: 12px; background: hsl(var(--accent) / 0.5); border: 1px solid hsl(var(--border)); border-radius: 10px;">
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                          <span style="font-size: 18px;"></span>
                          <span style="font-weight: 500;">Lineage OS Sounds</span>
                        </div>
                        <div style="font-size: 12px; color: hsl(var(--muted-foreground)); margin-bottom: 12px;">
                          Download premium sound effects from Lineage OS for a richer experience. Sounds will be cached locally.
                        </div>
                        <button onclick="event.stopPropagation(); window.installSoundsUI()" style="padding: 10px 16px; background: hsl(var(--primary)); color: white; border: none; border-radius: 8px; font-size: 13px; cursor: pointer; font-family: inherit; font-weight: 500;">
                           Download Sound Pack
                        </button>
                      </div>
                    `}
                  </div>
                </div>
                
                <!-- Sound Preview -->
                <div class="settings-item" style="flex-direction: column; align-items: flex-start; margin-top: 20px; padding-top: 20px; border-top: 1px solid hsl(var(--border));">
                  <div style="width: 100%;">
                    <div class="settings-label" style="font-size: 14px; font-weight: 500; margin-bottom: 12px;">Test Individual Sounds</div>
                    <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                      ${['click', 'open', 'close', 'minimize', 'notification', 'lock', 'unlock', 'trash'].map(sound => `
                        <button onclick="event.stopPropagation(); window.playSound('${sound}')" style="padding: 6px 12px; background: hsl(var(--accent)); color: hsl(var(--foreground)); border: 1px solid hsl(var(--border)); border-radius: 6px; font-size: 11px; cursor: pointer; font-family: inherit; text-transform: capitalize;">
                          ${sound}
                        </button>
                      `).join('')}
                    </div>
                  </div>
                </div>
              </div>
            `;
            
          case 'mouse':
            const cursorsInstalled = localStorage.getItem('customCursorsInstalled') === 'true';
            const cursorsEnabled = localStorage.getItem('customCursorsEnabled') !== 'false';
            const cursorCount = CURSOR_CONFIG.files.length;
            const installedCount = CURSOR_CONFIG.files.filter(f => localStorage.getItem(`cursor_${f}`)).length;
            
            return `
              <div class="settings-section">
                <h2 style="font-size: 28px; font-weight: 700; margin-bottom: 24px; color: hsl(var(--foreground));">Mouse & Cursor</h2>
                
                <!-- M OS Cursor Theme -->
                <div class="settings-item" style="flex-direction: column; align-items: flex-start; margin-bottom: 20px;">
                  <div style="width: 100%;">
                    <div class="settings-label" style="font-size: 16px; font-weight: 600;">M OS Cursor Theme</div>
                    <div class="settings-description">Custom animated cursors with offline support (stored in localStorage)</div>
                    
                    <div style="margin-top: 12px; padding: 12px; background: hsl(var(--accent) / 0.5); border-radius: 8px;">
                      <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                        <span style="font-size: 13px; color: hsl(var(--foreground));">
                          ${cursorsInstalled 
                            ? ` ${installedCount}/${cursorCount} cursors installed (offline ready)` 
                            : ' Cursors not installed'}
                        </span>
                        <div class="toggle-switch ${cursorsEnabled && cursorsInstalled ? 'active' : ''}" onclick="event.stopPropagation(); window.toggleCustomCursors(); setTimeout(() => render(), 100);" style="${!cursorsInstalled ? 'opacity: 0.5; pointer-events: none;' : ''}">
                          <div class="toggle-switch-thumb"></div>
                        </div>
                      </div>
                      
                      <div style="display: flex; gap: 8px; margin-top: 10px;">
                        ${!cursorsInstalled ? `
                          <button class="wallpaper-upload-btn" onclick="event.stopPropagation(); window.installCursorsUI();" style="font-size: 13px; padding: 8px 14px;">
                             Download Cursors
                          </button>
                        ` : `
                          <button class="wallpaper-reset-btn" onclick="event.stopPropagation(); window.reinstallCursorsUI();" style="font-size: 12px;">
                             Reinstall
                          </button>
                          <button class="wallpaper-reset-btn" onclick="event.stopPropagation(); window.clearCursorsUI();" style="font-size: 12px;">
                             Remove
                          </button>
                        `}
                      </div>
                      
                      ${cursorsInstalled ? `
                        <div style="margin-top: 12px; display: flex; flex-wrap: wrap; gap: 8px;">
                          ${CURSOR_CONFIG.files.map(f => {
                            const previewUrl = getCursorPreviewUrl(f);
                            const isAnimated = f.endsWith('.ani');
                            return previewUrl ? `<div style="width: 36px; height: 36px; background: hsl(var(--background)); border-radius: 6px; display: flex; align-items: center; justify-content: center; border: 1px solid hsl(var(--border)); position: relative;" title="${f.replace(/\.(cur|ani)$/, '')}${isAnimated ? ' (animated)' : ''}">
                              <img src="${previewUrl}" style="width: 28px; height: 28px; object-fit: contain; image-rendering: auto; image-rendering: smooth;" onerror="this.style.display='none'; this.parentElement.innerHTML='?';" />
                              ${isAnimated ? '<div style="position: absolute; bottom: 1px; right: 1px; width: 8px; height: 8px; background: hsl(var(--primary)); border-radius: 50%; font-size: 5px; display: flex; align-items: center; justify-content: center; color: white;"></div>' : ''}
                            </div>` : '';
                          }).join('')}
                        </div>
                      ` : ''}
                    </div>
                  </div>
                </div>
                
                <!-- Custom Cursor Upload (legacy) -->
                <div class="settings-item" style="flex-direction: column; align-items: flex-start;">
                  <div style="width: 100%;">
                    <div class="settings-label">Custom Cursor (Upload)</div>
                    <div class="settings-description">Upload a single cursor image</div>
                    <input type="file" id="cursor-upload" accept="image/*" style="display: none;" onchange="event.stopPropagation(); window.handleCursorUpload(event)" />
                    <button class="wallpaper-upload-btn" onclick="event.stopPropagation(); document.getElementById('cursor-upload').click()" style="margin-top: 12px;">
                      Choose Cursor
                    </button>
                    ${state.customCursor && !cursorsEnabled ? `
                      <div class="wallpaper-preview" style="background-image: url('${state.customCursor}'); background-size: contain; background-repeat: no-repeat; height: 60px; margin-top: 8px;"></div>
                      <div class="wallpaper-actions">
                        <button class="wallpaper-reset-btn" onclick="event.stopPropagation(); window.resetCursor()">
                          Reset to Default
                        </button>
                      </div>
                    ` : ''}
                  </div>
                </div>
              </div>
            `;
            
          case 'system':
            const currentVersion = getInstalledVersion();
            const autoUpdateEnabled = localStorage.getItem('mos_auto_update') === 'true';
            const isCheckingUpdate = state.isCheckingUpdate || false;
            const lastUpdateCheck = localStorage.getItem('mos_last_update_check');
            const lastCheckText = lastUpdateCheck ? new Date(parseInt(lastUpdateCheck)).toLocaleString() : 'Never';
            
            return `
              <div class="settings-section">
                <h2 style="font-size: 28px; font-weight: 700; margin-bottom: 24px; color: hsl(var(--foreground));">System</h2>
                <div class="settings-item">
                  <div>
                    <div class="settings-label">Animations</div>
                    <div class="settings-description">Enable smooth window animations</div>
                  </div>
                  <div class="toggle-switch ${state.animationsEnabled ? 'active' : ''}" onclick="event.stopPropagation(); window.toggleAnimations()">
                    <div class="toggle-switch-thumb"></div>
                  </div>
                </div>
                <div class="settings-item">
                  <div>
                    <div class="settings-label">MOS Version</div>
                    <div class="settings-description">${currentVersion}</div>
                  </div>
                </div>
              </div>
              
              <div class="settings-section">
                <h2 style="font-size: 28px; font-weight: 700; margin-bottom: 24px; color: hsl(var(--foreground));">Software Updates</h2>
                <div class="settings-item">
                  <div>
                    <div class="settings-label">Automatic Updates</div>
                    <div class="settings-description">Automatically check for and notify about updates on boot</div>
                  </div>
                  <div class="toggle-switch ${autoUpdateEnabled ? 'active' : ''}" onclick="event.stopPropagation(); window.toggleAutoUpdate()">
                    <div class="toggle-switch-thumb"></div>
                  </div>
                </div>
                <div class="settings-item">
                  <div>
                    <div class="settings-label">Current Version</div>
                    <div class="settings-description">${currentVersion}</div>
                  </div>
                </div>
                <div class="settings-item">
                  <div>
                    <div class="settings-label">Last Checked</div>
                    <div class="settings-description" id="last-update-check">${lastCheckText}</div>
                  </div>
                </div>
                <div class="settings-item" style="flex-direction: column; align-items: flex-start;">
                  <div style="width: 100%; display: flex; align-items: center; gap: 12px;">
                    <button 
                      class="wallpaper-upload-btn" 
                      onclick="event.stopPropagation(); window.manualCheckForUpdates()"
                      id="check-updates-btn"
                      ${isCheckingUpdate ? 'disabled style="opacity: 0.6; cursor: not-allowed;"' : ''}
                    >
                      ${isCheckingUpdate ? ' Checking...' : ' Check for Updates'}
                    </button>
                    <span id="update-status-text" style="font-size: 13px; color: hsl(var(--muted-foreground));"></span>
                  </div>
                </div>
              </div>
              
              <div class="settings-section">
                <h2 style="font-size: 28px; font-weight: 700; margin-bottom: 24px; color: hsl(var(--foreground));">Lockscreen</h2>
                <div class="settings-item" style="flex-direction: column; align-items: flex-start;">
                  <div style="width: 100%;">
                    <div class="settings-label">Lockscreen Wallpaper</div>
                    <div class="settings-description">Set a custom wallpaper for the lockscreen</div>
                    <div style="display: flex; gap: 12px; margin-top: 12px; flex-wrap: wrap;">
                      <button class="wallpaper-upload-btn" onclick="event.stopPropagation(); window.uploadLockscreenWallpaper()">
                         Choose Image
                      </button>
                      ${localStorage.getItem('mos_lockscreen_wallpaper') ? `
                        <button class="wallpaper-reset-btn" onclick="event.stopPropagation(); window.clearLockscreenWallpaper()">
                          Reset to Default
                        </button>
                      ` : ''}
                    </div>
                    ${localStorage.getItem('mos_lockscreen_wallpaper') ? `
                      <div class="wallpaper-preview" style="margin-top: 12px; height: 100px; background-image: url('${localStorage.getItem('mos_lockscreen_wallpaper')}');"></div>
                    ` : ''}
                  </div>
                </div>
              </div>
              
              <div class="settings-section">
                <h2 style="font-size: 28px; font-weight: 700; margin-bottom: 24px; color: hsl(var(--foreground));">Data Management</h2>
                <div class="settings-item" style="flex-direction: column; align-items: flex-start;">
                  <div style="width: 100%;">
                    <div class="settings-label">Reset All Data</div>
                    <div class="settings-description">Clear all saved data including window states, settings, history, and custom wallpapers. This action cannot be undone.</div>
                    <button class="wallpaper-reset-btn destructive" onclick="event.stopPropagation(); window.clearAllData()" style="margin-top: 12px;">
                       Clear All Data
                    </button>
                  </div>
                </div>
              </div>
            `;
            
          default:
            return `
              <div class="settings-section">
                <h2 style="font-size: 28px; font-weight: 700; margin-bottom: 24px; color: hsl(var(--foreground));">Settings</h2>
                <p>Select a category from the sidebar</p>
              </div>
            `;
        }
      }

      window.createWindow = function createWindow(appId, appName) {
        playSound('open');
        
        // Load saved window size from localStorage
        const savedSizes = JSON.parse(localStorage.getItem('windowSizes') || '{}');
        const savedSize = savedSizes[appId] || { width: 600, height: 400 };
        
        // Load saved window state from localStorage (position, maximize, snap, etc.)
        const savedWindowState = state.windowStates[appId];
        console.log('Loading window state for', appId, ':', savedWindowState);
        const savedMaximizeState = savedWindowState && typeof savedWindowState === 'object' ? savedWindowState.isMaximized : savedWindowState || false;
        console.log('Resolved maximized state for', appId, ':', savedMaximizeState);
        
        const win = {
          id: state.nextId++,
          appId,
          title: appName,
          x: (savedWindowState && savedWindowState.x !== undefined) ? savedWindowState.x : 100 + ((state.nextId * 30) % 200),
          y: (savedWindowState && savedWindowState.y !== undefined) ? savedWindowState.y : 100 + ((state.nextId * 30) % 200),
          width: (savedWindowState && savedWindowState.width !== undefined) ? savedWindowState.width : savedSize.width,
          height: (savedWindowState && savedWindowState.height !== undefined) ? savedWindowState.height : savedSize.height,
          zIndex: state.nextZIndex++,
          isMinimized: false,
          isMaximized: savedMaximizeState,
          isFullscreen: false,
          isOpening: true, // Flag to trigger opening animation
          isSnapped: (savedWindowState && savedWindowState.isSnapped) || false,
          snapRestorePos: (savedWindowState && savedWindowState.snapRestorePos) || null,
        };
        // Initialize terminal history for this window if it's a terminal
        if (appId === 'terminal') {
          state.terminalHistory[win.id] = [
            `<div style="margin-top: 10px;">Type 'help' for available commands</div>`
          ];
        }
        // Initialize input values for this window
        if (appId === 'browser') {
          state.inputValues[win.id] = '';
        }
        // Start Task Manager refresh interval
        if (appId === 'taskmanager') {
          window.startTaskManagerRefresh(win.id);
        }
        // Start background process for this app
        window.startBackgroundProcess(appId, {
          windowId: win.id,
          windowTitle: appName,
          startedAt: Date.now()
        });
        state.windows.push(win);
        state.activeWindowId = win.id; // Set new window as active
        render();
        
        // Trigger opening animation after render
        requestAnimationFrame(() => {
          const windowEl = document.getElementById(`window-${win.id}`);
          if (windowEl && !win.isMaximized) {
            // Enable hardware acceleration
            windowEl.style.willChange = 'transform, opacity';
            
            // Set initial state (small and semi-transparent)
            windowEl.style.transform = 'scale3d(0.9, 0.9, 1)';
            windowEl.style.opacity = '0';
            windowEl.style.transition = 'none';
            
            // Force layout recalculation
            void windowEl.offsetHeight;
            
            // Animate to final state
            windowEl.style.transition = 'all 0.25s cubic-bezier(0.16, 1, 0.3, 1)';
            windowEl.style.transform = 'scale3d(1, 1, 1)';
            windowEl.style.opacity = '1';
            
            setTimeout(() => {
              windowEl.style.transition = '';
              windowEl.style.transform = '';
              windowEl.style.willChange = 'auto';
              win.isOpening = false;
            }, 250);
          } else if (windowEl && win.isMaximized) {
            // For maximized windows, fade in from center
            windowEl.style.willChange = 'transform, opacity';
            windowEl.style.transform = 'scale3d(0.95, 0.95, 1)';
            windowEl.style.opacity = '0';
            windowEl.style.transition = 'none';
            
            void windowEl.offsetHeight;
            
            windowEl.style.transition = 'all 0.25s cubic-bezier(0.16, 1, 0.3, 1)';
            windowEl.style.transform = 'scale3d(1, 1, 1)';
            windowEl.style.opacity = '1';
            
            setTimeout(() => {
              windowEl.style.transition = '';
              windowEl.style.transform = '';
              windowEl.style.willChange = 'auto';
              win.isOpening = false;
            }, 250);
          }
        });
      };

      window.closeWindow = function closeWindow(id) {
        playSound('close');
        
        // Stop Task Manager refresh if this is a task manager window
        const win = state.windows.find((w) => w.id === id);
        if (win && win.appId === 'taskmanager') {
          window.stopTaskManagerRefresh();
        }
        
        const windowEl = document.getElementById(`window-${id}`);
        
        if (windowEl) {
          // Enable hardware acceleration
          windowEl.style.willChange = 'transform, opacity';
          windowEl.style.pointerEvents = 'none'; // Prevent interaction during close
          
          // Animate to small and transparent
          windowEl.style.transition = 'all 0.2s cubic-bezier(0.16, 1, 0.3, 1)';
          windowEl.style.transform = 'scale3d(0.9, 0.9, 1)';
          windowEl.style.opacity = '0';
          
          setTimeout(() => {
            // Save terminal history to localStorage before closing
            if (state.terminalHistory[id]) {
              localStorage.setItem('terminalHistory', JSON.stringify(state.terminalHistory));
            }
            
            const closedWin = state.windows.find((w) => w.id === id);
            const appId = closedWin ? closedWin.appId : null;
            
            state.windows = state.windows.filter((w) => w.id !== id);
            // Clean up terminal history and input values
            delete state.terminalHistory[id];
            delete state.inputValues[id];
            
            // Stop background process if no more windows for this app
            if (appId && !state.windows.some(w => w.appId === appId)) {
              window.stopBackgroundProcess(appId);
            }
            
            // Dispatch windowClosed event for cleanup handlers
            window.dispatchEvent(new CustomEvent('windowClosed', { detail: { id } }));
            
            render();
          }, 200);
        } else {
          // Fallback if window element not found
          if (state.terminalHistory[id]) {
            localStorage.setItem('terminalHistory', JSON.stringify(state.terminalHistory));
          }
          
          const closedWin = state.windows.find((w) => w.id === id);
          const appId = closedWin ? closedWin.appId : null;
          
          state.windows = state.windows.filter((w) => w.id !== id);
          delete state.terminalHistory[id];
          delete state.inputValues[id];
          
          // Stop background process if no more windows for this app
          if (appId && !state.windows.some(w => w.appId === appId)) {
            window.stopBackgroundProcess(appId);
          }
          
          // Dispatch windowClosed event for cleanup handlers
          window.dispatchEvent(new CustomEvent('windowClosed', { detail: { id } }));
          
          render();
        }
      };

      window.minimizeWindow = function minimizeWindow(id) {
        playSound('minimize');
        const win = state.windows.find((w) => w.id === id);
        if (!win) return;
        
        // Prevent double minimize
        if (win.isMinimizing) return;
        win.isMinimizing = true;

        // Stop Task Manager refresh when minimizing
        if (win.appId === 'taskmanager') {
          window.stopTaskManagerRefresh();
        }

        const windowEl = document.getElementById(`window-${id}`);
        const dockIcon = document.getElementById(`dock-${win.appId}`);

        if (windowEl && dockIcon) {
          // Enable hardware acceleration and prevent pointer events during animation
          windowEl.style.willChange = 'transform, opacity';
          windowEl.style.pointerEvents = 'none';
          
          const windowRect = windowEl.getBoundingClientRect();
          const dockRect = dockIcon.getBoundingClientRect();

          const scaleX = 56 / windowRect.width;
          const scaleY = 56 / windowRect.height;
          const translateX = dockRect.left + 28 - windowRect.left - windowRect.width / 2;
          const translateY = dockRect.top + 28 - windowRect.top - windowRect.height / 2;

          // Use requestAnimationFrame for smoother animation start
          requestAnimationFrame(() => {
            windowEl.style.transition = 'transform 0.3s cubic-bezier(0.16, 1, 0.3, 1), opacity 0.25s ease-out';
            windowEl.style.transform = `translate3d(${translateX}px, ${translateY}px, 0) scale3d(${scaleX}, ${scaleY}, 1)`;
            windowEl.style.opacity = '0';
          });

          setTimeout(() => {
            win.isMinimized = true;
            win.isMinimizing = false;
            windowEl.style.willChange = 'auto';
            windowEl.style.pointerEvents = '';
            // Hide the element immediately to prevent flash
            windowEl.style.display = 'none';
            // Use updateDockOnly instead of full render when possible
            renderDockOnly();
            // Schedule full render after dock update
            requestAnimationFrame(() => render());
          }, 300);
        } else {
          win.isMinimized = true;
          win.isMinimizing = false;
          render();
        }
      };

      window.restoreWindow = function restoreWindow(appId) {
        const win = state.windows.find((w) => w.appId === appId && w.isMinimized);
        if (!win) {
          const app = apps.find((a) => a.id === appId);
          if (app) createWindow(app.id, app.name);
          return;
        }
        
        playSound('open');
        
        // Restart Task Manager refresh if restoring task manager
        if (appId === 'taskmanager') {
          window.startTaskManagerRefresh(win.id);
        }
        
        const dockIcon = document.getElementById(`dock-${appId}`);
        if (!dockIcon) {
          win.isMinimized = false;
          win.zIndex = state.nextZIndex++;
          state.activeWindowId = win.id; // Set as active
          render();
          return;
        }
        
        // Store dock position before changing state
        const dockRect = dockIcon.getBoundingClientRect();
        
        win.isMinimized = false;
        win.zIndex = state.nextZIndex++;
        state.activeWindowId = win.id; // Set as active
        
        // Add a flag to indicate we're animating
        win.isRestoring = true;
        render();

        requestAnimationFrame(() => {
          const windowEl = document.getElementById(`window-${win.id}`);
          
          if (windowEl) {
            // Enable hardware acceleration
            windowEl.style.willChange = 'transform, opacity';
            
            const finalRect = windowEl.getBoundingClientRect();
            
            const scaleX = 56 / finalRect.width;
            const scaleY = 56 / finalRect.height;
            const translateX = dockRect.left + 28 - finalRect.left - finalRect.width / 2;
            const translateY = dockRect.top + 28 - finalRect.top - finalRect.height / 2;
            
            // Set initial state at dock position with 3D transforms
            windowEl.style.transform = `translate3d(${translateX}px, ${translateY}px, 0) scale3d(${scaleX}, ${scaleY}, 1)`;
            windowEl.style.opacity = '0';
            
            // Force layout recalculation
            void windowEl.offsetHeight;
            
            // Start animation to final position
            windowEl.style.transition = 'all 0.3s cubic-bezier(0.16, 1, 0.3, 1)';
            windowEl.style.transform = 'translate3d(0, 0, 0) scale3d(1, 1, 1)';
            windowEl.style.opacity = '1';
            
            setTimeout(() => {
              windowEl.style.transition = '';
              windowEl.style.transform = '';
              windowEl.style.willChange = 'auto';
              win.isRestoring = false;
            }, 300);
          } else {
            win.isRestoring = false;
          }
        });
      };

      window.toggleWindow = function toggleWindow(appId) {
        // Special handling for app launcher (finder)
        if (appId === 'finder') {
          state.showLaunchpad = !state.showLaunchpad;
          state.launchpadSearch = '';
          render();
          if (state.showLaunchpad) {
            // Focus search input after render
            setTimeout(() => {
              const searchInput = document.getElementById('launchpad-search');
              if (searchInput) searchInput.focus();
            }, 50);
          }
          return;
        }
        
        // Check for open (not minimized) windows
        const openWindow = state.windows.find((w) => w.appId === appId && !w.isMinimized);
        
        if (openWindow) {
          // Check if this window is already the focused window (highest z-index)
          const maxZIndex = Math.max(...state.windows.map(w => w.zIndex || 0));
          const isAlreadyFocused = openWindow.zIndex === maxZIndex;
          
          if (isAlreadyFocused) {
            // If already focused, minimize it
            minimizeWindow(openWindow.id);
          } else {
            // If not focused, just bring it to front
            focusWindow(openWindow.id);
          }
        } else {
          // Otherwise restore or create new window
          restoreWindow(appId);
        }
      };

      window.handleDockClick = function handleDockClick(e, appId) {
        // Only handle left click for toggle
        if (e.button === 0) {
          e.preventDefault();
          e.stopPropagation();
          toggleWindow(appId);
        }
      };

      window.handleDockMouseDown = function handleDockMouseDown(e, appId) {
        // Store click start position to detect drag vs click
        if (e.button === 0) {
          e._clickStartX = e.clientX;
          e._clickStartY = e.clientY;
          e._clickStartTime = Date.now();
          return;
        }
        
        // Middle click (button 1) opens new window
        if (e.button === 1) {
          e.preventDefault();
          const app = apps.find((a) => a.id === appId);
          if (app) {
            createWindow(app.id, app.name);
          }
        }
      };
      
      window.initDockDrag = function initDockDrag(e, appId) {
        // Only handle left click for drag reordering
        if (e.button !== 0) return;
        
        // Don't start drag on right click (for context menu)
        if (e.button === 2) return;
        
        const dockIcon = e.currentTarget;
        const rect = dockIcon.getBoundingClientRect();
        
        // Check if this is a pinned app
        const isPinned = state.pinnedApps.includes(appId);
        const currentIndex = isPinned ? state.pinnedApps.indexOf(appId) : -1;
        
        // Calculate offset between mouse position and icon's left edge
        const offsetX = e.clientX - rect.left;
        
        // Set up drag state for all apps including finder, but we'll prevent dragging finder later
        const isFinderIcon = appId === 'finder';
        
        dockDragState = {
          appId: appId,
          startX: e.clientX,
          currentX: e.clientX,
          deltaX: 0,
          iconWidth: rect.width,
          isDragging: false,
          dragThreshold: isFinderIcon ? 999999 : 6, // Set very high threshold for finder to prevent dragging
          originalIndex: currentIndex,
          currentIndex: currentIndex,
          draggedElement: dockIcon,
          isPinned: isPinned,
          lastSwapTime: 0,
          initialIconLeft: rect.left, // Store initial icon position
          offsetX: offsetX, // Store where on the icon the user clicked
          isFinderIcon: isFinderIcon, // Flag to identify finder icon
        };
        window.dockDragState = dockDragState;
        
        e.preventDefault();
        e.stopPropagation();
      };
      
      window.updateDockOrder = function updateDockOrder(fromIndex, toIndex) {
        if (fromIndex === toIndex) return;
        
        const newPinnedApps = [...state.pinnedApps];
        const [movedApp] = newPinnedApps.splice(fromIndex, 1);
        newPinnedApps.splice(toIndex, 0, movedApp);
        
        state.pinnedApps = newPinnedApps;
        // Persist to localStorage immediately for real-time saving
        localStorage.setItem('pinnedApps', JSON.stringify(state.pinnedApps));
      };

      window.maximizeWindow = function maximizeWindow(id) {
        const win = state.windows.find((w) => w.id === id);
        if (!win) {
          console.warn('maximizeWindow: no window found for id', id);
          return;
        }

        console.log('maximizeWindow: start', { id, isMaximized: win.isMaximized, isFullscreen: win.isFullscreen });

        const windowEl = document.getElementById(`window-${id}`);
        if (!windowEl) {
          console.warn('maximizeWindow: no DOM element for id', id);
          win.isMaximized = !win.isMaximized;
          win.isFullscreen = false;
          render();
          return;
        }

        // Calculate dock space based on current dock position and scale
        const dockPosition = state.dockPosition || 'bottom';
        const menubarHeight = 28;
        const dockDims = getDockDimensions();
        
        const dockSpaceBottom = dockPosition === 'bottom' ? dockDims.getBottomSpace() : 0;
        const dockSpaceSide = (dockPosition === 'left' || dockPosition === 'right') ? dockDims.getSideSpace() : 0;

        if (win.isMaximized) {
          // Restoring from maximized state
          const currentRect = windowEl.getBoundingClientRect();
          
          // Store values to restore to
          const restoreX = win.x;
          const restoreY = win.y;
          const restoreWidth = win.width;
          const restoreHeight = win.height;
          
          // Update window state IMMEDIATELY before animation
          win.isMaximized = false;
          win.isFullscreen = false;
          win.isSnapped = false;
          win.snapRestorePos = null;
          
          // Save to localStorage IMMEDIATELY so refresh works correctly
          const windowState = state.windowStates[win.appId] || {};
          windowState.x = restoreX;
          windowState.y = restoreY;
          windowState.width = restoreWidth;
          windowState.height = restoreHeight;
          windowState.isMaximized = false;
          windowState.isSnapped = false;
          windowState.snapRestorePos = null;
          state.windowStates[win.appId] = windowState;
          localStorage.setItem('windowStates', JSON.stringify(state.windowStates));
          
          // Enable hardware acceleration
          windowEl.style.willChange = 'transform, top, left, width, height, border-radius';
          windowEl.classList.add('restoring');
          
          // First, set the window to maximized state explicitly (respecting dock position)
          const targetWidth = window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0);
          const targetHeight = window.innerHeight - menubarHeight - dockSpaceBottom;
          const targetLeft = dockPosition === 'left' ? dockSpaceSide : 0;
          const targetTop = menubarHeight;
          
          windowEl.style.top = `${targetTop}px`;
          windowEl.style.left = `${targetLeft}px`;
          windowEl.style.width = `${targetWidth}px`;
          windowEl.style.height = `${targetHeight}px`;
          windowEl.style.borderRadius = '0px';
          windowEl.style.transform = 'none';
          windowEl.style.transition = 'none';
          
          // Force layout recalculation
          void windowEl.offsetHeight;
          
          // Use double requestAnimationFrame to GUARANTEE animation plays
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              // Now animate to restored position
              windowEl.style.transition = 'all 0.3s cubic-bezier(0.16, 1, 0.3, 1)';
              windowEl.style.top = `${restoreY}px`;
              windowEl.style.left = `${restoreX}px`;
              windowEl.style.width = `${restoreWidth}px`;
              windowEl.style.height = `${restoreHeight}px`;
              windowEl.style.borderRadius = '12px';
              windowEl.style.transform = 'scale3d(1, 1, 1)';
            });
          });
          
          setTimeout(() => {
            windowEl.classList.remove('restoring');
            windowEl.classList.remove('maximized');
            windowEl.style.willChange = 'auto';
            windowEl.style.transition = '';
            windowEl.style.transform = '';
            // Restore rounded corners for non-maximized state
            windowEl.style.borderRadius = '10px';
            
            render();
          }, 300);
          
        } else {
          // Maximizing
          const startRect = windowEl.getBoundingClientRect();
          
          // Store current position for restoration (prioritize snap restore position if available)
          if (!win.isMaximized) {
            if (win.isSnapped && win.snapRestorePos) {
              // Restore to pre-snap position when unmaximizing
              win.restoreX = win.snapRestorePos.x;
              win.restoreY = win.snapRestorePos.y;
              win.restoreWidth = win.snapRestorePos.width;
              win.restoreHeight = win.snapRestorePos.height;
            } else {
              win.restoreX = win.x;
              win.restoreY = win.y;
              win.restoreWidth = win.width;
              win.restoreHeight = win.height;
            }
          }
          
          // Clear snap state when maximizing
          win.isSnapped = false;
          win.snapRestorePos = null;
          
          // Update window state IMMEDIATELY before animation
          win.isMaximized = true;
          win.isFullscreen = false;
          // Store restore position for next time
          const tempX = win.restoreX || win.x;
          const tempY = win.restoreY || win.y;
          const tempWidth = win.restoreWidth || win.width;
          const tempHeight = win.restoreHeight || win.height;
          
          // Save to localStorage IMMEDIATELY so refresh works correctly
          const windowState = state.windowStates[win.appId] || {};
          windowState.x = tempX;
          windowState.y = tempY;
          windowState.width = tempWidth;
          windowState.height = tempHeight;
          windowState.isMaximized = true;
          state.windowStates[win.appId] = windowState;
          localStorage.setItem('windowStates', JSON.stringify(state.windowStates));
          
          // Enable hardware acceleration
          windowEl.style.willChange = 'transform, top, left, width, height, border-radius';
          windowEl.classList.add('maximizing');
          
          // Calculate target dimensions (accounting for menubar and dock)
          const targetWidth = window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0);
          const targetHeight = window.innerHeight - menubarHeight - dockSpaceBottom;
          const targetLeft = dockPosition === 'left' ? dockSpaceSide : 0;
          const targetTop = menubarHeight;
          
          // Set initial position explicitly
          windowEl.style.top = `${startRect.top}px`;
          windowEl.style.left = `${startRect.left}px`;
          windowEl.style.width = `${startRect.width}px`;
          windowEl.style.height = `${startRect.height}px`;
          windowEl.style.borderRadius = '12px';
          windowEl.style.transform = 'scale3d(1, 1, 1)';
          windowEl.style.transition = 'none';
          
          // Force layout recalculation
          void windowEl.offsetHeight;
          
          // Use double requestAnimationFrame to GUARANTEE animation plays
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              // Animate to maximized position (avoiding dock)
              windowEl.style.transition = 'all 0.3s cubic-bezier(0.16, 1, 0.3, 1)';
              windowEl.style.top = `${targetTop}px`;
              windowEl.style.left = `${targetLeft}px`;
              windowEl.style.width = `${targetWidth}px`;
              windowEl.style.height = `${targetHeight}px`;
              windowEl.style.borderRadius = '0px';
            });
          });
          
          setTimeout(() => {
            // Update position for next time
            win.x = tempX;
            win.y = tempY;
            win.width = tempWidth;
            win.height = tempHeight;
            windowEl.classList.remove('maximizing');
            windowEl.classList.add('maximized');
            windowEl.style.willChange = 'auto';
            windowEl.style.transition = '';
            // Keep border-radius: 0 for maximized state (don't clear it)
            windowEl.style.borderRadius = '0';
            
            render();
          }, 300);
        }
      };

      window.toggleFullscreen = function toggleFullscreen(id) {
        const win = state.windows.find((w) => w.id === id);
        if (!win) {
          console.warn('toggleFullscreen: no window found for id', id);
          return;
        }

        console.log('toggleFullscreen: start', { id, isFullscreen: win.isFullscreen });

        const windowEl = document.getElementById(`window-${id}`);
        if (!windowEl) {
          console.warn('toggleFullscreen: no DOM element for id', id);
          win.isFullscreen = !win.isFullscreen;
          win.isMaximized = false;
          render();
          return;
        }

        if (win.isFullscreen) {
          // EXITING borderless fullscreen - restore to previous state
          const currentRect = windowEl.getBoundingClientRect();
          
          // Get restore position
          const restoreX = win.fullscreenRestoreX || win.x || 100;
          const restoreY = win.fullscreenRestoreY || win.y || 100;
          const restoreWidth = win.fullscreenRestoreWidth || win.width || 800;
          const restoreHeight = win.fullscreenRestoreHeight || win.height || 600;
          const wasMaximized = win.fullscreenWasMaximized || false;
          
          // Update window state IMMEDIATELY
          win.isFullscreen = false;
          win.isMaximized = wasMaximized;
          
          // Clear fullscreen restore data
          delete win.fullscreenRestoreX;
          delete win.fullscreenRestoreY;
          delete win.fullscreenRestoreWidth;
          delete win.fullscreenRestoreHeight;
          delete win.fullscreenWasMaximized;
          
          // Enable hardware acceleration
          windowEl.style.willChange = 'transform, top, left, width, height, border-radius';
          windowEl.classList.add('restoring');
          windowEl.classList.remove('fullscreen');
          
          // Set starting position (fullscreen)
          windowEl.style.top = '0px';
          windowEl.style.left = '0px';
          windowEl.style.width = '100vw';
          windowEl.style.height = '100vh';
          windowEl.style.borderRadius = '0px';
          windowEl.style.transform = 'none';
          windowEl.style.transition = 'none';
          
          // Force layout
          void windowEl.offsetHeight;
          
          // Calculate target position
          let targetX, targetY, targetWidth, targetHeight, targetRadius;
          
          if (wasMaximized) {
            // Restore to maximized state
            const dockPosition = state.dockPosition || 'bottom';
            const menubarHeight = 28;
            const dockDims = getDockDimensions();
            const dockSpaceBottom = dockPosition === 'bottom' ? dockDims.getBottomSpace() : 0;
            const dockSpaceSide = (dockPosition === 'left' || dockPosition === 'right') ? dockDims.getSideSpace() : 0;
            
            targetWidth = window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0);
            targetHeight = window.innerHeight - menubarHeight - dockSpaceBottom;
            targetX = dockPosition === 'left' ? dockSpaceSide : 0;
            targetY = menubarHeight;
            targetRadius = '0px';
          } else {
            // Restore to windowed state
            targetX = restoreX;
            targetY = restoreY;
            targetWidth = restoreWidth;
            targetHeight = restoreHeight;
            targetRadius = '12px';
          }
          
          // Animate
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              windowEl.style.transition = 'all 0.3s cubic-bezier(0.16, 1, 0.3, 1)';
              windowEl.style.top = `${targetY}px`;
              windowEl.style.left = `${targetX}px`;
              windowEl.style.width = `${targetWidth}px`;
              windowEl.style.height = `${targetHeight}px`;
              windowEl.style.borderRadius = targetRadius;
              windowEl.style.transform = 'scale3d(1, 1, 1)';
            });
          });
          
          setTimeout(() => {
            windowEl.classList.remove('restoring');
            if (wasMaximized) {
              windowEl.classList.add('maximized');
            }
            windowEl.style.willChange = 'auto';
            windowEl.style.transition = '';
            windowEl.style.transform = '';
            windowEl.style.borderRadius = wasMaximized ? '0px' : '10px';
            
            render();
          }, 300);
          
        } else {
          // ENTERING borderless fullscreen
          const startRect = windowEl.getBoundingClientRect();
          
          // Store current position for restoration
          win.fullscreenRestoreX = win.x;
          win.fullscreenRestoreY = win.y;
          win.fullscreenRestoreWidth = win.width;
          win.fullscreenRestoreHeight = win.height;
          win.fullscreenWasMaximized = win.isMaximized;
          
          // Update window state IMMEDIATELY
          win.isFullscreen = true;
          win.isMaximized = false;
          
          // Enable hardware acceleration
          windowEl.style.willChange = 'transform, top, left, width, height, border-radius';
          windowEl.classList.add('maximizing'); // Use maximizing animation
          
          // Set initial position explicitly
          windowEl.style.top = `${startRect.top}px`;
          windowEl.style.left = `${startRect.left}px`;
          windowEl.style.width = `${startRect.width}px`;
          windowEl.style.height = `${startRect.height}px`;
          windowEl.style.borderRadius = win.fullscreenWasMaximized ? '0px' : '12px';
          windowEl.style.transform = 'scale3d(1, 1, 1)';
          windowEl.style.transition = 'none';
          
          // Force layout
          void windowEl.offsetHeight;
          
          // Animate to borderless fullscreen (entire screen, no corners)
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              windowEl.style.transition = 'all 0.3s cubic-bezier(0.16, 1, 0.3, 1)';
              windowEl.style.top = '0px';
              windowEl.style.left = '0px';
              windowEl.style.width = '100vw';
              windowEl.style.height = '100vh';
              windowEl.style.borderRadius = '0px';
            });
          });
          
          setTimeout(() => {
            windowEl.classList.remove('maximizing');
            windowEl.classList.add('fullscreen');
            windowEl.style.willChange = 'auto';
            windowEl.style.transition = '';
            windowEl.style.borderRadius = '0';
            
            render();
            
            // Focus iframe after fullscreen for keyboard events
            requestAnimationFrame(() => {
              const iframe = windowEl.querySelector('iframe');
              if (iframe) {
                try {
                  iframe.focus();
                  if (iframe.contentWindow) {
                    iframe.contentWindow.focus();
                    // Request pointer lock for games like Minecraft
                    if (win.appId === 'minecraft') {
                      try {
                        const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                        const canvas = iframeDoc.querySelector('canvas');
                        if (canvas && canvas.requestPointerLock) {
                          canvas.addEventListener('click', function() {
                            canvas.requestPointerLock();
                          }, { once: false });
                        }
                      } catch (e) {
                        console.log('Could not set up pointer lock for Minecraft');
                      }
                    }
                  }
                } catch (e) {
                  iframe.focus();
                }
              }
            });
          }, 300);
        }
      };
      
      // Fullscreen UI visibility helpers
      window.showFullscreenUI = function(winId) {
        const windowEl = document.getElementById(`window-${winId}`);
        if (windowEl) {
          const overlayUI = windowEl.querySelector('.fullscreen-overlay-ui');
          if (overlayUI) {
            overlayUI.classList.add('visible');
          }
        }
      };
      
      window.hideFullscreenUI = function(winId) {
        const windowEl = document.getElementById(`window-${winId}`);
        if (windowEl) {
          const overlayUI = windowEl.querySelector('.fullscreen-overlay-ui');
          if (overlayUI) {
            overlayUI.classList.remove('visible');
          }
        }
      };
      
      // Track when iframes steal focus and handle OS-level keybinds
      let lastFocusedIframe = null;
      
      window.addEventListener('blur', function() {
        // When main window loses focus (likely to an iframe), store which one
        const activeWin = state.windows.find(w => w.id === state.activeWindowId);
        if (activeWin) {
          const windowEl = document.getElementById(`window-${activeWin.id}`);
          if (windowEl) {
            const iframe = windowEl.querySelector('iframe');
            if (iframe && document.activeElement === iframe) {
              lastFocusedIframe = iframe;
            }
          }
        }
      });
      
      // Use capture phase to intercept keyboard events before iframes
      window.addEventListener('keydown', function(e) {
        // Handle OS-level keybinds even when iframe has focus
        if (e.key === 'Escape') {
          const fullscreenWin = state.windows.find(w => w.isFullscreen);
          if (fullscreenWin) {
            window.toggleFullscreen(fullscreenWin.id);
            e.preventDefault();
            e.stopPropagation();
            return;
          }
        }
        
        if (e.ctrlKey && e.shiftKey && (e.key === 'f' || e.key === 'F')) {
          e.preventDefault();
          e.stopPropagation();
          
          const activeWin = state.windows.find(w => w.id === state.activeWindowId);
          if (activeWin) {
            const app = apps.find(a => a.id === activeWin.appId);
            if ((app && app.supportsFullscreen) || activeWin.isFullscreen) {
              window.toggleFullscreen(activeWin.id);
            }
          }
          return;
        }
      }, true); // Use capture phase
      
      // Global mousedown handler in capture phase to ensure OS UI elements
      // (dock, menubar, desktop shortcuts) work even when an iframe has focus.
      // This fires BEFORE the iframe can capture the event.
      document.addEventListener('mousedown', (e) => {
        const target = e.target;
        
        // Check if click is on dock, menubar, or desktop (not inside a window)
        const isOnDock = target.closest('.dock-container');
        const isOnMenubar = target.closest('.menubar');
        const isOnDesktop = target.closest('.desktop-bg') && !target.closest('.window');
        const isOnDesktopShortcut = target.closest('.desktop-shortcut');
        const isOnLaunchpad = target.closest('.launchpad-overlay');
        const isOnQuickSettings = target.closest('.quick-settings');
        const isOnContextMenu = target.closest('.context-menu');
        
        if (isOnDock || isOnMenubar || isOnDesktop || isOnDesktopShortcut || isOnLaunchpad || isOnQuickSettings || isOnContextMenu) {
          // Blur any focused iframe to ensure OS UI can receive focus
          const focusedIframe = document.activeElement;
          if (focusedIframe && focusedIframe.tagName === 'IFRAME') {
            focusedIframe.blur();
          }
          
          // Deactivate all windows when clicking on OS elements
          if (isOnDesktop || isOnDock || isOnMenubar) {
            window.deactivateAllWindows();
          }
        }
      }, true); // Use capture phase to fire before bubbling
      
      window.handleLaunchpadSearch = function handleLaunchpadSearch(e) {
        state.launchpadSearch = e.target.value;
        
        // Update only the grid instead of full re-render
        const launchpadGrid = document.querySelector('.launchpad-grid');
        if (launchpadGrid) {
          const searchLower = state.launchpadSearch.toLowerCase();
          const filteredApps = apps.filter(app => {
            if (!state.launchpadSearch) return true;
            return app.name.toLowerCase().includes(searchLower);
          });
          
          launchpadGrid.innerHTML = filteredApps.map(app => `
            <div class="launchpad-item" onclick="window.toggleWindow('${app.id}'); window.closeLaunchpad();">
              ${icons[app.icon]}
              <span style="color: white; font-size: 13px; text-align: center; font-weight: 500;">${app.name}</span>
            </div>
          `).join('');
        }
      };

      window.closeLaunchpad = function closeLaunchpad() {
        if (state.showLaunchpad) {
          state.showLaunchpad = false;
          state.launchpadSearch = '';
          render();
        }
      };

      window.focusWindow = function focusWindow(id) {
        const win = state.windows.find((w) => w.id === id);
        if (win) {
          playSound('focus');
          win.zIndex = state.nextZIndex++;
          state.activeWindowId = id;
          
          // Update z-index and active state directly without re-rendering to preserve input state
          document.querySelectorAll('.window').forEach(windowEl => {
            const winId = parseInt(windowEl.dataset.id, 10);
            if (winId === id) {
              windowEl.style.zIndex = win.zIndex;
              windowEl.classList.remove('inactive');
              
              // If this window has an iframe (browser/game), focus it for keyboard controls.
              // BUT: don't steal focus from editable UI like the browser address bar.
              if (win.isFullscreen || win.appId === 'minecraft' || win.appId === 'browser') {
                const iframe = windowEl.querySelector('iframe');
                if (iframe) {
                  setTimeout(() => {
                    // If user is editing an input inside the browser chrome, keep focus there.
                    if (win.appId === 'browser') {
                      const ae = document.activeElement;
                      const isEditing = !!(
                        ae &&
                        (ae.tagName === 'INPUT' || ae.tagName === 'TEXTAREA' || ae.isContentEditable) &&
                        ae.closest('.browser-header')
                      );
                      if (isEditing) return;
                    }

                    try {
                      iframe.focus();
                      if (iframe.contentWindow) {
                        iframe.contentWindow.focus();
                      }
                    } catch (e) {
                      iframe.focus();
                    }
                  }, 50);
                }
              }
            } else {
              windowEl.classList.add('inactive');
            }
          });
          
          // Update window list buttons in the menubar to show active state
          const windowListWrapper = document.querySelector('[data-element-id="windowlist"]');
          if (windowListWrapper) {
            windowListWrapper.querySelectorAll('button').forEach(btn => {
              const onclick = btn.getAttribute('onclick');
              if (onclick) {
                const match = onclick.match(/handleWindowListClick\((\d+)\)|restoreWindowById\((\d+)\)/);
                if (match) {
                  const btnWindowId = parseInt(match[1] || match[2], 10);
                  if (btnWindowId === id) {
                    btn.style.background = 'hsl(var(--primary) / 0.2)';
                    btn.style.border = '1px solid hsl(var(--primary) / 0.3)';
                  } else {
                    btn.style.background = '';
                    btn.style.border = '';
                  }
                }
              }
            });
          }
          // Don't call render() here to avoid input field refresh
        }
      };
      
      // Handle window list button click - same behavior as dock
      window.handleWindowListClick = function(windowId) {
        const win = state.windows.find(w => w.id === windowId);
        if (!win) return;
        
        // Check if this window is already the top window (highest z-index)
        const maxZIndex = Math.max(...state.windows.map(w => w.zIndex || 0));
        const isTopWindow = win.zIndex === maxZIndex;
        
        if (isTopWindow) {
          // If already on top, minimize it
          minimizeWindow(windowId);
        } else {
          // If not on top, bring it to front
          focusWindow(windowId);
        }
      };
      
      // Restore a minimized window by its ID
      window.restoreWindowById = function(windowId) {
        const win = state.windows.find(w => w.id === windowId);
        if (win && win.isMinimized) {
          win.isMinimized = false;
          win.zIndex = state.nextZIndex++;
          state.activeWindowId = windowId;
          playSound('focus');
          render();
        }
      };
      
      // Deactivate all windows (when clicking outside of windows)
      window.deactivateAllWindows = function deactivateAllWindows() {
        state.activeWindowId = null;

        // Mark all windows as inactive
        document.querySelectorAll('.window').forEach(windowEl => {
          windowEl.classList.add('inactive');
        });
      };

      window.togglePinApp = function togglePinApp(appId) {
        const app = apps.find((a) => a.id === appId);
        if (app?.isPermanent) return;

        if (state.pinnedApps.includes(appId)) {
          state.pinnedApps = state.pinnedApps.filter((id) => id !== appId);
        } else {
          state.pinnedApps.push(appId);
        }
        localStorage.setItem('pinnedApps', JSON.stringify(state.pinnedApps));
        state.contextMenu = null;
        render();
      };

      window.showContextMenu = function showContextMenu(e, appId) {
        e.preventDefault();
        e.stopPropagation();
        const iconRect = e.currentTarget.getBoundingClientRect();
        state.contextMenu = {
          x: iconRect.left + iconRect.width / 2 - 90,
          y: iconRect.top - 88,
          appId,
        };
        render();
      };

      function updateTime() {
        const timeEl = document.querySelector('.current-time');
        if (timeEl) {
          timeEl.textContent = state.currentTime.toLocaleTimeString('en-US', {
            hour: 'numeric',
            minute: '2-digit',
          });
        }
      }

      function getWindowContent(appId) {
        if (appId === 'finder') {
          return `
            <div class="launchpad-grid">
              ${apps
                .map(
                  (app) => `
                    <div class="launchpad-item" onclick="window.toggleWindow('${app.id}')">
                      ${icons[app.icon]}
                      <span>${app.name}</span>
                    </div>
                  `,
                )
                .join('')}
            </div>
          `;
        }
        if (appId === 'cursor-calibration') {
          // Return the full calibration content directly for persistence across renders
          return getCalibrationContent();
        }
        if (appId === 'terminal') {
          // Get the window ID from the current windows array
          const win = state.windows.find(w => w.appId === 'terminal');
          const terminalId = win ? win.id : 'new';
          const history = state.terminalHistory[terminalId] || [];
          
          const savedValue = state.inputValues[`terminal-${terminalId}`] || '';
          return `
            <div class="terminal-content" data-terminal-id="${terminalId}">
              ${history.join('')}
              <div class="terminal-input-line" style="margin-top: 10px;">
                <span>user@mos ~ %</span>
                <input class="terminal-input" data-terminal-id="${terminalId}" type="text" value="${savedValue}" autofocus onkeydown="handleTerminalKeydown(event, ${terminalId})" onclick="event.stopPropagation()" />
              </div>
            </div>
          `;
        }
        if (appId === 'browser') {
          const win = state.windows.find(w => w.appId === 'browser');
          const windowId = win ? win.id : 'new';
          const savedValue = state.inputValues[windowId] || '';
          
          // Initialize tabs if needed
          initBrowserTabs(windowId);
          const tabs = state.browserTabs[windowId] || [];
          const activeTab = tabs.find(t => t.active);
          const currentUrl = activeTab?.url || '';
          
          // Update state to match active tab - but don't override inputValues if user might be editing
          state.browserUrls[windowId] = currentUrl;
          
          // Only sync inputValues to currentUrl on initial load (when inputValues is empty or matches browser URL)
          // This prevents overwriting what the user is typing
          if (!state.inputValues[windowId] || state.inputValues[windowId] === state.browserUrls[windowId]) {
            // Don't update inputValues here - let it be set only on navigation
          }
          
          // Update current tab info
          updateCurrentTabInfo(windowId);
          
          const isVerticalTabs = state.browserVerticalTabs;
          
          // Generate tabs HTML
          const generateTabs = () => tabs.map(tab => `
            <div class="browser-tab ${tab.active ? 'active' : ''}" data-tab-id="${tab.id}" onclick="window.switchBrowserTab(${windowId}, ${tab.id})">
              ${tab.loading ? '<div class="browser-tab-loading"></div>' : (tab.favicon ? `<img class="browser-tab-favicon" src="${tab.favicon}" alt="" onerror="this.style.display='none'" />` : '')}
              <span class="browser-tab-title">${tab.title}</span>
              <div class="browser-tab-close" onclick="window.closeBrowserTab(event, ${windowId}, ${tab.id})">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 12px; height: 12px;">
                  <path d="M18 6L6 18M6 6l12 12" stroke-linecap="round"/>
                </svg>
              </div>
            </div>
          `).join('');
          
          // Generate bookmarks bar
          const generateBookmarksBar = () => `
            <div class="browser-bookmarks-bar">
              ${state.browserBookmarks.map((bookmark, idx) => {
                let domain = bookmark;
                try { domain = new URL(bookmark).hostname.replace('www.', ''); } catch(e) {}
                return `
                  <div class="browser-bookmark ${state.activeBookmarkIndex === idx ? 'show-actions' : ''}" 
                       onclick="if(!event.target.closest('.browser-bookmark-action')){window.navigateCurrentTab(${windowId}, '${bookmark}')}" 
                       oncontextmenu="event.preventDefault(); window.toggleBookmarkActions(${idx})"
                       title="${bookmark}">
                    ${domain}
                    <div class="browser-bookmark-actions">
                      <div class="browser-bookmark-action" onclick="event.stopPropagation(); window.openEditBookmarkDialog(${idx})" title="Edit">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                          <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                          <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                        </svg>
                      </div>
                      <div class="browser-bookmark-action" onclick="event.stopPropagation(); window.removeBookmark(${idx})" title="Delete">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                          <path d="M18 6L6 18M6 6l12 12"/>
                        </svg>
                      </div>
                    </div>
                  </div>
                `;
              }).join('')}
              <div class="browser-bookmark" onclick="window.openAddBookmarkDialog()" title="Add Bookmark" style="opacity: 0.5;">+</div>
            </div>
          `;
          
          // Generate toolbar
          const generateToolbar = (addressValue, placeholder) => `
            <div class="browser-toolbar">
              <div class="browser-nav-buttons">
                <button class="browser-nav-button" title="Back" onclick="window.browserBack(${windowId})">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M19 12H5M12 19l-7-7 7-7" stroke-linecap="round" stroke-linejoin="round"/>
                  </svg>
                </button>
                <button class="browser-nav-button" title="Forward" onclick="window.browserForward(${windowId})">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M5 12h14M12 5l7 7-7 7" stroke-linecap="round" stroke-linejoin="round"/>
                  </svg>
                </button>
                <button class="browser-nav-button" title="Refresh" onclick="window.browserRefresh(${windowId})">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2" stroke-linecap="round" stroke-linejoin="round"/>
                  </svg>
                </button>
              </div>
              <div class="browser-address-bar">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <circle cx="11" cy="11" r="8"/>
                  <path d="m21 21-4.35-4.35"/>
                </svg>
                <input type="text" class="browser-address-input" data-window-id="${windowId}" value="${addressValue}" placeholder="${placeholder}" onclick="event.stopPropagation()" oninput="window.updateInputValue(${windowId}, this.value)" onkeydown="window.handleBrowserAddressKeydown(event, ${windowId})" />
              </div>
              <div class="browser-nav-buttons" style="margin-left: 8px;">
                <button class="browser-nav-button ${isVerticalTabs ? 'active' : ''}" title="Toggle Vertical Tabs" onclick="window.toggleBrowserVerticalTabs()" style="${isVerticalTabs ? 'background: hsl(var(--primary) / 0.2);' : ''}">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="3" width="18" height="18" rx="2"/>
                    <path d="M9 3v18"/>
                  </svg>
                </button>
                <button class="browser-nav-button ${state.showBrowserHistory ? 'active' : ''}" title="Search History" onclick="window.toggleBrowserHistory()" style="${state.showBrowserHistory ? 'background: hsl(var(--primary) / 0.2);' : ''}">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <polyline points="12 6 12 12 16 14"/>
                  </svg>
                </button>
              </div>
            </div>
          `;
          
          // Generate history panel
          const generateHistoryPanel = () => {
            if (!state.showBrowserHistory) return '';
            
            const formatTime = (timestamp) => {
              const date = new Date(timestamp);
              const now = new Date();
              const diffMs = now - date;
              const diffMins = Math.floor(diffMs / 60000);
              const diffHours = Math.floor(diffMs / 3600000);
              const diffDays = Math.floor(diffMs / 86400000);
              
              if (diffMins < 1) return 'Just now';
              if (diffMins < 60) return diffMins + 'm ago';
              if (diffHours < 24) return diffHours + 'h ago';
              if (diffDays < 7) return diffDays + 'd ago';
              return date.toLocaleDateString();
            };
            
            return `
              <div class="browser-history-panel">
                <div class="browser-history-header">
                  <h3>Search History</h3>
                  <div style="display: flex; gap: 8px;">
                    <button onclick="window.clearBrowserSearchHistory()" style="padding: 4px 8px; background: hsl(var(--destructive)); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Clear All</button>
                    <button onclick="window.toggleBrowserHistory()" style="padding: 4px 8px; background: hsl(var(--accent)); color: hsl(var(--foreground)); border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Close</button>
                  </div>
                </div>
                <div class="browser-history-list">
                  ${state.browserSearchHistory.length === 0 ? `
                    <div class="browser-history-empty">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 48px; height: 48px; margin: 0 auto 16px; opacity: 0.3;">
                        <circle cx="11" cy="11" r="8"/>
                        <path d="m21 21-4.35-4.35"/>
                      </svg>
                      <p>No search history yet</p>
                      <p style="font-size: 12px; opacity: 0.7; margin-top: 8px;">Type something in the address bar to search</p>
                    </div>
                  ` : state.browserSearchHistory.map(item => `
                    <div class="browser-history-item" onclick="window.searchFromHistory(${windowId}, '${item.query.replace(/'/g, "\\'")}')">
                      <div class="browser-history-item-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                          <circle cx="11" cy="11" r="8"/>
                          <path d="m21 21-4.35-4.35"/>
                        </svg>
                      </div>
                      <div class="browser-history-item-text">${item.query}</div>
                      <div class="browser-history-item-time">${formatTime(item.timestamp)}</div>
                    </div>
                  `).join('')}
                </div>
              </div>
            `;
          };
          
          // Generate per-tab content wrappers
          const generateTabContent = () => {
            return tabs.map(tab => {
              const isActive = tab.active;
              if (tab.url) {
                // Tab has URL - show iframe
                return `
                  <div class="browser-tab-iframe-wrapper ${isActive ? 'active' : ''}" data-tab-id="${tab.id}">
                    <div class="iframe-click-interceptor" onclick="event.stopPropagation(); window.focusWindow(${windowId}); const browserWin = state.windows.find(w => w.id === ${windowId}); if(browserWin) { const iframe = this.parentElement.querySelector('iframe'); if(iframe) { iframe.focus(); if(iframe.contentWindow) iframe.contentWindow.focus(); } }"></div>
                    <div class="browser-iframe-blocker" onclick="window.browserBlockerClick(this)"></div>
                    <iframe class="browser-iframe" id="browser-iframe-${windowId}-${tab.id}" src="${tab.url}" 
                      sandbox="allow-same-origin allow-scripts allow-popups allow-forms allow-top-navigation allow-pointer-lock" 
                      allow="fullscreen; gamepad" tabindex="0"
                      onload="window.onBrowserTabLoad(${windowId}, ${tab.id})"></iframe>
                  </div>
                `;
              } else {
                // Tab is home page - use M Search home
                return `
                  <div class="browser-tab-iframe-wrapper ${isActive ? 'active' : ''}" data-tab-id="${tab.id}">
                    ${getBrowserHomeContent(windowId)}
                  </div>
                `;
              }
            }).join('');
          };
          
          // Return layout based on vertical tabs setting
          if (isVerticalTabs) {
            return `
              <div class="browser-container vertical-tabs" data-window-id="${windowId}">
                <div class="browser-sidebar">
                  <div class="browser-tabs-container">
                    ${generateTabs()}
                    <button class="browser-new-tab-btn" onclick="window.createBrowserTab(${windowId})" title="New Tab">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 18px; height: 18px;">
                        <path d="M12 5v14M5 12h14" stroke-linecap="round"/>
                      </svg>
                      <span style="margin-left: 8px; font-size: 13px;">New Tab</span>
                    </button>
                  </div>
                </div>
                <div class="browser-main">
                  <div class="browser-header" onmouseenter="window.browserHeaderEnter(this)" onmouseleave="window.browserHeaderLeave(this)">
                    ${generateBookmarksBar()}
                    ${generateToolbar(savedValue || currentUrl, 'Search with M Search or enter URL')}
                  </div>
                  <div class="browser-content-wrapper" style="position: relative;">
                    <div class="browser-tab-iframes">
                      ${generateTabContent()}
                    </div>
                    ${generateHistoryPanel()}
                  </div>
                </div>
              </div>
            `;
          } else {
            return `
              <div class="browser-container" data-window-id="${windowId}">
                <div class="browser-header" onmouseenter="window.browserHeaderEnter(this)" onmouseleave="window.browserHeaderLeave(this)">
                  <div class="browser-tabs-container">
                    ${generateTabs()}
                    <button class="browser-new-tab-btn" onclick="window.createBrowserTab(${windowId})" title="New Tab">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 18px; height: 18px;">
                        <path d="M12 5v14M5 12h14" stroke-linecap="round"/>
                      </svg>
                    </button>
                  </div>
                  ${generateBookmarksBar()}
                  ${generateToolbar(savedValue || currentUrl, 'Search with M Search or enter URL')}
                </div>
                <div class="browser-content-wrapper" style="position: relative;">
                  <div class="browser-tab-iframes">
                    ${generateTabContent()}
                  </div>
                  ${generateHistoryPanel()}
                </div>
              </div>
            `;
          }
        }
        if (appId === 'settings') {
          const activeTab = state.settingsTab || 'appearance';
          const searchQuery = state.settingsSearchQuery || '';
          
          const settingsItems = [
            { id: 'general', label: 'General', icon: '<circle cx="12" cy="12" r="3"/><path d="M12 1v6m0 6v6m9-9h-6m-6 0H3"/>' },
            { id: 'appearance', label: 'Appearance', icon: '<circle cx="12" cy="12" r="10"/><path d="M12 2a10 10 0 0 1 0 20"/>' },
            { id: 'control-centre', label: 'Control Centre', icon: '<circle cx="12" cy="12" r="3"/><circle cx="19" cy="5" r="2"/><circle cx="5" cy="19" r="2"/><path d="M10.4 10.4 7 7m7.6 7.6 3.4 3.4"/>' },
            { id: 'desktop-dock', label: 'Desktop & Dock', icon: '<rect x="2" y="3" width="20" height="14" rx="2"/><path d="M8 21h8M12 17v4"/>' },
            { id: 'notifications', label: 'Notifications', icon: '<path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9M13.73 21a2 2 0 0 1-3.46 0"/>' },
            { id: 'sound', label: 'Sound', icon: '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/>' },
            { id: 'mouse', label: 'Mouse & Cursor', icon: '<path d="M12 2v6m-2-2 2-2 2 2M12 22v-6m-2 2 2 2 2-2"/><path d="M6 12H2m4-2-2 2 2 2M22 12h-4m2-2-2 2 2 2"/>' },
            { id: 'system', label: 'System', icon: '<rect x="4" y="4" width="16" height="16" rx="2"/><rect x="9" y="9" width="6" height="6"/><path d="M9 1v2M15 1v2M9 21v2M15 21v2M1 9h2M1 15h2M21 9h2M21 15h2"/>' }
          ];
          
          const filteredItems = settingsItems.filter(item => 
            item.label.toLowerCase().includes(searchQuery.toLowerCase())
          );
          
          return `
            <div class="settings-container">
              <div class="settings-sidebar">
                <div class="settings-search">
                  <input 
                    type="text" 
                    placeholder="Search" 
                    value="${searchQuery}"
                    oninput="event.stopPropagation(); window.filterSettingsItems(this.value)"
                    onclick="event.stopPropagation()" 
                  />
                </div>
                <div style="padding: 8px 0;">
                  ${filteredItems.map(item => `
                    <div class="settings-nav-item ${activeTab === item.id ? 'active' : ''}" onclick="event.stopPropagation(); window.switchSettingsTab('${item.id}')">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        ${item.icon}
                      </svg>
                      <span>${item.label}</span>
                    </div>
                  `).join('')}
                  ${filteredItems.length === 0 ? '<div style="padding: 12px; text-align: center; color: rgba(255,255,255,0.5); font-size: 13px;">No results found</div>' : ''}
                </div>
              </div>
              
              <div class="settings-content">
                ${getSettingsContent(activeTab)}
              </div>
            </div>
          `;
        }
        if (appId === 'taskmanager') {
          // Return initial structure immediately to prevent blank window
          // The actual content will be managed by updateTaskManagerContent which updates values
          return `<div data-task-manager-container style="width: 100%; height: 100%; display: flex; flex-direction: column; background: hsl(var(--window-bg)); color: hsl(var(--foreground)); font-family: 'JetBrains Mono', monospace; overflow: hidden;">
            <!-- Header with stats -->
            <div style="padding: 16px 20px; border-bottom: 1px solid hsl(var(--window-border)); display: flex; gap: 24px; align-items: center; background: hsl(var(--titlebar-bg));">
              <div style="display: flex; align-items: center; gap: 8px;">
                <div style="width: 12px; height: 12px; border-radius: 50%; background: #10B981;"></div>
                <span data-stat-cpu style="font-size: 12px; font-weight: 600;">CPU: 0.0%</span>
              </div>
              <div style="display: flex; align-items: center; gap: 8px;">
                <div style="width: 12px; height: 12px; border-radius: 50%; background: #3B82F6;"></div>
                <span data-stat-memory style="font-size: 12px; font-weight: 600;">Memory: 0 MB</span>
              </div>
              <div style="display: flex; align-items: center; gap: 8px;">
                <div style="width: 12px; height: 12px; border-radius: 50%; background: #F59E0B;"></div>
                <span data-stat-processes style="font-size: 12px; font-weight: 600;">Processes: 0</span>
              </div>
              <div style="flex: 1;"></div>
              <div style="font-size: 10px; color: hsl(var(--muted-foreground));">Auto-refresh: 1s</div>
            </div>
            
            <!-- Process table header -->
            <div style="display: grid; grid-template-columns: 80px 1fr 80px 100px 100px 100px; padding: 10px 20px; border-bottom: 1px solid hsl(var(--window-border)); font-size: 11px; font-weight: 600; color: hsl(var(--muted-foreground)); text-transform: uppercase; letter-spacing: 0.05em; background: hsl(var(--accent) / 0.3);">
              <span>PID</span>
              <span>Process Name</span>
              <span>CPU %</span>
              <span>Memory</span>
              <span>Status</span>
              <span>Actions</span>
            </div>
            
            <!-- Process list -->
            <div data-process-list style="flex: 1; overflow-y: auto; scrollbar-width: thin;">
              <div style="padding: 40px; text-align: center; color: hsl(var(--muted-foreground));">Loading processes...</div>
            </div>
            
            <!-- Footer -->
            <div style="padding: 12px 20px; border-top: 1px solid hsl(var(--window-border)); display: flex; justify-content: space-between; align-items: center; background: hsl(var(--titlebar-bg)); font-size: 11px; color: hsl(var(--muted-foreground));">
              <span>M OS Task Manager</span>
              <span>Press Ctrl+Alt+\` or Ctrl+Alt+; to quick open</span>
            </div>
          </div>`;
        }
        if (appId === 'minecraft') {
          // Check if Minecraft is installed
          const isInstalled = state.installedApps && state.installedApps.includes('minecraft');
          
          if (!isInstalled) {
            return `
              <div style="width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%); color: white; text-align: center; padding: 40px;">
                <div style="width: 120px; height: 120px; margin-bottom: 24px;">
                  ${icons.Minecraft}
                </div>
                <h2 style="font-size: 24px; font-weight: 600; margin-bottom: 12px;">Minecraft Not Installed</h2>
                <p style="font-size: 14px; color: #888; margin-bottom: 24px;">Install Minecraft from the App Store to play</p>
                <button 
                  style="padding: 12px 32px; background: hsl(var(--primary)); color: white; border: none; border-radius: 24px; font-size: 16px; font-weight: 600; cursor: pointer; transition: transform 0.15s ease;"
                  onmouseover="this.style.transform='scale(1.05)';"
                  onmouseout="this.style.transform='scale(1)';"
                  onclick="event.stopPropagation(); window.toggleWindow('appstore');"
                >
                  Open App Store
                </button>
              </div>
            `;
          }
          
          // Load from localStorage and use srcdoc for better compatibility
          const minecraftFile = localStorage.getItem('fakePCFile_minecraft.html');
          
          if (!minecraftFile) {
            return `
              <div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background: #1a1a1a; color: white;">
                <p>Minecraft not found. Please reinstall from App Store.</p>
              </div>
            `;
          }
          
          // Check if there's a preserved iframe for ANY minecraft window
          // This is a simplified approach since we typically only have one minecraft window
          let hasPreservedIframe = false;
          let preservedKey = null;
          
          for (const key of preservedIframes.keys()) {
            if (key.startsWith('minecraft-')) {
              hasPreservedIframe = true;
              preservedKey = key;
              break;
            }
          }
          
          if (hasPreservedIframe) {
            // Return empty container with exit button - iframe will be reattached after render
            return `
              <div class="minecraft-container" data-preserved="true" data-key="${preservedKey}" style="width: 100%; height: 100%; overflow: hidden; background: #1a1a1a; position: relative;">
                <div class="iframe-click-interceptor" onclick="event.stopPropagation(); const win = state.windows.find(w => w.appId === 'minecraft'); if(win) { window.focusWindow(win.id); const iframe = this.parentElement.querySelector('iframe'); if(iframe) { iframe.focus(); if(iframe.contentWindow) iframe.contentWindow.focus(); } }"></div>
                <button class="fullscreen-exit-btn" onclick="event.stopPropagation(); const win = state.windows.find(w => w.appId === 'minecraft'); if(win) window.toggleFullscreen(win.id);" title="Toggle Fullscreen">
                  <svg viewBox="0 0 24 24">
                    <path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3" stroke-linecap="round" stroke-linejoin="round"/>
                  </svg>
                </button>
              </div>
            `;
          }
          
          // Escape the HTML content for srcdoc attribute
          const escapedContent = minecraftFile
            .replace(/&/g, '&amp;')
            .replace(/"/g, '&quot;');
          
          return `
            <div class="minecraft-container" style="width: 100%; height: 100%; overflow: hidden; background: #1a1a1a; position: relative;">
              <div class="iframe-click-interceptor" onclick="event.stopPropagation(); const win = state.windows.find(w => w.appId === 'minecraft'); if(win) { window.focusWindow(win.id); const iframe = this.parentElement.querySelector('iframe'); if(iframe) { iframe.focus(); if(iframe.contentWindow) iframe.contentWindow.focus(); } }"></div>
              <iframe 
                id="minecraft-frame"
                srcdoc="${escapedContent}" 
                style="width: 100%; height: 100%; border: none; display: block;"
                allow="fullscreen; gamepad; autoplay; pointer-lock"
                sandbox="allow-scripts allow-same-origin allow-pointer-lock allow-popups allow-forms allow-modals"
                tabindex="0"
                onload="this.focus(); this.contentWindow && this.contentWindow.focus();"
              ></iframe>
              <button class="fullscreen-exit-btn" onclick="event.stopPropagation(); const win = state.windows.find(w => w.appId === 'minecraft'); if(win) window.toggleFullscreen(win.id);" title="Toggle Fullscreen">
                <svg viewBox="0 0 24 24">
                  <path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
              </button>
            </div>
          `;
        }
        if (appId === 'appstore') {
          const minecraftInstalled = state.installedApps && state.installedApps.includes('minecraft');
          
          return `
            <div class="appstore-container" style="height: 100%; background: linear-gradient(180deg, hsl(var(--window-bg)) 0%, hsl(var(--accent) / 0.3) 100%); overflow-y: auto; padding: 24px;">
              <div style="max-width: 800px; margin: 0 auto;">
                <h1 style="font-size: 32px; font-weight: 700; margin-bottom: 8px; color: hsl(var(--foreground));">App Store</h1>
                <p style="font-size: 14px; color: hsl(var(--muted-foreground)); margin-bottom: 32px;">Discover and install apps for your MOS desktop</p>
                
                <h2 style="font-size: 18px; font-weight: 600; margin-bottom: 16px; color: hsl(var(--foreground));">Available Apps</h2>
                
                <div style="display: grid; gap: 16px;">
                  <!-- Minecraft App Card -->
                  <div style="display: flex; align-items: center; gap: 16px; padding: 20px; background: hsl(var(--window-bg)); border-radius: 16px; border: 1px solid hsl(var(--window-border)); box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
                    <div style="width: 80px; height: 80px; flex-shrink: 0;">
                      ${icons.Minecraft}
                    </div>
                    <div style="flex: 1; min-width: 0;">
                      <h3 style="font-size: 18px; font-weight: 600; color: hsl(var(--foreground)); margin-bottom: 4px;">Minecraft</h3>
                      <p style="font-size: 13px; color: hsl(var(--muted-foreground)); margin-bottom: 8px;">Classic sandbox game - build, explore, and survive in infinite worlds</p>
                      <div style="display: flex; align-items: center; gap: 8px;">
                        <span style="font-size: 12px; color: hsl(var(--muted-foreground)); background: hsl(var(--accent)); padding: 4px 8px; border-radius: 6px;">Game</span>
                        <span style="font-size: 12px; color: hsl(var(--muted-foreground));">v1.0</span>
                        ${minecraftInstalled ? '<span style="font-size: 12px; color: #4ade80; background: rgba(74, 222, 128, 0.15); padding: 4px 8px; border-radius: 6px;"> Installed</span>' : ''}
                      </div>
                    </div>
                    <div style="flex-shrink: 0; display: flex; gap: 8px;">
                      ${minecraftInstalled ? `
                        <button 
                          style="padding: 10px 24px; background: hsl(var(--primary)); color: white; border: none; border-radius: 20px; font-size: 14px; font-weight: 600; cursor: pointer; transition: transform 0.15s ease;"
                          onmouseover="this.style.transform='scale(1.05)';"
                          onmouseout="this.style.transform='scale(1)';"
                          onclick="event.stopPropagation(); window.toggleWindow('minecraft');"
                        >
                          Open
                        </button>
                        <button 
                          style="padding: 10px 16px; background: #ef4444; color: white; border: none; border-radius: 20px; font-size: 14px; font-weight: 600; cursor: pointer; transition: transform 0.15s ease, box-shadow 0.15s ease;"
                          onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 4px 12px rgba(239,68,68,0.4)';"
                          onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none';"
                          onclick="event.stopPropagation(); window.uninstallMinecraft();"
                          title="Uninstall Minecraft"
                        >
                          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                            <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
                          </svg>
                        </button>
                      ` : `
                        <button 
                          style="padding: 10px 24px; background: hsl(var(--primary)); color: white; border: none; border-radius: 20px; font-size: 14px; font-weight: 600; cursor: pointer; transition: transform 0.15s ease, box-shadow 0.15s ease;"
                          onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 4px 12px rgba(0,122,255,0.4)';"
                          onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none';"
                          onclick="event.stopPropagation(); window.installMinecraft();"
                        >
                          Download
                        </button>
                      `}
                    </div>
                  </div>
                </div>
                
                <div style="margin-top: 32px; padding: 20px; background: hsl(var(--accent) / 0.3); border-radius: 12px; text-align: center;">
                  <p style="font-size: 13px; color: hsl(var(--muted-foreground));">Apps are stored in your virtual PC and persist across sessions</p>
                </div>
              </div>
            </div>
          `;
        }
        return `<div><h2>${appId}</h2><p>Content for ${appId} app</p></div>`;
      }

      // Task Manager refresh functions
      window.startTaskManagerRefresh = function startTaskManagerRefresh(windowId) {
        // Clear any existing interval
        if (state.taskManagerInterval) {
          clearInterval(state.taskManagerInterval);
        }
        
        // Store the windowId for use in interval
        state.taskManagerWindowId = windowId;
        
        // Use a retry mechanism to ensure the window is ready
        let retryCount = 0;
        const maxRetries = 10;
        
        const tryUpdate = () => {
          const taskManagerWindow = document.querySelector(`[data-id="${windowId}"] .window-content`);
          if (taskManagerWindow) {
            window.updateTaskManagerContent(windowId);
          } else if (retryCount < maxRetries) {
            retryCount++;
            setTimeout(tryUpdate, 50);
          }
        };
        
        // Update immediately with retry
        setTimeout(tryUpdate, 50);
        
        // Start refresh interval (every 1 second)
        state.taskManagerInterval = setInterval(() => {
          // Check if window still exists
          const win = state.windows.find(w => w.id === windowId);
          if (!win) {
            window.stopTaskManagerRefresh();
            return;
          }
          window.updateTaskManagerContent(windowId);
        }, 1000);
      };
      
      window.stopTaskManagerRefresh = function stopTaskManagerRefresh() {
        if (state.taskManagerInterval) {
          clearInterval(state.taskManagerInterval);
          state.taskManagerInterval = null;
        }
        state.taskManagerWindowId = null;
      };
      
      window.updateTaskManagerContent = function updateTaskManagerContent(windowId) {
        const taskManagerWindow = document.querySelector(`[data-id="${windowId}"] .window-content`);
        if (!taskManagerWindow) {
          console.warn('Task Manager window not found:', windowId);
          return;
        }
        
        // Check if window is minimized
        const win = state.windows.find(w => w.id === windowId);
        if (!win || win.isMinimized) return;
        
        // Get process info from open windows
        const processes = state.windows.map((w, idx) => {
          const app = apps.find(a => a.id === w.appId);
          return {
            pid: 1000 + w.id,
            name: app ? app.name : w.appId,
            windowId: w.id,
            cpu: (Math.random() * 15).toFixed(1),
            memory: (Math.random() * 200 + 50).toFixed(0),
            status: w.isMinimized ? 'Suspended' : 'Running'
          };
        });
        
        // Add some fake system processes with slight variations
        const systemProcesses = [
          { pid: 1, name: 'System', cpu: (0.05 + Math.random() * 0.1).toFixed(1), memory: '128', status: 'Running', isSystem: true },
          { pid: 2, name: 'WindowServer', cpu: (2.0 + Math.random() * 0.6).toFixed(1), memory: '256', status: 'Running', isSystem: true },
          { pid: 3, name: 'Dock', cpu: (0.3 + Math.random() * 0.4).toFixed(1), memory: '64', status: 'Running', isSystem: true },
          { pid: 4, name: 'Finder', cpu: (0.5 + Math.random() * 0.6).toFixed(1), memory: '128', status: 'Running', isSystem: true },
          { pid: 5, name: 'SystemUIServer', cpu: (0.2 + Math.random() * 0.2).toFixed(1), memory: '48', status: 'Running', isSystem: true },
        ];
        
        const allProcesses = [...systemProcesses, ...processes];
        const totalCPU = allProcesses.reduce((sum, p) => sum + parseFloat(p.cpu), 0).toFixed(1);
        const totalMemory = allProcesses.reduce((sum, p) => sum + parseInt(p.memory), 0);
        
        // Check if task manager content already exists and has the process list - if so, only update values
        const existingContainer = taskManagerWindow.querySelector('[data-task-manager-container]');
        const processList = existingContainer ? existingContainer.querySelector('[data-process-list]') : null;
        
        if (existingContainer && processList) {
          // Update only the stats text
          const cpuStat = existingContainer.querySelector('[data-stat-cpu]');
          const memoryStat = existingContainer.querySelector('[data-stat-memory]');
          const processesStat = existingContainer.querySelector('[data-stat-processes]');
          
          if (cpuStat) cpuStat.textContent = `CPU: ${totalCPU}%`;
          if (memoryStat) memoryStat.textContent = `Memory: ${totalMemory} MB`;
          if (processesStat) processesStat.textContent = `Processes: ${allProcesses.length}`;
          
          // Update process rows in-place to avoid flicker - only update values, not DOM structure
          const existingRows = processList.querySelectorAll('[data-proc-row]');
          
          // If row count matches, update in place; otherwise rebuild
          if (existingRows.length === allProcesses.length) {
            existingRows.forEach((row, idx) => {
              const proc = allProcesses[idx];
              const cpuSpan = row.querySelector('[data-cpu]');
              const memSpan = row.querySelector('[data-mem]');
              const statusDot = row.querySelector('[data-status-dot]');
              const statusText = row.querySelector('[data-status-text]');
              
              if (cpuSpan) {
                cpuSpan.textContent = `${proc.cpu}%`;
                cpuSpan.style.color = parseFloat(proc.cpu) > 10 ? '#EF4444' : parseFloat(proc.cpu) > 5 ? '#F59E0B' : '#10B981';
              }
              if (memSpan) memSpan.textContent = `${proc.memory} MB`;
              if (statusDot) statusDot.style.background = proc.status === 'Running' ? '#10B981' : '#F59E0B';
              if (statusText) statusText.textContent = proc.status;
            });
            return;
          }
          
          // Row count changed - need to rebuild, preserve scroll
          const scrollTop = processList.scrollTop;
          
          processList.innerHTML = allProcesses.map(proc => `
              <div data-proc-row data-pid="${proc.pid}" style="display: grid; grid-template-columns: 80px 1fr 80px 100px 100px 100px; padding: 10px 20px; border-bottom: 1px solid hsl(var(--window-border) / 0.5); font-size: 12px; cursor: default;" onmouseover="this.style.background='hsl(var(--accent) / 0.3)'" onmouseout="this.style.background='transparent'">
                <span style="color: hsl(var(--muted-foreground));">${proc.pid}</span>
                <span style="font-weight: 500; display: flex; align-items: center; gap: 8px;">
                  ${proc.isSystem ? '<span style="width: 8px; height: 8px; border-radius: 2px; background: hsl(var(--primary));"></span>' : '<span style="width: 8px; height: 8px; border-radius: 2px; background: #10B981;"></span>'}
                  ${proc.name}
                </span>
                <span data-cpu style="color: ${parseFloat(proc.cpu) > 10 ? '#EF4444' : parseFloat(proc.cpu) > 5 ? '#F59E0B' : '#10B981'};">${proc.cpu}%</span>
                <span data-mem>${proc.memory} MB</span>
                <span style="display: flex; align-items: center; gap: 6px;">
                  <span data-status-dot style="width: 6px; height: 6px; border-radius: 50%; background: ${proc.status === 'Running' ? '#10B981' : '#F59E0B'};"></span>
                  <span data-status-text>${proc.status}</span>
                </span>
                <span>
                  ${!proc.isSystem ? `
                    <button onclick="event.stopPropagation(); window.closeWindow(${proc.windowId})" style="padding: 4px 10px; background: #EF4444; color: white; border: none; border-radius: 4px; font-size: 10px; cursor: pointer; font-family: inherit;" onmouseover="this.style.background='#DC2626'" onmouseout="this.style.background='#EF4444'">
                      End Task
                    </button>
                  ` : `
                    <span style="color: hsl(var(--muted-foreground)); font-size: 10px;">System</span>
                  `}
                </span>
              </div>
            `).join('');
          
          processList.scrollTop = scrollTop;
          return;
        }
        
        // Initial render - create full structure with data attributes for later updates
        taskManagerWindow.innerHTML = `
          <div data-task-manager-container style="width: 100%; height: 100%; display: flex; flex-direction: column; background: hsl(var(--window-bg)); color: hsl(var(--foreground)); font-family: 'JetBrains Mono', monospace; overflow: hidden;">
            <!-- Header with stats -->
            <div style="padding: 16px 20px; border-bottom: 1px solid hsl(var(--window-border)); display: flex; gap: 24px; align-items: center; background: hsl(var(--titlebar-bg));">
              <div style="display: flex; align-items: center; gap: 8px;">
                <div style="width: 12px; height: 12px; border-radius: 50%; background: #10B981;"></div>
                <span data-stat-cpu style="font-size: 12px; font-weight: 600;">CPU: ${totalCPU}%</span>
              </div>
              <div style="display: flex; align-items: center; gap: 8px;">
                <div style="width: 12px; height: 12px; border-radius: 50%; background: #3B82F6;"></div>
                <span data-stat-memory style="font-size: 12px; font-weight: 600;">Memory: ${totalMemory} MB</span>
              </div>
              <div style="display: flex; align-items: center; gap: 8px;">
                <div style="width: 12px; height: 12px; border-radius: 50%; background: #F59E0B;"></div>
                <span data-stat-processes style="font-size: 12px; font-weight: 600;">Processes: ${allProcesses.length}</span>
              </div>
              <div style="flex: 1;"></div>
              <div style="font-size: 10px; color: hsl(var(--muted-foreground));">Auto-refresh: 1s</div>
            </div>
            
            <!-- Process table header -->
            <div style="display: grid; grid-template-columns: 80px 1fr 80px 100px 100px 100px; padding: 10px 20px; border-bottom: 1px solid hsl(var(--window-border)); font-size: 11px; font-weight: 600; color: hsl(var(--muted-foreground)); text-transform: uppercase; letter-spacing: 0.05em; background: hsl(var(--accent) / 0.3);">
              <span>PID</span>
              <span>Process Name</span>
              <span>CPU %</span>
              <span>Memory</span>
              <span>Status</span>
              <span>Actions</span>
            </div>
            
            <!-- Process list -->
            <div data-process-list style="flex: 1; overflow-y: auto; scrollbar-width: thin;">
              ${allProcesses.map(proc => `
                <div data-proc-row data-pid="${proc.pid}" style="display: grid; grid-template-columns: 80px 1fr 80px 100px 100px 100px; padding: 10px 20px; border-bottom: 1px solid hsl(var(--window-border) / 0.5); font-size: 12px; cursor: default;" onmouseover="this.style.background='hsl(var(--accent) / 0.3)'" onmouseout="this.style.background='transparent'">
                  <span style="color: hsl(var(--muted-foreground));">${proc.pid}</span>
                  <span style="font-weight: 500; display: flex; align-items: center; gap: 8px;">
                    ${proc.isSystem ? '<span style="width: 8px; height: 8px; border-radius: 2px; background: hsl(var(--primary));"></span>' : '<span style="width: 8px; height: 8px; border-radius: 2px; background: #10B981;"></span>'}
                    ${proc.name}
                  </span>
                  <span data-cpu style="color: ${parseFloat(proc.cpu) > 10 ? '#EF4444' : parseFloat(proc.cpu) > 5 ? '#F59E0B' : '#10B981'};">${proc.cpu}%</span>
                  <span data-mem>${proc.memory} MB</span>
                  <span style="display: flex; align-items: center; gap: 6px;">
                    <span data-status-dot style="width: 6px; height: 6px; border-radius: 50%; background: ${proc.status === 'Running' ? '#10B981' : '#F59E0B'};"></span>
                    <span data-status-text>${proc.status}</span>
                  </span>
                  <span>
                    ${!proc.isSystem ? `
                      <button onclick="event.stopPropagation(); window.closeWindow(${proc.windowId})" style="padding: 4px 10px; background: #EF4444; color: white; border: none; border-radius: 4px; font-size: 10px; cursor: pointer; font-family: inherit;" onmouseover="this.style.background='#DC2626'" onmouseout="this.style.background='#EF4444'">
                        End Task
                      </button>
                    ` : `
                      <span style="color: hsl(var(--muted-foreground)); font-size: 10px;">System</span>
                    `}
                  </span>
                </div>
              `).join('')}
            </div>
            
            <!-- Footer -->
            <div style="padding: 12px 20px; border-top: 1px solid hsl(var(--window-border)); display: flex; justify-content: space-between; align-items: center; background: hsl(var(--titlebar-bg)); font-size: 11px; color: hsl(var(--muted-foreground));">
              <span>M OS Task Manager</span>
              <span>Press Ctrl+Alt+\` or Ctrl+Alt+; to quick open</span>
            </div>
          </div>
        `;
        
        // Restore scroll position from state after initial render
        const newProcessList = taskManagerWindow.querySelector('[data-process-list]');
        if (newProcessList && state.scrollPositions[`${windowId}-taskmanager`] !== undefined) {
          newProcessList.scrollTop = state.scrollPositions[`${windowId}-taskmanager`];
        }
      };

      window.updateInputValue = function updateInputValue(windowId, value) {
        state.inputValues[windowId] = value;
      };

      window.handleBrowserAddressKeydown = function handleBrowserAddressKeydown(e, windowId) {
        if (e.key === 'Enter') {
          e.preventDefault();
          let input = e.target.value.trim();
          
          if (!input) return;
          
          let url;
          let isSearch = false;
          
          // Check if it's a URL or a search query
          const isURL = (str) => {
            // Check for common URL patterns
            if (str.includes(' ')) return false; // URLs don't have spaces
            if (str.match(/^(https?:\/\/|www\.)/i)) return true;
            if (str.match(/^[a-zA-Z0-9-]+\.[a-zA-Z]{2,}/)) return true; // domain.tld pattern
            if (str.match(/^localhost(:\d+)?/)) return true;
            return false;
          };
          
          if (isURL(input)) {
            // It's a URL
            url = input;
            if (!url.startsWith('http://') && !url.startsWith('https://')) {
              url = 'https://' + url;
            }
          } else {
            // It's a search query - use M Search (DuckDuckGo HTML)
            isSearch = true;
            const searchQuery = encodeURIComponent(input);
            url = 'https://html.duckduckgo.com/html/?q=' + searchQuery;
            
            // Save to search history
            const historyEntry = { query: input, timestamp: Date.now() };
            state.browserSearchHistory.unshift(historyEntry);
            // Keep only last 50 searches
            if (state.browserSearchHistory.length > 50) {
              state.browserSearchHistory = state.browserSearchHistory.slice(0, 50);
            }
            localStorage.setItem('browserSearchHistory', JSON.stringify(state.browserSearchHistory));
          }
          
          // Initialize browser history for this window if it doesn't exist
          if (!state.browserHistory[windowId]) {
            state.browserHistory[windowId] = [];
            state.browserHistoryIndex[windowId] = -1;
          }
          
          // Add to history
          state.browserHistory[windowId].push(url);
          state.browserHistoryIndex[windowId] = state.browserHistory[windowId].length - 1;
          
          // Blur input FIRST to allow navigateCurrentTab to update inputValues
          e.target.blur();
          
          // Update inputValues to the new URL (now that input is blurred)
          state.inputValues[windowId] = url;
          
          // Use navigateCurrentTab to update DOM directly without full re-render
          // This prevents iframe reload and input focus issues
          navigateCurrentTab(windowId, url);
        }
      };
      
      // Toggle search history panel - update DOM directly without full render
      window.toggleBrowserHistory = function toggleBrowserHistory() {
        state.showBrowserHistory = !state.showBrowserHistory;
        
        // Find the browser window
        const browserWin = state.windows.find(w => w.appId === 'browser' && !w.isMinimized);
        if (!browserWin) {
          render();
          return;
        }
        
        const windowEl = document.getElementById(`window-${browserWin.id}`);
        if (!windowEl) {
          render();
          return;
        }
        
        const contentWrapper = windowEl.querySelector('.browser-content-wrapper');
        if (!contentWrapper) {
          render();
          return;
        }
        
        // Toggle history panel without full render
        let historyPanel = contentWrapper.querySelector('.browser-history-panel');
        
        if (state.showBrowserHistory) {
          // Create and show history panel
          if (!historyPanel) {
            historyPanel = document.createElement('div');
            historyPanel.className = 'browser-history-panel';
            contentWrapper.appendChild(historyPanel);
          }
          
          const formatTime = (timestamp) => {
            const date = new Date(timestamp);
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);
            
            if (diffMins < 1) return 'Just now';
            if (diffMins < 60) return diffMins + 'm ago';
            if (diffHours < 24) return diffHours + 'h ago';
            if (diffDays < 7) return diffDays + 'd ago';
            return date.toLocaleDateString();
          };
          
          historyPanel.innerHTML = `
            <div class="browser-history-header">
              <h3>Search History</h3>
              <div style="display: flex; gap: 8px;">
                <button onclick="window.clearBrowserSearchHistory()" style="padding: 4px 8px; background: hsl(var(--destructive)); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Clear All</button>
                <button onclick="window.toggleBrowserHistory()" style="padding: 4px 8px; background: hsl(var(--accent)); color: hsl(var(--foreground)); border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Close</button>
              </div>
            </div>
            <div class="browser-history-list">
              ${state.browserSearchHistory.length === 0 ? `
                <div class="browser-history-empty">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 48px; height: 48px; margin: 0 auto 16px; opacity: 0.3;">
                    <circle cx="11" cy="11" r="8"/>
                    <path d="m21 21-4.35-4.35"/>
                  </svg>
                  <p>No search history yet</p>
                  <p style="font-size: 12px; opacity: 0.7; margin-top: 8px;">Type something in the address bar to search</p>
                </div>
              ` : state.browserSearchHistory.map(item => `
                <div class="browser-history-item" onclick="window.searchFromHistory(${browserWin.id}, '${item.query.replace(/'/g, "\\'")}')">
                  <div class="browser-history-item-icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                      <circle cx="11" cy="11" r="8"/>
                      <path d="m21 21-4.35-4.35"/>
                    </svg>
                  </div>
                  <div class="browser-history-item-text">${item.query}</div>
                  <div class="browser-history-item-time">${formatTime(item.timestamp)}</div>
                </div>
              `).join('')}
            </div>
          `;
        } else {
          // Remove history panel
          if (historyPanel) {
            historyPanel.remove();
          }
        }
        
        // Update button active state
        const historyBtn = windowEl.querySelector('.browser-nav-button[title="Search History"]');
        if (historyBtn) {
          historyBtn.classList.toggle('active', state.showBrowserHistory);
          historyBtn.style.background = state.showBrowserHistory ? 'hsl(var(--primary) / 0.2)' : '';
        }
      };
      
      // Clear search history
      window.clearBrowserSearchHistory = function clearBrowserSearchHistory() {
        state.browserSearchHistory = [];
        localStorage.setItem('browserSearchHistory', JSON.stringify(state.browserSearchHistory));
        
        // Update the history panel content without full render
        const historyList = document.querySelector('.browser-history-list');
        if (historyList) {
          historyList.innerHTML = `
            <div class="browser-history-empty">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 48px; height: 48px; margin: 0 auto 16px; opacity: 0.3;">
                <circle cx="11" cy="11" r="8"/>
                <path d="m21 21-4.35-4.35"/>
              </svg>
              <p>No search history yet</p>
              <p style="font-size: 12px; opacity: 0.7; margin-top: 8px;">Type something in the address bar to search</p>
            </div>
          `;
        }
      };
      
      // Search from history
      window.searchFromHistory = function searchFromHistory(windowId, query) {
        const searchQuery = encodeURIComponent(query);
        const url = 'https://www.google.com/search?q=' + searchQuery;
        state.showBrowserHistory = false;
        
        // Remove history panel
        const historyPanel = document.querySelector('.browser-history-panel');
        if (historyPanel) {
          historyPanel.remove();
        }
        
        // Update button state
        const historyBtn = document.querySelector('.browser-nav-button[title="Search History"]');
        if (historyBtn) {
          historyBtn.classList.remove('active');
          historyBtn.style.background = '';
        }
        
        navigateCurrentTab(windowId, url);
      };
      
      // Toggle vertical tabs - preserve iframes when switching layout
      window.toggleBrowserVerticalTabs = function toggleBrowserVerticalTabs() {
        state.browserVerticalTabs = !state.browserVerticalTabs;
        localStorage.setItem('browserVerticalTabs', state.browserVerticalTabs);
        
        // Find the browser window
        const browserWin = state.windows.find(w => w.appId === 'browser' && !w.isMinimized);
        if (!browserWin) {
          render();
          return;
        }
        
        const windowId = browserWin.id;
        const windowEl = document.getElementById(`window-${windowId}`);
        if (!windowEl) {
          render();
          return;
        }
        
        const browserContainer = windowEl.querySelector('.browser-container');
        if (!browserContainer) {
          render();
          return;
        }
        
        // Preserve all iframes before restructuring
        const preservedIframes = new Map();
        const tabs = state.browserTabs[windowId] || [];
        tabs.forEach(tab => {
          const iframe = browserContainer.querySelector(`#browser-iframe-${windowId}-${tab.id}`);
          if (iframe) {
            preservedIframes.set(tab.id, iframe.cloneNode(true));
            // Keep the src to avoid reload
            const clonedIframe = preservedIframes.get(tab.id);
            clonedIframe.src = iframe.src;
          }
        });
        
        // Get current values
        const isVerticalTabs = state.browserVerticalTabs;
        const savedValue = state.inputValues[windowId] || '';
        const currentUrl = state.browserUrls[windowId] || '';
        
        // Generate tabs HTML
        const generateTabs = () => tabs.map(tab => `
          <div class="browser-tab ${tab.active ? 'active' : ''}" data-tab-id="${tab.id}" onclick="window.switchBrowserTab(${windowId}, ${tab.id})">
            ${tab.loading ? '<div class="browser-tab-loading"></div>' : (tab.favicon ? `<img class="browser-tab-favicon" src="${tab.favicon}" alt="" />` : '')}
            <span class="browser-tab-title">${tab.title}</span>
            <div class="browser-tab-close" onclick="window.closeBrowserTab(event, ${windowId}, ${tab.id})">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 12px; height: 12px;">
                <path d="M18 6L6 18M6 6l12 12" stroke-linecap="round"/>
              </svg>
            </div>
          </div>
        `).join('');
        
        // Generate bookmarks bar
        const generateBookmarksBar = () => `
          <div class="browser-bookmarks-bar">
            ${state.browserBookmarks.map((url, idx) => {
              let domain;
              try { domain = new URL(url).hostname.replace('www.', ''); } 
              catch (e) { domain = url; }
              const favicon = `https://www.google.com/s2/favicons?domain=${domain}&sz=16`;
              return `
                <div class="browser-bookmark ${state.activeBookmarkIndex === idx ? 'show-actions' : ''}" 
                     data-bookmark-index="${idx}"
                     onclick="if(!event.target.closest('.browser-bookmark-remove')){window.openBookmark(${windowId}, '${url.replace(/'/g, "\\'")}')}"
                     title="${url}">
                  <img src="${favicon}" alt="" style="width: 14px; height: 14px; margin-right: 4px; opacity: 0.8;" onerror="this.style.display='none'" />
                  ${domain.length > 15 ? domain.substring(0, 15) + '...' : domain}
                  <span class="browser-bookmark-remove" onclick="event.stopPropagation(); window.removeBookmark(${idx})"></span>
                </div>
              `;
            }).join('')}
            <div class="browser-bookmark" onclick="window.openAddBookmarkDialog()" title="Add Bookmark" style="opacity: 0.5;">+</div>
          </div>
        `;
        
        // Generate toolbar
        const generateToolbar = () => `
          <div class="browser-toolbar">
            <div class="browser-nav-buttons">
              <button class="browser-nav-button" title="Back" onclick="window.browserBack(${windowId})">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M19 12H5M12 19l-7-7 7-7" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
              </button>
              <button class="browser-nav-button" title="Forward" onclick="window.browserForward(${windowId})">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M5 12h14M12 5l7 7-7 7" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
              </button>
              <button class="browser-nav-button" title="Refresh" onclick="window.browserRefresh(${windowId})">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
              </button>
            </div>
            <div class="browser-address-bar">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="11" cy="11" r="8"/>
                <path d="m21 21-4.35-4.35"/>
              </svg>
              <input type="text" class="browser-address-input" data-window-id="${windowId}" value="${savedValue || currentUrl}" placeholder="Search with M Search or enter URL" onclick="event.stopPropagation()" oninput="window.updateInputValue(${windowId}, this.value)" onkeydown="window.handleBrowserAddressKeydown(event, ${windowId})" />
            </div>
            <div class="browser-nav-buttons" style="margin-left: 8px;">
              <button class="browser-nav-button ${isVerticalTabs ? 'active' : ''}" title="Toggle Vertical Tabs" onclick="window.toggleBrowserVerticalTabs()" style="${isVerticalTabs ? 'background: hsl(var(--primary) / 0.2);' : ''}">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="3" y="3" width="18" height="18" rx="2"/>
                  <path d="M9 3v18"/>
                </svg>
              </button>
              <button class="browser-nav-button ${state.showBrowserHistory ? 'active' : ''}" title="Search History" onclick="window.toggleBrowserHistory()" style="${state.showBrowserHistory ? 'background: hsl(var(--primary) / 0.2);' : ''}">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <circle cx="12" cy="12" r="10"/>
                  <polyline points="12 6 12 12 16 14"/>
                </svg>
              </button>
            </div>
          </div>
        `;
        
        // Generate tab content (just wrappers, we'll restore iframes)
        const generateTabContentWrappers = () => tabs.map(tab => {
          const isActive = tab.active;
          return `
            <div class="browser-tab-iframe-wrapper ${isActive ? 'active' : ''}" data-tab-id="${tab.id}">
              ${tab.url ? `
                <div class="iframe-click-interceptor" onclick="event.stopPropagation(); window.focusWindow(${windowId}); const iframe = this.parentElement.querySelector('iframe'); if(iframe) { iframe.focus(); if(iframe.contentWindow) iframe.contentWindow.focus(); }"></div>
                <div class="browser-iframe-blocker" onclick="window.browserBlockerClick(this)"></div>
                <iframe class="browser-iframe" id="browser-iframe-${windowId}-${tab.id}" src="${tab.url}" 
                  sandbox="allow-same-origin allow-scripts allow-popups allow-forms allow-top-navigation allow-pointer-lock" 
                  allow="fullscreen; gamepad" tabindex="0"
                  onload="window.onBrowserTabLoad(${windowId}, ${tab.id})"></iframe>
              ` : getBrowserHomeContent(windowId)}
            </div>
          `;
        }).join('');
        
        // Build new layout
        if (isVerticalTabs) {
          browserContainer.className = 'browser-container vertical-tabs';
          browserContainer.innerHTML = `
            <div class="browser-sidebar">
              <div class="browser-tabs-container">
                ${generateTabs()}
                <button class="browser-new-tab-btn" onclick="window.createBrowserTab(${windowId})" title="New Tab">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 18px; height: 18px;">
                    <path d="M12 5v14M5 12h14" stroke-linecap="round"/>
                  </svg>
                  <span style="margin-left: 8px; font-size: 13px;">New Tab</span>
                </button>
              </div>
            </div>
            <div class="browser-main">
              <div class="browser-header" onmouseenter="window.browserHeaderEnter(this)" onmouseleave="window.browserHeaderLeave(this)">
                ${generateBookmarksBar()}
                ${generateToolbar()}
              </div>
              <div class="browser-content-wrapper" style="position: relative;">
                <div class="browser-tab-iframes">
                  ${generateTabContentWrappers()}
                </div>
              </div>
            </div>
          `;
        } else {
          browserContainer.className = 'browser-container';
          browserContainer.innerHTML = `
            <div class="browser-header" onmouseenter="window.browserHeaderEnter(this)" onmouseleave="window.browserHeaderLeave(this)">
              <div class="browser-tabs-container">
                ${generateTabs()}
                <button class="browser-new-tab-btn" onclick="window.createBrowserTab(${windowId})" title="New Tab">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 18px; height: 18px;">
                    <path d="M12 5v14M5 12h14" stroke-linecap="round"/>
                  </svg>
                </button>
              </div>
              ${generateBookmarksBar()}
              ${generateToolbar()}
            </div>
            <div class="browser-content-wrapper" style="position: relative;">
              <div class="browser-tab-iframes">
                ${generateTabContentWrappers()}
              </div>
            </div>
          `;
        }
      };

      window.browserBack = function browserBack(windowId) {
        if (!state.browserHistory[windowId] || state.browserHistoryIndex[windowId] <= 0) return;

        state.browserHistoryIndex[windowId]--;
        const url = state.browserHistory[windowId][state.browserHistoryIndex[windowId]];
        
        // Update the active tab with the new URL
        const activeTab = state.browserTabs[windowId]?.find(t => t.active);
        if (activeTab) {
          activeTab.url = url;
          activeTab.loading = true;
          try {
            const urlObj = new URL(url);
            activeTab.title = urlObj.hostname.replace('www.', '');
            activeTab.favicon = `https://www.google.com/s2/favicons?domain=${urlObj.hostname}&sz=32`;
          } catch (e) {
            activeTab.title = url.substring(0, 20);
          }
        }
        
        state.browserUrls[windowId] = url;
        state.inputValues[windowId] = url;
        
        // Navigate the current tab
        navigateCurrentTab(windowId, url);
      };

      window.browserForward = function browserForward(windowId) {
        if (!state.browserHistory[windowId] || state.browserHistoryIndex[windowId] >= state.browserHistory[windowId].length - 1) return;

        state.browserHistoryIndex[windowId]++;
        const url = state.browserHistory[windowId][state.browserHistoryIndex[windowId]];
        
        // Update the active tab with the new URL
        const activeTab = state.browserTabs[windowId]?.find(t => t.active);
        if (activeTab) {
          activeTab.url = url;
          activeTab.loading = true;
          try {
            const urlObj = new URL(url);
            activeTab.title = urlObj.hostname.replace('www.', '');
            activeTab.favicon = `https://www.google.com/s2/favicons?domain=${urlObj.hostname}&sz=32`;
          } catch (e) {
            activeTab.title = url.substring(0, 20);
          }
        }
        
        state.browserUrls[windowId] = url;
        state.inputValues[windowId] = url;
        
        // Navigate the current tab
        navigateCurrentTab(windowId, url);
      };

      window.browserRefresh = function browserRefresh(windowId) {
        const activeTab = state.browserTabs[windowId]?.find(t => t.active);
        if (!activeTab || !activeTab.url) return;

        const iframe = document.getElementById(`browser-iframe-${windowId}-${activeTab.id}`);
        if (iframe) {
          activeTab.loading = true;
          iframe.src = iframe.src; // Force reload
          
          // Show loading indicator
          const windowEl = document.getElementById(`window-${windowId}`);
          if (windowEl) {
            const tabEl = windowEl.querySelector(`.browser-tab[data-tab-id="${activeTab.id}"]`);
            if (tabEl && !tabEl.querySelector('.browser-tab-loading')) {
              const loader = document.createElement('div');
              loader.className = 'browser-tab-loading';
              tabEl.insertBefore(loader, tabEl.firstChild);
            }
          }
        }
      };

      // Update browser UI without re-rendering the whole OS (prevents iframe reload)
      function updateBrowserDom(windowId) {
        const windowEl = document.getElementById(`window-${windowId}`);
        if (!windowEl) return false;

        const tabs = state.browserTabs[windowId] || [];

        // Address bar
        const addressInput = windowEl.querySelector(`.browser-address-input[data-window-id="${windowId}"]`);
        if (addressInput && typeof state.inputValues[windowId] === 'string') {
          addressInput.value = state.inputValues[windowId];
        }

        // Tabs (only safe to update if counts match  otherwise fall back to forceRenderBrowser)
        const tabEls = Array.from(windowEl.querySelectorAll('.browser-tab'));
        if (tabEls.length && tabEls.length !== tabs.length) return false;

        if (tabEls.length && tabs.length) {
          tabEls.forEach((el, idx) => {
            const tab = tabs[idx];
            el.classList.toggle('active', !!tab.active);
            const titleEl = el.querySelector('.browser-tab-title');
            if (titleEl) titleEl.textContent = tab.title;
          });
        }

        // Content
        const url = state.browserUrls[windowId] || '';
        const iframe = windowEl.querySelector(`#browser-iframe-${windowId}`);

        // If we're in iframe view, just change src (no full re-render)
        if (iframe && url) {
          if (iframe.getAttribute('src') !== url) iframe.setAttribute('src', url);
          return true;
        }

        // If we're not in iframe view but url is set (or url cleared back to home), we need a render
        const hasIframeView = !!iframe;
        if ((url && !hasIframeView) || (!url && hasIframeView)) return false;

        return true;
      }
      window.updateBrowserDom = updateBrowserDom;

      // Force re-render just the browser window content (preserves other windows' iframes)
      function forceRenderBrowser(windowId) {
        const windowEl = document.getElementById(`window-${windowId}`);
        if (!windowEl) {
          render();
          return;
        }
        
        const contentEl = windowEl.querySelector('.window-content');
        if (!contentEl) {
          render();
          return;
        }
        
        // Re-generate just the browser content
        contentEl.innerHTML = getWindowContent('browser');
      }
      window.forceRenderBrowser = forceRenderBrowser;

      // ========== BROWSER UI INTERACTION SYSTEM ==========
      // Prevents iframe from stealing mouse events when user interacts with browser chrome
      
      window.suspendBrowserIframe = function(element) {
        const container = element.closest('.browser-container');
        if (container) container.classList.add('ui-active');
      };
      
      window.resumeBrowserIframe = function(element) {
        const container = element.closest('.browser-container');
        if (container) container.classList.remove('ui-active');
      };
      
      // Called when mouse enters browser header - blocks iframe clicks
      window.browserHeaderEnter = function(header) {
        const container = header.closest('.browser-container');
        if (container) container.classList.add('ui-active');
      };
      
      // Called when mouse leaves browser header - unblocks iframe clicks
      window.browserHeaderLeave = function(header) {
        const container = header.closest('.browser-container');
        if (container) container.classList.remove('ui-active');
      };
      
      // Click on blocker dismisses it and focuses iframe
      window.browserBlockerClick = function(blocker) {
        const container = blocker.closest('.browser-container');
        if (container) {
          container.classList.remove('ui-active');
          const iframe = container.querySelector('.browser-iframe');
          if (iframe) iframe.focus();
        }
      };

      // ========== BROWSER TAB FUNCTIONS ==========
      
      window.initBrowserTabs = function(windowId) {
        if (!state.browserTabs[windowId]) {
          state.browserTabs[windowId] = [{
            id: Date.now(),
            title: 'New Tab',
            url: '',
            active: true,
            loading: false,
            favicon: null
          }];
        }
        if (!state.browserTabIframes[windowId]) {
          state.browserTabIframes[windowId] = {};
        }
      };

      window.createBrowserTab = function createBrowserTab(windowId) {
        initBrowserTabs(windowId);
        const newTab = {
          id: Date.now(),
          title: 'New Tab',
          url: '',
          active: true,
          loading: false,
          favicon: null
        };
        
        // Set all other tabs to inactive
        state.browserTabs[windowId].forEach(tab => tab.active = false);
        state.browserTabs[windowId].push(newTab);
        
        // Clear current URL for this window
        state.browserUrls[windowId] = '';
        state.inputValues[windowId] = '';
        
        // Update DOM directly for tab switching (preserve existing iframes)
        updateBrowserTabsDom(windowId);
      };

      window.switchBrowserTab = function switchBrowserTab(windowId, tabId) {
        if (!state.browserTabs[windowId]) return;

        state.browserTabs[windowId].forEach(tab => {
          tab.active = (tab.id === tabId);
          if (tab.active) {
            state.browserUrls[windowId] = tab.url;
            state.inputValues[windowId] = tab.url;
          }
        });

        // Update DOM directly - just toggle visibility of tab wrappers
        updateBrowserTabsDom(windowId);
      };

      window.closeBrowserTab = function closeBrowserTab(event, windowId, tabId) {
        event.stopPropagation();
        
        if (!state.browserTabs[windowId]) return;
        const tabs = state.browserTabs[windowId];
        
        // Don't allow closing the last tab
        if (tabs.length === 1) return;
        
        const tabIndex = tabs.findIndex(t => t.id === tabId);
        const wasActive = tabs[tabIndex].active;
        
        // Remove the preserved iframe for this tab
        if (state.browserTabIframes[windowId]) {
          delete state.browserTabIframes[windowId][tabId];
        }
        
        tabs.splice(tabIndex, 1);
        
        // If we closed the active tab, activate another one
        if (wasActive && tabs.length > 0) {
          const newActiveTab = tabs[Math.max(0, tabIndex - 1)];
          newActiveTab.active = true;
          state.browserUrls[windowId] = newActiveTab.url;
          state.inputValues[windowId] = newActiveTab.url;
        }
        
        // Update DOM directly
        updateBrowserTabsDom(windowId);
      };

      // Update browser tabs DOM without full re-render (preserves iframes)
      window.updateBrowserTabsDom = function updateBrowserTabsDom(windowId) {
        const windowEl = document.getElementById(`window-${windowId}`);
        if (!windowEl) {
          forceRenderBrowser(windowId);
          return;
        }

        const tabs = state.browserTabs[windowId] || [];
        const activeTab = tabs.find(t => t.active);
        
        // Update tabs bar
        const tabsContainer = windowEl.querySelector('.browser-tabs-container');
        if (tabsContainer) {
          const tabElements = tabsContainer.querySelectorAll('.browser-tab');
          
          // If tab count changed, we need to rebuild tabs bar only
          if (tabElements.length !== tabs.length) {
            // Rebuild just the tabs
            const newTabsHtml = tabs.map(tab => `
              <div class="browser-tab ${tab.active ? 'active' : ''}" data-tab-id="${tab.id}" onclick="window.switchBrowserTab(${windowId}, ${tab.id})">
                ${tab.loading ? '<div class="browser-tab-loading"></div>' : (tab.favicon ? `<img class="browser-tab-favicon" src="${tab.favicon}" alt="" />` : '')}
                <span class="browser-tab-title">${tab.title}</span>
                <div class="browser-tab-close" onclick="window.closeBrowserTab(event, ${windowId}, ${tab.id})">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 12px; height: 12px;">
                    <path d="M18 6L6 18M6 6l12 12" stroke-linecap="round"/>
                  </svg>
                </div>
              </div>
            `).join('');
            
            // Find new tab button and preserve it
            const newTabBtn = tabsContainer.querySelector('.browser-new-tab-btn');
            const newTabBtnHtml = newTabBtn ? newTabBtn.outerHTML : '';
            
            tabsContainer.innerHTML = newTabsHtml + newTabBtnHtml;
          } else {
            // Just update active states
            tabElements.forEach((el, idx) => {
              const tab = tabs[idx];
              el.classList.toggle('active', !!tab.active);
              const titleEl = el.querySelector('.browser-tab-title');
              if (titleEl) titleEl.textContent = tab.title;
              
              // Update loading indicator
              const existingLoader = el.querySelector('.browser-tab-loading');
              const existingFavicon = el.querySelector('.browser-tab-favicon');
              
              if (tab.loading && !existingLoader) {
                const loader = document.createElement('div');
                loader.className = 'browser-tab-loading';
                el.insertBefore(loader, el.firstChild);
                if (existingFavicon) existingFavicon.remove();
              } else if (!tab.loading && existingLoader) {
                existingLoader.remove();
              }
            });
          }
        }

        // Update address bar - only if NOT focused to avoid overwriting user input
        const addressInput = windowEl.querySelector(`.browser-address-input[data-window-id="${windowId}"]`);
        if (addressInput && document.activeElement !== addressInput) {
          addressInput.value = state.inputValues[windowId] || '';
        }

        // Update iframe content area - show/hide per-tab wrappers
        const iframesContainer = windowEl.querySelector('.browser-tab-iframes');
        if (iframesContainer) {
          // Ensure we have wrappers for all tabs
          tabs.forEach(tab => {
            let wrapper = iframesContainer.querySelector(`[data-tab-id="${tab.id}"]`);
            
            if (!wrapper) {
              // Create wrapper for this tab
              wrapper = document.createElement('div');
              wrapper.className = 'browser-tab-iframe-wrapper';
              wrapper.dataset.tabId = tab.id;
              
              if (tab.url) {
                // Create iframe for this tab
                const iframe = document.createElement('iframe');
                iframe.className = 'browser-iframe';
                iframe.id = `browser-iframe-${windowId}-${tab.id}`;
                iframe.src = tab.url;
                iframe.sandbox = 'allow-same-origin allow-scripts allow-popups allow-forms allow-top-navigation allow-pointer-lock';
                iframe.allow = 'fullscreen; gamepad';
                iframe.tabIndex = 0;
                
                // Add load event to track loading state
                iframe.addEventListener('load', () => {
                  const t = state.browserTabs[windowId]?.find(x => x.id === tab.id);
                  if (t) {
                    t.loading = false;
                    // Try to extract title
                    try {
                      if (iframe.contentDocument && iframe.contentDocument.title) {
                        t.title = iframe.contentDocument.title.substring(0, 30);
                      }
                    } catch (e) {
                      // Cross-origin, use domain
                    }
                    // Update tab display
                    const tabEl = windowEl.querySelector(`.browser-tab[data-tab-id="${tab.id}"]`);
                    if (tabEl) {
                      const loader = tabEl.querySelector('.browser-tab-loading');
                      if (loader) loader.remove();
                      const titleEl = tabEl.querySelector('.browser-tab-title');
                      if (titleEl) titleEl.textContent = t.title;
                    }
                  }
                });
                
                wrapper.appendChild(iframe);
                state.browserTabIframes[windowId] = state.browserTabIframes[windowId] || {};
                state.browserTabIframes[windowId][tab.id] = iframe;
              } else {
                // Home page content
                wrapper.innerHTML = getBrowserHomeContent(windowId);
              }
              
              iframesContainer.appendChild(wrapper);
            }
            
            // Toggle visibility
            wrapper.classList.toggle('active', tab.active);
            
            // If this is active tab and URL changed, update iframe src
            if (tab.active && tab.url) {
              const iframe = wrapper.querySelector('iframe');
              if (iframe && iframe.src !== tab.url) {
                tab.loading = true;
                iframe.src = tab.url;
                // Update loading indicator
                const tabEl = windowEl.querySelector(`.browser-tab[data-tab-id="${tab.id}"]`);
                if (tabEl && !tabEl.querySelector('.browser-tab-loading')) {
                  const loader = document.createElement('div');
                  loader.className = 'browser-tab-loading';
                  tabEl.insertBefore(loader, tabEl.firstChild);
                }
              }
            }
          });
          
          // Remove wrappers for closed tabs
          const wrappers = iframesContainer.querySelectorAll('.browser-tab-iframe-wrapper');
          wrappers.forEach(wrapper => {
            const tabId = parseInt(wrapper.dataset.tabId);
            if (!tabs.find(t => t.id === tabId)) {
              wrapper.remove();
            }
          });
        } else {
          // No iframes container yet - need to rebuild content
          forceRenderBrowser(windowId);
        }
      };

      // Generate home page content for a tab with M Search
      window.getBrowserHomeContent = function getBrowserHomeContent(windowId) {
        return `
          <div class="browser-home">
            <!-- M Search Engine -->
            <div class="m-search-container">
              <div class="m-search-logo">
                <div class="m-search-logo-circle">
                  <span class="m-search-logo-letter">M</span>
                </div>
                <span class="m-search-logo-text">Search</span>
              </div>
              <form class="m-search-form" onsubmit="window.performMSearch(event, ${windowId})">
                <div class="m-search-input-wrapper">
                  <input type="text" class="m-search-input" id="m-search-input-${windowId}" placeholder="Search the web..." autocomplete="off" />
                  <button type="submit" class="m-search-btn">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                      <circle cx="11" cy="11" r="8"/>
                      <path d="m21 21-4.35-4.35"/>
                    </svg>
                  </button>
                </div>
              </form>
              <div class="m-search-suggestions">
                <div class="m-search-suggestion" onclick="window.quickMSearch(${windowId}, 'weather today')">Weather</div>
                <div class="m-search-suggestion" onclick="window.quickMSearch(${windowId}, 'latest news')">News</div>
                <div class="m-search-suggestion" onclick="window.quickMSearch(${windowId}, 'trending topics')">Trending</div>
                <div class="m-search-suggestion" onclick="window.quickMSearch(${windowId}, 'how to code')">Learn to Code</div>
              </div>
            </div>
            
            <div class="m-search-divider"></div>
            <div class="m-search-section-title">Favorites</div>
            
            <div class="browser-sites-grid" style="max-width: 680px; margin: 0 auto;">
              <div class="browser-site-add" onclick="window.openAddSiteDialog()">
                <div class="browser-site-add-icon">+</div>
                <div class="browser-site-title">Add Shortcut</div>
              </div>
              ${state.browserSavedSites.map((site, idx) => `
                <div class="browser-site-card ${state.activeSiteIndex === idx ? 'show-actions' : ''}" 
                     onclick="if(!event.target.closest('.browser-site-edit, .browser-site-remove')){window.openSavedSite(${windowId}, '${site.url.replace(/'/g, "\\'")}')}"">
                  <div class="browser-site-edit" onclick="event.stopPropagation(); window.openEditSiteDialog(${idx})" title="Edit"></div>
                  <div class="browser-site-remove" onclick="event.stopPropagation(); window.removeSavedSite(${idx})"></div>
                  <div class="browser-site-icon">${site.icon || ''}</div>
                  <div class="browser-site-title">${site.title}</div>
                </div>
              `).join('')}
            </div>
          </div>
        `;
      };
      
      // M Search functions
      window.performMSearch = function performMSearch(event, windowId) {
        event.preventDefault();
        const input = document.getElementById('m-search-input-' + windowId);
        if (!input) return;
        
        const query = input.value.trim();
        if (!query) return;
        
        // Save to search history
        const historyEntry = { query: query, timestamp: Date.now() };
        state.browserSearchHistory.unshift(historyEntry);
        if (state.browserSearchHistory.length > 50) {
          state.browserSearchHistory = state.browserSearchHistory.slice(0, 50);
        }
        localStorage.setItem('browserSearchHistory', JSON.stringify(state.browserSearchHistory));
        
        // Use DuckDuckGo HTML which works in iframes
        const searchUrl = 'https://html.duckduckgo.com/html/?q=' + encodeURIComponent(query);
        
        // Navigate to search results
        navigateCurrentTab(windowId, searchUrl);
      };
      
      window.quickMSearch = function quickMSearch(windowId, query) {
        // Save to search history
        const historyEntry = { query: query, timestamp: Date.now() };
        state.browserSearchHistory.unshift(historyEntry);
        if (state.browserSearchHistory.length > 50) {
          state.browserSearchHistory = state.browserSearchHistory.slice(0, 50);
        }
        localStorage.setItem('browserSearchHistory', JSON.stringify(state.browserSearchHistory));
        
        // Use DuckDuckGo HTML
        const searchUrl = 'https://html.duckduckgo.com/html/?q=' + encodeURIComponent(query);
        navigateCurrentTab(windowId, searchUrl);
      };

      window.updateCurrentTabInfo = function updateCurrentTabInfo(windowId) {
        if (!state.browserTabs[windowId]) return;
        
        const activeTab = state.browserTabs[windowId].find(t => t.active);
        if (activeTab) {
          activeTab.url = state.browserUrls[windowId] || '';
          const url = activeTab.url;
          
          // Extract domain for title
          if (url) {
            try {
              const urlObj = new URL(url);
              activeTab.title = urlObj.hostname.replace('www.', '');
              // Try to get favicon
              activeTab.favicon = `https://www.google.com/s2/favicons?domain=${urlObj.hostname}&sz=32`;
            } catch (e) {
              activeTab.title = url.substring(0, 20);
            }
          } else {
            activeTab.title = 'New Tab';
            activeTab.favicon = null;
          }
        }
      };

      // Navigate current active tab to a URL (used by bookmarks, saved sites)
      window.navigateCurrentTab = function navigateCurrentTab(windowId, url) {
        if (!state.browserTabs[windowId]) return;
        
        const activeTab = state.browserTabs[windowId].find(t => t.active);
        if (!activeTab) return;
        
        // Set loading state
        activeTab.loading = true;
        activeTab.url = url;
        
        // Update state
        state.browserUrls[windowId] = url;
        // Only update inputValues if the address bar is not currently focused (user not editing)
        const addressInput = document.querySelector(`.browser-address-input[data-window-id="${windowId}"]`);
        if (!addressInput || document.activeElement !== addressInput) {
          state.inputValues[windowId] = url;
        }
        
        // Update tab info (title, favicon)
        try {
          const urlObj = new URL(url);
          activeTab.title = urlObj.hostname.replace('www.', '');
          activeTab.favicon = `https://www.google.com/s2/favicons?domain=${urlObj.hostname}&sz=32`;
        } catch (e) {
          activeTab.title = url.substring(0, 20);
        }
        
        // Update DOM - check if iframe exists for this tab
        const windowEl = document.getElementById(`window-${windowId}`);
        if (windowEl) {
          const wrapper = windowEl.querySelector(`.browser-tab-iframe-wrapper[data-tab-id="${activeTab.id}"]`);
          if (wrapper) {
            let iframe = wrapper.querySelector('iframe');
            if (!iframe) {
              // Create iframe (tab was on home page)
              wrapper.innerHTML = `
                <div class="browser-iframe-blocker" onclick="window.browserBlockerClick(this)"></div>
                <iframe class="browser-iframe" id="browser-iframe-${windowId}-${activeTab.id}" src="${url}" 
                  sandbox="allow-same-origin allow-scripts allow-popups allow-forms allow-top-navigation allow-pointer-lock" 
                  allow="fullscreen; gamepad" tabindex="0"
                  onload="window.onBrowserTabLoad(${windowId}, ${activeTab.id})"></iframe>
              `;
            } else {
              // Update existing iframe src
              iframe.src = url;
            }
          }
          
          // Update tab UI
          const tabEl = windowEl.querySelector(`.browser-tab[data-tab-id="${activeTab.id}"]`);
          if (tabEl) {
            // Add loading spinner
            if (!tabEl.querySelector('.browser-tab-loading')) {
              const loader = document.createElement('div');
              loader.className = 'browser-tab-loading';
              tabEl.insertBefore(loader, tabEl.firstChild);
            }
            // Update title
            const titleEl = tabEl.querySelector('.browser-tab-title');
            if (titleEl) titleEl.textContent = activeTab.title;
          }
          
          // Update address bar
          const addressInput = windowEl.querySelector(`.browser-address-input[data-window-id="${windowId}"]`);
          if (addressInput) addressInput.value = url;
        }
      };

      // Handle iframe load event
      window.onBrowserTabLoad = function onBrowserTabLoad(windowId, tabId) {
        const tab = state.browserTabs[windowId]?.find(t => t.id === tabId);
        if (!tab) return;
        
        tab.loading = false;
        
        // Update tab UI - remove loading spinner
        const windowEl = document.getElementById(`window-${windowId}`);
        if (windowEl) {
          const tabEl = windowEl.querySelector(`.browser-tab[data-tab-id="${tabId}"]`);
          if (tabEl) {
            const loader = tabEl.querySelector('.browser-tab-loading');
            if (loader) loader.remove();
            
            // Add favicon if not present
            if (tab.favicon && !tabEl.querySelector('.browser-tab-favicon')) {
              const favicon = document.createElement('img');
              favicon.className = 'browser-tab-favicon';
              favicon.src = tab.favicon;
              favicon.alt = '';
              favicon.onerror = () => { favicon.style.display = 'none'; };
              tabEl.insertBefore(favicon, tabEl.firstChild);
            }
          }
        }
      };

      // Bookmark Functions
      window.addBookmark = function addBookmark(url) {
        if (!state.browserBookmarks.includes(url)) {
          state.browserBookmarks.push(url);
          localStorage.setItem('browserBookmarks', JSON.stringify(state.browserBookmarks));
          render();
        }
      };

      window.openBookmark = function openBookmark(windowId, url) {
        navigateCurrentTab(windowId, url);
      };

      window.openSavedSite = function openSavedSite(windowId, url) {
        navigateCurrentTab(windowId, url);
      };

      // Add Site Functions
      window.openAddSiteDialog = function openAddSiteDialog() {
        state.showAddSiteDialog = true;
        render();
        // Focus the first input after render
        setTimeout(() => {
          const input = document.getElementById('add-site-title');
          if (input) input.focus();
        }, 50);
      };

      window.closeAddSiteDialog = function closeAddSiteDialog() {
        state.showAddSiteDialog = false;
        render();
      };

      window.addSavedSite = function addSavedSite() {
        const title = document.getElementById('add-site-title').value.trim();
        const url = document.getElementById('add-site-url').value.trim();
        
        if (!title || !url) {
          alert('Please fill in both title and URL');
          return;
        }
        
        // Add protocol if missing
        let fullUrl = url;
        if (!url.startsWith('http://') && !url.startsWith('https://')) {
          fullUrl = 'https://' + url;
        }
        
        // Try to fetch favicon
        const icon = ''; // Default icon
        
        // Try to get favicon from the URL
        try {
          const urlObj = new URL(fullUrl);
          const faviconUrl = `https://www.google.com/s2/favicons?domain=${urlObj.hostname}&sz=64`;
          
          // Create an image element to check if favicon loads
          const img = new Image();
          img.onload = function() {
            // Favicon loaded successfully, use it
            const newSite = { 
              title, 
              url: fullUrl, 
              icon: `<img src="${faviconUrl}" style="width: 32px; height: 32px; object-fit: contain;" alt="${title}" />` 
            };
            state.browserSavedSites.push(newSite);
            localStorage.setItem('browserSavedSites', JSON.stringify(state.browserSavedSites));
            state.showAddSiteDialog = false;
            render();
          };
          img.onerror = function() {
            // Favicon failed to load, use default icon
            const newSite = { title, url: fullUrl, icon };
            state.browserSavedSites.push(newSite);
            localStorage.setItem('browserSavedSites', JSON.stringify(state.browserSavedSites));
            state.showAddSiteDialog = false;
            render();
          };
          img.src = faviconUrl;
        } catch (e) {
          // If URL parsing fails, use default icon
          const newSite = { title, url: fullUrl, icon };
          state.browserSavedSites.push(newSite);
          localStorage.setItem('browserSavedSites', JSON.stringify(state.browserSavedSites));
          state.showAddSiteDialog = false;
          render();
        }
      };

      window.removeSavedSite = function removeSavedSite(index) {
        if (confirm('Remove this shortcut?')) {
          state.browserSavedSites.splice(index, 1);
          localStorage.setItem('browserSavedSites', JSON.stringify(state.browserSavedSites));
          render();
        }
      };

      // Bookmark Edit Functions
      window.openAddBookmarkDialog = function openAddBookmarkDialog() {
        state.showEditBookmarkDialog = true;
        state.editingBookmarkIndex = null;
        render();
        setTimeout(() => {
          const input = document.getElementById('edit-bookmark-url');
          if (input) input.focus();
        }, 50);
      };

      window.openEditBookmarkDialog = function openEditBookmarkDialog(index) {
        state.showEditBookmarkDialog = true;
        state.editingBookmarkIndex = index;
        render();
        setTimeout(() => {
          const input = document.getElementById('edit-bookmark-url');
          if (input) {
            input.value = state.browserBookmarks[index];
            input.focus();
          }
        }, 50);
      };

      window.closeEditBookmarkDialog = function closeEditBookmarkDialog() {
        state.showEditBookmarkDialog = false;
        state.editingBookmarkIndex = null;
        render();
      };

      window.saveBookmark = function saveBookmark() {
        const url = document.getElementById('edit-bookmark-url').value.trim();
        
        if (!url) {
          alert('Please enter a URL');
          return;
        }
        
        // Add protocol if missing
        let fullUrl = url;
        if (!url.startsWith('http://') && !url.startsWith('https://')) {
          fullUrl = 'https://' + url;
        }
        
        if (state.editingBookmarkIndex !== null) {
          // Editing existing bookmark
          state.browserBookmarks[state.editingBookmarkIndex] = fullUrl;
        } else {
          // Adding new bookmark
          state.browserBookmarks.push(fullUrl);
        }
        
        localStorage.setItem('browserBookmarks', JSON.stringify(state.browserBookmarks));
        state.showEditBookmarkDialog = false;
        state.editingBookmarkIndex = null;
        render();
      };

      window.removeBookmark = function removeBookmark(index) {
        if (confirm('Remove this bookmark?')) {
          state.browserBookmarks.splice(index, 1);
          localStorage.setItem('browserBookmarks', JSON.stringify(state.browserBookmarks));
          render();
        }
      };

      // Saved Site Edit Functions
      window.openEditSiteDialog = function openEditSiteDialog(index) {
        state.showEditSiteDialog = true;
        state.editingSiteIndex = index;
        render();
        setTimeout(() => {
          const titleInput = document.getElementById('edit-site-title');
          const urlInput = document.getElementById('edit-site-url');
          if (titleInput && urlInput) {
            const site = state.browserSavedSites[index];
            titleInput.value = site.title;
            urlInput.value = site.url;
            titleInput.focus();
          }
        }, 50);
      };

      window.closeEditSiteDialog = function closeEditSiteDialog() {
        state.showEditSiteDialog = false;
        state.editingSiteIndex = null;
        render();
      };

      window.saveEditedSite = function saveEditedSite() {
        const title = document.getElementById('edit-site-title').value.trim();
        const url = document.getElementById('edit-site-url').value.trim();
        
        if (!title || !url) {
          alert('Please fill in both title and URL');
          return;
        }
        
        // Add protocol if missing
        let fullUrl = url;
        if (!url.startsWith('http://') && !url.startsWith('https://')) {
          fullUrl = 'https://' + url;
        }
        
        // Update the site
        const icon = state.browserSavedSites[state.editingSiteIndex].icon || '';
        
        // Try to fetch new favicon
        try {
          const urlObj = new URL(fullUrl);
          const faviconUrl = `https://www.google.com/s2/favicons?domain=${urlObj.hostname}&sz=64`;
          
          const img = new Image();
          img.onload = function() {
            state.browserSavedSites[state.editingSiteIndex] = { 
              title, 
              url: fullUrl, 
              icon: `<img src="${faviconUrl}" style="width: 32px; height: 32px; object-fit: contain;" alt="${title}" />` 
            };
            localStorage.setItem('browserSavedSites', JSON.stringify(state.browserSavedSites));
            state.showEditSiteDialog = false;
            state.editingSiteIndex = null;
            render();
          };
          img.onerror = function() {
            state.browserSavedSites[state.editingSiteIndex] = { title, url: fullUrl, icon };
            localStorage.setItem('browserSavedSites', JSON.stringify(state.browserSavedSites));
            state.showEditSiteDialog = false;
            state.editingSiteIndex = null;
            render();
          };
          img.src = faviconUrl;
        } catch (e) {
          state.browserSavedSites[state.editingSiteIndex] = { title, url: fullUrl, icon };
          localStorage.setItem('browserSavedSites', JSON.stringify(state.browserSavedSites));
          state.showEditSiteDialog = false;
          state.editingSiteIndex = null;
          render();
        }
      };

      // Toggle bookmark actions on right-click
      window.toggleBookmarkActions = function toggleBookmarkActions(index) {
        if (state.activeBookmarkIndex === index) {
          state.activeBookmarkIndex = null;
        } else {
          state.activeBookmarkIndex = index;
        }
        render();
      };

      // Toggle site actions on right-click
      window.toggleSiteActions = function toggleSiteActions(index) {
        if (state.activeSiteIndex === index) {
          state.activeSiteIndex = null;
        } else {
          state.activeSiteIndex = index;
        }
        render();
      };

      // New efficient function to update only terminal content
      window.updateTerminalContent = function updateTerminalContent(terminalId, scrollToBottom = true) {
        const terminalContent = document.querySelector(`.terminal-content[data-terminal-id="${terminalId}"]`);
        if (!terminalContent) return;
        
        // Save current scroll position
        const wasAtBottom = terminalContent.scrollHeight - terminalContent.scrollTop <= terminalContent.clientHeight + 10;
        
        const history = state.terminalHistory[terminalId] || [];
        const terminalInput = terminalContent.querySelector('.terminal-input');
        const savedValue = terminalInput ? terminalInput.value : '';
        
        // Update only the terminal content div
        terminalContent.innerHTML = `
          ${history.join('')}
          <div class="terminal-input-line" style="margin-top: 10px;">
            <span>user@mos ~ %</span>
            <input class="terminal-input" data-terminal-id="${terminalId}" type="text" value="${savedValue}" autofocus onkeydown="handleTerminalKeydown(event, ${terminalId})" onclick="event.stopPropagation()" />
          </div>
        `;
        
        // Restore focus
        const newInput = terminalContent.querySelector('.terminal-input');
        if (newInput) {
          newInput.focus();
          // Only scroll to bottom if explicitly requested or if user was already at the bottom
          if (scrollToBottom || wasAtBottom) {
            terminalContent.scrollTop = terminalContent.scrollHeight;
            // Update saved scroll position
            state.scrollPositions[`terminal-${terminalId}`] = terminalContent.scrollHeight;
          }
        }
      };

      // Handle arrow key navigation and enter key
      window.handleTerminalKeydown = function handleTerminalKeydown(e, terminalId) {
        const input = e.target;
        
        // Arrow Up - Navigate to previous command
        if (e.key === 'ArrowUp') {
          e.preventDefault();
          playSound('terminal-key');
          if (state.commandHistory.length === 0) return;
          
          if (state.commandHistoryIndex === -1) {
            // Save current input before navigating history
            state.inputValues[`terminal-${terminalId}`] = input.value;
            state.commandHistoryIndex = state.commandHistory.length - 1;
          } else if (state.commandHistoryIndex > 0) {
            state.commandHistoryIndex--;
          }
          
          input.value = state.commandHistory[state.commandHistoryIndex];
          // Move cursor to end
          setTimeout(() => input.setSelectionRange(input.value.length, input.value.length), 0);
          return;
        }
        
        // Arrow Down - Navigate to next command
        if (e.key === 'ArrowDown') {
          e.preventDefault();
          playSound('terminal-key');
          if (state.commandHistory.length === 0) return;
          
          if (state.commandHistoryIndex !== -1) {
            state.commandHistoryIndex++;
            
            if (state.commandHistoryIndex >= state.commandHistory.length) {
              // Reached the end, restore original input
              state.commandHistoryIndex = -1;
              input.value = state.inputValues[`terminal-${terminalId}`] || '';
            } else {
              input.value = state.commandHistory[state.commandHistoryIndex];
            }
            // Move cursor to end
            setTimeout(() => input.setSelectionRange(input.value.length, input.value.length), 0);
          }
          return;
        }
        
        // Play terminal key sound for regular keypresses
        if (e.key.length === 1 || e.key === 'Backspace' || e.key === 'Delete') {
          playSound('terminal-key');
        }
        
        // Enter key - Execute command
        if (e.key === 'Enter') {
          handleTerminalInput(e, terminalId);
        }
      };

      window.handleTerminalInput = function handleTerminalInput(e, terminalId) {
        const input = e.target.value.trim();
        playSound('terminal-enter');
        
        // Reset history navigation
        state.commandHistoryIndex = -1;
        
        // Add command to history
        if (!state.terminalHistory[terminalId]) {
          state.terminalHistory[terminalId] = [];
        }
        
        state.terminalHistory[terminalId].push(`<div style="color: #0f0; margin-top: 10px;">user@mos ~ % ${input}</div>`);

        // Save command to command history if not empty
        if (input !== '') {
          // Avoid duplicate consecutive commands
          if (state.commandHistory[state.commandHistory.length - 1] !== input) {
            state.commandHistory.push(input);
            // Keep only last 100 commands
            if (state.commandHistory.length > 100) {
              state.commandHistory.shift();
            }
            // Save to localStorage
            localStorage.setItem('commandHistory', JSON.stringify(state.commandHistory));
          }
        }

        if (input === 'help') {
          state.terminalHistory[terminalId].push(`
            <div style="color: #0f0;">Available commands:</div>
            <div style="color: #0f0;">  clear     - Clear the terminal</div>
            <div style="color: #0f0;">  date      - Display current date and time</div>
            <div style="color: #0f0;">  whoami    - Display current user</div>
            <div style="color: #0f0;">  fastfetch - Display system information</div>
            <div style="color: #0f0;">  history   - Show command history</div>
            <div style="color: #0f0;">  help      - Display this help message</div>
            <div style="color: #888; margin-top: 8px; font-size: 12px;">Use  arrow keys to navigate command history</div>
          `);
        } else if (input === 'clear') {
          state.terminalHistory[terminalId] = [];
        } else if (input === 'history') {
          if (state.commandHistory.length === 0) {
            state.terminalHistory[terminalId].push(`<div style="color: #888;">No command history yet</div>`);
          } else {
            state.terminalHistory[terminalId].push(`<div style="color: #0f0;">Command History:</div>`);
            state.commandHistory.forEach((cmd, i) => {
              state.terminalHistory[terminalId].push(`<div style="color: #0f0;">  ${i + 1}. ${cmd}</div>`);
            });
          }
        } else if (input === 'date') {
          state.terminalHistory[terminalId].push(`<div style="color: #0f0;">${new Date().toString()}</div>`);
        } else if (input === 'whoami') {
          state.terminalHistory[terminalId].push(`<div style="color: #0f0;">user</div>`);
        } else if (input === 'fastfetch') {
          const userAgent = navigator.userAgent;
          const platform = navigator.platform;
          const browserInfo = (() => {
            if (userAgent.includes('Firefox')) return 'Firefox';
            if (userAgent.includes('Edg')) return 'Edge';
            if (userAgent.includes('Chrome')) return 'Chrome';
            if (userAgent.includes('Safari')) return 'Safari';
            return 'Unknown';
          })();
          
          const osInfo = (() => {
            if (platform.includes('Win')) return 'Windows';
            if (platform.includes('Mac')) return 'macOS';
            if (platform.includes('Linux')) return 'Linux';
            if (platform.includes('iPhone') || platform.includes('iPad')) return 'iOS';
            if (platform.includes('Android')) return 'Android';
            return 'Unknown';
          })();
          
          const ascii = `@@@@@@@@@@@@                       @@@@@@@@@@@@ 
@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@     @@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@    (@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@    (@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@    (@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@   /@@@@@@@@@@@    @@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@    @@@@@@@@@@@    @@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@    @@@@@@@@@@@    @@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@    @@@@@@@@@@@    @@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@    @@@@@@@@@@@    @@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@    #@@@@@@@@@,    @@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@`;
          
          const info = `<span style="color: #10B981;">user</span>@<span style="color: #10B981;">mos</span>

<span style="color: #60A5FA;">OS:</span> ${osInfo}
<span style="color: #60A5FA;">Host:</span> Web Desktop Environment
<span style="color: #60A5FA;">Kernel:</span> Browser-based OS
<span style="color: #60A5FA;">Shell:</span> MOS Terminal v1.0
<span style="color: #60A5FA;">Browser:</span> ${browserInfo}
<span style="color: #60A5FA;">Platform:</span> ${platform}
<span style="color: #60A5FA;">Resolution:</span> ${window.innerWidth}x${window.innerHeight}
<span style="color: #60A5FA;">Theme:</span> ${state.isDark ? 'Dark' : 'Light'}
<span style="color: #60A5FA;">WM:</span> MOS Window Manager
<span style="color: #60A5FA;">Uptime:</span> ${Math.floor(performance.now() / 1000)}s`;

          state.terminalHistory[terminalId].push(`<div style="color: #0f0; font-family: monospace; white-space: pre; line-height: 1.2; display: flex; gap: 20px;"><div style="color: #A78BFA;">${ascii}</div><div>${info}</div></div>`);
        } else if (input !== '') {
          state.terminalHistory[terminalId].push(`<div style="color: #ff6b6b;">command not found: ${input}</div>`);
        }

        // Save terminal history to localStorage
        localStorage.setItem('terminalHistory', JSON.stringify(state.terminalHistory));

        // Clear input and update only this terminal (not the entire page)
        e.target.value = '';
        updateTerminalContent(terminalId);
      };

      let dragState = null;
      let resizeState = null;
      let isAltPressed = false;
      let dockDragState = null;
      
      // Expose states globally for cursor detection
      window.dragState = dragState;
      window.resizeState = resizeState;
      window.dockDragState = dockDragState;
      
      document.addEventListener('keydown', (e) => {
        if (e.altKey || e.key === 'Alt') {
          isAltPressed = true;
        }
        
        // Escape key exits fullscreen mode for any fullscreen window
        if (e.key === 'Escape') {
          const fullscreenWindow = state.windows.find(w => w.isFullscreen);
          if (fullscreenWindow) {
            e.preventDefault();
            window.toggleFullscreen(fullscreenWindow.id);
          }
        }
      });
      
      document.addEventListener('keyup', (e) => {
        if (!e.altKey && e.key === 'Alt') {
          isAltPressed = false;
        }
      });
      
      // Click handler to deactivate windows when clicking outside them
      document.addEventListener('click', (e) => {
        // Skip if we're in the middle of a drag operation
        if (dragState || resizeState || dockDragState) {
          return;
        }
        
        // Skip if clicking on a window or window-related element
        if (e.target.closest('.window')) {
          return;
        }
        
        // Skip if clicking on dock icons - they handle focus themselves
        if (e.target.closest('.dock-icon') || e.target.closest('.dock')) {
          return;
        }
        
        // Skip if clicking on context menu
        if (e.target.closest('.context-menu')) {
          return;
        }
        
        // Skip if clicking on quick settings panel
        if (e.target.closest('.quick-settings')) {
          return;
        }
        
        // Skip if clicking on launchpad
        if (e.target.closest('.launchpad-overlay')) {
          return;
        }
        
        // Skip if clicking on dialogs
        if (e.target.closest('.add-site-dialog-overlay')) {
          return;
        }
        
        // Deactivate all windows when clicking on desktop, dock, menubar, etc.
        window.deactivateAllWindows();
      });

      document.addEventListener('mousedown', (e) => {
        // Don't interfere with titlebar buttons or input fields
        if (e.target.classList.contains('titlebar-button') ||
            e.target.tagName === 'INPUT' || 
            e.target.tagName === 'TEXTAREA' ||
            e.target.closest('.titlebar-button') ||
            e.target.closest('.terminal-content') ||
            e.target.closest('.browser-address-input')) {
          return;
        }

        if (e.target.classList.contains('resize-handle')) {
          const windowEl = e.target.closest('.window');
          const windowId = parseInt(windowEl.dataset.id, 10);
          const win = state.windows.find((w) => w.id === windowId);
          if (win) {
            const direction = e.target.classList[1]; // Get direction class (se, sw, ne, nw, n, s, e, w)
            resizeState = {
              id: windowId,
              direction: direction,
              startX: e.clientX,
              startY: e.clientY,
              startWidth: win.width,
              startHeight: win.height,
              startPosX: win.x,
              startPosY: win.y,
              resizeFromCenter: isAltPressed,
            };
            window.resizeState = resizeState;
            focusWindow(windowId);
            e.stopPropagation();
          }
          return;
        }

        const titlebar = e.target.closest('.titlebar');
        if (titlebar) {
          const windowEl = titlebar.closest('.window');
          const windowId = parseInt(windowEl.dataset.id, 10);
          const win = state.windows.find((w) => w.id === windowId);
          if (win) {
            // If window is maximized, store click position but don't unmaximize yet
            if (win.isMaximized) {
              // Store click start position to detect drag vs click
              dragState = {
                id: windowId,
                startX: e.clientX,
                startY: e.clientY,
                initialMouseX: e.clientX,
                initialMouseY: e.clientY,
                isMaximized: true,
                dragThreshold: 8, // Minimum pixels to move before starting drag
                hasMoved: false,
              };
              window.dragState = dragState;
              focusWindow(windowId);
              
            } else if (win.isSnapped && win.snapRestorePos) {
              // If window is snapped, store click position but don't unsnap yet - wait for drag
              dragState = {
                id: windowId,
                startX: e.clientX - win.x,
                startY: e.clientY - win.y,
                initialMouseX: e.clientX,
                initialMouseY: e.clientY,
                isSnapped: true,
                snapRestorePos: win.snapRestorePos,
                dragThreshold: 5, // Minimum pixels to move before unsnapping
                hasMoved: false,
              };
              window.dragState = dragState;
              focusWindow(windowId);
            } else {
              // Normal drag - add threshold to prevent accidental movement
              dragState = {
                id: windowId,
                startX: e.clientX - win.x,
                startY: e.clientY - win.y,
                initialMouseX: e.clientX,
                initialMouseY: e.clientY,
                isMaximized: false,
                dragThreshold: 5, // Minimum pixels to move before starting drag
                hasMoved: false,
              };
              window.dragState = dragState;
              focusWindow(windowId);
            }
          }
        }
      });

      document.addEventListener('mousemove', (e) => {
        if (dockDragState) {
          const icon = dockDragState.draggedElement;
          if (!icon) {
            dockDragState = null;
            return;
          }
          
          // Calculate movement maintaining the click offset
          dockDragState.currentX = e.clientX;
          const rawDeltaX = (e.clientX - dockDragState.offsetX) - dockDragState.initialIconLeft;
          
          // Get dock boundaries to constrain dragging
          const dock = document.querySelector('.dock');
          if (dock) {
            const dockRect = dock.getBoundingClientRect();
            const iconRect = icon.getBoundingClientRect();
            
            // Calculate maximum allowed deltaX (left and right boundaries)
            const maxLeft = dockRect.left - dockDragState.initialIconLeft;
            const maxRight = (dockRect.right - dockDragState.iconWidth) - dockDragState.initialIconLeft;
            
            // Constrain deltaX within dock boundaries
            dockDragState.deltaX = Math.max(maxLeft, Math.min(maxRight, rawDeltaX));
          } else {
            dockDragState.deltaX = rawDeltaX;
          }
          
          // Start dragging if moved beyond threshold
          if (!dockDragState.isDragging && Math.abs(dockDragState.deltaX) > dockDragState.dragThreshold) {
            dockDragState.isDragging = true;
            icon.classList.add("dragging");
            document.body.style.cursor = 'grabbing';
          }
          
          if (dockDragState.isDragging) {
            const dock = document.querySelector('.dock');
            if (dock) {
              // Get all dock icons in current DOM order (both pinned and unpinned)
              const allIcons = Array.from(dock.querySelectorAll('.dock-icon'));
              
              if (allIcons.length === 0) return;
              
              // Debounce swaps - only allow one swap every 100ms
              const now = Date.now();
              if (now - dockDragState.lastSwapTime < 100) {
                // Still update visual position (already constrained)
                icon.style.transform = `translateX(${dockDragState.deltaX}px) scale(1.15)`;
                icon.style.transition = 'none';
                icon.style.zIndex = '1000';
                return;
              }
              
              // Find which icon we should swap with
              const mouseX = e.clientX;
              let targetIcon = null;
              let targetIndex = -1;
              
              for (let i = 0; i < allIcons.length; i++) {
                const currentIcon = allIcons[i];
                if (currentIcon === icon) {
                  targetIndex = i;
                  continue;
                }
                
                const rect = currentIcon.getBoundingClientRect();
                const iconCenter = rect.left + rect.width / 2;
                
                // Check if mouse is past 60% of the icon's width (prevents glitchy back-and-forth)
                const threshold = rect.width * 0.6;
                
                if (mouseX >= rect.left && mouseX <= rect.right) {
                  // We're hovering over this icon
                  if (targetIndex < i && mouseX > iconCenter + threshold / 4) {
                    // Moving right, swap if past center
                    targetIcon = currentIcon;
                    break;
                  } else if (targetIndex > i && mouseX < iconCenter - threshold / 4) {
                    // Moving left, swap if past center
                    targetIcon = currentIcon;
                    break;
                  }
                }
              }
              
              // Perform the swap if we found a target
              if (targetIcon && targetIcon !== icon) {
                const targetIdx = allIcons.indexOf(targetIcon);
                const currentIdx = allIcons.indexOf(icon);
                
                if (targetIdx !== -1 && currentIdx !== -1 && targetIdx !== currentIdx) {
                  // Check if target is pinned or unpinned
                  const targetAppId = targetIcon.id.replace('dock-', '');
                  const draggedAppId = icon.id.replace('dock-', '');
                  
                  // Don't allow swapping with the app launcher (finder)
                  if (targetAppId === 'finder') {
                    // Update visual position but don't swap (already constrained)
                    icon.style.transform = `translateX(${dockDragState.deltaX}px) scale(1.15)`;
                    icon.style.transition = 'none';
                    icon.style.zIndex = '1000';
                    return;
                  }
                  
                  const targetIsPinned = state.pinnedApps.includes(targetAppId);
                  
                  // Handle pin/unpin when crossing boundaries
                  if (!dockDragState.isPinned && targetIsPinned) {
                    // Unpinned icon moving to pinned section - pin it
                    if (!state.pinnedApps.includes(draggedAppId)) {
                      const targetPinnedIdx = state.pinnedApps.indexOf(targetAppId);
                      if (targetPinnedIdx !== -1) {
                        // Insert at the target's position
                        state.pinnedApps.splice(targetPinnedIdx, 0, draggedAppId);
                        dockDragState.isPinned = true;
                        localStorage.setItem('pinnedApps', JSON.stringify(state.pinnedApps));
                        console.log('Icon pinned:', draggedAppId);
                      }
                    }
                  } else if (dockDragState.isPinned && !targetIsPinned) {
                    // Pinned icon moving to unpinned section - unpin it
                    const pinnedIdx = state.pinnedApps.indexOf(draggedAppId);
                    if (pinnedIdx !== -1) {
                      state.pinnedApps.splice(pinnedIdx, 1);
                      dockDragState.isPinned = false;
                      localStorage.setItem('pinnedApps', JSON.stringify(state.pinnedApps));
                      console.log('Icon unpinned:', draggedAppId);
                    }
                  }
                  
                  // Physically swap DOM elements
                  if (currentIdx < targetIdx) {
                    // Moving right - insert after target
                    targetIcon.parentNode.insertBefore(icon, targetIcon.nextSibling);
                  } else {
                    // Moving left - insert before target
                    targetIcon.parentNode.insertBefore(icon, targetIcon);
                  }
                  
                  // Update pinned apps order if both are pinned
                  if (dockDragState.isPinned && targetIsPinned) {
                    const fromIdx = state.pinnedApps.indexOf(draggedAppId);
                    const toIdx = state.pinnedApps.indexOf(targetAppId);
                    
                    if (fromIdx !== -1 && toIdx !== -1) {
                      // Create new array with updated order
                      const newPinnedApps = [...state.pinnedApps];
                      const [movedApp] = newPinnedApps.splice(fromIdx, 1);
                      newPinnedApps.splice(toIdx, 0, movedApp);
                      state.pinnedApps = newPinnedApps;
                      
                      // Immediately save to localStorage for persistence
                      localStorage.setItem('pinnedApps', JSON.stringify(state.pinnedApps));
                      console.log('Pinned apps order updated:', state.pinnedApps);
                    }
                  }
                  
                  // Update the initial position after swap to prevent jump
                  const newRect = icon.getBoundingClientRect();
                  dockDragState.initialIconLeft = newRect.left - dockDragState.deltaX;
                  dockDragState.lastSwapTime = now;
                }
              }
              
              // Smooth visual feedback for dragged icon following cursor (already constrained)
              icon.style.transform = `translateX(${dockDragState.deltaX}px) scale(1.15)`;
              icon.style.transition = 'none';
              icon.style.zIndex = '1000';
            }
          }
          
          e.preventDefault();
          return;
        }
        
        if (dragState) {
          const win = state.windows.find((w) => w.id === dragState.id);
          if (win) {
            const windowEl = document.querySelector(`[data-id="${win.id}"]`);
            if (windowEl) {
              // Add dragging class to disable transitions
              windowEl.classList.add('dragging');
              // Add body class to hide dock tooltips and disable dock magnification
              document.body.classList.add('window-dragging');
            }
            
            // Check if window is snapped and we haven't started unsnapping yet
            if (dragState.isSnapped && !dragState.hasMoved) {
              const deltaX = Math.abs(e.clientX - dragState.initialMouseX);
              const deltaY = Math.abs(e.clientY - dragState.initialMouseY);
              
              // Only start unsnapping if moved beyond threshold
              if (deltaX > dragState.dragThreshold || deltaY > dragState.dragThreshold) {
                dragState.hasMoved = true;
                
                // Now unsnap the window
                const restoreX = dragState.snapRestorePos.x;
                const restoreY = dragState.snapRestorePos.y;
                const restoreWidth = dragState.snapRestorePos.width;
                const restoreHeight = dragState.snapRestorePos.height;
                
                win.width = restoreWidth;
                win.height = restoreHeight;
                win.isSnapped = false;
                
                // Position window centered under cursor
                win.x = e.clientX - (win.width / 2);
                win.y = Math.max(28, e.clientY - 20);
                
                // Keep window within screen bounds
                win.x = Math.max(0, Math.min(win.x, window.innerWidth - win.width));
                
                // Clear snap restore position
                win.snapRestorePos = null;
                
                // Update drag state for normal dragging
                dragState.startX = win.width / 2;
                dragState.startY = 20;
                dragState.isSnapped = false;
                
                // Update visual immediately with no animation - NO render() call to eliminate flicker
                const windowEl = document.querySelector(`[data-id="${win.id}"]`);
                if (windowEl) {
                  windowEl.style.transition = 'none';
                  windowEl.style.width = `${win.width}px`;
                  windowEl.style.height = `${win.height}px`;
                  windowEl.style.left = `${win.x}px`;
                  windowEl.style.top = `${win.y}px`;
                  windowEl.style.borderRadius = '12px';
                  windowEl.style.boxShadow = '';
                  windowEl.classList.remove('snapped', 'maximized');
                  void windowEl.offsetHeight;
                }
                
                // NO render() here - DOM is already updated, avoid flicker
              } else {
                // Haven't moved enough yet, don't do anything
                return;
              }
            }
            
            // Check if window is maximized and we haven't started dragging yet
            if (dragState.isMaximized && !dragState.hasMoved) {
              const deltaX = Math.abs(e.clientX - dragState.initialMouseX);
              const deltaY = Math.abs(e.clientY - dragState.initialMouseY);
              
              // Only start dragging if moved beyond threshold (reduced threshold for maximized windows)
              if (deltaX > 2 || deltaY > 2) {
                dragState.hasMoved = true;
                
                // Now unmaximize the window
                win.x = win.restoreX || 100;
                win.y = win.restoreY || 100;
                win.width = win.restoreWidth || 800;
                win.height = win.restoreHeight || 600;
                win.isMaximized = false;
                win.isFullscreen = false;
                
                // Position window so cursor stays under the titlebar
                // Center the window horizontally around the cursor
                win.x = e.clientX - (win.width / 2);
                win.y = 28; // Just below menubar
                
                // Keep window within screen bounds
                win.x = Math.max(0, Math.min(win.x, window.innerWidth - win.width));
                
                // Save unmaximized state to localStorage immediately
                const windowState = state.windowStates[win.appId] || {};
                windowState.x = win.x;
                windowState.y = win.y;
                windowState.width = win.width;
                windowState.height = win.height;
                windowState.isMaximized = false;
                state.windowStates[win.appId] = windowState;
                localStorage.setItem('windowStates', JSON.stringify(state.windowStates));
                
                // Update drag state for normal dragging
                dragState.startX = win.width / 2;
                dragState.startY = 10;
                dragState.isMaximized = false;
                
                // Update visual immediately with no animation - NO render() call to eliminate flicker
                const windowEl = document.querySelector(`[data-id="${win.id}"]`);
                if (windowEl) {
                  windowEl.style.transition = 'none';
                  windowEl.style.width = `${win.width}px`;
                  windowEl.style.height = `${win.height}px`;
                  windowEl.style.left = `${win.x}px`;
                  windowEl.style.top = `${win.y}px`;
                  windowEl.style.borderRadius = '12px';
                  windowEl.style.boxShadow = '';
                  windowEl.classList.remove('maximized', 'snapped');
                  void windowEl.offsetHeight;
                }
                
                // NO render() here - DOM is already updated, avoid flicker
              } else {
                // Haven't moved enough yet, don't do anything
                return;
              }
            }
            
            // Check if normal window hasn't moved beyond threshold yet
            if (!dragState.isMaximized && !dragState.isSnapped && dragState.hasMoved === false) {
              const deltaX = Math.abs(e.clientX - dragState.initialMouseX);
              const deltaY = Math.abs(e.clientY - dragState.initialMouseY);
              
              // Only start dragging if moved beyond threshold
              if (deltaX > dragState.dragThreshold || deltaY > dragState.dragThreshold) {
                dragState.hasMoved = true;
              } else {
                // Haven't moved enough yet, don't move window
                return;
              }
            }
            
            // Normal drag behavior
            if (!dragState.isMaximized && !dragState.isSnapped) {
              // Calculate new position
              let newX = e.clientX - dragState.startX;
              let newY = e.clientY - dragState.startY;
              
              // Constrain to keep at least half the window visible on screen
              const halfWidth = win.width / 2;
              const halfHeight = win.height / 2;
              const minX = -halfWidth;
              const maxX = window.innerWidth - halfWidth;
              const minY = 28; // Keep below menubar
              const maxY = window.innerHeight - halfHeight;
              
              win.x = Math.max(minX, Math.min(maxX, newX));
              win.y = Math.max(minY, Math.min(maxY, newY));
              
              const windowEl = document.querySelector(`[data-id="${win.id}"]`);
              if (windowEl) {
                windowEl.style.left = `${win.x}px`;
                windowEl.style.top = `${win.y}px`;
              }
              
              // Note: Don't save to localStorage during drag - it's too slow
              // We'll save on mouseup instead
            }
            
            // Detect snap zones with improved logic
            const edgeThreshold = 15; // Reduced from 20 for more precise control
            const cornerThreshold = 250; // Reduced from 300 for more precise corners
            const bottomCornerThreshold = 200; // Reduced from 250
            const menubarHeight = 28;
            const dockPosition = state.dockPosition || 'bottom';
            // Calculate dock dimensions based on scale
            const dockDims = getDockDimensions();
            
            const dockSpaceBottom = dockPosition === 'bottom' ? dockDims.getBottomSpace() : 0;
            const dockSpaceSide = (dockPosition === 'left' || dockPosition === 'right') ? dockDims.getSideSpace() : 0;
            const snapIndicator = document.querySelector('.snap-indicator');
            
            // Add dragging class to disable transitions on snap indicator
            if (snapIndicator) {
              snapIndicator.classList.add('dragging');
            }
            
            // Add dragging class to disable transitions on snap indicator
            if (snapIndicator) {
              snapIndicator.classList.add('dragging');
            }
            
            // Priority order: Corners > Edges > Top (maximize)
            // This ensures corners are accessible even when windows are snapped to edges
            
            // Check bottom corners first (highest priority)
            // Stop the snap zone before the dock area
            if (e.clientY >= window.innerHeight - bottomCornerThreshold && e.clientY <= window.innerHeight - dockSpaceBottom) {
              // Bottom area (but not in dock area)
              if (e.clientX <= cornerThreshold) {
                // Bottom-left corner
                state.snapZone = 'bottom-left';
                if (snapIndicator) {
                  const leftOffset = dockPosition === 'left' ? dockSpaceSide : 0;
                  const availableWidth = window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0);
                  const availableHeight = window.innerHeight - menubarHeight - dockSpaceBottom;
                  snapIndicator.style.left = `${leftOffset}px`;
                  snapIndicator.style.top = `${menubarHeight + availableHeight / 2}px`;
                  snapIndicator.style.width = `${availableWidth / 2}px`;
                  snapIndicator.style.height = `${availableHeight / 2}px`;
                  snapIndicator.classList.add('active');
                }
              } else if (e.clientX >= window.innerWidth - cornerThreshold) {
                // Bottom-right corner
                state.snapZone = 'bottom-right';
                if (snapIndicator) {
                  const leftOffset = dockPosition === 'left' ? dockSpaceSide : 0;
                  const availableWidth = window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0);
                  const availableHeight = window.innerHeight - menubarHeight - dockSpaceBottom;
                  snapIndicator.style.left = `${leftOffset + availableWidth / 2}px`;
                  snapIndicator.style.top = `${menubarHeight + availableHeight / 2}px`;
                  snapIndicator.style.width = `${availableWidth / 2}px`;
                  snapIndicator.style.height = `${availableHeight / 2}px`;
                  snapIndicator.classList.add('active');
                }
              } else {
                // No snap zone in bottom center
                state.snapZone = null;
                if (snapIndicator) {
                  snapIndicator.classList.remove('active');
                }
              }
            }
            // Check top corners (second priority)
            else if (e.clientY <= menubarHeight + edgeThreshold) {
              // Top area
              if (e.clientX <= cornerThreshold) {
                // Top-left corner - always available
                state.snapZone = 'top-left';
                if (snapIndicator) {
                  const leftOffset = dockPosition === 'left' ? dockSpaceSide : 0;
                  const availableWidth = window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0);
                  const availableHeight = window.innerHeight - menubarHeight - dockSpaceBottom;
                  snapIndicator.style.left = `${leftOffset}px`;
                  snapIndicator.style.top = `${menubarHeight}px`;
                  snapIndicator.style.width = `${availableWidth / 2}px`;
                  snapIndicator.style.height = `${availableHeight / 2}px`;
                  snapIndicator.classList.add('active');
                }
              } else if (e.clientX >= window.innerWidth - cornerThreshold) {
                // Top-right corner - always available
                state.snapZone = 'top-right';
                if (snapIndicator) {
                  const leftOffset = dockPosition === 'left' ? dockSpaceSide : 0;
                  const availableWidth = window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0);
                  const availableHeight = window.innerHeight - menubarHeight - dockSpaceBottom;
                  snapIndicator.style.left = `${leftOffset + availableWidth / 2}px`;
                  snapIndicator.style.top = `${menubarHeight}px`;
                  snapIndicator.style.width = `${availableWidth / 2}px`;
                  snapIndicator.style.height = `${availableHeight / 2}px`;
                  snapIndicator.classList.add('active');
                }
              } else {
                // Top center - maximize
                state.snapZone = 'top';
                if (snapIndicator) {
                  const leftOffset = dockPosition === 'left' ? dockSpaceSide : 0;
                  const availableWidth = window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0);
                  const availableHeight = window.innerHeight - menubarHeight - dockSpaceBottom;
                  snapIndicator.style.left = `${leftOffset}px`;
                  snapIndicator.style.top = `${menubarHeight}px`;
                  snapIndicator.style.width = `${availableWidth}px`;
                  snapIndicator.style.height = `${availableHeight}px`;
                  snapIndicator.classList.add('active');
                }
              }
            }
            // Check left and right edges (third priority)
            else if (e.clientX <= edgeThreshold + (dockPosition === 'left' ? dockSpaceSide : 0) && e.clientY <= window.innerHeight - dockSpaceBottom) {
              // Left edge (but not overlapping dock)
              state.snapZone = 'left';
              if (snapIndicator) {
                const leftOffset = dockPosition === 'left' ? dockSpaceSide : 0;
                const availableWidth = window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0);
                const availableHeight = window.innerHeight - menubarHeight - dockSpaceBottom;
                snapIndicator.style.left = `${leftOffset}px`;
                snapIndicator.style.top = `${menubarHeight}px`;
                snapIndicator.style.width = `${availableWidth / 2}px`;
                snapIndicator.style.height = `${availableHeight}px`;
                snapIndicator.classList.add('active');
              }
            } else if (e.clientX >= window.innerWidth - edgeThreshold - (dockPosition === 'right' ? dockSpaceSide : 0) && e.clientY <= window.innerHeight - dockSpaceBottom) {
              // Right edge (but not overlapping dock)
              state.snapZone = 'right';
              if (snapIndicator) {
                const leftOffset = dockPosition === 'left' ? dockSpaceSide : 0;
                const availableWidth = window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0);
                const availableHeight = window.innerHeight - menubarHeight - dockSpaceBottom;
                snapIndicator.style.left = `${leftOffset + availableWidth / 2}px`;
                snapIndicator.style.top = `${menubarHeight}px`;
                snapIndicator.style.width = `${availableWidth / 2}px`;
                snapIndicator.style.height = `${availableHeight}px`;
                snapIndicator.classList.add('active');
              }
            } else {
              // No snap zone
              state.snapZone = null;
              if (snapIndicator) {
                snapIndicator.classList.remove('active');
              }
            }
          }
        }
        if (resizeState) {
          const win = state.windows.find((w) => w.id === resizeState.id);
          if (win) {
            const deltaX = e.clientX - resizeState.startX;
            const deltaY = e.clientY - resizeState.startY;
            const dir = resizeState.direction;
            const fromCenter = resizeState.resizeFromCenter;
            
            let newWidth = resizeState.startWidth;
            let newHeight = resizeState.startHeight;
            let newX = resizeState.startPosX;
            let newY = resizeState.startPosY;
            
            // Handle width changes
            if (dir.includes('e')) {
              newWidth = Math.max(300, resizeState.startWidth + (fromCenter ? deltaX * 2 : deltaX));
              if (fromCenter) newX = resizeState.startPosX - deltaX;
            } else if (dir.includes('w')) {
              newWidth = Math.max(300, resizeState.startWidth - deltaX);
              newX = fromCenter ? resizeState.startPosX + deltaX : resizeState.startPosX + deltaX;
              if (newWidth === 300) {
                newX = resizeState.startPosX + resizeState.startWidth - 300;
              }
            }
            
            // Handle height changes
            if (dir.includes('s')) {
              newHeight = Math.max(200, resizeState.startHeight + (fromCenter ? deltaY * 2 : deltaY));
              if (fromCenter) newY = resizeState.startPosY - deltaY;
            } else if (dir.includes('n')) {
              newHeight = Math.max(200, resizeState.startHeight - deltaY);
              newY = fromCenter ? resizeState.startPosY + deltaY : resizeState.startPosY + deltaY;
              if (newHeight === 200) {
                newY = resizeState.startPosY + resizeState.startHeight - 200;
              }
            }
            
            win.width = newWidth;
            win.height = newHeight;
            win.x = newX;
            win.y = Math.max(28, newY);
            
            const windowEl = document.querySelector(`[data-id="${win.id}"]`);
            if (windowEl) {
              windowEl.style.width = `${win.width}px`;
              windowEl.style.height = `${win.height}px`;
              windowEl.style.left = `${win.x}px`;
              windowEl.style.top = `${win.y}px`;
            }
          }
        }
      });

      document.addEventListener('mouseup', (e) => {
        // Remove dragging class from all windows
        document.querySelectorAll('.window.dragging').forEach(el => {
          el.classList.remove('dragging');
        });
        
        // Remove body dragging class
        document.body.classList.remove('window-dragging');
        
        // Remove dragging class from snap indicator and remove it
        const snapIndicator = document.querySelector('.snap-indicator');
        if (snapIndicator) {
          snapIndicator.classList.remove('dragging');
          if (!state.snapZone) {
            snapIndicator.classList.remove('active');
          }
        }
        
        // Handle maximized window click without drag
        if (dragState && dragState.isMaximized && !dragState.hasMoved) {
          // Just a click on a maximized window, do nothing
          dragState = null;
          window.dragState = null;
          return;
        }
        
        // Handle snapped window click without drag
        if (dragState && dragState.isSnapped && !dragState.hasMoved) {
          // Just a click on a snapped window, do nothing (don't unsnap it)
          dragState = null;
          window.dragState = null;
          return;
        }
        
        // Handle normal window click without drag
        if (dragState && !dragState.isMaximized && !dragState.isSnapped && dragState.hasMoved === false) {
          // Just a click on a normal window, do nothing (don't move it)
          dragState = null;
          window.dragState = null;
          return;
        }
        
        if (dockDragState) {
          const { appId, isDragging, draggedElement, isPinned } = dockDragState;
          const icon = draggedElement;
          
          // Reset cursor
          document.body.style.cursor = '';
          
          if (icon) {
            icon.classList.remove('dragging');
            // Smooth transition back to its new position
            icon.style.transition = 'transform 0.25s cubic-bezier(0.16, 1, 0.3, 1), z-index 0s 0.25s';
            icon.style.transform = '';
            icon.style.zIndex = '';
            
            setTimeout(() => {
              if (icon) {
                icon.style.transition = '';
              }
            }, 250);
          }
          
          // If we actually dragged, ensure the final order is saved and re-render
          if (isDragging) {
            // Rebuild the pinnedApps array based on current DOM order
            const dockElement = document.querySelector('.dock');
            if (dockElement) {
              const allIcons = Array.from(dockElement.querySelectorAll('.dock-icon'));
              const newPinnedApps = [];
              
              // Collect all pinned apps in their current DOM order
              allIcons.forEach(el => {
                const id = el.id.replace('dock-', '');
                if (state.pinnedApps.includes(id)) {
                  newPinnedApps.push(id);
                }
              });
              
              // Only update if order actually changed
              const currentOrder = JSON.stringify(state.pinnedApps);
              const newOrder = JSON.stringify(newPinnedApps);
              
              if (currentOrder !== newOrder && newPinnedApps.length > 0) {
                state.pinnedApps = newPinnedApps;
                localStorage.setItem('pinnedApps', JSON.stringify(state.pinnedApps));
                console.log('Final pinned apps order saved:', state.pinnedApps);
              }
            }
            
            // Re-render to show updated dock with correct pin states
            setTimeout(() => render(), 300);
          } else {
            // Treat as simple click if we didn't drag
            handleDockClick(e, appId);
          }
          
          dockDragState = null;
          window.dockDragState = null;
          return;
        }
        
        // Apply window snap if in snap zone
        if (dragState && state.snapZone) {
          const win = state.windows.find((w) => w.id === dragState.id);
          if (win) {
            const menubarHeight = 28;
            const dockPosition = state.dockPosition || 'bottom';
            
            // Calculate dock dimensions based on scale
            const dockDims = getDockDimensions();
            
            const dockSpaceBottom = dockPosition === 'bottom' ? dockDims.getBottomSpace() : 0;
            const dockSpaceSide = (dockPosition === 'left' || dockPosition === 'right') ? dockDims.getSideSpace() : 0;
            
            // Store original position for restore (only if not already stored)
            if (!win.isMaximized && !win.snapRestorePos && state.snapZone !== 'top') {
              win.snapRestorePos = { x: win.x, y: win.y, width: win.width, height: win.height };
            }
            
            // Get the window element for smooth animation
            const windowEl = document.querySelector(`[data-id="${win.id}"]`);
            
            // Calculate target dimensions based on snap zone
            let targetX, targetY, targetWidth, targetHeight;
            
            switch (state.snapZone) {
              case 'left':
                targetX = dockPosition === 'left' ? dockSpaceSide : 0;
                targetY = menubarHeight;
                targetWidth = (window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0)) / 2;
                targetHeight = window.innerHeight - menubarHeight - dockSpaceBottom;
                win.isMaximized = false;
                win.isSnapped = true;
                break;
              case 'right':
                targetX = (window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0)) / 2 + (dockPosition === 'left' ? dockSpaceSide : 0);
                targetY = menubarHeight;
                targetWidth = (window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0)) / 2;
                targetHeight = window.innerHeight - menubarHeight - dockSpaceBottom;
                win.isMaximized = false;
                win.isSnapped = true;
                break;
              case 'top':
                // Top center snap - call maximizeWindow for proper maximize behavior
                console.log('Snap finalize: top zone, calling maximizeWindow for same behavior as double-click');
                
                // Clear snap indicator immediately
                const snapIndicator = document.querySelector('.snap-indicator');
                if (snapIndicator) {
                  snapIndicator.classList.remove('active');
                }
                
                // Reset snap zone state
                state.snapZone = null;
                
                // Remove dragging class from window element immediately
                if (windowEl) {
                  windowEl.classList.remove('dragging');
                  // Clear inline transition that might interfere
                  windowEl.style.transition = '';
                }
                
                // Clear drag state to prevent window from sticking to cursor
                dragState = null;
                window.dragState = null;
                
                // Use requestAnimationFrame to ensure the drag is fully complete
                // before starting the maximize animation
                requestAnimationFrame(() => {
                  // Call the maximize function for consistent behavior and proper restore handling
                  window.maximizeWindow(win.id);
                });
                
                // Early return - don't continue to shared animation code
                return;
              case 'top-left':
                targetX = dockPosition === 'left' ? dockSpaceSide : 0;
                targetY = menubarHeight;
                targetWidth = (window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0)) / 2;
                targetHeight = (window.innerHeight - menubarHeight - dockSpaceBottom) / 2;
                win.isMaximized = false;
                win.isSnapped = true;
                break;
              case 'top-right':
                targetX = (window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0)) / 2 + (dockPosition === 'left' ? dockSpaceSide : 0);
                targetY = menubarHeight;
                targetWidth = (window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0)) / 2;
                targetHeight = (window.innerHeight - menubarHeight - dockSpaceBottom) / 2;
                win.isMaximized = false;
                win.isSnapped = true;
                break;
              case 'bottom-left':
                targetX = dockPosition === 'left' ? dockSpaceSide : 0;
                targetY = menubarHeight + (window.innerHeight - menubarHeight - dockSpaceBottom) / 2;
                targetWidth = (window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0)) / 2;
                targetHeight = (window.innerHeight - menubarHeight - dockSpaceBottom) / 2;
                win.isMaximized = false;
                win.isSnapped = true;
                break;
              case 'bottom-right':
                targetX = (window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0)) / 2 + (dockPosition === 'left' ? dockSpaceSide : 0);
                targetY = menubarHeight + (window.innerHeight - menubarHeight - dockSpaceBottom) / 2;
                targetWidth = (window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0)) / 2;
                targetHeight = (window.innerHeight - menubarHeight - dockSpaceBottom) / 2;
                win.isMaximized = false;
                win.isSnapped = true;
                break;
            }
            
            // Snap window with animation - ALWAYS trigger animation
            if (windowEl) {
              // Mark that a snap animation is in progress so global click handlers
              // don't trigger a full render that would cancel the transition.
              state.isSnappingWindow = true;
              
              // Capture EXACT current position from inline styles (set during drag)
              // This is more reliable than getBoundingClientRect()
              const currentLeft = parseFloat(windowEl.style.left) || win.x;
              const currentTop = parseFloat(windowEl.style.top) || win.y;
              const currentWidth = parseFloat(windowEl.style.width) || win.width;
              const currentHeight = parseFloat(windowEl.style.height) || win.height;
              
              // STEP 1: Clear ALL classes and styles immediately
              windowEl.classList.remove('snapping', 'snapped', 'maximizing', 'restoring', 'dragging');
              windowEl.style.willChange = '';
              windowEl.style.transform = '';
              windowEl.style.transition = '';
              windowEl.style.animation = '';
              
              // STEP 2: Force reflow to ensure clean slate
              void windowEl.offsetHeight;
              
              // STEP 3: Set starting position explicitly with NO transition
              windowEl.style.transition = 'none';
              windowEl.style.left = `${currentLeft}px`;
              windowEl.style.top = `${currentTop}px`;
              windowEl.style.width = `${currentWidth}px`;
              windowEl.style.height = `${currentHeight}px`;
              windowEl.style.borderRadius = '12px';
              
              // STEP 4: Force another reflow with starting position locked in
              void windowEl.offsetHeight;
              
              // STEP 5: Use double requestAnimationFrame to GUARANTEE animation plays
              // This ensures the starting position is painted before we animate
              requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                  // Enable transition - SAME AS MAXIMIZE (0.3s)
                  windowEl.style.transition = 'all 0.3s cubic-bezier(0.16, 1, 0.3, 1)';
                  windowEl.style.willChange = 'left, top, width, height, border-radius, box-shadow';
                  windowEl.classList.add('snapping');
                  
                  // STEP 6: Animate to target position
                  windowEl.style.left = `${targetX}px`;
                  windowEl.style.top = `${targetY}px`;
                  windowEl.style.width = `${targetWidth}px`;
                  windowEl.style.height = `${targetHeight}px`;
                  windowEl.style.borderRadius = '0px';
                  windowEl.style.boxShadow = 'none';
                });
              });
              
              // Update state after starting animation
              win.x = targetX;
              win.y = targetY;
              win.width = targetWidth;
              win.height = targetHeight;
              
              // Clean up after animation completes (300ms to match maximize)
              setTimeout(() => {
                if (windowEl) {
                  windowEl.classList.remove('snapping');
                  windowEl.style.willChange = '';
                  windowEl.style.transition = '';
                  windowEl.style.transform = '';
                }
                // Allow global click handlers to render again
                state.isSnappingWindow = false;
              }, 300);
            } else {
              // Fallback - instant snap
              win.x = targetX;
              win.y = targetY;
              win.width = targetWidth;
              win.height = targetHeight;
              if (windowEl) {
                windowEl.style.borderRadius = '0px';
              }
            }
            
            // Save window state to localStorage after snap
            const windowState = state.windowStates[win.appId] || {};
            windowState.x = win.x;
            windowState.y = win.y;
            windowState.width = win.width;
            windowState.height = win.height;
            windowState.isMaximized = win.isMaximized;
            windowState.isSnapped = win.isSnapped;
            // Save snapRestorePos so we can restore original size when unsnapping
            if (win.snapRestorePos) {
              windowState.snapRestorePos = win.snapRestorePos;
            }
            state.windowStates[win.appId] = windowState;
            localStorage.setItem('windowStates', JSON.stringify(state.windowStates));
            
            // Keep window active after snapping
            focusWindow(win.id);
          }
          
          // Hide snap indicator
          const snapIndicator = document.querySelector('.snap-indicator');
          if (snapIndicator) {
            snapIndicator.classList.remove('active');
          }
          state.snapZone = null;
        }
        
        // Save window position if it was dragged (not snapped)
        if (dragState && dragState.hasMoved) {
          const win = state.windows.find((w) => w.id === dragState.id);
          if (win && !win.isSnapped) {
            // Save state for both normal dragging and unmaximized-via-drag windows
            const windowState = state.windowStates[win.appId] || {};
            windowState.x = win.x;
            windowState.y = win.y;
            windowState.width = win.width;
            windowState.height = win.height;
            windowState.isMaximized = win.isMaximized; // Use current state, not hardcoded false
            windowState.isSnapped = false;
            windowState.snapRestorePos = null;
            state.windowStates[win.appId] = windowState;
            localStorage.setItem('windowStates', JSON.stringify(state.windowStates));
            console.log('Window state saved on mouseup:', win.appId, windowState);
          }
        }
        
        // Save window size when resize is complete
        if (resizeState) {
          const win = state.windows.find((w) => w.id === resizeState.id);
          if (win) {
            const savedSizes = JSON.parse(localStorage.getItem('windowSizes') || '{}');
            savedSizes[win.appId] = { width: win.width, height: win.height };
            localStorage.setItem('windowSizes', JSON.stringify(savedSizes));
          }
        }
        
        dragState = null;
        resizeState = null;
        window.dragState = null;
        window.resizeState = null;
      });

      function renderDockOnly() {
        // Quick render just for the dock during drag operations
        const dockElement = document.querySelector('.dock');
        if (!dockElement) return;
        
        const finderApp = apps.find(app => app.id === 'finder');
        const isLaunchpadActive = state.showLaunchpad;
        const finderIconKey = finderApp.icon;
        const finderName = finderApp.name;
        
        const dockHTML = `
          ${finderApp ? `
            <div class="dock-icon" id="dock-finder" onmousedown="window.initDockDrag(event, 'finder'); window.handleDockMouseDown(event, 'finder')" oncontextmenu="window.showContextMenu(event, 'finder')">
              ${icons[finderIconKey]}
              <div class="dock-tooltip">${finderName}</div>
              ${isLaunchpadActive
                ? `
                  <div style="position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%);">
                    <div style="width: 5px; height: 5px; border-radius: 50%; background: ${state.accentColor};"></div>
                  </div>
                `
                : ''}
            </div>
          ` : ''}
          ${state.pinnedApps
            .map((appId) => apps.find((app) => app.id === appId))
            .filter((app) => app !== undefined && app.id !== 'finder')
            .map((app) => {
              const openWindows = state.windows.filter((w) => w.appId === app.id && !w.isMinimized);
              const minimizedWindows = state.windows.filter((w) => w.appId === app.id && w.isMinimized);
              const windowCount = openWindows.length;
              const hasMinimized = minimizedWindows.length > 0;
              return `
                <div class="dock-icon" id="dock-${app.id}" onmousedown="window.initDockDrag(event, '${app.id}'); window.handleDockMouseDown(event, '${app.id}')" oncontextmenu="window.showContextMenu(event, '${app.id}')">
                  ${icons[app.icon]}
                  <div class="dock-tooltip">${app.name}</div>
                  ${windowCount > 0
                    ? `
                      <div style="position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%); display: flex; gap: 3px;">
                        ${Array.from({ length: Math.min(windowCount, 3) })
                          .map(
                            () => `
                              <div style="width: 5px; height: 5px; border-radius: 50%; background: ${state.accentColor};"></div>
                            `,
                          )
                          .join('')}
                      </div>
                    `
                    : hasMinimized
                    ? `
                      <div style="position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%);">
                        <div style="width: 5px; height: 5px; border-radius: 50%; background: ${state.accentColor}; opacity: 0.6;"></div>
                      </div>
                    `
                    : ''}
                </div>
              `;
            })
            .join('')}
          ${(() => {
            const unpinnedOpenApps = apps.filter(app => 
              !state.pinnedApps.includes(app.id) && 
              state.windows.some(w => w.appId === app.id)
            );
            
            if (unpinnedOpenApps.length === 0) return '';
            
            return `
              <div class="dock-divider"></div>
              ${unpinnedOpenApps.map((app) => {
                const openWindows = state.windows.filter((w) => w.appId === app.id && !w.isMinimized);
                const minimizedWindows = state.windows.filter((w) => w.appId === app.id && w.isMinimized);
                const windowCount = openWindows.length;
                const hasMinimized = minimizedWindows.length > 0;
                return `
                  <div class="dock-icon" id="dock-${app.id}" onmousedown="window.initDockDrag(event, '${app.id}'); window.handleDockMouseDown(event, '${app.id}')" oncontextmenu="window.showContextMenu(event, '${app.id}')">
                    ${icons[app.icon]}
                    <div class="dock-tooltip">${app.name}</div>
                    ${windowCount > 0
                      ? `
                        <div style="position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%); display: flex; gap: 3px;">
                          ${Array.from({ length: Math.min(windowCount, 3) })
                            .map(
                              () => `
                                <div style="width: 5px; height: 5px; border-radius: 50%; background: ${state.accentColor};"></div>
                              `,
                            )
                            .join('')}
                        </div>
                      `
                      : hasMinimized
                      ? `
                        <div style="position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%);">
                          <div style="width: 5px; height: 5px; border-radius: 50%; background: ${state.accentColor}; opacity: 0.6;"></div>
                        </div>
                      `
                      : ''}
                  </div>
                `;
              }).join('')}
            `;
          })()}
        `;
        // Track existing dock icon IDs before updating
        const existingIconIds = new Set(
          Array.from(dockElement.querySelectorAll('.dock-icon')).map(icon => icon.id)
        );
        
        dockElement.innerHTML = dockHTML;
        
        // Animate only newly appeared dock icons
        requestAnimationFrame(() => {
          const dockIcons = dockElement.querySelectorAll('.dock-icon');
          dockIcons.forEach((icon) => {
            // Only animate icons that didn't exist before
            if (icon.id && !existingIconIds.has(icon.id)) {
              icon.classList.add('appearing');
              
              // Remove appearing class after animation completes
              setTimeout(() => {
                icon.classList.remove('appearing');
              }, 400); // Match animation duration
            }
          });
        });
      }

      // ============= Background Process System =============
      // Like a real OS, apps can run in background and preserve state when minimized/restored
      
      window.startBackgroundProcess = function(appId, processData = {}) {
        state.backgroundProcesses[appId] = {
          state: 'running',
          data: processData,
          startTime: Date.now(),
          lastUpdate: Date.now()
        };
        state.processStartTimes[appId] = Date.now();
        localStorage.setItem('backgroundProcesses', JSON.stringify(state.backgroundProcesses));
      };
      
      window.updateBackgroundProcess = function(appId, newData) {
        if (state.backgroundProcesses[appId]) {
          state.backgroundProcesses[appId].data = {
            ...state.backgroundProcesses[appId].data,
            ...newData
          };
          state.backgroundProcesses[appId].lastUpdate = Date.now();
          localStorage.setItem('backgroundProcesses', JSON.stringify(state.backgroundProcesses));
        }
      };
      
      window.getBackgroundProcess = function(appId) {
        return state.backgroundProcesses[appId] || null;
      };
      
      window.stopBackgroundProcess = function(appId) {
        delete state.backgroundProcesses[appId];
        delete state.processStartTimes[appId];
        localStorage.setItem('backgroundProcesses', JSON.stringify(state.backgroundProcesses));
      };
      
      window.isProcessRunning = function(appId) {
        return !!state.backgroundProcesses[appId];
      };
      
      window.getProcessUptime = function(appId) {
        if (state.processStartTimes[appId]) {
          return Date.now() - state.processStartTimes[appId];
        }
        return 0;
      };
      
      window.getAllRunningProcesses = function() {
        const processes = [];
        // Add system processes
        processes.push({
          pid: 1,
          name: 'System',
          appId: 'system',
          cpu: Math.random() * 5,
          memory: 150 + Math.random() * 50,
          uptime: Date.now() - (state.systemStartTime || Date.now())
        });
        processes.push({
          pid: 2,
          name: 'Dock',
          appId: 'dock',
          cpu: Math.random() * 2,
          memory: 30 + Math.random() * 10,
          uptime: Date.now() - (state.systemStartTime || Date.now())
        });
        processes.push({
          pid: 3,
          name: 'Menubar',
          appId: 'menubar',
          cpu: Math.random() * 1,
          memory: 20 + Math.random() * 10,
          uptime: Date.now() - (state.systemStartTime || Date.now())
        });
        
        // Add open window processes
        state.windows.forEach((win, idx) => {
          const app = apps.find(a => a.id === win.appId);
          const process = state.backgroundProcesses[win.appId];
          processes.push({
            pid: 100 + idx,
            name: app ? app.name : win.appId,
            appId: win.appId,
            windowId: win.id,
            isMinimized: win.isMinimized,
            cpu: win.isMinimized ? Math.random() * 0.5 : 5 + Math.random() * 15,
            memory: win.isMinimized ? 50 + Math.random() * 30 : 100 + Math.random() * 200,
            uptime: process ? Date.now() - process.startTime : 0,
            state: win.isMinimized ? 'background' : 'active'
          });
        });
        
        // Add background processes without open windows
        Object.entries(state.backgroundProcesses).forEach(([appId, process]) => {
          if (!state.windows.some(w => w.appId === appId)) {
            const app = apps.find(a => a.id === appId);
            processes.push({
              pid: 200 + processes.length,
              name: app ? app.name : appId,
              appId: appId,
              cpu: Math.random() * 3,
              memory: 40 + Math.random() * 60,
              uptime: Date.now() - process.startTime,
              state: 'background'
            });
          }
        });
        
        return processes.sort((a, b) => b.cpu - a.cpu);
      };
      
      // Initialize system start time
      if (!state.systemStartTime) {
        state.systemStartTime = Date.now();
      }
      
      // ============= Throttled Render System =============
      // Prevents excessive re-renders during rapid state changes
      
      const RENDER_THROTTLE_MS = 16; // ~60fps
      
      function throttledRender() {
        const now = Date.now();
        
        // If a render is already queued, skip
        if (state.renderQueued) return;
        
        // Calculate time since last render
        const timeSinceLastRender = now - state.lastRenderTime;
        
        if (timeSinceLastRender >= RENDER_THROTTLE_MS) {
          // Enough time has passed, render immediately
          state.lastRenderTime = now;
          render();
        } else {
          // Queue a render for later
          state.renderQueued = true;
          requestAnimationFrame(() => {
            state.renderQueued = false;
            state.lastRenderTime = Date.now();
            render();
          });
        }
      }

      // ============= Split Render System =============
      // renderShell() - Renders desktop shell (bg, menubar, dock, quick settings, launchpad, dialogs)
      // renderWindows() - Renders only the windows layer
      // render() - Full render (calls both + handles iframe preservation, scroll restoration, etc.)
      
      // Generate windows HTML - extracted for reuse
      function generateWindowsHTML() {
        return state.windows
          .filter((w) => !w.isMinimized && !state.showLaunchpad)
          .map((win) => {
            let style = '';
            let className = 'window';
            
            // Add inactive class for non-active windows
            const isActive = state.activeWindowId === win.id;
            if (!isActive) {
              className += ' inactive';
            }

            if (win.isFullscreen) {
              className += ' fullscreen';
              style = `top: 0; left: 0; width: 100vw; height: 100vh; z-index: ${win.zIndex}`;
             } else if (win.isMaximized) {
              className += ' maximized';
              // Calculate dock space based on current dock position and scale
              const dockPosition = state.dockPosition || 'bottom';
              const menubarHeight = 28;
              const dockDims = getDockDimensions();
              
              const dockSpaceBottom = dockPosition === 'bottom' ? dockDims.getBottomSpace() : 0;
              const dockSpaceSide = (dockPosition === 'left' || dockPosition === 'right') ? dockDims.getSideSpace() : 0;
              const targetWidth = window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0);
              const targetHeight = window.innerHeight - menubarHeight - dockSpaceBottom;
              const targetLeft = dockPosition === 'left' ? dockSpaceSide : 0;
              const targetTop = menubarHeight;
              style = `top: ${targetTop}px; left: ${targetLeft}px; width: ${targetWidth}px; height: ${targetHeight}px; z-index: ${win.zIndex}; border-radius: 0`;
            } else {
              // Add 'snapped' class when window is snapped
              if (win.isSnapped) {
                className += ' snapped';
              }
              style = `top: ${win.y}px; left: ${win.x}px; width: ${win.width}px; height: ${win.height}px; z-index: ${win.zIndex}${win.isSnapped ? '; border-radius: 0' : ''}`;
            }

            return `
              <div class="${className}" id="window-${win.id}" data-id="${win.id}" style="${style}" onmousedown="window.focusWindow(${win.id})" ondblclick="window.handleWindowDblClick(event, ${win.id})">
                ${!win.isFullscreen
                  ? `
                    <div class="titlebar ${state.mirroredControls ? 'mirrored-controls' : ''}" ondblclick="event.stopPropagation(); window.maximizeWindow(${win.id})">
                      ${(() => {
                        const app = apps.find(a => a.id === win.appId);
                        const supportsFullscreen = app && app.supportsFullscreen;
                        return supportsFullscreen ? `
                          <button class="titlebar-fullscreen-btn" onclick="event.stopPropagation(); window.toggleFullscreen(${win.id})" title="Enter Fullscreen">
                            <svg viewBox="0 0 24 24">
                              <path d="M15 3h6v6M9 21H3v-6M21 3l-7 7M3 21l7-7"/>
                            </svg>
                          </button>
                        ` : '';
                      })()}
                      <div class="titlebar-buttons">
                        <button class="titlebar-button close" onclick="event.stopPropagation(); window.closeWindow(${win.id})"></button>
                        <button class="titlebar-button minimize ${win.isMaximized ? 'is-maximized' : ''}" onclick="event.stopPropagation(); window.minimizeWindow(${win.id})"></button>
                        <button class="titlebar-button maximize" onclick="event.stopPropagation(); window.maximizeWindow(${win.id})"></button>
                      </div>
                      <div class="titlebar-title">${win.title}</div>
                    </div>
                  `
                  : ''}
                <div class="window-content" ondblclick="event.stopPropagation()">
                  ${getWindowContent(win.appId)}
                </div>
                ${win.isFullscreen
                  ? `
                    <div class="fullscreen-hover-zone" onmouseenter="window.showFullscreenUI(${win.id})" onmouseleave="window.hideFullscreenUI(${win.id})"></div>
                    <div class="fullscreen-overlay-ui" onmouseenter="window.showFullscreenUI(${win.id})" onmouseleave="window.hideFullscreenUI(${win.id})">
                      <div class="fullscreen-exit-btn" onclick="window.toggleFullscreen(${win.id})">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                          <path d="M4 14h6v6M20 10h-6V4M14 10l7-7M3 21l7-7" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                        <span>Exit Fullscreen</span>
                      </div>
                      <div class="fullscreen-hint">Press ESC or Ctrl+Shift+F to exit</div>
                    </div>
                  `
                  : ''}
                ${!win.isMaximized && !win.isFullscreen
                  ? `
                    <div class="resize-handle se"></div>
                    <div class="resize-handle sw"></div>
                    <div class="resize-handle ne"></div>
                    <div class="resize-handle nw"></div>
                    <div class="resize-handle n"></div>
                    <div class="resize-handle s"></div>
                    <div class="resize-handle e"></div>
                    <div class="resize-handle w"></div>
                  `
                  : ''}
              </div>
            `;
          })
          .join('');
      }
      
      // ============= DOM Diffing System for Windows =============
      // Computes minimal DOM mutations to update windows layer efficiently
      
      // Compute the desired state for a window (style, classes, etc.)
      function computeWindowState(win) {
        let style = '';
        let classes = ['window'];
        
        // Active/inactive state
        if (state.activeWindowId !== win.id) {
          classes.push('inactive');
        }

        if (win.isFullscreen) {
          classes.push('fullscreen');
          style = 'top: 0; left: 0; width: 100vw; height: 100vh; z-index: ' + win.zIndex;
        } else if (win.isMaximized) {
          classes.push('maximized');
          const dockPosition = state.dockPosition || 'bottom';
          const menubarHeight = 28;
          const dockDims = getDockDimensions();
          
          const dockSpaceBottom = dockPosition === 'bottom' ? dockDims.getBottomSpace() : 0;
          const dockSpaceSide = (dockPosition === 'left' || dockPosition === 'right') ? dockDims.getSideSpace() : 0;
          const targetWidth = window.innerWidth - (dockPosition === 'left' ? dockSpaceSide : 0) - (dockPosition === 'right' ? dockSpaceSide : 0);
          const targetHeight = window.innerHeight - menubarHeight - dockSpaceBottom;
          const targetLeft = dockPosition === 'left' ? dockSpaceSide : 0;
          const targetTop = menubarHeight;
          style = 'top: ' + targetTop + 'px; left: ' + targetLeft + 'px; width: ' + targetWidth + 'px; height: ' + targetHeight + 'px; z-index: ' + win.zIndex + '; border-radius: 0';
        } else {
          if (win.isSnapped) {
            classes.push('snapped');
          }
          style = 'top: ' + win.y + 'px; left: ' + win.x + 'px; width: ' + win.width + 'px; height: ' + win.height + 'px; z-index: ' + win.zIndex + (win.isSnapped ? '; border-radius: 0' : '');
        }

        return {
          id: win.id,
          appId: win.appId,
          title: win.title,
          style: style,
          className: classes.join(' '),
          isFullscreen: win.isFullscreen,
          isMaximized: win.isMaximized
        };
      }
      
      // Generate single window HTML (for creating new windows)
      function generateSingleWindowHTML(win) {
        const computed = computeWindowState(win);
        const app = apps.find(a => a.id === win.appId);
        const supportsFullscreen = app && app.supportsFullscreen;
        
        let html = '<div class="' + computed.className + '" id="window-' + win.id + '" data-id="' + win.id + '" style="' + computed.style + '" onmousedown="window.focusWindow(' + win.id + ')" ondblclick="window.handleWindowDblClick(event, ' + win.id + ')">';
        
        if (!win.isFullscreen) {
          html += '<div class="titlebar ' + (state.mirroredControls ? 'mirrored-controls' : '') + '" ondblclick="event.stopPropagation(); window.maximizeWindow(' + win.id + ')">';
          if (supportsFullscreen) {
            html += '<button class="titlebar-fullscreen-btn" onclick="event.stopPropagation(); window.toggleFullscreen(' + win.id + ')" title="Enter Fullscreen">';
            html += '<svg viewBox="0 0 24 24"><path d="M15 3h6v6M9 21H3v-6M21 3l-7 7M3 21l7-7"/></svg>';
            html += '</button>';
          }
          html += '<div class="titlebar-buttons">';
          html += '<button class="titlebar-button close" onclick="event.stopPropagation(); window.closeWindow(' + win.id + ')"></button>';
          html += '<button class="titlebar-button minimize ' + (win.isMaximized ? 'is-maximized' : '') + '" onclick="event.stopPropagation(); window.minimizeWindow(' + win.id + ')"></button>';
          html += '<button class="titlebar-button maximize" onclick="event.stopPropagation(); window.maximizeWindow(' + win.id + ')"></button>';
          html += '</div>';
          html += '<div class="titlebar-title">' + win.title + '</div>';
          html += '</div>';
        }
        
        html += '<div class="window-content" ondblclick="event.stopPropagation()">' + getWindowContent(win.appId) + '</div>';
        
        if (win.isFullscreen) {
          html += '<div class="fullscreen-hover-zone" onmouseenter="window.showFullscreenUI(' + win.id + ')" onmouseleave="window.hideFullscreenUI(' + win.id + ')"></div>';
          html += '<div class="fullscreen-overlay-ui" onmouseenter="window.showFullscreenUI(' + win.id + ')" onmouseleave="window.hideFullscreenUI(' + win.id + ')">';
          html += '<div class="fullscreen-exit-btn" onclick="window.toggleFullscreen(' + win.id + ')">';
          html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;"><path d="M4 14h6v6M20 10h-6V4M14 10l7-7M3 21l7-7" stroke-linecap="round" stroke-linejoin="round"/></svg>';
          html += '<span>Exit Fullscreen</span>';
          html += '</div>';
          html += '<div class="fullscreen-hint">Press ESC or Ctrl+Shift+F to exit</div>';
          html += '</div>';
        }
        
        if (!win.isMaximized && !win.isFullscreen) {
          html += '<div class="resize-handle se"></div>';
          html += '<div class="resize-handle sw"></div>';
          html += '<div class="resize-handle ne"></div>';
          html += '<div class="resize-handle nw"></div>';
          html += '<div class="resize-handle n"></div>';
          html += '<div class="resize-handle s"></div>';
          html += '<div class="resize-handle e"></div>';
          html += '<div class="resize-handle w"></div>';
        }
        
        html += '</div>';
        return html;
      }
      
      // Diff and patch a single window element
      function patchWindow(windowEl, win, prevState) {
        const newState = computeWindowState(win);
        
        // Update style if changed
        if (windowEl.getAttribute('style') !== newState.style) {
          windowEl.setAttribute('style', newState.style);
        }
        
        // Update class if changed
        if (windowEl.className !== newState.className) {
          windowEl.className = newState.className;
        }
        
        // Update title if changed
        const titleEl = windowEl.querySelector('.titlebar-title');
        if (titleEl && titleEl.textContent !== newState.title) {
          titleEl.textContent = newState.title;
        }
        
        // Handle fullscreen/maximize state changes that require structure updates
        const hadTitlebar = windowEl.querySelector('.titlebar') !== null;
        const needsTitlebar = !win.isFullscreen;
        
        if (hadTitlebar !== needsTitlebar) {
          // Structure changed significantly, rebuild content
          return false; // Signal needs full rebuild
        }
        
        // Handle resize handles visibility
        const hasResizeHandles = windowEl.querySelector('.resize-handle') !== null;
        const needsResizeHandles = !win.isMaximized && !win.isFullscreen;
        
        if (hasResizeHandles !== needsResizeHandles) {
          return false; // Signal needs full rebuild
        }
        
        // Update mirrored controls class on titlebar
        const titlebar = windowEl.querySelector('.titlebar');
        if (titlebar) {
          const hasMirrored = titlebar.classList.contains('mirrored-controls');
          if (hasMirrored !== state.mirroredControls) {
            if (state.mirroredControls) {
              titlebar.classList.add('mirrored-controls');
            } else {
              titlebar.classList.remove('mirrored-controls');
            }
          }
          
          // Update minimize button is-maximized class
          const minBtn = titlebar.querySelector('.titlebar-button.minimize');
          if (minBtn) {
            const hasIsMaximized = minBtn.classList.contains('is-maximized');
            if (hasIsMaximized !== win.isMaximized) {
              if (win.isMaximized) {
                minBtn.classList.add('is-maximized');
              } else {
                minBtn.classList.remove('is-maximized');
              }
            }
          }
        }
        
        return true; // Successfully patched
      }
      
      // Render only the windows layer with DOM diffing
      function renderWindows() {
        // Update apps list
        apps = getApps();
        
        const windowsLayer = document.querySelector('.windows-layer');
        if (!windowsLayer) {
          // Shell not rendered yet, do full render
          render();
          return;
        }
        
        // Skip during drag/resize
        if (dragState || resizeState) {
          return;
        }
        
        // Get visible windows
        const visibleWindows = state.windows.filter(w => !w.isMinimized && !state.showLaunchpad);
        const visibleIds = new Set(visibleWindows.map(w => w.id));
        
        // Get existing window elements
        const existingEls = Array.from(windowsLayer.querySelectorAll(':scope > .window'));
        const existingById = new Map();
        existingEls.forEach(el => {
          const id = parseInt(el.dataset.id, 10);
          existingById.set(id, el);
        });
        
        // Track windows that need full rebuild
        const needsRebuild = new Set();
        
        // Phase 1: Remove windows that no longer exist
        existingEls.forEach(el => {
          const id = parseInt(el.dataset.id, 10);
          if (!visibleIds.has(id)) {
            // Preserve iframes before removing
            const win = state.windows.find(w => w.id === id);
            if (win) {
              preserveWindowIframes(el, win);
            }
            el.remove();
            existingById.delete(id);
          }
        });
        
        // Phase 2: Patch existing windows or mark for rebuild
        visibleWindows.forEach(win => {
          const el = existingById.get(win.id);
          if (el) {
            // Try to patch
            const success = patchWindow(el, win);
            if (!success) {
              needsRebuild.add(win.id);
            }
          }
        });
        
        // Phase 3: Rebuild windows that need it (preserving iframes)
        needsRebuild.forEach(id => {
          const el = existingById.get(id);
          const win = visibleWindows.find(w => w.id === id);
          if (el && win) {
            preserveWindowIframes(el, win);
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = generateSingleWindowHTML(win);
            const newEl = tempDiv.firstElementChild;
            el.replaceWith(newEl);
            existingById.set(id, newEl);
            restoreWindowIframes(newEl, win);
          }
        });
        
        // Phase 4: Add new windows
        visibleWindows.forEach(win => {
          if (!existingById.has(win.id)) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = generateSingleWindowHTML(win);
            const newEl = tempDiv.firstElementChild;
            windowsLayer.appendChild(newEl);
            existingById.set(win.id, newEl);
          }
        });
        
        // Phase 5: Reorder windows by z-index if needed
        const sortedWindows = [...visibleWindows].sort((a, b) => a.zIndex - b.zIndex);
        let needsReorder = false;
        const currentOrder = Array.from(windowsLayer.querySelectorAll(':scope > .window')).map(el => parseInt(el.dataset.id, 10));
        const targetOrder = sortedWindows.map(w => w.id);
        
        if (currentOrder.length === targetOrder.length) {
          for (let i = 0; i < currentOrder.length; i++) {
            if (currentOrder[i] !== targetOrder[i]) {
              needsReorder = true;
              break;
            }
          }
        }
        
        if (needsReorder) {
          sortedWindows.forEach(win => {
            const el = existingById.get(win.id);
            if (el) {
              windowsLayer.appendChild(el); // Move to end in z-order
            }
          });
        }
        
        // Restore any preserved Task Manager content
        preservedTaskManagerContent.forEach((data, key) => {
          const windowEl = document.getElementById('window-' + data.winId);
          if (windowEl) {
            const windowContent = windowEl.querySelector('.window-content');
            if (windowContent && data.element) {
              windowContent.innerHTML = '';
              windowContent.appendChild(data.element);
              
              // Restore scroll position
              const processList = data.element.querySelector('[data-process-list]');
              if (processList && data.scrollTop) {
                processList.scrollTop = data.scrollTop;
              }
              
              preservedTaskManagerContent.delete(key);
            }
          }
        });
        
        // Restore any remaining preserved iframes
        preservedIframes.forEach((data, key) => {
          const windowEl = document.getElementById('window-' + data.winId);
          if (windowEl) {
            restoreIframeToWindow(windowEl, data, key);
          }
        });
        
        // Restore scroll positions
        requestAnimationFrame(() => {
          document.querySelectorAll('.window-content').forEach(content => {
            const windowEl = content.closest('.window');
            if (windowEl) {
              const windowId = windowEl.dataset.id;
              if (windowId && state.scrollPositions[windowId] !== undefined) {
                content.scrollTop = state.scrollPositions[windowId];
              }
            }
          });
        });
        
        // Setup fullscreen iframe focus if needed
        setupFullscreenIframeFocus();
      }
      
      // Helper: Preserve iframes and task manager content from a window element
      function preserveWindowIframes(windowEl, win) {
        // PRESERVE TASK MANAGER CONTENT
        if (win.appId === 'taskmanager') {
          const taskManagerContainer = windowEl.querySelector('[data-task-manager-container]');
          if (taskManagerContainer) {
            const tmKey = `taskmanager-${win.id}`;
            const processList = taskManagerContainer.querySelector('[data-process-list]');
            const scrollTop = processList ? processList.scrollTop : 0;
            
            preservedTaskManagerContent.set(tmKey, {
              element: taskManagerContainer,
              winId: win.id,
              scrollTop: scrollTop
            });
            taskManagerContainer.remove();
          }
        }
        
        // PRESERVE IFRAMES
        const iframes = windowEl.querySelectorAll('iframe');
        iframes.forEach((iframe, idx) => {
          const iframeKey = win.appId + '-' + win.id + '-' + idx;
          const hasContent = iframe.src && iframe.src !== 'about:blank';
          const isMCFrame = iframe.id === 'minecraft-frame';
          const isBrowserFrame = iframe.classList.contains('browser-iframe');
          
          if (hasContent || isMCFrame || isBrowserFrame) {
            const container = iframe.parentElement;
            if (container) {
              preservedIframes.set(iframeKey, {
                iframe: iframe,
                parentStyles: container.getAttribute('style'),
                isMinimized: win.isMinimized,
                appId: win.appId,
                winId: win.id,
                idx: idx,
                src: iframe.src
              });
              iframe.remove();
            }
          }
        });
        
        // Save scroll position
        const content = windowEl.querySelector('.window-content');
        if (content) {
          state.scrollPositions[win.id] = content.scrollTop;
        }
      }
      
      // Helper: Restore iframes and task manager content to a window element
      function restoreWindowIframes(windowEl, win) {
        // RESTORE TASK MANAGER CONTENT
        if (win.appId === 'taskmanager') {
          const tmKey = `taskmanager-${win.id}`;
          const data = preservedTaskManagerContent.get(tmKey);
          if (data) {
            const windowContent = windowEl.querySelector('.window-content');
            if (windowContent && data.element) {
              windowContent.innerHTML = '';
              windowContent.appendChild(data.element);
              
              // Restore scroll position
              const processList = data.element.querySelector('[data-process-list]');
              if (processList && data.scrollTop) {
                processList.scrollTop = data.scrollTop;
              }
              
              preservedTaskManagerContent.delete(tmKey);
            }
          }
        }
        
        // RESTORE IFRAMES
        preservedIframes.forEach((data, key) => {
          if (data.winId === win.id) {
            restoreIframeToWindow(windowEl, data, key);
          }
        });
      }
      
      // Helper: Restore a single iframe to its window
      function restoreIframeToWindow(windowEl, data, key) {
        if (data.appId === 'minecraft') {
          const container = windowEl.querySelector('.minecraft-container');
          if (container && data.iframe) {
            container.appendChild(data.iframe);
            preservedIframes.delete(key);
          }
        } else if (data.appId === 'browser') {
          // Browser can have MULTIPLE iframes (tabs). Restore by matching the original iframe id.
          let target = null;
          if (data.iframe && data.iframe.id) {
            const byId = document.getElementById(data.iframe.id);
            if (byId && windowEl.contains(byId)) target = byId;
          }

          if (!target) {
            const iframes = windowEl.querySelectorAll('iframe.browser-iframe');
            target = iframes[data.idx] || iframes[0] || null;
          }

          if (target && data.iframe) {
            target.replaceWith(data.iframe);
            preservedIframes.delete(key);
          }
        } else {
          const iframes = windowEl.querySelectorAll('iframe');
          if (iframes[data.idx]) {
            iframes[data.idx].replaceWith(data.iframe);
            preservedIframes.delete(key);
          } else if (iframes.length > 0) {
            iframes[0].replaceWith(data.iframe);
            preservedIframes.delete(key);
          }
        }
      }
      
      // Render only the shell (dock, menubar, etc.) without touching windows
      function renderShell() {
        const root = document.getElementById('root');
        const existingDesktop = root.querySelector('.desktop');
        
        if (!existingDesktop) {
          // No desktop yet, do full render
          render();
          return;
        }
        
        // Update dock
        const dockContainer = existingDesktop.querySelector('.dock-container');
        if (dockContainer && !state.showLaunchpad) {
          dockContainer.outerHTML = generateDockHTML();
          setupDockMagnification();
        }
        
        // Update menubar quick settings state if needed
        const quickSettings = existingDesktop.querySelector('.quick-settings');
        if (quickSettings) {
          if (state.showQuickSettings) {
            quickSettings.classList.add('active');
          } else {
            quickSettings.classList.remove('active');
          }
        }
      }
      
      // Generate dock HTML - extracted for shell updates
      function generateDockHTML() {
        if (state.showLaunchpad) return '';
        
        const finderApp = apps.find(app => app.id === 'finder');
        const isLaunchpadActive = state.showLaunchpad;
        
        // Generate finder icon
        let finderHTML = '';
        if (finderApp) {
          const finderIconKey = finderApp.icon;
          const finderName = finderApp.name;
          finderHTML = '<div class="dock-icon" id="dock-finder" onmousedown="window.initDockDrag(event, \'finder\'); window.handleDockMouseDown(event, \'finder\')" oncontextmenu="window.showContextMenu(event, \'finder\')">' +
            icons[finderIconKey] +
            '<div class="dock-tooltip">' + finderName + '</div>' +
            (isLaunchpadActive ? '<div style="position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%);"><div style="width: 5px; height: 5px; border-radius: 50%; background: ' + state.accentColor + ';"></div></div>' : '') +
            '</div>';
        }
        
        // Generate pinned apps
        const pinnedHTML = state.pinnedApps
          .map((appId) => apps.find((app) => app.id === appId))
          .filter((app) => app !== undefined && app.id !== 'finder')
          .map((app) => {
            const openWindows = state.windows.filter((w) => w.appId === app.id && !w.isMinimized);
            const minimizedWindows = state.windows.filter((w) => w.appId === app.id && w.isMinimized);
            const windowCount = openWindows.length;
            const hasMinimized = minimizedWindows.length > 0;
            
            let indicator = '';
            if (windowCount > 0) {
              const dots = Array.from({ length: Math.min(windowCount, 3) })
                .map(() => '<div style="width: 5px; height: 5px; border-radius: 50%; background: ' + state.accentColor + ';"></div>')
                .join('');
              indicator = '<div style="position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%); display: flex; gap: 3px;">' + dots + '</div>';
            } else if (hasMinimized) {
              indicator = '<div style="position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%);"><div style="width: 5px; height: 5px; border-radius: 50%; background: ' + state.accentColor + '; opacity: 0.6;"></div></div>';
            }
            
            return '<div class="dock-icon" id="dock-' + app.id + '" onmousedown="window.initDockDrag(event, \'' + app.id + '\'); window.handleDockMouseDown(event, \'' + app.id + '\')" oncontextmenu="window.showContextMenu(event, \'' + app.id + '\')">' +
              icons[app.icon] +
              '<div class="dock-tooltip">' + app.name + '</div>' +
              indicator +
              '</div>';
          })
          .join('');
        
        // Generate unpinned open apps
        const unpinnedOpenApps = apps.filter(app => 
          !state.pinnedApps.includes(app.id) && 
          state.windows.some(w => w.appId === app.id)
        );
        
        let unpinnedHTML = '';
        if (unpinnedOpenApps.length > 0) {
          unpinnedHTML = '<div class="dock-divider"></div>';
          unpinnedHTML += unpinnedOpenApps.map((app) => {
            const openWindows = state.windows.filter((w) => w.appId === app.id && !w.isMinimized);
            const minimizedWindows = state.windows.filter((w) => w.appId === app.id && w.isMinimized);
            const windowCount = openWindows.length;
            const hasMinimized = minimizedWindows.length > 0;
            
            let indicator = '';
            if (windowCount > 0) {
              const dots = Array.from({ length: Math.min(windowCount, 3) })
                .map(() => '<div style="width: 5px; height: 5px; border-radius: 50%; background: ' + state.accentColor + ';"></div>')
                .join('');
              indicator = '<div style="position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%); display: flex; gap: 3px;">' + dots + '</div>';
            } else if (hasMinimized) {
              indicator = '<div style="position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%);"><div style="width: 5px; height: 5px; border-radius: 50%; background: ' + state.accentColor + '; opacity: 0.6;"></div></div>';
            }
            
            return '<div class="dock-icon" id="dock-' + app.id + '" onmousedown="window.initDockDrag(event, \'' + app.id + '\'); window.handleDockMouseDown(event, \'' + app.id + '\')" oncontextmenu="window.showContextMenu(event, \'' + app.id + '\')">' +
              icons[app.icon] +
              '<div class="dock-tooltip">' + app.name + '</div>' +
              indicator +
              '</div>';
          }).join('');
        }
        
        return '<div class="dock-container dock-' + (state.dockPosition || 'bottom') + '">' +
          '<div class="dock">' +
          finderHTML +
          pinnedHTML +
          unpinnedHTML +
          '</div>' +
          '</div>';
      }

      function render() {
        // Update apps list with installed apps
        apps = getApps();
        
        // CRITICAL: Don't re-render during active window dragging/resizing to eliminate flicker
        // The drag handlers update DOM styles directly, so render() would cause visual reset
        if (dragState || resizeState) {
          // Skip render during drag/resize - DOM is updated directly in mousemove handler
          return;
        }
        
        // CRITICAL: Don't re-render when Minecraft is actively running to prevent game interruption
        // This prevents the 3D rendering from being interrupted by UI updates
        const minecraftWin = state.windows.find(w => w.appId === 'minecraft' && !w.isMinimized);
        const minecraftFrame = minecraftWin ? document.querySelector('#minecraft-frame') : null;
        if (minecraftFrame && document.activeElement === minecraftFrame) {
          // Only skip if Minecraft has focus - allow other renders when user is interacting with OS
          console.log('Skipping render - Minecraft has focus');
          return;
        }
        
        // Don't re-render if user has text selected anywhere to preserve selection
        const selection = window.getSelection();
        if (selection && selection.toString().length > 0) {
          // Skip render to preserve text selection
          return;
        }
        
        // Don't re-render if a select dropdown is active
        const activeElement = document.activeElement;
        if (activeElement && activeElement.tagName === 'SELECT') {
          // Skip render to preserve dropdown state
          return;
        }
        
        // Don't re-render if a calibration input is focused to preserve input state
        if (activeElement && activeElement.id && activeElement.id.startsWith('cal-') && 
            (activeElement.id.endsWith('-x') || activeElement.id.endsWith('-y'))) {
          // Skip render to preserve calibration input focus and values
          return;
        }
        
        // Don't re-render if a browser address input is focused to preserve typing state
        if (activeElement && activeElement.classList && activeElement.classList.contains('browser-address-input')) {
          // Skip render to preserve browser address input focus and values
          return;
        }
        
        // Don't re-render if any input or textarea is focused to preserve typing state
        if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
          // Skip render to preserve input focus and prevent losing user's typing
          return;
        }
        
        // NOTE: We no longer skip full renders just because Task Manager / Minecraft / Browser are open.
        // Those early-returns froze the rest of the desktop (opening apps, updating UI) whenever these apps existed.
        // Instead we rely on the iframe preservation system below to avoid reloads, and on app-specific in-place
        // updates (e.g. Task Manager) to reduce flicker.

        // PRESERVE IFRAMES: Save ALL iframes before re-render to prevent reload
        // This prevents game reset, browser page reload, and any other iframe content loss
        state.windows.forEach(win => {
          const windowEl = document.getElementById(`window-${win.id}`);
          if (windowEl) {
            // PRESERVE TASK MANAGER CONTENT: Save the entire Task Manager container to prevent refresh
            if (win.appId === 'taskmanager') {
              const taskManagerContainer = windowEl.querySelector('[data-task-manager-container]');
              if (taskManagerContainer) {
                const tmKey = `taskmanager-${win.id}`;
                // Save scroll position before preserving
                const processList = taskManagerContainer.querySelector('[data-process-list]');
                const scrollTop = processList ? processList.scrollTop : 0;
                
                preservedTaskManagerContent.set(tmKey, {
                  element: taskManagerContainer,
                  winId: win.id,
                  scrollTop: scrollTop
                });
                taskManagerContainer.remove();
              }
            }
            
            // Find all iframes in this window
            const iframes = windowEl.querySelectorAll('iframe');
            iframes.forEach((iframe, idx) => {
              // Generate a unique key for this iframe
              const iframeKey = `${win.appId}-${win.id}-${idx}`;
              
              // Check if iframe has content worth preserving
              const hasContent = iframe.src && iframe.src !== 'about:blank';
              const isMCFrame = iframe.id === 'minecraft-frame';
              const isBrowserFrame = iframe.classList.contains('browser-iframe');
              
              if (hasContent || isMCFrame || isBrowserFrame) {
                const container = iframe.parentElement;
                if (container) {
                  preservedIframes.set(iframeKey, {
                    iframe: iframe,
                    parentStyles: container.getAttribute('style'),
                    isMinimized: win.isMinimized,
                    appId: win.appId,
                    winId: win.id,
                    idx: idx,
                    src: iframe.src
                  });
                  iframe.remove();
                }
              }
            });
          }
        });
        
        // Preserve focus state before re-render
        const wasInputFocused = activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA');
        const inputTerminalId = wasInputFocused && activeElement.dataset ? activeElement.dataset.terminalId : null;
        const inputWindowId = wasInputFocused && activeElement.dataset ? activeElement.dataset.windowId : null;
        const cursorPosition = wasInputFocused && activeElement.selectionStart !== undefined ? activeElement.selectionStart : 0;
        
        // Save current input values before re-render
        document.querySelectorAll('.browser-address-input').forEach(input => {
          const winId = input.dataset.windowId;
          if (winId) {
            state.inputValues[winId] = input.value;
          }
        });
        
        // Save terminal input values before re-render
        document.querySelectorAll('.terminal-input').forEach(input => {
          const termId = input.dataset.terminalId;
          if (termId) {
            state.inputValues[`terminal-${termId}`] = input.value;
          }
        });
        
        // Save calibration input values before re-render (preserve hotspot values)
        const cursorTypes = typeof DEFAULT_HOTSPOTS !== 'undefined' ? Object.keys(DEFAULT_HOTSPOTS) : [];
        cursorTypes.forEach(type => {
          const xInput = document.querySelector(`#cal-${type}-x`);
          const yInput = document.querySelector(`#cal-${type}-y`);
          if (xInput && yInput) {
            liveHotspots[type].x = parseFloat(xInput.value) || 0;
            liveHotspots[type].y = parseFloat(yInput.value) || 0;
          }
        });
        
        // Save scroll positions for all windows (only if not actively scrolling)
        if (!state.isScrolling) {
          document.querySelectorAll('.window-content').forEach(content => {
            const windowEl = content.closest('.window');
            if (windowEl) {
              const windowId = windowEl.dataset.id;
              if (windowId) {
                state.scrollPositions[windowId] = content.scrollTop;
              }
            }
          });
          
          // Save terminal scroll positions
          document.querySelectorAll('.terminal-content').forEach(el => {
            const terminalId = el.dataset.terminalId;
            if (terminalId) {
              state.scrollPositions[`terminal-${terminalId}`] = el.scrollTop;
            }
          });
          
          // Save browser-specific scrollable areas
          document.querySelectorAll('.youtube-videos').forEach(el => {
            const windowEl = el.closest('.window');
            if (windowEl) {
              const windowId = windowEl.dataset.id;
              if (windowId) {
                state.scrollPositions[`${windowId}-youtube-videos`] = el.scrollTop;
              }
            }
          });
          
          document.querySelectorAll('.youtube-sidebar').forEach(el => {
            const windowEl = el.closest('.window');
            if (windowEl) {
              const windowId = windowEl.dataset.id;
              if (windowId) {
                state.scrollPositions[`${windowId}-youtube-sidebar`] = el.scrollTop;
              }
            }
          });
          
          document.querySelectorAll('.browser-home').forEach(el => {
            const windowEl = el.closest('.window');
            if (windowEl) {
              const windowId = windowEl.dataset.id;
              if (windowId) {
                state.scrollPositions[`${windowId}-browser-home`] = el.scrollTop;
              }
            }
          });
          
          // Also save launchpad scroll position
          const launchpadGrid = document.querySelector('.launchpad-grid');
          if (launchpadGrid) {
            state.scrollPositions['launchpad'] = launchpadGrid.scrollTop;
          }
          
          // Save settings content scroll position
          const settingsContent = document.querySelector('.settings-content');
          if (settingsContent) {
            state.scrollPositions['settings-content'] = settingsContent.scrollTop;
          }
          
          // Save settings sidebar scroll position
          const settingsSidebar = document.querySelector('.settings-sidebar');
          if (settingsSidebar) {
            state.scrollPositions['settings-sidebar'] = settingsSidebar.scrollTop;
          }
          
          // Save appstore scroll positions
          document.querySelectorAll('.appstore-container').forEach(el => {
            const windowEl = el.closest('.window');
            if (windowEl) {
              const windowId = windowEl.dataset.id;
              if (windowId) {
                state.scrollPositions[`${windowId}-appstore`] = el.scrollTop;
              }
            }
          });
          
          // Save task manager scroll positions
          document.querySelectorAll('[data-process-list]').forEach(el => {
            const windowEl = el.closest('.window');
            if (windowEl) {
              const windowId = windowEl.dataset.id;
              if (windowId) {
                state.scrollPositions[`${windowId}-taskmanager`] = el.scrollTop;
              }
            }
          });
          
          // Save browser vertical tabs scroll positions
          document.querySelectorAll('.browser-sidebar .browser-tabs-container').forEach(el => {
            const windowEl = el.closest('.window');
            if (windowEl) {
              const windowId = windowEl.dataset.id;
              if (windowId) {
                state.scrollPositions[`${windowId}-browser-vertical-tabs`] = el.scrollTop;
              }
            }
          });
        }
        
        const root = document.getElementById('root');
        root.innerHTML = `
          <div class="desktop" style="--dock-scale: ${state.dockScale || 1.0};">
            <div class="desktop-bg" style="${state.customWallpaper ? `background-image: url('${state.customWallpaper}'); background-size: cover; background-position: center;` : ''}"></div>

            ${!state.showLaunchpad ? `
            <div class="menubar ${state.contextMenuCustomizeMode ? 'customize-mode' : ''}" oncontextmenu="window.showContextMenuRightClick(event)">
                <!-- M OS Context Menu (Top Bar) -->
                ${renderContextMenuBar()}
            </div>
            
            ${state.contextMenuCustomizeMode ? `
              <div class="context-menu-customize-bar">
                <span> Drag elements to rearrange  Click to move/remove</span>
                ${(() => {
                  const hiddenElements = state.contextMenuLayout.elements.filter(e => !e.visible);
                  const elementLabels = { 
                    logo: 'Logo', 
                    menus: 'Menus', 
                    quicksettings: 'Quick Settings', 
                    clock: 'Clock',
                    windowlist: 'Window List',
                    workspaces: 'Workspaces',
                    separator1: 'Separator',
                    separator2: 'Separator',
                    systray: 'System Tray',
                    battery: 'Battery',
                    notifications: 'Notifications'
                  };
                  if (hiddenElements.length > 0) {
                    return `
                      <div class="hidden-elements-list">
                        <span class="label">Hidden:</span>
                        ${hiddenElements.map(e => `
                          <button class="hidden-element-btn" onclick="window.addContextMenuElement('${e.id}', 'center')">
                            + ${elementLabels[e.id] || e.id}
                          </button>
                        `).join('')}
                      </div>
                    `;
                  }
                  return '';
                })()}
                <button class="reset-btn" onclick="window.resetContextMenuLayout()">Reset</button>
                <button class="done-btn" onclick="window.exitContextMenuCustomizeMode()">Done</button>
              </div>
            ` : ''}
            
            <!-- Quick Settings Panel -->
            <div class="quick-settings ${state.showQuickSettings ? 'active' : ''}" onclick="event.stopPropagation()">
              <div class="quick-settings-volume">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>
                  <path d="M15.54 8.46a5 5 0 0 1 0 7.07"/>
                  <path d="M19.07 4.93a10 10 0 0 1 0 14.14"/>
                </svg>
                <div class="volume-slider">
                  <div class="volume-slider-fill"></div>
                  <div class="volume-slider-thumb"></div>
                </div>
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                  <path d="M9 18l6-6-6-6"/>
                </svg>
              </div>
              
              <!-- Icon Grid - M OS Control Center -->
              <div class="quick-settings-icons">
                <div class="quick-settings-icon-btn ${state.wifiEnabled ? 'active' : ''}" onclick="window.toggleWifi()">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M5 12.55a11 11 0 0 1 14.08 0"/>
                    <path d="M1.42 9a16 16 0 0 1 21.16 0"/>
                    <path d="M8.53 16.11a6 6 0 0 1 6.95 0"/>
                    <circle cx="12" cy="20" r="1" fill="currentColor"/>
                  </svg>
                  <span>Wi-Fi</span>
                </div>
                <div class="quick-settings-icon-btn ${state.bluetoothEnabled ? 'active' : ''}" onclick="window.toggleBluetooth()">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="6.5 6.5 17.5 17.5 12 23 12 1 17.5 6.5 6.5 17.5"/>
                  </svg>
                  <span>Bluetooth</span>
                </div>
                <div class="quick-settings-icon-btn ${state.shareEnabled ? 'active' : ''}" onclick="window.toggleShare()">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="18" cy="5" r="3"/>
                    <circle cx="6" cy="12" r="3"/>
                    <circle cx="18" cy="19" r="3"/>
                    <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/>
                    <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/>
                  </svg>
                  <span>Share</span>
                </div>
                <div class="quick-settings-icon-btn ${state.isDark ? 'active' : ''}" onclick="window.toggleTheme()">
                  <span class="qs-theme-icon theme-toggle-icon">
                    ${state.isDark ? icons.Moon : icons.Sun}
                  </span>
                  <span>${state.isDark ? 'Dark' : 'Light'}</span>
                </div>
                <div class="quick-settings-icon-btn ${state.focusEnabled ? 'active' : ''}" onclick="window.toggleFocus()">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"/>
                    <path d="M13.73 21a2 2 0 0 1-3.46 0"/>
                  </svg>
                  <span>Focus</span>
                </div>
                <div class="quick-settings-icon-btn destructive" onclick="if(confirm('Shut down M OS?')) location.reload()">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M18.36 6.64a9 9 0 1 1-12.73 0"/>
                    <line x1="12" y1="2" x2="12" y2="12"/>
                  </svg>
                  <span>Power</span>
                </div>
              </div>
              
              <div class="quick-settings-option">
                <div class="quick-settings-option-label">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px; margin-right: 8px; display: inline-block;">
                    <path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83"/>
                  </svg>
                  Performance
                </div>
                <span class="quick-settings-option-value">Balanced</span>
              </div>
            </div>
            
            <!-- Notification Panel -->
            <div class="notification-panel ${state.showNotificationPanel ? 'active' : ''}" onclick="event.stopPropagation()">
              <!-- Clock & Date Section (Top) -->
              <div class="notification-clock-section">
                <div class="notification-clock-main">
                  <div class="notification-clock-time" id="notification-clock-time">${new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false })}</div>
                  <div class="notification-clock-date">${new Date().toLocaleDateString('en-US', { weekday: 'long', day: 'numeric', month: 'long' })}</div>
                </div>
              </div>
              
              <!-- Calendar Section -->
              <div class="notification-calendar-section">
                <div class="notification-calendar-header">
                  <span class="notification-calendar-month">${new Date(state.calendarYear, state.calendarMonth).toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}</span>
                  <div class="notification-calendar-nav">
                    <button onclick="window.changeCalendarMonth(-1)">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M15 18l-6-6 6-6"/>
                      </svg>
                    </button>
                    <button onclick="window.changeCalendarMonth(1)">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M9 18l6-6-6-6"/>
                      </svg>
                    </button>
                  </div>
                </div>
                
                <div class="notification-calendar-weekdays">
                  ${['Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa', 'Su'].map(d => `<span class="notification-calendar-weekday">${d}</span>`).join('')}
                </div>
                
                <div class="notification-calendar-days">
                  ${(() => {
                    const year = state.calendarYear;
                    const month = state.calendarMonth;
                    const firstDay = new Date(year, month, 1);
                    const lastDay = new Date(year, month + 1, 0);
                    const startPad = (firstDay.getDay() + 6) % 7;
                    const today = new Date();
                    const isCurrentMonth = today.getMonth() === month && today.getFullYear() === year;
                    
                    let days = '';
                    
                    // Previous month padding
                    const prevMonthLastDay = new Date(year, month, 0).getDate();
                    for (let i = startPad - 1; i >= 0; i--) {
                      days += '<span class="notification-calendar-day other-month">' + (prevMonthLastDay - i) + '</span>';
                    }
                    
                    // Current month days
                    for (let d = 1; d <= lastDay.getDate(); d++) {
                      const isToday = isCurrentMonth && d === today.getDate();
                      days += '<span class="notification-calendar-day' + (isToday ? ' today' : '') + '">' + d + '</span>';
                    }
                    
                    // Next month padding
                    const totalCells = startPad + lastDay.getDate();
                    const remaining = totalCells % 7 === 0 ? 0 : 7 - (totalCells % 7);
                    for (let i = 1; i <= remaining; i++) {
                      days += '<span class="notification-calendar-day other-month">' + i + '</span>';
                    }
                    
                    return days;
                  })()}
                </div>
              </div>
              
              <!-- Focus Timer Footer -->
              <div class="notification-footer">
                <div class="notification-footer-timer">
                  <button class="notification-footer-timer-btn" onclick="window.adjustFocusTimer(-5); event.stopPropagation();">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M5 12h14"/>
                    </svg>
                  </button>
                  <span class="notification-footer-timer-value">${state.focusTimerMinutes} min</span>
                  <button class="notification-footer-timer-btn" onclick="window.adjustFocusTimer(5); event.stopPropagation();">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M12 5v14M5 12h14"/>
                    </svg>
                  </button>
                </div>
                <button class="notification-footer-focus ${state.focusEnabled ? 'active' : ''}" onclick="window.toggleFocusMode(); event.stopPropagation();">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    ${state.focusEnabled ? '<rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/>' : '<polygon points="5 3 19 12 5 21 5 3"/>'}
                  </svg>
                  ${state.focusEnabled ? 'Stop Focus' : 'Focus'}
                </button>
              </div>
              
              <!-- Notifications Section -->
              <div class="notification-section">
                <div class="notification-header">
                  <span class="notification-header-title">Notifications</span>
                  <div class="notification-header-actions">
                    <button class="notification-header-btn" onclick="window.clearNotifications(); event.stopPropagation();" title="Clear all">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="3" width="18" height="18" rx="2"/>
                        <path d="M9 9l6 6M15 9l-6 6"/>
                      </svg>
                      Clear all
                    </button>
                  </div>
                </div>
                
                <div class="notification-list">
                  ${state.notifications.length === 0 ? `
                    <div class="notification-empty">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"/>
                        <path d="M13.73 21a2 2 0 0 1-3.46 0"/>
                      </svg>
                      <span>No notifications</span>
                    </div>
                  ` : state.notifications.map((notif, index) => {
                    const notifTime = new Date(notif.time);
                    const timeStr = notifTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                    return `
                      <div class="notification-item" style="animation-delay: ${index * 0.03}s" onclick="window.removeNotification(${notif.id}); event.stopPropagation();">
                        <div class="notification-icon">
                          ${notif.icon ? `<img src="${notif.icon}" alt="">` : `
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                              <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"/>
                              <path d="M13.73 21a2 2 0 0 1-3.46 0"/>
                            </svg>
                          `}
                        </div>
                        <div class="notification-content">
                          <div class="notification-app">
                            ${notif.app}
                            <span class="notification-time">${timeStr}</span>
                          </div>
                          <div class="notification-title">${notif.title}</div>
                          <div class="notification-body">${notif.message}</div>
                        </div>
                      </div>
                    `;
                  }).join('')}
                </div>
              </div>
            </div>
            ` : ''}

            <div class="windows-layer">
            ${generateWindowsHTML()}
            </div>

            ${!state.showLaunchpad ? `
            <div class="dock-container dock-${state.dockPosition || 'bottom'}">
              <div class="dock">
                ${(() => {
                  const finderApp = apps.find(app => app.id === 'finder');
                  const isLaunchpadActive = state.showLaunchpad;
                  const finderIconKey = finderApp.icon;
                  const finderName = finderApp.name;
                  
                  // Show finder first (macOS style)
                  if (finderApp) {
                    return `
                      <div class="dock-icon" id="dock-finder" onmousedown="window.initDockDrag(event, 'finder'); window.handleDockMouseDown(event, 'finder')" oncontextmenu="window.showContextMenu(event, 'finder')">
                        ${icons[finderIconKey]}
                        <div class="dock-tooltip">${finderName}</div>
                        ${isLaunchpadActive
                          ? `
                            <div style="position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%);">
                              <div style="width: 5px; height: 5px; border-radius: 50%; background: ${state.accentColor};"></div>
                            </div>
                          `
                          : ''}
                      </div>
                    `;
                  }
                  return '';
                })()}
                ${state.pinnedApps
                  .map((appId) => apps.find((app) => app.id === appId))
                  .filter((app) => app !== undefined && app.id !== 'finder')
                  .map((app) => {
                    const openWindows = state.windows.filter((w) => w.appId === app.id && !w.isMinimized);
                    const minimizedWindows = state.windows.filter((w) => w.appId === app.id && w.isMinimized);
                    const windowCount = openWindows.length;
                    const hasMinimized = minimizedWindows.length > 0;
                    
                    return `
                      <div class="dock-icon" id="dock-${app.id}" onmousedown="window.initDockDrag(event, '${app.id}'); window.handleDockMouseDown(event, '${app.id}')" oncontextmenu="window.showContextMenu(event, '${app.id}')">
                        ${icons[app.icon]}
                        <div class="dock-tooltip">${app.name}</div>
                        ${windowCount > 0
                          ? `
                            <div style="position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%); display: flex; gap: 3px;">
                              ${Array.from({ length: Math.min(windowCount, 3) })
                                .map(
                                  () => `
                                    <div style="width: 5px; height: 5px; border-radius: 50%; background: ${state.accentColor};"></div>
                                  `,
                                )
                                .join('')}
                            </div>
                          `
                          : hasMinimized
                          ? `
                            <div style="position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%);">
                              <div style="width: 5px; height: 5px; border-radius: 50%; background: ${state.accentColor}; opacity: 0.6;"></div>
                            </div>
                          `
                          : ''}
                      </div>
                    `;
                  })
                  .join('')}
                ${(() => {
                  // Get unpinned apps that have open or minimized windows
                  const unpinnedOpenApps = apps.filter(app => 
                    !state.pinnedApps.includes(app.id) && 
                    state.windows.some(w => w.appId === app.id)
                  );
                  
                  if (unpinnedOpenApps.length === 0) return '';
                  
                  return `
                    <div class="dock-divider"></div>
                    ${unpinnedOpenApps.map((app) => {
                      const openWindows = state.windows.filter((w) => w.appId === app.id && !w.isMinimized);
                      const minimizedWindows = state.windows.filter((w) => w.appId === app.id && w.isMinimized);
                      const windowCount = openWindows.length;
                      const hasMinimized = minimizedWindows.length > 0;
                      return `
                        <div class="dock-icon" id="dock-${app.id}" onmousedown="window.initDockDrag(event, '${app.id}'); window.handleDockMouseDown(event, '${app.id}')" oncontextmenu="window.showContextMenu(event, '${app.id}')">
                          ${icons[app.icon]}
                          <div class="dock-tooltip">${app.name}</div>
                          ${windowCount > 0
                            ? `
                              <div style="position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%); display: flex; gap: 3px;">
                                ${Array.from({ length: Math.min(windowCount, 3) })
                                  .map(
                                    () => `
                                      <div style="width: 5px; height: 5px; border-radius: 50%; background: ${state.accentColor};"></div>
                                    `,
                                  )
                                  .join('')}
                              </div>
                            `
                            : hasMinimized
                            ? `
                              <div style="position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%);">
                                <div style="width: 5px; height: 5px; border-radius: 50%; background: ${state.accentColor}; opacity: 0.6;"></div>
                              </div>
                            `
                            : ''}
                        </div>
                      `;
                    }).join('')}
                  `;
                })()}
              </div>
            </div>
            ` : ''}

            ${state.showLaunchpad ? `
              <div class="launchpad-overlay" onclick="if(event.target === event.currentTarget) window.closeLaunchpad();">
                <div class="launchpad-search-container">
                  <input 
                    type="text" 
                    id="launchpad-search" 
                    class="launchpad-search" 
                    placeholder="Search" 
                    value="${state.launchpadSearch}"
                    oninput="window.handleLaunchpadSearch(event)"
                    onclick="event.stopPropagation()"
                  />
                </div>
                <div class="launchpad-grid" onclick="if(event.target === event.currentTarget) window.closeLaunchpad();">
                  ${apps
                    .filter(app => {
                      if (app.id === 'finder') return false; // Hide app launcher from launchpad
                      if (!state.launchpadSearch) return true;
                      const searchLower = state.launchpadSearch.toLowerCase();
                      return app.name.toLowerCase().includes(searchLower);
                    })
                    .map(app => `
                      <div class="launchpad-item" onclick="window.toggleWindow('${app.id}'); window.closeLaunchpad();">
                        ${icons[app.icon]}
                        <span style="color: white; font-size: 13px; text-align: center; font-weight: 500;">${app.name}</span>
                      </div>
                    `)
                    .join('')}
                </div>
              </div>
            ` : ''}

            ${state.contextMenu
              ? `
                <div class="context-menu" style="left: ${state.contextMenu.x}px; top: ${state.contextMenu.y}px;">
                  <div class="context-menu-item" onclick="window.toggleWindow('${state.contextMenu.appId}'); state.contextMenu = null; render();">
                    Open
                  </div>
                  ${!apps.find((a) => a.id === state.contextMenu.appId)?.isPermanent
                    ? `
                      <div class="context-menu-divider"></div>
                      <div class="context-menu-item" onclick="window.togglePinApp('${state.contextMenu.appId}')">
                        ${state.pinnedApps.includes(state.contextMenu.appId) ? 'Unpin from Dock' : 'Pin to Dock'}
                      </div>
                    `
                    : ''}
                  <div class="context-menu-divider"></div>
                  <div class="context-menu-item" onclick="window.toggleWindow('taskmanager'); state.contextMenu = null; render();">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px; margin-right: 6px; vertical-align: middle;">
                      <rect x="3" y="3" width="7" height="7"/>
                      <rect x="14" y="3" width="7" height="7"/>
                      <rect x="14" y="14" width="7" height="7"/>
                      <rect x="3" y="14" width="7" height="7"/>
                    </svg>
                    Task Manager
                  </div>
                </div>
              `
              : ''}

            ${state.menubarContextMenu
              ? `
                <div class="menubar-context-menu" style="left: ${state.menubarContextMenu.x}px; top: ${state.menubarContextMenu.y}px;" onclick="event.stopPropagation()">
                  <div class="menubar-context-menu-header">Context Menu</div>
                  <div class="context-menu-item" onclick="window.enterContextMenuCustomizeMode(); state.menubarContextMenu = null; render();">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                      <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                      <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                    </svg>
                    Customize Layout
                  </div>
                  <div class="context-menu-divider"></div>
                  <div class="context-menu-item" onclick="window.toggleWindow('settings'); state.menubarContextMenu = null; render();">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                      <circle cx="12" cy="12" r="3"/>
                      <path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/>
                    </svg>
                    Settings
                  </div>
                  <div class="context-menu-divider"></div>
                  <div class="context-menu-item" onclick="window.toggleTheme(); state.menubarContextMenu = null; render();">
                    ${state.isDark 
                      ? `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>` 
                      : `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>`
                    }
                    ${state.isDark ? 'Switch to Light' : 'Switch to Dark'}
                  </div>
                  <div class="context-menu-item" onclick="window.toggleQuickSettings(); state.menubarContextMenu = null; render();">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                      <rect x="3" y="3" width="7" height="7"/>
                      <rect x="14" y="3" width="7" height="7"/>
                      <rect x="14" y="14" width="7" height="7"/>
                      <rect x="3" y="14" width="7" height="7"/>
                    </svg>
                    Control Center
                  </div>
                  <div class="context-menu-divider"></div>
                  <div class="context-menu-item" onclick="state.showLaunchpad = true; state.menubarContextMenu = null; render();">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                      <circle cx="12" cy="12" r="10"/>
                      <path d="M14.31 8l5.74 9.94M9.69 8h11.48M7.38 12l5.74-9.94M9.69 16L3.95 6.06M14.31 16H2.83M16.62 12l-5.74 9.94"/>
                    </svg>
                    Show Launchpad
                  </div>
                  <div class="context-menu-item" onclick="window.toggleWindow('taskmanager'); state.menubarContextMenu = null; render();">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                      <rect x="3" y="14" width="4" height="7"/>
                      <rect x="10" y="9" width="4" height="12"/>
                      <rect x="17" y="4" width="4" height="17"/>
                    </svg>
                    Task Manager
                  </div>
                </div>
              `
              : ''}
            
            ${state.showAddSiteDialog ? `
              <div class="add-site-dialog-overlay" onclick="if(event.target === this) window.closeAddSiteDialog()">
                <div class="add-site-dialog" onclick="event.stopPropagation()">
                  <h3>Add Shortcut</h3>
                  <div class="add-site-form">
                    <div class="add-site-input-group">
                      <label class="add-site-label" for="add-site-title">Title</label>
                      <input type="text" id="add-site-title" class="add-site-input" placeholder="My Favorite Site" />
                    </div>
                    <div class="add-site-input-group">
                      <label class="add-site-label" for="add-site-url">URL</label>
                      <input type="text" id="add-site-url" class="add-site-input" placeholder="example.com" onkeydown="if(event.key === 'Enter') window.addSavedSite()" />
                    </div>
                    <div class="add-site-buttons">
                      <button class="add-site-button add-site-button-cancel" onclick="window.closeAddSiteDialog()">Cancel</button>
                      <button class="add-site-button add-site-button-submit" onclick="window.addSavedSite()">Add</button>
                    </div>
                  </div>
                </div>
              </div>
            ` : ''}
            
            ${state.showEditBookmarkDialog ? `
              <div class="add-site-dialog-overlay" onclick="if(event.target === this) window.closeEditBookmarkDialog()">
                <div class="add-site-dialog" onclick="event.stopPropagation()">
                  <h3>${state.editingBookmarkIndex !== null ? 'Edit Bookmark' : 'Add Bookmark'}</h3>
                  <div class="add-site-form">
                    <div class="add-site-input-group">
                      <label class="add-site-label" for="edit-bookmark-url">URL</label>
                      <input type="text" id="edit-bookmark-url" class="add-site-input" placeholder="https://example.com" onkeydown="if(event.key === 'Enter') window.saveBookmark()" />
                    </div>
                    <div class="add-site-buttons">
                      <button class="add-site-button add-site-button-cancel" onclick="window.closeEditBookmarkDialog()">Cancel</button>
                      <button class="add-site-button add-site-button-submit" onclick="window.saveBookmark()">Save</button>
                    </div>
                  </div>
                </div>
              </div>
            ` : ''}
            
            ${state.showEditSiteDialog ? `
              <div class="add-site-dialog-overlay" onclick="if(event.target === this) window.closeEditSiteDialog()">
                <div class="add-site-dialog" onclick="event.stopPropagation()">
                  <h3>Edit Shortcut</h3>
                  <div class="add-site-form">
                    <div class="add-site-input-group">
                      <label class="add-site-label" for="edit-site-title">Title</label>
                      <input type="text" id="edit-site-title" class="add-site-input" placeholder="My Favorite Site" />
                    </div>
                    <div class="add-site-input-group">
                      <label class="add-site-label" for="edit-site-url">URL</label>
                      <input type="text" id="edit-site-url" class="add-site-input" placeholder="example.com" onkeydown="if(event.key === 'Enter') window.saveEditedSite()" />
                    </div>
                    <div class="add-site-buttons">
                      <button class="add-site-button add-site-button-cancel" onclick="window.closeEditSiteDialog()">Cancel</button>
                      <button class="add-site-button add-site-button-submit" onclick="window.saveEditedSite()">Save</button>
                    </div>
                  </div>
                </div>
              </div>
            ` : ''}
            
            <!-- Snap Indicator -->
            <div class="snap-indicator"></div>
          </div>
        `;
        
        // Restore focus to input fields after re-render
        if (wasInputFocused) {
          requestAnimationFrame(() => {
            let newInput = null;
            
            // For terminal inputs, use data-terminal-id to find the correct input
            if (inputTerminalId) {
              newInput = document.querySelector(`input[data-terminal-id="${inputTerminalId}"]`);
            } else if (inputWindowId) {
              // For browser inputs, use data-window-id
              newInput = document.querySelector(`input[data-window-id="${inputWindowId}"]`);
            }
            
            if (newInput && (newInput.tagName === 'INPUT' || newInput.tagName === 'TEXTAREA')) {
              // Restore value for browser inputs
              if (inputWindowId && state.inputValues[inputWindowId] !== undefined) {
                newInput.value = state.inputValues[inputWindowId];
              }
              // Restore value for terminal inputs
              if (inputTerminalId && state.inputValues[`terminal-${inputTerminalId}`] !== undefined) {
                newInput.value = state.inputValues[`terminal-${inputTerminalId}`];
              }
              newInput.focus();
              // Restore cursor position
              if (newInput.setSelectionRange && typeof cursorPosition === 'number') {
                newInput.setSelectionRange(cursorPosition, cursorPosition);
              }
            }
          });
        }
        
        // RESTORE PRESERVED TASK MANAGER CONTENT: Re-attach preserved Task Manager containers
        // Do this synchronously before iframes for immediate restoration
        preservedTaskManagerContent.forEach((data, key) => {
          const windowEl = document.getElementById(`window-${data.winId}`);
          if (windowEl) {
            const windowContent = windowEl.querySelector('.window-content');
            if (windowContent && data.element) {
              // Clear the placeholder content and append the preserved Task Manager
              windowContent.innerHTML = '';
              windowContent.appendChild(data.element);
              
              // Restore scroll position
              const processList = data.element.querySelector('[data-process-list]');
              if (processList && data.scrollTop) {
                processList.scrollTop = data.scrollTop;
              }
              
              preservedTaskManagerContent.delete(key);
            }
          }
        });
        
        // RESTORE PRESERVED IFRAMES: Re-attach all preserved iframes to prevent reload
        // Do this synchronously, not in requestAnimationFrame, for immediate restoration
        preservedIframes.forEach((data, key) => {
          const windowEl = document.getElementById(`window-${data.winId}`);
          if (windowEl) {
            // Find the appropriate container based on appId
            let container = null;
            let newIframe = null;
            
            if (data.appId === 'minecraft') {
              container = windowEl.querySelector('.minecraft-container');
              if (container && data.iframe) {
                container.appendChild(data.iframe);
                preservedIframes.delete(key);
              }
            } else if (data.appId === 'browser') {
              // Browser can have multiple tab iframes; restore by matching the original iframe id.
              let target = null;
              if (data.iframe && data.iframe.id) {
                const byId = document.getElementById(data.iframe.id);
                if (byId && windowEl.contains(byId)) target = byId;
              }

              if (!target) {
                const iframes = windowEl.querySelectorAll('iframe.browser-iframe');
                target = iframes[data.idx] || iframes[0] || null;
              }

              if (target && data.iframe) {
                target.replaceWith(data.iframe);
                preservedIframes.delete(key);
              }
            } else {
              // Generic iframe restoration - find iframe at same position
              const iframes = windowEl.querySelectorAll('iframe');
              if (iframes[data.idx]) {
                iframes[data.idx].replaceWith(data.iframe);
                preservedIframes.delete(key);
              } else if (iframes.length > 0) {
                // Fallback: replace first iframe found
                iframes[0].replaceWith(data.iframe);
                preservedIframes.delete(key);
              }
            }
          }
          // If windowEl doesn't exist (window is minimized), keep the iframe preserved
          // It will be reattached when the window is restored
        });
        
        // Restore scroll positions IMMEDIATELY - must happen synchronously to prevent visual flash
        const restoreAllScrolls = () => {
          document.querySelectorAll('.window-content').forEach(content => {
            const windowEl = content.closest('.window');
            if (windowEl) {
              const windowId = windowEl.dataset.id;
              if (windowId && state.scrollPositions[windowId] !== undefined) {
                content.scrollTop = state.scrollPositions[windowId];
              }
            }
          });
          
          // Restore terminal scroll positions
          document.querySelectorAll('.terminal-content').forEach(el => {
            const terminalId = el.dataset.terminalId;
            if (terminalId && state.scrollPositions[`terminal-${terminalId}`] !== undefined) {
              el.scrollTop = state.scrollPositions[`terminal-${terminalId}`];
            }
          });
          
          // Restore browser-specific scrollable areas
          document.querySelectorAll('.youtube-videos').forEach(el => {
            const windowEl = el.closest('.window');
            if (windowEl) {
              const windowId = windowEl.dataset.id;
              if (windowId && state.scrollPositions[`${windowId}-youtube-videos`] !== undefined) {
                el.scrollTop = state.scrollPositions[`${windowId}-youtube-videos`];
              }
            }
          });
          
          document.querySelectorAll('.youtube-sidebar').forEach(el => {
            const windowEl = el.closest('.window');
            if (windowEl) {
              const windowId = windowEl.dataset.id;
              if (windowId && state.scrollPositions[`${windowId}-youtube-sidebar`] !== undefined) {
                el.scrollTop = state.scrollPositions[`${windowId}-youtube-sidebar`];
              }
            }
          });
          
          document.querySelectorAll('.browser-home').forEach(el => {
            const windowEl = el.closest('.window');
            if (windowEl) {
              const windowId = windowEl.dataset.id;
              if (windowId && state.scrollPositions[`${windowId}-browser-home`] !== undefined) {
                el.scrollTop = state.scrollPositions[`${windowId}-browser-home`];
              }
            }
          });
          
          const launchpad = document.querySelector('.launchpad-grid');
          if (launchpad && state.scrollPositions['launchpad'] !== undefined) {
            launchpad.scrollTop = state.scrollPositions['launchpad'];
          }
          
          const settingsContent = document.querySelector('.settings-content');
          if (settingsContent && state.scrollPositions['settings-content'] !== undefined) {
            settingsContent.scrollTop = state.scrollPositions['settings-content'];
          }
          
          const settingsSidebar = document.querySelector('.settings-sidebar');
          if (settingsSidebar && state.scrollPositions['settings-sidebar'] !== undefined) {
            settingsSidebar.scrollTop = state.scrollPositions['settings-sidebar'];
          }
          
          // Restore appstore scroll positions
          document.querySelectorAll('.appstore-container').forEach(el => {
            const windowEl = el.closest('.window');
            if (windowEl) {
              const windowId = windowEl.dataset.id;
              if (windowId && state.scrollPositions[`${windowId}-appstore`] !== undefined) {
                el.scrollTop = state.scrollPositions[`${windowId}-appstore`];
              }
            }
          });
          
          // Restore task manager scroll positions
          document.querySelectorAll('[data-process-list]').forEach(el => {
            const windowEl = el.closest('.window');
            if (windowEl) {
              const windowId = windowEl.dataset.id;
              if (windowId && state.scrollPositions[`${windowId}-taskmanager`] !== undefined) {
                el.scrollTop = state.scrollPositions[`${windowId}-taskmanager`];
              }
            }
          });
          
          // Restore browser vertical tabs scroll positions
          document.querySelectorAll('.browser-sidebar .browser-tabs-container').forEach(el => {
            const windowEl = el.closest('.window');
            if (windowEl) {
              const windowId = windowEl.dataset.id;
              if (windowId && state.scrollPositions[`${windowId}-browser-vertical-tabs`] !== undefined) {
                el.scrollTop = state.scrollPositions[`${windowId}-browser-vertical-tabs`];
              }
            }
          });
        };
        
        // Call immediately to prevent visual flash
        restoreAllScrolls();
        
        // Force a synchronous reflow to ensure scroll positions are applied before paint
        void document.body.offsetHeight;
        
        // Also restore in next frame as a backup for any delayed content rendering
        requestAnimationFrame(restoreAllScrolls);
        
        // Setup scroll tracking for all scrollable areas to maintain positions during re-renders
        const setupScrollTracking = () => {
          // Track scrolling state
          const handleScroll = (e) => {
            const element = e.target;
            state.isScrolling = true;
            
            // Clear existing timeout
            if (state.scrollTimeout) {
              clearTimeout(state.scrollTimeout);
            }
            
            // Update scroll position immediately
            if (element.classList.contains('window-content')) {
              const windowEl = element.closest('.window');
              if (windowEl) {
                const windowId = windowEl.dataset.id;
                if (windowId) {
                  state.scrollPositions[windowId] = element.scrollTop;
                }
              }
            } else if (element.classList.contains('terminal-content')) {
              const terminalId = element.dataset.terminalId;
              if (terminalId) {
                state.scrollPositions[`terminal-${terminalId}`] = element.scrollTop;
              }
            } else if (element.classList.contains('youtube-videos')) {
              const windowEl = element.closest('.window');
              if (windowEl) {
                const windowId = windowEl.dataset.id;
                if (windowId) {
                  state.scrollPositions[`${windowId}-youtube-videos`] = element.scrollTop;
                }
              }
            } else if (element.classList.contains('youtube-sidebar')) {
              const windowEl = element.closest('.window');
              if (windowEl) {
                const windowId = windowEl.dataset.id;
                if (windowId) {
                  state.scrollPositions[`${windowId}-youtube-sidebar`] = element.scrollTop;
                }
              }
            } else if (element.classList.contains('browser-home')) {
              const windowEl = element.closest('.window');
              if (windowEl) {
                const windowId = windowEl.dataset.id;
                if (windowId) {
                  state.scrollPositions[`${windowId}-browser-home`] = element.scrollTop;
                }
              }
            } else if (element.classList.contains('launchpad-grid')) {
              state.scrollPositions['launchpad'] = element.scrollTop;
            } else if (element.classList.contains('settings-content')) {
              state.scrollPositions['settings-content'] = element.scrollTop;
            } else if (element.classList.contains('settings-sidebar')) {
              state.scrollPositions['settings-sidebar'] = element.scrollTop;
            } else if (element.classList.contains('appstore-container')) {
              const windowEl = element.closest('.window');
              if (windowEl) {
                const windowId = windowEl.dataset.id;
                if (windowId) {
                  state.scrollPositions[`${windowId}-appstore`] = element.scrollTop;
                }
              }
            } else if (element.classList.contains('browser-tabs-container') && element.closest('.browser-sidebar')) {
              const windowEl = element.closest('.window');
              if (windowEl) {
                const windowId = windowEl.dataset.id;
                if (windowId) {
                  state.scrollPositions[`${windowId}-browser-vertical-tabs`] = element.scrollTop;
                }
              }
            }
            
            // Set timeout to mark scrolling as finished after 150ms of no scroll events
            state.scrollTimeout = setTimeout(() => {
              state.isScrolling = false;
            }, 150);
          };
          
          // Add scroll listeners to all scrollable areas
          document.querySelectorAll('.window-content, .terminal-content, .youtube-videos, .youtube-sidebar, .browser-home, .launchpad-grid, .settings-content, .settings-sidebar, .appstore-container, .browser-sidebar .browser-tabs-container').forEach(el => {
            el.addEventListener('scroll', handleScroll, { passive: true });
          });
        };
        
        // Setup scroll tracking after a short delay to ensure all elements are rendered
        setTimeout(setupScrollTracking, 50);
        
        // Setup dock magnification effect
        setupDockMagnification();
        
        // Focus iframe in fullscreen windows so keyboard controls work
        setupFullscreenIframeFocus();
        
        // Re-setup calibration events if calibration window exists (content is now inline)
        if (calibrationWindowId !== null) {
          const calibrationWin = state.windows.find(w => w.id === calibrationWindowId);
          if (calibrationWin && !calibrationWin.isMinimized) {
            requestAnimationFrame(() => {
              const windowContent = document.querySelector(`[data-id="${calibrationWindowId}"] .window-content`);
              if (windowContent) {
                setupCalibrationEvents(windowContent);
                updateCalibrationPreview();
              }
            });
          }
        }
      }
      
      // Setup focus on iframes in fullscreen windows for keyboard controls
      function setupFullscreenIframeFocus() {
        state.windows.forEach(win => {
          if (win.isFullscreen) {
            const windowEl = document.getElementById(`window-${win.id}`);
            if (windowEl) {
              const iframe = windowEl.querySelector('iframe');
              if (iframe) {
                // Delay focus slightly to ensure iframe is ready
                setTimeout(() => {
                  try {
                    iframe.focus();
                    if (iframe.contentWindow) {
                      iframe.contentWindow.focus();
                    }
                  } catch (e) {
                    iframe.focus();
                  }
                }, 100);
              }
            }
          }
        });
      }

      // Dock magnification effect setup
      function setupDockMagnification() {
        const dock = document.querySelector('.dock');
        const dockContainer = document.querySelector('.dock-container');
        
        if (!dock || !dockContainer) return;
        
        const maxScale = 1.5; // Maximum magnification scale
        const influenceRadius = 120; // Distance in pixels that affects nearby icons
        
        // Remove any existing listener
        if (dockContainer._magnifyHandler) {
          dockContainer.removeEventListener('mousemove', dockContainer._magnifyHandler);
          dockContainer.removeEventListener('mouseleave', dockContainer._magnifyLeave);
        }
        
        const magnifyHandler = (e) => {
          // Skip magnification when dragging windows or resizing
          if (dragState || resizeState || document.body.classList.contains('window-dragging')) {
            // Reset all icons to default scale when dragging
            const icons = Array.from(dock.querySelectorAll('.dock-icon'));
            const dividers = Array.from(dock.querySelectorAll('.dock-divider'));
            
            icons.forEach(icon => {
              icon.style.setProperty('--icon-magnify', 1);
              const svg = icon.querySelector('svg');
              if (svg) {
                svg.style.transform = 'translateY(0)';
              }
            });
            
            dividers.forEach(divider => {
              divider.style.setProperty('--icon-magnify', 1);
            });
            return;
          }
          
          const icons = Array.from(dock.querySelectorAll('.dock-icon'));
          if (icons.length === 0) return;
          
          const dockPosition = state.dockPosition || 'bottom';
          
          icons.forEach(icon => {
            const rect = icon.getBoundingClientRect();
            const iconCenter = {
              x: rect.left + rect.width / 2,
              y: rect.top + rect.height / 2
            };
            
            // Calculate distance from mouse to icon center
            const distance = dockPosition === 'bottom' 
              ? Math.abs(e.clientX - iconCenter.x)
              : Math.abs(e.clientY - iconCenter.y);
            
            // Calculate scale based on distance
            let scale = 1;
            if (distance < influenceRadius) {
              const normalizedDistance = distance / influenceRadius;
              scale = maxScale - (maxScale - 1) * normalizedDistance;
            }
            
            // Apply scale via CSS variable (horizontal growth)
            icon.style.setProperty('--icon-magnify', scale);
            
            // For bottom dock: Calculate vertical translation (move icon up as it scales)
            if (dockPosition === 'bottom') {
              const baseSize = 48 * (state.dockScale || 1);
              const scaledSize = baseSize * scale;
              const verticalOffset = (scaledSize - baseSize); // Move up by full growth amount
              
              // Apply transform for vertical movement to the SVG
              const svg = icon.querySelector('svg');
              if (svg) {
                svg.style.transform = `translateY(${-verticalOffset}px)`;
              }
            }
            
            // Don't scale dividers
            const divider = icon.nextElementSibling;
            if (divider && divider.classList.contains('dock-divider')) {
              divider.style.setProperty('--icon-magnify', 1);
            }
          });
        };
        
        const leaveHandler = () => {
          const icons = Array.from(dock.querySelectorAll('.dock-icon'));
          const dividers = Array.from(dock.querySelectorAll('.dock-divider'));
          
          icons.forEach(icon => {
            icon.style.setProperty('--icon-magnify', 1);
            const svg = icon.querySelector('svg');
            if (svg) {
              svg.style.transform = 'translateY(0)';
            }
          });
          
          dividers.forEach(divider => {
            divider.style.setProperty('--icon-magnify', 1);
          });
        };
        
        // Store handlers for removal
        dockContainer._magnifyHandler = magnifyHandler;
        dockContainer._magnifyLeave = leaveHandler;
        
        dockContainer.addEventListener('mousemove', magnifyHandler);
        dockContainer.addEventListener('mouseleave', leaveHandler);
      }
        const win = state.windows.find((w) => w.id === id);
        if (win && !win.isFullscreen && win.appId !== 'terminal') {
          maximizeWindow(id);
        };

      window.handleWallpaperUpload = function handleWallpaperUpload(event) {
        // Deprecated - kept for compatibility
      };

      let tempWallpaperPair = { dark: null, light: null };
      window.tempWallpaperName = ''; // Global variable to persist wallpaper name across renders

      window.showAddWallpaperDialog = function showAddWallpaperDialog() {
        const overlay = document.createElement('div');
        overlay.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); backdrop-filter: blur(4px); display: flex; align-items: center; justify-content: center; z-index: 10000; animation: fadeIn 0.2s ease;';
        
        const dialog = document.createElement('div');
        dialog.style.cssText = 'background: hsl(var(--background)); border-radius: 12px; padding: 24px; width: 90%; max-width: 500px; box-shadow: 0 20px 40px rgba(0,0,0,0.3); animation: slideUp 0.3s ease;';
        
        dialog.innerHTML = `
          <style>
            @keyframes fadeIn {
              from { opacity: 0; }
              to { opacity: 1; }
            }
            @keyframes slideUp {
              from { transform: translateY(20px); opacity: 0; }
              to { transform: translateY(0); opacity: 1; }
            }
          </style>
          <h3 style="font-size: 18px; font-weight: 600; margin-bottom: 16px; color: hsl(var(--foreground));">Add New Wallpaper Pair</h3>
          <input type="text" id="dialog-wallpaper-name" placeholder="Wallpaper Name" value="${window.tempWallpaperName || ''}" style="width: 100%; padding: 10px; margin-bottom: 12px; background: hsl(var(--accent)); border: 1px solid hsl(var(--border)); border-radius: 8px; font-size: 14px; color: hsl(var(--foreground));" />
          
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px;">
            <div>
              <label style="display: block; font-size: 12px; font-weight: 500; margin-bottom: 6px; color: hsl(var(--muted-foreground));">Dark Mode</label>
              <input type="file" id="dialog-wallpaper-dark" accept="image/*" style="display: none;" />
              <button class="wallpaper-upload-btn" onclick="document.getElementById('dialog-wallpaper-dark').click()" style="width: 100%; padding: 10px; font-size: 13px;">
                Choose Image
              </button>
              <div id="dialog-dark-preview" style="margin-top: 6px; font-size: 11px; color: hsl(var(--muted-foreground)); text-align: center;">No file selected</div>
            </div>
            <div>
              <label style="display: block; font-size: 12px; font-weight: 500; margin-bottom: 6px; color: hsl(var(--muted-foreground));">Light Mode</label>
              <input type="file" id="dialog-wallpaper-light" accept="image/*" style="display: none;" />
              <button class="wallpaper-upload-btn" onclick="document.getElementById('dialog-wallpaper-light').click()" style="width: 100%; padding: 10px; font-size: 13px;">
                Choose Image
              </button>
              <div id="dialog-light-preview" style="margin-top: 6px; font-size: 11px; color: hsl(var(--muted-foreground)); text-align: center;">No file selected</div>
            </div>
          </div>
          
          <div style="display: flex; gap: 8px; justify-content: flex-end;">
            <button id="dialog-cancel" style="padding: 10px 20px; background: hsl(var(--secondary)); color: hsl(var(--secondary-foreground)); border: none; border-radius: 8px; font-size: 14px; font-weight: 500; cursor: pointer;">
              Cancel
            </button>
            <button id="dialog-save" style="padding: 10px 20px; background: hsl(var(--primary)); color: hsl(var(--primary-foreground)); border: none; border-radius: 8px; font-size: 14px; font-weight: 500; cursor: pointer;">
              Add Wallpaper
            </button>
          </div>
        `;
        
        overlay.appendChild(dialog);
        document.body.appendChild(overlay);
        
        // Focus input
        setTimeout(() => document.getElementById('dialog-wallpaper-name').focus(), 100);
        
        // Handle name input
        const nameInput = document.getElementById('dialog-wallpaper-name');
        nameInput.addEventListener('input', (e) => {
          window.tempWallpaperName = e.target.value;
        });
        
        // Handle file uploads
        document.getElementById('dialog-wallpaper-dark').addEventListener('change', (e) => {
          window.handleWallpaperPairUpload('dark', e, 'dialog-dark-preview');
        });
        
        document.getElementById('dialog-wallpaper-light').addEventListener('change', (e) => {
          window.handleWallpaperPairUpload('light', e, 'dialog-light-preview');
        });
        
        // Handle buttons
        document.getElementById('dialog-cancel').addEventListener('click', () => {
          document.body.removeChild(overlay);
        });
        
        document.getElementById('dialog-save').addEventListener('click', () => {
          window.saveWallpaperPair();
          document.body.removeChild(overlay);
        });
        
        // Close on overlay click
        overlay.addEventListener('click', (e) => {
          if (e.target === overlay) {
            document.body.removeChild(overlay);
          }
        });
      };

      window.handleWallpaperPairUpload = function handleWallpaperPairUpload(type, event, previewId) {
        const file = event.target.files[0];
        if (!file) return;

        if (!file.type.startsWith('image/')) {
          alert('Please upload an image file');
          return;
        }

        const reader = new FileReader();
        reader.onload = function(e) {
          tempWallpaperPair[type] = e.target.result;
          const preview = document.getElementById(previewId || `${type}-preview`);
          if (preview) {
            preview.textContent = ' ' + file.name.substring(0, 15) + (file.name.length > 15 ? '...' : '');
            preview.style.color = 'hsl(var(--primary))';
          }
        };
        reader.readAsDataURL(file);
      };

      window.saveWallpaperPair = function saveWallpaperPair() {
        const name = (window.tempWallpaperName || '').trim();
        
        if (!name) {
          alert('Please enter a wallpaper name');
          return;
        }
        
        if (!tempWallpaperPair.dark || !tempWallpaperPair.light) {
          alert('Please select both dark and light wallpapers');
          return;
        }
        
        if (state.customWallpapers.length >= 50) {
          alert('Maximum 50 wallpaper pairs reached');
          return;
        }
        
        const newWallpaper = {
          id: Date.now(),
          name: name,
          dark: tempWallpaperPair.dark,
          light: tempWallpaperPair.light
        };
        
        state.customWallpapers.push(newWallpaper);
        localStorage.setItem('customWallpapers', JSON.stringify(state.customWallpapers));
        
        // Reset temp data
        tempWallpaperPair = { dark: null, light: null };
        window.tempWallpaperName = '';
        
        // Re-render to show new wallpaper
        render();
      };

      window.deleteWallpaperPair = function deleteWallpaperPair(index) {
        if (!confirm('Delete this wallpaper pair?')) return;
        
        state.customWallpapers.splice(index, 1);
        localStorage.setItem('customWallpapers', JSON.stringify(state.customWallpapers));
        
        // If deleted wallpaper was active, reset to default
        if (state.activeCustomWallpaper === index) {
          state.activeCustomWallpaper = -1;
          localStorage.setItem('activeCustomWallpaper', '-1');
          window.resetWallpaper();
        } else if (state.activeCustomWallpaper > index) {
          // Adjust index if active wallpaper is after deleted one
          state.activeCustomWallpaper--;
          localStorage.setItem('activeCustomWallpaper', state.activeCustomWallpaper.toString());
        }
        
        render();
      };

      window.setActiveWallpaper = function setActiveWallpaper(index) {
        state.activeCustomWallpaper = index;
        localStorage.setItem('activeCustomWallpaper', index.toString());
        
        // Built-in wallpapers with external URLs
        const builtInWallpapers = {
          '-1': { // Ubuntu Quokka
            light: 'https://res.cloudinary.com/canonical/image/fetch/f_auto,q_auto,fl_sanitize,c_fill,w_1920/https%3A%2F%2Fubuntu.com%2Fwp-content%2Fuploads%2F2e6a%2FQuesting_Quokka_Wallpaper_Color_1920x1080.png',
            dark: 'https://res.cloudinary.com/canonical/image/fetch/f_auto,q_auto,fl_sanitize,c_fill,w_1920/https%3A%2F%2Fubuntu.com%2Fwp-content%2Fuploads%2F196b%2FQuesting_Quokka_Wallpaper_Dark_1920x1080.png'
          },
          '-2': { // Tahoe
            light: 'https://raw.githubusercontent.com/Matko802/my-web-os-things/refs/heads/main/26-Tahoe-Light-1080x1920.png',
            dark: 'https://raw.githubusercontent.com/Matko802/my-web-os-things/refs/heads/main/26-Tahoe-Dark-1080x1920.png'
          },
          '-3': { // macOS Sonoma
            light: 'https://512pixels.net/downloads/macos-wallpapers-thumbs/14-0-Sonoma-L.jpg',
            dark: 'https://512pixels.net/downloads/macos-wallpapers-thumbs/14-0-Sonoma-D.jpg'
          }
        };
        
        if (index < 0 && builtInWallpapers[index]) {
          // Use built-in wallpaper
          const wallpaper = builtInWallpapers[index];
          const wallpaperURL = state.isDark ? wallpaper.dark : wallpaper.light;
          window.setWallpaperFromURL(wallpaperURL);
        } else if (index >= 0) {
          // Use custom wallpaper
          const customWallpaper = state.customWallpapers[index];
          if (customWallpaper) {
            const wallpaperURL = state.isDark ? customWallpaper.dark : customWallpaper.light;
            window.setWallpaperFromURL(wallpaperURL);
          }
        }
        
        render();
      };

      window.resetWallpaper = function resetWallpaper() {
        state.customWallpaper = null;
        localStorage.removeItem('customWallpaper');
        
        // Set wallpaper based on current theme (default to Ubuntu Quokka)
        const wallpaperURL = state.isDark 
          ? 'https://res.cloudinary.com/canonical/image/fetch/f_auto,q_auto,fl_sanitize,c_fill,w_1920/https%3A%2F%2Fubuntu.com%2Fwp-content%2Fuploads%2F196b%2FQuesting_Quokka_Wallpaper_Dark_1920x1080.png'
          : 'https://res.cloudinary.com/canonical/image/fetch/f_auto,q_auto,fl_sanitize,c_fill,w_1920/https%3A%2F%2Fubuntu.com%2Fwp-content%2Fuploads%2F2e6a%2FQuesting_Quokka_Wallpaper_Color_1920x1080.png';
        
        window.setWallpaperFromURL(wallpaperURL);
        
        // Remove preview and actions in settings
        const preview = document.querySelector('.wallpaper-preview');
        const actions = document.querySelector('.wallpaper-actions');
        if (preview) preview.remove();
        if (actions) actions.remove();
      };

      window.setWallpaperFromURL = function setWallpaperFromURL(url, animate = true) {
        const oldWallpaper = state.customWallpaper;
        state.customWallpaper = url;
        localStorage.setItem('customWallpaper', url);
        
        // Update desktop background with crossfade animation
        const desktopBg = document.querySelector('.desktop-bg');
        let desktopBgNext = document.querySelector('.desktop-bg-next');
        
        if (desktopBg) {
          if (animate && oldWallpaper && oldWallpaper !== url) {
            // Create or get the next background layer for crossfade
            if (!desktopBgNext) {
              desktopBgNext = document.createElement('div');
              desktopBgNext.className = 'desktop-bg-next';
              desktopBg.parentNode.insertBefore(desktopBgNext, desktopBg.nextSibling);
            }
            
            // Preload the new image
            const img = new Image();
            img.onload = () => {
              // Set new wallpaper on the next layer
              desktopBgNext.style.backgroundImage = `url('${url}')`;
              
              // Trigger crossfade
              requestAnimationFrame(() => {
                desktopBgNext.classList.add('visible');
                
                // After transition, update main bg and reset next layer
                setTimeout(() => {
                  desktopBg.style.backgroundImage = `url('${url}')`;
                  desktopBg.style.backgroundSize = 'cover';
                  desktopBg.style.backgroundPosition = 'center';
                  desktopBgNext.classList.remove('visible');
                  desktopBgNext.style.backgroundImage = '';
                }, 600); // Match transition duration
              });
            };
            img.src = url;
          } else {
            // No animation, just set directly
            desktopBg.style.backgroundImage = `url('${url}')`;
            desktopBg.style.backgroundSize = 'cover';
            desktopBg.style.backgroundPosition = 'center';
          }
        }
        
        // Update active state on wallpaper options
        document.querySelectorAll('.wallpaper-option').forEach(option => {
          if (option.style.backgroundImage.includes(url)) {
            option.classList.add('active');
          } else {
            option.classList.remove('active');
          }
        });
      };

      window.handleCursorUpload = function handleCursorUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        // Check if it's a ZIP file (cursor pack)
        if (file.type === 'application/zip' || file.name.endsWith('.zip')) {
          alert('Cursor pack support coming soon! For now, please upload individual cursor images.');
          return;
        }

        if (!file.type.startsWith('image/')) {
          alert('Please upload an image file or cursor pack (ZIP)');
          return;
        }

        const reader = new FileReader();
        reader.onload = function(e) {
          state.customCursor = e.target.result;
          state.cursorPack = null;
          localStorage.setItem('customCursor', e.target.result);
          localStorage.removeItem('cursorPack');
          document.body.style.cursor = `url('${e.target.result}') 0 0, auto`;
          
          // Update settings preview if in settings window - don't call render()
          const preview = document.querySelector('.wallpaper-preview');
          if (preview && preview.parentElement && preview.parentElement.previousElementSibling) {
            const label = preview.parentElement.previousElementSibling.querySelector('.settings-label');
            if (label && label.textContent === 'Custom Cursor') {
              if (!document.querySelector('.wallpaper-actions')) {
                const actions = document.createElement('div');
                actions.className = 'wallpaper-actions';
                actions.innerHTML = '<button class="wallpaper-reset-btn" onclick="event.stopPropagation(); window.resetCursor()">Reset to Default</button>';
                preview.parentElement.appendChild(actions);
              }
            }
          }
        };
        reader.readAsDataURL(file);
      };

      window.resetCursor = function resetCursor() {
        state.customCursor = null;
        state.cursorPack = null;
        localStorage.removeItem('customCursor');
        localStorage.removeItem('cursorPack');
        document.body.style.cursor = 'auto';
        
        // Just remove preview elements without full re-render
        const previews = document.querySelectorAll('.wallpaper-preview');
        previews.forEach(preview => {
          if (preview.parentElement && preview.parentElement.previousElementSibling) {
            const label = preview.parentElement.previousElementSibling.querySelector('.settings-label');
            if (label && label.textContent === 'Custom Cursor') {
              preview.remove();
              const actions = preview.parentElement.querySelector('.wallpaper-actions');
              if (actions) actions.remove();
            }
          }
        });
      };

      window.handleDockPosition = function handleDockPosition(position) {
        state.dockPosition = position;
        localStorage.setItem('dockPosition', position);
        // Delay render to allow select to lose focus first
        setTimeout(() => {
          document.activeElement.blur();
          setTimeout(() => render(), 50);
        }, 100);
      };

      window.handleDockScale = function handleDockScale(scale) {
        state.dockScale = parseFloat(scale);
        localStorage.setItem('dockScale', scale);
        render();
      };

      window.handleMirroredControls = function handleMirroredControls(enabled) {
        state.mirroredControls = enabled;
        localStorage.setItem('mirroredControls', enabled ? 'true' : 'false');
        render();
      };

      window.toggleMirroredControls = function toggleMirroredControls() {
        state.mirroredControls = !state.mirroredControls;
        localStorage.setItem('mirroredControls', state.mirroredControls ? 'true' : 'false');
        
        // Update only the toggle switch without full render
        const toggles = document.querySelectorAll('.toggle-switch');
        toggles.forEach(toggle => {
          const label = toggle.parentElement.querySelector('.settings-label');
          if (label && label.textContent === 'Mirror Window Controls') {
            if (state.mirroredControls) {
              toggle.classList.add('active');
            } else {
              toggle.classList.remove('active');
            }
          }
        });
        
        // Animate titlebar buttons with warp effect
        const titlebars = document.querySelectorAll('.titlebar');
        titlebars.forEach(titlebar => {
          const buttons = titlebar.querySelector('.titlebar-buttons');
          const fullscreenBtn = titlebar.querySelector('.titlebar-fullscreen-btn');
          
          if (buttons) {
            // Remove any existing animation classes
            buttons.classList.remove('animating-to-right', 'animating-to-left');
            // Force reflow to restart animation
            void buttons.offsetWidth;
            
            if (state.mirroredControls) {
              titlebar.classList.add('mirrored-controls');
              buttons.classList.add('animating-to-right');
            } else {
              titlebar.classList.remove('mirrored-controls');
              buttons.classList.add('animating-to-left');
            }
            
            // Remove animation class after animation completes
            setTimeout(() => {
              buttons.classList.remove('animating-to-right', 'animating-to-left');
            }, 400);
          }
          
          if (fullscreenBtn) {
            fullscreenBtn.classList.remove('animating-to-right', 'animating-to-left');
            void fullscreenBtn.offsetWidth;
            
            if (state.mirroredControls) {
              fullscreenBtn.classList.add('animating-to-left');
            } else {
              fullscreenBtn.classList.add('animating-to-right');
            }
            
            setTimeout(() => {
              fullscreenBtn.classList.remove('animating-to-right', 'animating-to-left');
            }, 400);
          }
        });
        
        playSound('click');
        render();
      };

      window.toggleAnimations = function toggleAnimations() {
        state.animationsEnabled = !state.animationsEnabled;
        localStorage.setItem('animationsEnabled', state.animationsEnabled.toString());
        
        // Apply or remove no-animations class
        if (state.animationsEnabled) {
          document.body.classList.remove('no-animations');
        } else {
          document.body.classList.add('no-animations');
        }
        
        // Update only the toggle switch without full render
        const toggles = document.querySelectorAll('.toggle-switch');
        toggles.forEach((toggle, index) => {
          const label = toggle.parentElement.querySelector('.settings-label');
          if (label && label.textContent === 'Animations') {
            if (state.animationsEnabled) {
              toggle.classList.add('active');
            } else {
              toggle.classList.remove('active');
            }
          }
        });
        
        playSound('click');
      };

      window.toggleSound = function toggleSound() {
        state.soundEnabled = !state.soundEnabled;
        localStorage.setItem('soundEnabled', state.soundEnabled.toString());
        
        // Update only the toggle switch without full render
        const toggles = document.querySelectorAll('.toggle-switch');
        toggles.forEach((toggle, index) => {
          const label = toggle.parentElement.querySelector('.settings-label');
          if (label && label.textContent === 'Sound Effects') {
            if (state.soundEnabled) {
              toggle.classList.add('active');
            } else {
              toggle.classList.remove('active');
            }
          }
        });
        
        // Play a test sound if enabling
        if (state.soundEnabled) {
          playSound('click');
        }
      };

      // Sound Effects System - Lineage OS Sounds with localStorage caching
      const SOUND_CONFIG = {
        baseUrl: 'https://raw.githubusercontent.com/EvilScout/Lineage-OS-Sounds/main/system/media/audio',
        storageKey: 'lineageSoundsInstalled',
        enabledKey: 'soundEnabled',
        files: [
          // UI Sounds
          'ui/Effect_Tick.ogg',
          'ui/Dock.ogg',
          'ui/Undock.ogg',
          'ui/Lock.ogg',
          'ui/Unlock.ogg',
          'ui/KeypressStandard.ogg',
          'ui/KeypressReturn.ogg',
          'ui/KeypressDelete.ogg',
          'ui/KeypressSpacebar.ogg',
          'ui/KeypressInvalid.ogg',
          'ui/LowBattery.ogg',
          'ui/Trusted.ogg',
          'ui/camera_click.ogg',
          'ui/camera_focus.ogg',
          'ui/VideoRecord.ogg',
          'ui/VideoStop.ogg',
          'ui/WirelessChargingStarted.ogg',
          // Notification sounds
          'notifications/Adara.ogg',
          'notifications/Altair.ogg',
          'notifications/Antares.ogg',
          'notifications/CyanMessage.ogg',
          'notifications/Doink.ogg'
        ],
        // Map sound types to actual sound files
        soundMap: {
          'click': 'ui/Effect_Tick.ogg',
          'open': 'ui/Dock.ogg',
          'close': 'ui/Undock.ogg',
          'minimize': 'ui/Undock.ogg',
          'focus': 'ui/Effect_Tick.ogg',
          'lock': 'ui/Lock.ogg',
          'unlock': 'ui/Unlock.ogg',
          'notification': 'notifications/Adara.ogg',
          'terminal-key': 'ui/KeypressStandard.ogg',
          'terminal-enter': 'ui/KeypressReturn.ogg',
          'terminal-error': 'ui/KeypressInvalid.ogg',
          'trash': 'ui/Undock.ogg',
          'camera': 'ui/camera_click.ogg',
          'message': 'notifications/CyanMessage.ogg',
          'alert': 'notifications/Antares.ogg'
        }
      };
      
      // Audio context for Web Audio API (fallback)
      let audioContext = null;
      
      // Cache for audio elements
      const audioCache = new Map();
      
      // Initialize audio context on first user interaction
      function getAudioContext() {
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        return audioContext;
      }
      
      // Check if sounds are installed in localStorage
      function areSoundsInstalled() {
        return localStorage.getItem(SOUND_CONFIG.storageKey) === 'true';
      }
      
      // Get sound from localStorage or return null
      function getSound(filename) {
        return localStorage.getItem(`sound_${filename}`);
      }
      
      // Download and store a single sound file
      async function downloadAndStoreSound(filename) {
        try {
          const url = `${SOUND_CONFIG.baseUrl}/${filename}`;
          console.log(`[Sound] Downloading: ${filename}`);
          
          const response = await fetch(url);
          if (!response.ok) {
            console.warn(`[Sound] Failed to fetch ${filename}: ${response.status}`);
            return false;
          }
          
          const arrayBuffer = await response.arrayBuffer();
          const base64 = arrayBufferToBase64(arrayBuffer);
          const dataUrl = `data:audio/ogg;base64,${base64}`;
          
          localStorage.setItem(`sound_${filename}`, dataUrl);
          console.log(` Cached sound: ${filename}`);
          return true;
        } catch (error) {
          console.warn(`[Sound] Failed to download: ${filename}`, error);
          return false;
        }
      }
      
      // Convert ArrayBuffer to Base64
      function arrayBufferToBase64(buffer) {
        let binary = '';
        const bytes = new Uint8Array(buffer);
        const len = bytes.byteLength;
        for (let i = 0; i < len; i++) {
          binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
      }
      
      // Install all sounds from GitHub
      async function installSoundsFromGitHub() {
        console.log('[Sound] Installing Lineage OS sounds from GitHub...');
        
        const results = await Promise.all(
          SOUND_CONFIG.files.map(file => downloadAndStoreSound(file))
        );
        
        const successCount = results.filter(r => r).length;
        console.log(`[Sound] Installed ${successCount}/${SOUND_CONFIG.files.length} sounds`);
        
        if (successCount > 0) {
          localStorage.setItem(SOUND_CONFIG.storageKey, 'true');
          return true;
        }
        return false;
      }
      
      // Play sound by type
      function playSound(type) {
        if (!state.soundEnabled) return;
        
        const filename = SOUND_CONFIG.soundMap[type];
        if (!filename) {
          // Fallback to synthesized sound
          playSynthSound(type);
          return;
        }
        
        const soundData = getSound(filename);
        if (soundData) {
          // Play from cached data
          playAudioFromDataUrl(soundData, type);
        } else {
          // Fallback to synthesized sound if not cached
          playSynthSound(type);
        }
      }
      
      // Play audio from data URL
      function playAudioFromDataUrl(dataUrl, type) {
        try {
          // Use cached audio element or create new one
          let audio = audioCache.get(type);
          if (!audio) {
            audio = new Audio();
            audioCache.set(type, audio);
          }
          
          audio.src = dataUrl;
          audio.volume = 0.5; // Adjust volume
          audio.currentTime = 0;
          
          const playPromise = audio.play();
          if (playPromise !== undefined) {
            playPromise.catch(e => {
              console.warn('[Sound] Playback failed, user interaction required:', e.message);
            });
          }
        } catch (error) {
          console.warn('[Sound] Error playing audio:', error);
          playSynthSound(type);
        }
      }
      
      // Fallback synthesized sounds using Web Audio API
      function playSynthSound(type) {
        try {
          const ctx = getAudioContext();
          const now = ctx.currentTime;
          const oscillator = ctx.createOscillator();
          const gainNode = ctx.createGain();
          
          oscillator.connect(gainNode);
          gainNode.connect(ctx.destination);
          
          switch(type) {
            case 'open':
              oscillator.frequency.setValueAtTime(300, now);
              oscillator.frequency.exponentialRampToValueAtTime(800, now + 0.1);
              gainNode.gain.setValueAtTime(0.15, now);
              gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
              oscillator.start(now);
              oscillator.stop(now + 0.15);
              break;
              
            case 'close':
              oscillator.frequency.setValueAtTime(800, now);
              oscillator.frequency.exponentialRampToValueAtTime(300, now + 0.1);
              gainNode.gain.setValueAtTime(0.15, now);
              gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
              oscillator.start(now);
              oscillator.stop(now + 0.15);
              break;
              
            case 'minimize':
              oscillator.frequency.setValueAtTime(600, now);
              oscillator.frequency.exponentialRampToValueAtTime(200, now + 0.08);
              gainNode.gain.setValueAtTime(0.12, now);
              gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
              oscillator.start(now);
              oscillator.stop(now + 0.1);
              break;
              
            case 'click':
            case 'focus':
              oscillator.type = 'sine';
              oscillator.frequency.setValueAtTime(800, now);
              oscillator.frequency.exponentialRampToValueAtTime(400, now + 0.03);
              gainNode.gain.setValueAtTime(0.1, now);
              gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
              oscillator.start(now);
              oscillator.stop(now + 0.05);
              break;
              
            case 'terminal-key':
              oscillator.type = 'sine';
              oscillator.frequency.setValueAtTime(600, now);
              gainNode.gain.setValueAtTime(0.06, now);
              gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.03);
              oscillator.start(now);
              oscillator.stop(now + 0.03);
              break;
              
            case 'terminal-enter':
              oscillator.frequency.setValueAtTime(700, now);
              oscillator.frequency.setValueAtTime(900, now + 0.06);
              gainNode.gain.setValueAtTime(0.08, now);
              gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
              oscillator.start(now);
              oscillator.stop(now + 0.12);
              break;
              
            case 'terminal-error':
              oscillator.type = 'square';
              oscillator.frequency.setValueAtTime(300, now);
              oscillator.frequency.setValueAtTime(250, now + 0.08);
              gainNode.gain.setValueAtTime(0.1, now);
              gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
              oscillator.start(now);
              oscillator.stop(now + 0.15);
              break;
              
            case 'trash':
              oscillator.type = 'sawtooth';
              oscillator.frequency.setValueAtTime(200, now);
              oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.15);
              gainNode.gain.setValueAtTime(0.12, now);
              gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
              oscillator.start(now);
              oscillator.stop(now + 0.2);
              break;
              
            default:
              oscillator.frequency.setValueAtTime(500, now);
              gainNode.gain.setValueAtTime(0.08, now);
              gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
              oscillator.start(now);
              oscillator.stop(now + 0.08);
          }
        } catch (e) {
          // Silent fail - audio not supported or blocked
        }
      }
      
      // UI Helper functions for sound management
      window.installSoundsUI = async function installSoundsUI() {
        const btn = event.target;
        const originalText = btn.innerHTML;
        btn.innerHTML = ' Downloading...';
        btn.style.opacity = '0.7';
        btn.style.pointerEvents = 'none';
        
        try {
          const success = await installSoundsFromGitHub();
          if (success) {
            btn.innerHTML = ' Installed!';
            playSound('notification');
            setTimeout(() => render(), 500);
          } else {
            btn.innerHTML = ' Failed';
            setTimeout(() => {
              btn.innerHTML = originalText;
              btn.style.opacity = '1';
              btn.style.pointerEvents = 'auto';
            }, 2000);
          }
        } catch (e) {
          console.error('[Sound] Install failed:', e);
          btn.innerHTML = ' Error';
          setTimeout(() => {
            btn.innerHTML = originalText;
            btn.style.opacity = '1';
            btn.style.pointerEvents = 'auto';
          }, 2000);
        }
      };
      
      window.reinstallSoundsUI = async function reinstallSoundsUI() {
        if (!confirm('Reinstall sound pack from GitHub? This will re-download all sound files.')) return;
        
        // Clear existing sounds
        SOUND_CONFIG.files.forEach(file => {
          localStorage.removeItem(`sound_${file}`);
        });
        localStorage.removeItem(SOUND_CONFIG.storageKey);
        audioCache.clear();
        
        // Reinstall
        await installSoundsFromGitHub();
        render();
      };
      
      window.clearSoundsUI = function clearSoundsUI() {
        if (!confirm('Remove all cached sounds? You can reinstall them later.')) return;
        
        // Clear all sound data
        SOUND_CONFIG.files.forEach(file => {
          localStorage.removeItem(`sound_${file}`);
        });
        localStorage.removeItem(SOUND_CONFIG.storageKey);
        audioCache.clear();
        
        render();
      };
      
      window.testSound = function testSound() {
        playSound('notification');
      };
      
      // Initialize sound system on load
      async function initSoundSystem() {
        console.log('[Sound] Initializing sound system...');
        console.log('[Sound] Sounds installed:', areSoundsInstalled());
        console.log('[Sound] Sounds enabled:', state.soundEnabled);
        
        // If sounds not installed, try to install automatically
        if (!areSoundsInstalled() && !window.location.protocol.startsWith('file:')) {
          console.log('[Sound] Sounds not installed, auto-downloading...');
          try {
            await installSoundsFromGitHub();
          } catch (e) {
            console.warn('[Sound] Auto-install failed:', e);
          }
        }
      }
      
      // Initialize sounds after a short delay
      setTimeout(initSoundSystem, 1000);

      window.clearAllData = function clearAllData() {
        if (confirm('Are you sure you want to clear all data? This cannot be undone.')) {
          localStorage.clear();
          location.reload();
        }
      };

      // App Store Functions - Download minecraft.html to the fake PC (localStorage)
      window.installMinecraft = async function installMinecraft() {
        // Show downloading state
        const downloadBtn = document.querySelector('[onclick*="installMinecraft"]');
        if (downloadBtn) {
          downloadBtn.innerHTML = 'Downloading...';
          downloadBtn.style.opacity = '0.7';
          downloadBtn.style.pointerEvents = 'none';
        }
        
        try {
          const downloadUrl = 'https://raw.githubusercontent.com/Matko802/my-web-os-things/refs/heads/main/minecraft.html';
          const response = await fetch(downloadUrl);

          if (!response.ok) {
            throw new Error('Failed to download: ' + response.statusText);
          }

          const htmlContent = await response.text();
          
          // Store the HTML content in the fake PC's filesystem (localStorage)
          localStorage.setItem('fakePCFile_minecraft.html', htmlContent);
          localStorage.setItem('installedApps', JSON.stringify([...new Set([...state.installedApps, 'minecraft'])]));
          
          // Update state
          state.installedApps.push('minecraft');
          state.minecraftSource = 'localStorage';
          
          // Create blob URL for the iframe
          const blob = new Blob([htmlContent], { type: 'text/html' });
          state.minecraftBlobUrl = URL.createObjectURL(blob);
          
          // Update apps list
          apps = getApps();
          
          playSound('open');
          console.log('Minecraft installed to fake PC filesystem!');
          render();
          
        } catch (error) {
          console.error('Download failed:', error);
          alert('Download failed. Please try again.');
          if (downloadBtn) {
            downloadBtn.innerHTML = 'Download';
            downloadBtn.style.opacity = '1';
            downloadBtn.style.pointerEvents = 'auto';
          }
        }
      };
      
      // Uninstall Minecraft from the fake PC
      window.uninstallMinecraft = function uninstallMinecraft() {
        if (!confirm('Are you sure you want to uninstall Minecraft?')) return;
        
        // Close any open Minecraft windows first
        const minecraftWindows = state.windows.filter(w => w.appId === 'minecraft');
        minecraftWindows.forEach(win => closeWindow(win.id));
        
        // Remove from localStorage
        localStorage.removeItem('fakePCFile_minecraft.html');
        
        // Update installed apps list
        state.installedApps = state.installedApps.filter(id => id !== 'minecraft');
        localStorage.setItem('installedApps', JSON.stringify(state.installedApps));
        
        // Clean up blob URL
        if (state.minecraftBlobUrl) {
          URL.revokeObjectURL(state.minecraftBlobUrl);
          state.minecraftBlobUrl = null;
        }
        
        state.minecraftSource = null;
        
        // Remove from pinned apps if pinned
        if (state.pinnedApps.includes('minecraft')) {
          state.pinnedApps = state.pinnedApps.filter(id => id !== 'minecraft');
          localStorage.setItem('pinnedApps', JSON.stringify(state.pinnedApps));
        }
        
        // Update apps list
        apps = getApps();
        
        playSound('close');
        console.log('Minecraft uninstalled from fake PC!');
        render();
      };
      
      // Check for installed apps from localStorage on startup
      window.checkInstalledApps = function checkInstalledApps() {
        // Load installed apps from localStorage
        const savedInstalledApps = localStorage.getItem('installedApps');
        if (savedInstalledApps) {
          try {
            state.installedApps = JSON.parse(savedInstalledApps);
          } catch (e) {
            state.installedApps = [];
          }
        }
        
        // Check if minecraft.html exists in fake PC filesystem
        const minecraftFile = localStorage.getItem('fakePCFile_minecraft.html');
        if (minecraftFile) {
          if (!state.installedApps.includes('minecraft')) {
            state.installedApps.push('minecraft');
            localStorage.setItem('installedApps', JSON.stringify(state.installedApps));
          }
          state.minecraftSource = 'localStorage';
          
          // Create blob URL for the iframe
          const blob = new Blob([minecraftFile], { type: 'text/html' });
          state.minecraftBlobUrl = URL.createObjectURL(blob);
          
          console.log('Minecraft loaded from fake PC filesystem!');
        } else {
          // Make sure it's not in installed apps if file doesn't exist
          if (state.installedApps.includes('minecraft')) {
            state.installedApps = state.installedApps.filter(id => id !== 'minecraft');
            localStorage.setItem('installedApps', JSON.stringify(state.installedApps));
          }
        }
        
        // Update apps list
        apps = getApps();
      };
      
      // Initialize app check
      checkInstalledApps();

      // Cache wallpaper images for offline use
      async function cacheWallpapers() {
        const wallpaperURLs = [
          'https://res.cloudinary.com/canonical/image/fetch/f_auto,q_auto,fl_sanitize,c_fill,w_1920/https%3A%2F%2Fubuntu.com%2Fwp-content%2Fuploads%2F196b%2FQuesting_Quokka_Wallpaper_Dark_1920x1080.png',
          'https://res.cloudinary.com/canonical/image/fetch/f_auto,q_auto,fl_sanitize,c_fill,w_1920/https%3A%2F%2Fubuntu.com%2Fwp-content%2Fuploads%2F2e6a%2FQuesting_Quokka_Wallpaper_Color_1920x1080.png'
        ];

        try {
          const cache = await caches.open('ubuntu-wallpapers-v1');
          
          // Check if images are already cached
          const cachedRequests = await cache.keys();
          const cachedURLs = cachedRequests.map(req => req.url);
          
          // Cache any missing wallpapers
          for (const url of wallpaperURLs) {
            if (!cachedURLs.some(cachedUrl => cachedUrl.includes(url))) {
              try {
                const response = await fetch(url, { mode: 'cors' });
                if (response.ok) {
                  await cache.put(url, response);
                  console.log('Cached wallpaper:', url.substring(0, 80) + '...');
                }
              } catch (error) {
                console.warn('Failed to cache wallpaper:', error);
              }
            }
          }
        } catch (error) {
          console.warn('Cache API not available:', error);
        }
      }

      // Enhanced setWallpaperFromURL to use cache
      const originalSetWallpaperFromURL = window.setWallpaperFromURL;
      window.setWallpaperFromURL = async function setWallpaperFromURL(url) {
        try {
          // Try to get from cache first
          const cache = await caches.open('ubuntu-wallpapers-v1');
          const cachedResponse = await cache.match(url);
          
          if (cachedResponse) {
            const blob = await cachedResponse.blob();
            const objectURL = URL.createObjectURL(blob);
            state.customWallpaper = objectURL;
            localStorage.setItem('customWallpaper', url); // Store original URL
            localStorage.setItem('customWallpaperBlob', objectURL); // Store blob URL
            
            // Update desktop background
            const desktopBg = document.querySelector('.desktop-bg');
            if (desktopBg) {
              desktopBg.style.backgroundImage = `url('${objectURL}')`;
              desktopBg.style.backgroundSize = 'cover';
              desktopBg.style.backgroundPosition = 'center';
            }
          } else {
            // Fallback to original function if not cached
            originalSetWallpaperFromURL(url);
          }
        } catch (error) {
          // Fallback to original function on error
          originalSetWallpaperFromURL(url);
        }
        
        // Update active state on wallpaper options
        document.querySelectorAll('.wallpaper-option').forEach(option => {
          if (option.style.backgroundImage.includes(url)) {
            option.classList.add('active');
          } else {
            option.classList.remove('active');
          }
        });
      };

      // Pre-load wallpapers on page load
      cacheWallpapers();

      // ==========================================
      // CUSTOM CURSOR SYSTEM - Download from GitHub and store in localStorage
      // Cursors are 87.5% bigger (scale: 1.875 = 1.5 * 1.25)
      // With embedded fallback cursors for offline/local file support
      // ==========================================
      const CURSOR_CONFIG = {
        baseUrl: 'https://raw.githubusercontent.com/Matko802/my-web-os-things/main/Cursors/',
        previewBaseUrl: 'https://raw.githubusercontent.com/Matko802/my-web-os-things/main/Cursors%20gif%20png/',
        // Files from GitHub repo - includes both .cur and .ani files
        files: [
          '01-normal-select.cur',
          '02-help-select.ani',
          '03-working-in-background.ani',
          '04-busy.ani',
          '05-precision-select.cur',
          '06-text-select.cur',
          '07-handwriting.cur',
          '08-unavailable.ani',
          '09-vertical-resize.cur',
          '10-horizontal-resize.cur',
          '11-diagonal-resize-1.cur',
          '12-diagonal-resize-2.cur',
          '13-move.cur',
          '14-alternate-select.cur',
          '15-link-select.cur',
        ],
        // Preview files (GIF for animated, PNG for static) from GitHub for display in settings/calibration
        previewFiles: {
          '01-normal-select': '01-normal-select.png',
          '02-help-select': '02-help-select.gif',
          '03-working-in-background': '03-working-in-background.gif',
          '04-busy': '04-busy.gif',
          '05-precision-select': '05-precision-select.png',
          '06-text-select': '06-text-select.png',
          '07-handwriting': '07-handwriting.png',
          '08-unavailable': '08-unavailable.gif',
          '09-vertical-resize': '09-vertical-resize.png',
          '10-horizontal-resize': '10-horizontal-resize.png',
          '11-diagonal-resize-1': '11-diagonal-resize-1.png',
          '12-diagonal-resize-2': '12-diagonal-resize-2.png',
          '13-move': '13-move.png',
          '14-alternate-select': '14-alternate-select.png',
          '15-link-select': '15-link-select.png',
        },
        storageKey: 'customCursorsInstalled',
        enabledKey: 'customCursorsEnabled',
        styleId: 'custom-cursor-styles',
        cursorScale: 1.875 // 87.5% bigger cursors (1.5 * 1.25 = 25% bigger than before)
      };
      
      // Helper to get preview URL for a cursor file (uses GIF/PNG from GitHub)
      function getCursorPreviewUrl(cursorFile) {
        const baseName = cursorFile.replace(/\.(cur|ani)$/, '');
        const previewFile = CURSOR_CONFIG.previewFiles[baseName];
        if (previewFile) {
          return CURSOR_CONFIG.previewBaseUrl + previewFile;
        }
        return '';
      }
      
      // Embedded fallback cursors as base64 PNG (generated from simple shapes)
      // These are used when GitHub download fails (e.g., running as local file)
      const FALLBACK_CURSORS = {
        // Simple arrow cursor (white with black outline)
        '01-normal-select.cur': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAGbSURBVFiF7ZYxTsQwEEW/sxsqCo5AQcEBOAIHoKGg4gRcgYIDsAe4BRUlB6FANCwFRbQI8S1iJ7HjxN4lhXhSNPbM+P95nARY2NbsqwJgA+AAWAPvwCPwBHwCn8AXcL8NAKD7AjbAG/ACvAIvwBfwDmjXC2oCeBCBAC+AB+AeuAOu5xYA8C78twBHQAdcA3fALXA1q4BxiKMQiPAKuBwB55bQ1ASMQyiECK+Ac0voagLWIUZCiPASWLWErr4EjEMohAjPgZUT4dQEjEMohAhPgaUT4dQE7IboCYEQL4BFKDtNQNdvJvAdAvE8WDgRTk3AbogxCRE+BxZhKHSeQL4QCvEEWISy+kIskHl9YQ0wS0iE+ySYhbKyQC6QdRtC3IZnwSwUVRNwE6Ibgt+Ge8HMFVQTOI5QC8G/hvvALBRUEziO0A0hyg/BAJi5gmoCpxH0IdgLeAxmOq+awGmEbgjxApwCM51XTeA0Qk8I+Sk4Bmauv5rAbghNCLkJ+BBmMqea4OgI/xNCvgT7wazm1Sb4T8AfKDLQCjAdG3cAAAAASUVORK5CYII=',
        // Hand/pointer cursor
        '15-link-select.cur': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAHKSURBVFiF7ZZNTsQwDIW/NB0qFq2EC7BgxQFYsGLFCbgCC1ZwAK7AghUH4A5wC1asOAgLxKxggZoZFqiTJmn+ZpjRSK80Ss/x87Nd2xTsqjFXBcAKYA04AN6BO+AOuAcegEfgEXgAngvNAFsC1oBb4Bq4Am6AG+C6KADweAwB/oF/CXERXuGXRQkA3IoQvABXwFV4BVwXBQCeKDwmBC/ARXgFXBYFAJ4kfB0S4ht4AS7CK+C80ADgyeI3h0SEb+AFOAvnhQaA3xQ/nBJCXIAXYBbKDg0A3iT+ZkoIcQqch7JD0wH3EnKYEOIUOAtldQdcKEQtRCMEPwtloaw2wFNCHCSE2AAnYSg7NADcKkQ1BO/DSShTG+BdQtRD8LdQpm7A/YSohuCj4CCUqRvw2xBtIfinYC+UqQ54lJBqCDkK9kKZuoFwQihC8FGwF8rUBjwphByC7IW9UKZuILQQkhC8F/ZCmdqA0EJIQsgV2Atlcw0IjSAJwV7YC2V1B0IgSELIHtgLZXUHQiI0QvBe2AtldQdCIjRC8G54FMrqDoREaIRgV+xXKPsJfxDiIAQKZXUHQiI0QpBzPxTKHiM0IQoh+J8C+xXKFvYH+wHLBHFbHGKdUAAAAABJRU5ErkJggg==',
        // Text I-beam cursor
        '06-text-select.cur': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAACxSURBVFiF7dYxCoAwDAXQnxyhs3fw/kfwBCJu4uTgIogiWNoMif2QIYTyIT9tBfhvEqIq4KugKuArYTTgK6ExYCTgK2E0YBTgK2EsYBzgK2EcYDRgHGAsYD3gK2EcYBRgLGAsYBxgLGAsYDRgHGAcYCxgLGAcYDxgFGAsYCxgHGBMIQ8wplCFGFOoQowplCHGFIYQYwpdiDGFNsSYQhViTKEOMaagQIwp9CHGFLroA3wBZsQhvPsVXvUAAAAASUVORK5CYII=',
        // Crosshair cursor
        '05-precision-select.cur': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAACMSURBVFiF7daxCYAwEAXQnzgYuIFrOIcbuJU7OIG7OYcb2IsWgvE0iYL/wUEgXB5JTgD+m4SoCvgqqAr4ShgN+EpoDRgJ+EoYDRgF+EoYCxgH+EoYBxgNGAcYCxgLGAcYDxgFGAsYCxgHGFPIA4wp1CHGFO4QYwq3iDGFMsSYQhdijPIJcTbEl3kB30R8A9/a3CYAAAAASUVORK5CYII=',
        // Move cursor (4-way arrow)
        '13-move.cur': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAADpSURBVFiF7ZZBCsIwEEW/jQsuPIEn8P5X8ARu3HkCT+ANPIELd+JCXBS0LoyZJJMGodIPgzCd+U3yZ5IA/0xCVAN8FVQFfCWMBnwltAaMBHwljAaMAnwljAWMA3wljAOMAowFjAWMA4wDjAKMBYwFjAOMA4wCjAWMBYwDjCnkAcYU6hBjCneIMYVbxJhCGWJMoQsxptCGGFOoQowp1CHGFL4g8hT8JMRBCBTqDjgmhEKIV0AfYkyhDjGm0IUYUyhDtEMohNgCz8BxKFt0wB4hFEI8A0/D66sDtkMohNgCD8NDU3fAPiEk4J0/4APZzVEq8Z0VsQAAAABJRU5ErkJggg==',
        // Vertical resize cursor
        '09-vertical-resize.cur': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAACwSURBVFiF7daxCYAwEAXQnzgYuIFrOIcbuJU7OIG7OYcb2IsWgvE0iYL/wUEgXB5JTgD+m4SoCvgqqAr4ShgN+EpoDRgJ+EoYDRgF+EoYCxgH+EoYBxgNGAcYCxgLGAcYDxgFGAsYCxgHGFPIA4wp1CHGFO4QYwq3iDGFMsSYQhdijPIJcTbEl3kB30R8AdlT8Cy4G14WyuoO2A+hEOIZ2A9l6g44IIRCCD8Fz0KZ+oAvwBddqBsIANVs9QAAAABJRU5ErkJggg==',
        // Horizontal resize cursor
        '10-horizontal-resize.cur': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAACzSURBVFiF7daxCYAwEAXQnzgYuIFrOIcbuJU7OIG7OYcb2IsWgvE0iYL/wUEgXB5JTgD+m4SoCvgqqAr4ShgN+EpoDRgJ+EoYDRgF+EoYCxgH+EoYBxgNGAcYCxgLGAcYDxgFGAsYCxgHGFPIA4wp1CHGFO4QYwq3iDGFMsSYQhdiTOEBIYbArwjxFGwFM3UDHhFCEIJ/C66GsnoDHhVCEoKXYDuUqRvwqBCSELwR7IeyJ/sHyQl9XDoVAtIAAAAASUVORK5CYII=',
        // NW-SE diagonal resize
        '11-diagonal-resize-1.cur': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAC+SURBVFiF7daxCYAwEAXQnzgYuIFrOIcbuJU7OIG7OYcb2IsWgvE0iYL/wUEgXB5JTgD+m4SoCvgqqAr4ShgN+EpoDRgJ+EoYDRgF+EoYCxgH+EoYBxgNGAcYCxgLGAcYDxgFGAsYCxgHGFPIA4wp1CHGFO4QYwq3iDGFMsSYQhdijPIJIU7ACTgMZeoG3CWEQognYD+UqQ24TwhJCN6C3VCmNuBeISQhZAvshTJ1A+4VQhKCt2AvlD3ZPx3aYEQ0W0ygAAAAAElFTkSuQmCC',
        // NE-SW diagonal resize
        '12-diagonal-resize-2.cur': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAC7SURBVFiF7daxCYAwEAXQnzgYuIFrOIcbuJU7OIG7OYcb2IsWgvE0iYL/wUEgXB5JTgD+m4SoCvgqqAr4ShgN+EpoDRgJ+EoYDRgF+EoYCxgH+EoYBxgNGAcYCxgLGAcYDxgFGAsYCxgHGFPIA4wp1CHGFO4QYwq3iDGFMsSYQhdiTOEOIU7ACdgPZeoG3CWEJ4RvYD+UqQ24TwhJCPkW7IcydQPuFUISQvaC/VD2ZP8g+Q5ErzgpA9h7yAAAAABJRU5ErkJggg==',
        // Help cursor (arrow with ?)
        '02-help-select.ani': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAHISURBVFiF7ZZNTsQwDIW/NB0qFq2EC7BgxQFYsGLFCbgCC1ZwAK7AghUH4A5wC1asOAgLxKxggZoZFqiTJmn+ZpjRSK80Ss/x87Nd2xTsqjFXBcAKYA04AN6BO+AOuAcegEfgEXgAngvNAFsC1oBb4Bq4Am6AG+C6KADwmIQgfwi+A1fhFXBdFAB4kvhNSRD8LZQpG/DcIWoh+FsoU3fAvYSoh+B/wkkoUzfgQUIoQvArcBLK1A14lBCKEHwKnIQydQMeJYQiBBuhTN2ARwmhCCG3YC+UqRvwKCEUIXgrtkOZugEPEkIRgu+FvVCmbsCjhFCE4HthL5SpG/AgIRQh+F7YC2VqA0IiKELwVtgLZXUHQiIoQrAX9kKZugEPEkIRgr2wF8rUDXiUEIoQchXshbL/8AdBDkKQS+E/hPIv+K8JPAaBQtkP+LMI+xAohPIH+L8I+xAoBP8A/y/CPgQKwSeh7L/8L4I+BH8LfhPKfoL/izAe8L2wF8rUBtyH6InAf8L/wUwfgLuEqIVgLzgBZjqvmsC9hOiG4F44Dma6gGoCdwuhEIJrYDOYhYJqArcJoRCCXLEXzGRONQH7Ifgh+M9A9Y/8B94AWoRBKAPiAc0AAAAASUVORK5CYII=',
        // Progress/working cursor
        '03-working-in-background.ani': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAGLSURBVFiF7ZY9TsQwEIW/NA4FRaLgABQUHICGgoITcAUKDsAeYC9AQUnBAVhQEBqKaBGiIISfImQnsZ3EnmW3YCSpisfj9+IZewLsatdXBbAFsAbsAG/AA/AA3AP3wAPwCDwCj8Aj8FxqBtgWsAbcAtfAFXAD3ADXZQGAp1oI/ivEPXAVXgHXZQGAJ1r8xxDiLryiLGAdYkeIcQjeCXGfCOEuUBEwDsE7IS7DVYq6gHGIERD8TohJSN2AsRCjIPRdiGlIXcA4xIgQ8kwIeUg5gXGIUSH4mRCTkHICtxGSQohJCLkJ5wXMQtq6gNsQfRD8TrgVzFRe3YDbEL0Q/E7YC2Yqr2rAbYg+CL4X9oKZyqsacBuiFEKeC3vBTOXVDawJoQjB98JeMFN5dQPbhFCE4HthL5ipvKoBexBKIfheuBfMVF7VgG2EUgh+L2wFM5X7if8g6InA58J/wawnMEoIRQh+Au4Es1DuZ+6F0Ach/wV/C2Yu95P+IYRGCP4z8DuY5by/jf8AiNMGxVAfFdYAAAAASUVORK5CYII=',
        // Busy/wait cursor
        '04-busy.ani': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAFSSURBVFiF7ZaxSgQxEIa/5G53D7G4wgN4BQUt7OwtrLSysvMJfAULC9/AV7CwsrK1sbC4wgN4hZyHuE6yyWaTLHcHCgMDYTL5J5kkE+C/SYhugK+CroCvhNGAr4TegJGAr4TRgFGAr4SxgHGAr4RxgNGAcYCxgLGAcYBxgFGAsYCxgHGAMYU8wJhCHWJM4Q4xpnCLGFMoQ4wpdCHGFNoQYwp1iDGFOsSYwhciTsFPhTgOgUJdBxwSQiHES2AUytQNeEgIhRAvgFEoUxtwmBCKEP5dMAxl6gY8JIRC+HfBKJSpG/CQEL0Q/C4YhjJ1Ax4SoheC3wXDUKZuwENC9ELwu2AYytQNBEFohODvguNQpm7AQ0L0QvB3wTiUqQ14SIheCH4XjEOZugEPCaEQgu+FcShTNxAEoRGC/RQMQ9lP+EMgByHIXfifUPYToQ2h/ySsA3ADAC8AAAAASUVORK5CYII=',
        // Unavailable cursor (circle with line)
        '08-unavailable.ani': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAE2SURBVFiF7Za9TsQwDMe/NLlnQGJgYmJiYGJiYmRiYGRiYGBiYGJkYmRiYmJkYmdnZ+C9Y+CdE+d7uYOBn5QqTuz4F9t1Avw3CVENsFNQFbCTMBqwk9Ab0BOwk9AbMBKwk9AbMBKwkzASMBKwkzASMBqwk9AbMBKwkzAaMBKwk9AbMBKwkzAaMBKwk9AbMBIwEjCSMBKwkzAasJPQ9/AnhJiE4HfBQShTG7AT0heC74X9UKZuwE5I3wu+F/ZDmdqAOxE9L/iZ8BDK1AaEhKiF4OfCQyhTNxASohaC74X9UKY2ICREL4S/DfuhTN1ASIheCH4bHoQydQMhIXoh+G14EMrUDYSEqIXgt+FBKFMbEBKiFoKfhgehzE/4g0AOQpC74D+h7CdCG0L/SVgHYAYAnkUTxPXpbEQAAAAASUVORK5CYII=',
        // Handwriting cursor
        '07-handwriting.cur': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAADWSURBVFiF7ZaxCYAwEEV/4mBgAwdwDOdwAbdyByewdg4HsLcWLSxEC0FCThMF/4MDgRDu8S4JB/w3CVEN8FVQFfCVMBrwldAaMBLwlTAaMArwlTAWMA7wlTAOMAowFjAWMA4wDjAKMBYwFjAOMKaQBxhTqEOMKdwhxhRuEWMKZYgxhS7EmEIbYkyhDjGmUIcYU/hC+FMQ4nchxEsw03XA3xBKIeQh2A9l6gY8JoRCCH4I9kKZugEPhVAIIR+CvVCmNuChEAoh+NuwF8p8wh+EIAfBf4WyNxk5N0AexTz4AAAAAElFTkSuQmCC',
        // Alternate cursor
        '14-alternate-select.cur': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3/OAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAACqSURBVFiF7daxCYAwEAXQnzgYuIFrOIcbuJU7OIG7OYcb2IsWgvE0iYL/wUEgXB5JTgD+m4SoCvgqqAr4ShgN+EpoDRgJ+EoYDRgF+EoYCxgH+EoYBxgNGAcYCxgLGAcYDxgFGAsYCxgHGFPIA4wp1CHGFO4QYwq3iDGFMsSYQhdiTKENMaZQhxhTqEPcbg7xDOyEMp9wQIhTCBTKfMIRIaahLPiAfwFvALVsPEQdfLIAAAAASUVORK5CYII='
      };
      
      // Custom cursor follower element for scaling
      let cursorFollower = null;
      let currentCursorImage = null;
      let currentCursorType = 'normal';
      
      // ANI cursor animation state
      let aniCursors = {}; // Store parsed ANI frames
      let aniAnimationFrame = null;
      let currentAniType = null;

      // Default hotspots (base 32px coordinates) - from your config
      const DEFAULT_HOTSPOTS = {
        normal: { x: 0.5, y: 0.5 },
        pointer: { x: 6.5, y: 2.5 },
        help: { x: 0.5, y: 0.5 },
        text: { x: 7.5, y: 7.5 },
        handwriting: { x: 16, y: 16 },
        crosshair: { x: 7.5, y: 7.5 },
        move: { x: 7.5, y: 7.5 },
        unavailable: { x: 4, y: 4 },
        nsResize: { x: 7.5, y: 7.5 },
        ewResize: { x: 8.5, y: 8.5 },
        nwseResize: { x: 7.5, y: 7.5 },
        neswResize: { x: 7.5, y: 7.5 },
        alternate: { x: 7.5, y: 3.5 },
        progress: { x: 0.5, y: 0.5 },
        busy: { x: 7.5, y: 7.5 },
      };

      // Map cursor types to filenames for preview
      const CURSOR_TYPE_TO_FILE = {
        normal: '01-normal-select.cur',
        pointer: '15-link-select.cur',
        help: '02-help-select.ani',
        text: '06-text-select.cur',
        handwriting: '07-handwriting.cur',
        crosshair: '05-precision-select.cur',
        move: '13-move.cur',
        unavailable: '08-unavailable.ani',
        nsResize: '09-vertical-resize.cur',
        ewResize: '10-horizontal-resize.cur',
        nwseResize: '11-diagonal-resize-1.cur',
        neswResize: '12-diagonal-resize-2.cur',
        alternate: '14-alternate-select.cur',
        progress: '03-working-in-background.ani',
        busy: '04-busy.ani',
      };
      
      // Install fallback cursors to localStorage (used when GitHub download fails)
      function installFallbackCursors() {
        console.log('[Cursor] Installing fallback embedded cursors...');
        let count = 0;
        for (const [filename, dataUrl] of Object.entries(FALLBACK_CURSORS)) {
          if (!localStorage.getItem(`cursor_${filename}`)) {
            localStorage.setItem(`cursor_${filename}`, dataUrl);
            count++;
          }
        }
        if (count > 0) {
          localStorage.setItem(CURSOR_CONFIG.storageKey, 'true');
          localStorage.setItem(CURSOR_CONFIG.enabledKey, 'true');
          console.log(`[Cursor] Installed ${count} fallback cursors`);
        }
        return count > 0;
      }
      
      // ==========================================
      // ANI (Animated Cursor) Parser
      // Parses Windows .ani files and extracts frames
      // Now with proper ICO/CUR binary parsing for offline support
      // ==========================================
      class ANIParser {
        static async parse(arrayBuffer) {
          const view = new DataView(arrayBuffer);
          let offset = 0;
          
          // Read RIFF header
          const riff = this.readString(view, offset, 4);
          if (riff !== 'RIFF') throw new Error('Not a valid RIFF file');
          offset += 4;
          
          const fileSize = view.getUint32(offset, true);
          offset += 4;
          
          const acon = this.readString(view, offset, 4);
          if (acon !== 'ACON') throw new Error('Not a valid ANI file');
          offset += 4;
          
          const frames = [];
          let frameRate = 60; // Default jiffies (1/60th second)
          let sequence = null;
          let rates = null;
          
          // Parse chunks
          while (offset < arrayBuffer.byteLength - 8) {
            const chunkId = this.readString(view, offset, 4);
            offset += 4;
            const chunkSize = view.getUint32(offset, true);
            offset += 4;
            
            if (chunkId === 'anih') {
              // Animation header
              const headerSize = view.getUint32(offset, true);
              const numFrames = view.getUint32(offset + 4, true);
              const numSteps = view.getUint32(offset + 8, true);
              frameRate = view.getUint32(offset + 16, true);
              offset += chunkSize;
            } else if (chunkId === 'rate') {
              // Frame rates
              rates = [];
              for (let i = 0; i < chunkSize / 4; i++) {
                rates.push(view.getUint32(offset + i * 4, true));
              }
              offset += chunkSize;
            } else if (chunkId === 'seq ') {
              // Sequence
              sequence = [];
              for (let i = 0; i < chunkSize / 4; i++) {
                sequence.push(view.getUint32(offset + i * 4, true));
              }
              offset += chunkSize;
            } else if (chunkId === 'LIST') {
              const listType = this.readString(view, offset, 4);
              offset += 4;
              
              if (listType === 'fram') {
                // Frame data
                let frameOffset = offset;
                const listEnd = offset + chunkSize - 4;
                
                while (frameOffset < listEnd) {
                  const iconId = this.readString(view, frameOffset, 4);
                  frameOffset += 4;
                  const iconSize = view.getUint32(frameOffset, true);
                  frameOffset += 4;
                  
                  if (iconId === 'icon') {
                    const iconData = new Uint8Array(arrayBuffer, frameOffset, iconSize);
                    frames.push(iconData);
                  }
                  frameOffset += iconSize;
                  // Align to word boundary
                  if (iconSize % 2 !== 0) frameOffset++;
                }
                offset = listEnd;
              } else {
                offset += chunkSize - 4;
              }
            } else {
              offset += chunkSize;
            }
            
            // Align to word boundary
            if (chunkSize % 2 !== 0) offset++;
          }
          
          // Convert frames to data URLs using proper ICO parsing
          const frameUrls = await Promise.all(frames.map(async (frameData) => {
            return await this.curDataToDataURL(frameData);
          }));
          
          return {
            frames: frameUrls.filter(f => f), // Filter out failed frames
            frameRate: frameRate,
            rates: rates,
            sequence: sequence
          };
        }
        
        static readString(view, offset, length) {
          let str = '';
          for (let i = 0; i < length; i++) {
            str += String.fromCharCode(view.getUint8(offset + i));
          }
          return str;
        }
        
        // Parse ICO/CUR format properly and render to canvas
        static async curDataToDataURL(curData) {
          try {
            const view = new DataView(curData.buffer, curData.byteOffset, curData.byteLength);
            
            // ICO/CUR header
            const reserved = view.getUint16(0, true);
            const type = view.getUint16(2, true); // 1 = ICO, 2 = CUR
            const count = view.getUint16(4, true);
            
            if (count === 0) return null;
            
            // Read first image directory entry (offset 6)
            const width = view.getUint8(6) || 256;
            const height = view.getUint8(7) || 256;
            const colorCount = view.getUint8(8);
            const planes = view.getUint16(10, true);
            const bitCount = view.getUint16(12, true);
            const imageSize = view.getUint32(14, true);
            const imageOffset = view.getUint32(18, true);
            
            // Check if it's a PNG embedded in ICO
            if (imageOffset + 8 <= curData.byteLength) {
              const pngSig = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];
              let isPng = true;
              for (let i = 0; i < 8; i++) {
                if (curData[imageOffset + i] !== pngSig[i]) {
                  isPng = false;
                  break;
                }
              }
              
              if (isPng) {
                // Extract PNG data and return as data URL
                const pngData = curData.slice(imageOffset, imageOffset + imageSize);
                const blob = new Blob([pngData], { type: 'image/png' });
                return await this.blobToDataURL(blob);
              }
            }
            
            // Parse BMP data (DIB format inside ICO)
            return await this.parseBMPFromICO(curData, imageOffset, width, height, bitCount);
            
          } catch (e) {
            console.warn('Failed to parse CUR frame:', e);
            // Fallback: return as raw data URL
            const blob = new Blob([curData], { type: 'image/x-icon' });
            return await this.blobToDataURL(blob);
          }
        }
        
        static async blobToDataURL(blob) {
          return new Promise((resolve) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.onerror = () => resolve(null);
            reader.readAsDataURL(blob);
          });
        }
        
        // Parse BMP/DIB data from ICO format
        static async parseBMPFromICO(data, offset, width, height, bitCount) {
          try {
            const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
            
            // DIB header starts at offset
            const headerSize = view.getUint32(offset, true);
            const dibWidth = view.getInt32(offset + 4, true);
            let dibHeight = view.getInt32(offset + 8, true);
            const dibPlanes = view.getUint16(offset + 12, true);
            const dibBitCount = view.getUint16(offset + 14, true) || bitCount || 32;
            const compression = view.getUint32(offset + 18, true);
            
            // Height in ICO is doubled (includes mask)
            const actualHeight = Math.abs(dibHeight) / 2 || height;
            const actualWidth = dibWidth || width;
            
            // Create canvas
            const canvas = document.createElement('canvas');
            canvas.width = actualWidth;
            canvas.height = actualHeight;
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(actualWidth, actualHeight);
            
            // Calculate row size (padded to 4 bytes)
            const rowSize = Math.ceil((actualWidth * dibBitCount) / 32) * 4;
            const pixelDataOffset = offset + headerSize;
            
            // Color table for indexed images
            let colorTable = [];
            if (dibBitCount <= 8) {
              const numColors = 1 << dibBitCount;
              for (let i = 0; i < numColors; i++) {
                const colorOffset = offset + headerSize + (i * 4);
                if (colorOffset + 4 <= data.byteLength) {
                  colorTable.push({
                    b: data[colorOffset],
                    g: data[colorOffset + 1],
                    r: data[colorOffset + 2],
                    a: 255
                  });
                }
              }
            }
            
            const colorTableSize = colorTable.length * 4;
            const bitmapOffset = pixelDataOffset + colorTableSize;
            
            // Parse pixels (BMP is bottom-up)
            for (let y = 0; y < actualHeight; y++) {
              const srcY = actualHeight - 1 - y; // Flip vertically
              const rowOffset = bitmapOffset + (srcY * rowSize);
              
              for (let x = 0; x < actualWidth; x++) {
                const dstIdx = (y * actualWidth + x) * 4;
                
                if (dibBitCount === 32) {
                  const pixelOffset = rowOffset + (x * 4);
                  if (pixelOffset + 4 <= data.byteLength) {
                    imageData.data[dstIdx] = data[pixelOffset + 2];     // R
                    imageData.data[dstIdx + 1] = data[pixelOffset + 1]; // G
                    imageData.data[dstIdx + 2] = data[pixelOffset];     // B
                    imageData.data[dstIdx + 3] = data[pixelOffset + 3]; // A
                  }
                } else if (dibBitCount === 24) {
                  const pixelOffset = rowOffset + (x * 3);
                  if (pixelOffset + 3 <= data.byteLength) {
                    imageData.data[dstIdx] = data[pixelOffset + 2];     // R
                    imageData.data[dstIdx + 1] = data[pixelOffset + 1]; // G
                    imageData.data[dstIdx + 2] = data[pixelOffset];     // B
                    imageData.data[dstIdx + 3] = 255;                    // A
                  }
                } else if (dibBitCount === 8 && colorTable.length > 0) {
                  const pixelOffset = rowOffset + x;
                  if (pixelOffset < data.byteLength) {
                    const colorIdx = data[pixelOffset];
                    const color = colorTable[colorIdx] || { r: 0, g: 0, b: 0, a: 255 };
                    imageData.data[dstIdx] = color.r;
                    imageData.data[dstIdx + 1] = color.g;
                    imageData.data[dstIdx + 2] = color.b;
                    imageData.data[dstIdx + 3] = color.a;
                  }
                } else if (dibBitCount === 4 && colorTable.length > 0) {
                  const pixelOffset = rowOffset + Math.floor(x / 2);
                  if (pixelOffset < data.byteLength) {
                    const byte = data[pixelOffset];
                    const colorIdx = (x % 2 === 0) ? (byte >> 4) : (byte & 0x0F);
                    const color = colorTable[colorIdx] || { r: 0, g: 0, b: 0, a: 255 };
                    imageData.data[dstIdx] = color.r;
                    imageData.data[dstIdx + 1] = color.g;
                    imageData.data[dstIdx + 2] = color.b;
                    imageData.data[dstIdx + 3] = color.a;
                  }
                } else if (dibBitCount === 1 && colorTable.length >= 2) {
                  const pixelOffset = rowOffset + Math.floor(x / 8);
                  if (pixelOffset < data.byteLength) {
                    const byte = data[pixelOffset];
                    const bit = 7 - (x % 8);
                    const colorIdx = (byte >> bit) & 1;
                    const color = colorTable[colorIdx];
                    imageData.data[dstIdx] = color.r;
                    imageData.data[dstIdx + 1] = color.g;
                    imageData.data[dstIdx + 2] = color.b;
                    imageData.data[dstIdx + 3] = color.a;
                  }
                }
              }
            }
            
            // Apply AND mask for transparency (if not 32-bit with alpha)
            if (dibBitCount < 32) {
              const maskRowSize = Math.ceil(actualWidth / 32) * 4;
              const maskOffset = bitmapOffset + (rowSize * actualHeight);
              
              for (let y = 0; y < actualHeight; y++) {
                const srcY = actualHeight - 1 - y;
                const rowOffset = maskOffset + (srcY * maskRowSize);
                
                for (let x = 0; x < actualWidth; x++) {
                  const byteOffset = rowOffset + Math.floor(x / 8);
                  if (byteOffset < data.byteLength) {
                    const bit = 7 - (x % 8);
                    const mask = (data[byteOffset] >> bit) & 1;
                    if (mask === 1) {
                      const dstIdx = (y * actualWidth + x) * 4;
                      imageData.data[dstIdx + 3] = 0; // Transparent
                    }
                  }
                }
              }
            }
            
            ctx.putImageData(imageData, 0, 0);
            return canvas.toDataURL('image/png');
            
          } catch (e) {
            console.warn('BMP parsing failed:', e);
            return null;
          }
        }
      }
      
      // Parse standalone CUR file (same ICO format)
      async function parseCURFile(arrayBuffer) {
        const data = new Uint8Array(arrayBuffer);
        return await ANIParser.curDataToDataURL(data);
      }
      
      // Start ANI animation for a cursor type
      function startAniAnimation(type, aniData) {
        stopAniAnimation();
        currentAniType = type;
        
        if (!aniData || !aniData.frames || aniData.frames.length === 0) return;
        
        let frameIndex = 0;
        const sequence = aniData.sequence || aniData.frames.map((_, i) => i);
        const rates = aniData.rates || aniData.frames.map(() => aniData.frameRate);
        
        function animate() {
          const seqIndex = frameIndex % sequence.length;
          const actualFrameIndex = sequence[seqIndex];
          const frameUrl = aniData.frames[actualFrameIndex];
          
          if (frameUrl && cursorFollower) {
            cursorFollower.style.backgroundImage = `url('${frameUrl}')`;
          }
          
          // ANI jiffies: 1 jiffy = 1/60th of a second = ~16.67ms
          // Typical animated cursor runs at about 5-10 jiffies per frame = ~83-167ms
          // If rate seems too low (fast animation), use a minimum of ~80ms
          const jiffyRate = rates[seqIndex] || aniData.frameRate || 6;
          const delay = Math.max(jiffyRate * (1000 / 60), 80); // Minimum 80ms per frame
          frameIndex++;
          
          aniAnimationFrame = setTimeout(animate, delay);
        }
        
        animate();
      }
      
      function stopAniAnimation() {
        if (aniAnimationFrame) {
          clearTimeout(aniAnimationFrame);
          aniAnimationFrame = null;
        }
        currentAniType = null;
      }

      // Live hotspots (can be modified by calibration)
      let liveHotspots = JSON.parse(JSON.stringify(DEFAULT_HOTSPOTS));

      function getCursorHotspot(type) {
        const hs = liveHotspots[type] || liveHotspots.normal;
        return {
          x: Math.round(hs.x * CURSOR_CONFIG.cursorScale),
          y: Math.round(hs.y * CURSOR_CONFIG.cursorScale),
        };
      }

      // ========== DEV CURSOR CALIBRATION (Ctrl+Shift+C) ==========
      let calibrationPanel = null;
      let calibrationWindowId = null;
      let selectedCalType = null; // No cursor selected by default in calibration
      let calibrationModeActive = false; // When true, forces the selected cursor everywhere
      let calibrationZoom = 2.5; // Default zoom level for preview
      let calibrationScrollPos = 0; // Preserve scroll position

      // Force update cursor to selected calibration type
      function forceCalibrationCursor() {
        if (!calibrationModeActive || !areCursorsEnabled() || !selectedCalType) return;
        
        const cursorFile = CURSOR_TYPE_TO_FILE[selectedCalType];
        if (!cursorFile) return;
        
        const cursorDataUrl = localStorage.getItem(`cursor_${cursorFile}`) || getCursor(cursorFile);
        const isAnimated = cursorFile && cursorFile.endsWith('.ani');
        
        setCursorFollowerType(selectedCalType);
        
        // Handle ANI cursors with animation
        if (isAnimated && aniCursors[selectedCalType]) {
          if (currentAniType !== selectedCalType) {
            startAniAnimation(selectedCalType, aniCursors[selectedCalType]);
          }
        } else {
          stopAniAnimation();
          updateCursorFollowerImage(cursorDataUrl);
        }
      }

      // Open/close calibration panel and manage forced cursor mode
      function setCalibrationMode(active) {
        calibrationModeActive = active;
        if (active) {
          forceCalibrationCursor();
        } else {
          // Revert to normal cursor behavior - trigger a fake mouseover to reset
          stopAniAnimation();
          const normal = getCursor('01-normal-select.cur');
          setCursorFollowerType('normal');
          updateCursorFollowerImage(normal);
        }
      }

      function updateCalibrationPreview() {
        const previewCursor = document.getElementById('cal-preview-cursor');
        const previewInfo = document.getElementById('cal-preview-info');
        const zoomLabel = document.getElementById('cal-zoom-label');
        if (!previewCursor || !previewInfo) return;

        // Handle null selectedCalType - show placeholder
        if (!selectedCalType) {
          previewCursor.style.cssText = `display: none;`;
          previewInfo.textContent = 'Select a cursor type to preview';
          if (zoomLabel) zoomLabel.textContent = `${calibrationZoom.toFixed(1)}x`;
          return;
        }

        const cursorFile = CURSOR_TYPE_TO_FILE[selectedCalType];
        const cursorDataUrl = localStorage.getItem(`cursor_${cursorFile}`) || '';
        const hs = liveHotspots[selectedCalType];
        if (!hs) return;
        
        // Use calibrationZoom for preview
        const scaledSize = Math.round(32 * CURSOR_CONFIG.cursorScale * calibrationZoom);
        const scaledX = Math.round(hs.x * CURSOR_CONFIG.cursorScale * calibrationZoom);
        const scaledY = Math.round(hs.y * CURSOR_CONFIG.cursorScale * calibrationZoom);

        // Use localStorage data URL for all cursors (more reliable), fallback to GitHub preview
        const isAnimated = cursorFile && cursorFile.endsWith('.ani');
        const storedCursor = localStorage.getItem(`cursor_${cursorFile}`) || getCursor(cursorFile);
        // Always fall back to getCursorPreviewUrl for GitHub preview if no local data
        const previewUrl = storedCursor || getCursorPreviewUrl(cursorFile);
        
        previewCursor.style.cssText = `
          position: absolute;
          display: block;
          width: ${scaledSize}px;
          height: ${scaledSize}px;
          background-image: url('${previewUrl}');
          background-size: ${scaledSize}px ${scaledSize}px;
          background-repeat: no-repeat;
          left: calc(50% - ${scaledX}px);
          top: calc(50% - ${scaledY}px);
          image-rendering: pixelated;
          image-rendering: crisp-edges;
          transition: all 0.15s ease;
        `;
        previewInfo.textContent = `${selectedCalType}: X=${hs.x.toFixed(1)}, Y=${hs.y.toFixed(1)} (scaled: ${(hs.x * CURSOR_CONFIG.cursorScale).toFixed(1)}, ${(hs.y * CURSOR_CONFIG.cursorScale).toFixed(1)})`;
        if (zoomLabel) zoomLabel.textContent = `${calibrationZoom.toFixed(1)}x`;
      }

      function createCalibrationPanel() {
        // If window exists, just toggle visibility
        if (calibrationWindowId !== null) {
          const existingWindow = state.windows.find(w => w.id === calibrationWindowId);
          if (existingWindow) {
            if (existingWindow.isMinimized) {
              existingWindow.isMinimized = false;
              render();
            }
            bringToFront(calibrationWindowId);
            setCalibrationMode(true);
            setTimeout(updateCalibrationPreview, 50);
            return;
          }
        }
        
        // Opening panel for first time - enable calibration mode
        setCalibrationMode(true);

        // Create as OS window
        const win = {
          id: state.nextId++,
          appId: 'cursor-calibration',
          title: ' Cursor Calibration',
          x: Math.max(50, (window.innerWidth - 680) / 2),
          y: Math.max(50, (window.innerHeight - 600) / 2),
          width: 680,
          height: 580,
          zIndex: state.nextZIndex++,
          isMinimized: false,
          isMaximized: false,
          isFullscreen: false,
          isOpening: true,
        };
        
        calibrationWindowId = win.id;
        state.windows.push(win);
        state.activeWindowId = win.id;
        render();
        
        // Setup calibration event listeners after render (content is now inline via getWindowContent)
        requestAnimationFrame(() => {
          const windowContent = document.querySelector(`[data-id="${win.id}"] .window-content`);
          if (!windowContent) return;
          
          // Setup event listeners
          setupCalibrationEvents(windowContent);
          
          // Initial preview
          updateCalibrationPreview();
        });
      }
      
      function getCalibrationContent() {
        const cursorTypes = Object.keys(DEFAULT_HOTSPOTS);
        
        // Fallback SVG icons for cursor types when images fail to load
        const CURSOR_FALLBACK_ICONS = {
          normal: '<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M4 4l12 16-4-4-4 8-2-10z"/></svg>',
          pointer: '<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M10 6v2h1v5l-2 2v2h6v-2l-2-2V8h1V6h-4m2-4a2 2 0 012 2 2 2 0 01-2 2 2 2 0 01-2-2 2 2 0 012-2m-6 6v10c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V8"/></svg>',
          help: '<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M4 4l8 12-2-2-2 5-1-7zM15 4a5 5 0 015 5c0 2-1 3-2 4l-1 1v2h-2v-3l2-2c.5-.5 1-1 1-2a3 3 0 00-6 0h-2a5 5 0 015-5m-2 14h2v2h-2v-2z"/></svg>',
          text: '<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M5 4v3h5v12h4V7h5V4H5z"/></svg>',
          handwriting: '<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>',
          crosshair: '<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><circle cx="12" cy="12" r="3" fill="none" stroke="currentColor" stroke-width="2"/><line x1="12" y1="2" x2="12" y2="8" stroke="currentColor" stroke-width="2"/><line x1="12" y1="16" x2="12" y2="22" stroke="currentColor" stroke-width="2"/><line x1="2" y1="12" x2="8" y2="12" stroke="currentColor" stroke-width="2"/><line x1="16" y1="12" x2="22" y2="12" stroke="currentColor" stroke-width="2"/></svg>',
          move: '<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M13 6v5h5V8l4 4-4 4v-3h-5v5h3l-4 4-4-4h3v-5H6v3l-4-4 4-4v3h5V6H8l4-4 4 4h-3z"/></svg>',
          unavailable: '<svg viewBox="0 0 24 24" fill="none" width="20" height="20"><circle cx="12" cy="12" r="9" stroke="currentColor" stroke-width="2"/><line x1="5" y1="5" x2="19" y2="19" stroke="currentColor" stroke-width="2"/></svg>',
          nsResize: '<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M12 2l5 5h-3v10h3l-5 5-5-5h3V7H7l5-5z"/></svg>',
          ewResize: '<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M2 12l5-5v3h10V7l5 5-5 5v-3H7v3l-5-5z"/></svg>',
          nwseResize: '<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M4 4h6v2H6.41L10 9.59 8.59 11 5 7.41V10H3V4h1m16 16h-6v-2h3.59L14 14.41 15.41 13 19 16.59V14h2v6h-1z"/></svg>',
          neswResize: '<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M20 4h-6v2h3.59L14 9.59 15.41 11 19 7.41V10h2V4h-1M4 20h6v-2H6.41L10 14.41 8.59 13 5 16.59V14H3v6h1z"/></svg>',
          alternate: '<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M4 4l12 16-4-4-4 8-2-10z"/><circle cx="18" cy="6" r="3"/></svg>',
          progress: '<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M4 4l8 12-2-2-2 5-1-7z"/><circle cx="17" cy="12" r="5" fill="none" stroke="currentColor" stroke-width="2" stroke-dasharray="10 5"/></svg>',
          busy: '<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><circle cx="12" cy="12" r="8" fill="none" stroke="currentColor" stroke-width="2" stroke-dasharray="15 10"><animateTransform attributeName="transform" type="rotate" from="0 12 12" to="360 12 12" dur="1s" repeatCount="indefinite"/></circle></svg>',
        };
        
        let cursorRows = '';
        cursorTypes.forEach(type => {
          const cursorFile = CURSOR_TYPE_TO_FILE[type];
          const storedCursor = localStorage.getItem(`cursor_${cursorFile}`) || getCursor(cursorFile);
          const previewUrl = storedCursor || getCursorPreviewUrl(cursorFile);
          const isAnimated = cursorFile && cursorFile.endsWith('.ani');
          const fallbackIcon = CURSOR_FALLBACK_ICONS[type] || '<span style="opacity:0.5">?</span>';
          const hs = liveHotspots[type];
          
          cursorRows += `
            <div class="cal-row${type === selectedCalType ? ' selected' : ''}" data-type="${type}" style="
              display: flex;
              align-items: center;
              justify-content: space-between;
              padding: 10px 12px;
              margin: 3px 0;
              border-radius: 8px;
              cursor: pointer;
              transition: all 0.15s ease;
            ">
              <div style="display: flex; align-items: center; gap: 12px; min-width: 140px;">
                <div style="width: 36px; height: 36px; background: hsl(var(--background)); border-radius: 8px; display: flex; align-items: center; justify-content: center; position: relative; border: 1px solid hsl(var(--border)); overflow: hidden;">
                  ${previewUrl ? `<img src="${previewUrl}" style="width: 22px; height: 22px; object-fit: contain; image-rendering: pixelated;" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';" /><div style="display: none; align-items: center; justify-content: center; color: hsl(var(--foreground));">${fallbackIcon}</div>` : `<div style="display: flex; align-items: center; justify-content: center; color: hsl(var(--foreground));">${fallbackIcon}</div>`}
                  ${isAnimated ? '<div style="position: absolute; bottom: 2px; right: 2px; width: 12px; height: 12px; background: hsl(var(--primary)); border-radius: 50%; font-size: 7px; display: flex; align-items: center; justify-content: center; color: white;"></div>' : ''}
                </div>
                <div style="display: flex; flex-direction: column; gap: 2px;">
                  <span style="font-size: 13px; color: hsl(var(--foreground)); font-weight: 500;">${type}</span>
                  ${isAnimated ? '<span style="font-size: 10px; color: hsl(var(--primary)); font-weight: 500;">animated</span>' : ''}
                </div>
              </div>
              <div style="display: flex; gap: 6px; align-items: center;">
                <div style="display: flex; align-items: center; gap: 4px; background: hsl(var(--background)); padding: 4px 8px; border-radius: 6px; border: 1px solid hsl(var(--border));">
                  <label style="font-size: 11px; color: hsl(var(--muted-foreground)); font-weight: 500;">X</label>
                  <input type="number" step="0.5" id="cal-${type}-x" value="${hs.x.toFixed(1)}" 
                    style="width: 52px; padding: 4px 6px; background: transparent; border: none; color: hsl(var(--foreground)); font-size: 12px; font-weight: 500; text-align: center; outline: none;" />
                </div>
                <div style="display: flex; align-items: center; gap: 4px; background: hsl(var(--background)); padding: 4px 8px; border-radius: 6px; border: 1px solid hsl(var(--border));">
                  <label style="font-size: 11px; color: hsl(var(--muted-foreground)); font-weight: 500;">Y</label>
                  <input type="number" step="0.5" id="cal-${type}-y" value="${hs.y.toFixed(1)}" 
                    style="width: 52px; padding: 4px 6px; background: transparent; border: none; color: hsl(var(--foreground)); font-size: 12px; font-weight: 500; text-align: center; outline: none;" />
                </div>
              </div>
            </div>
          `;
        });
        
        return `
          <style>
            .cal-content-wrapper {
              display: flex;
              flex-direction: column;
              height: 100%;
              background: hsl(var(--window-bg));
            }
            .cal-content-wrapper::-webkit-scrollbar { width: 12px; }
            .cal-content-wrapper::-webkit-scrollbar-track { background: transparent; }
            .cal-content-wrapper::-webkit-scrollbar-thumb { 
              background: rgba(128, 128, 128, 0.5);
              border-radius: 10px;
              border: 3px solid transparent;
              background-clip: padding-box;
            }
            .cal-content-wrapper::-webkit-scrollbar-thumb:hover { 
              background: rgba(128, 128, 128, 0.7);
              background-clip: padding-box;
            }
            .cal-list {
              scrollbar-width: thin;
              scrollbar-color: rgba(128, 128, 128, 0.5) transparent;
            }
            .cal-list::-webkit-scrollbar { width: 12px; }
            .cal-list::-webkit-scrollbar-track { background: transparent; }
            .cal-list::-webkit-scrollbar-thumb { 
              background: rgba(128, 128, 128, 0.5);
              border-radius: 10px;
              border: 3px solid transparent;
              background-clip: padding-box;
            }
            .cal-list::-webkit-scrollbar-thumb:hover { 
              background: rgba(128, 128, 128, 0.7);
              background-clip: padding-box;
            }
            .cal-row {
              background: hsl(var(--accent) / 0.3);
              border: 1px solid transparent;
            }
            .cal-row:hover {
              background: hsl(var(--accent) / 0.5);
              border-color: hsl(var(--border));
            }
            .cal-row.selected {
              background: hsl(var(--primary) / 0.15) !important;
              border-color: hsl(var(--primary) / 0.4) !important;
            }
            .cal-btn {
              padding: 8px 16px;
              border: none;
              border-radius: 8px;
              font-size: 12px;
              font-weight: 500;
              cursor: pointer;
              transition: all 0.15s ease;
            }
            .cal-btn:hover { transform: translateY(-1px); }
            .cal-btn:active { transform: scale(0.98); }
            .cal-btn-primary { background: hsl(var(--primary)); color: white; }
            .cal-btn-success { background: #10b981; color: white; }
            .cal-btn-secondary { background: hsl(var(--accent)); color: hsl(var(--foreground)); }
            .cal-zoom-btn {
              width: 28px;
              height: 28px;
              border-radius: 6px;
              border: 1px solid hsl(var(--border));
              background: hsl(var(--background));
              color: hsl(var(--foreground));
              font-size: 14px;
              font-weight: 600;
              cursor: pointer;
              display: flex;
              align-items: center;
              justify-content: center;
              transition: all 0.15s ease;
            }
            .cal-zoom-btn:hover { background: hsl(var(--accent)); }
          </style>
          
          <div class="cal-content-wrapper" style="padding: 0;">
            <!-- Preview Section -->
            <div style="padding: 16px; border-bottom: 1px solid hsl(var(--window-border)); background: hsl(var(--accent) / 0.2);">
              <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                <span style="font-size: 11px; color: hsl(var(--muted-foreground)); font-weight: 500; text-transform: uppercase; letter-spacing: 0.5px;">Preview</span>
                <div style="display: flex; align-items: center; gap: 6px;">
                  <button class="cal-zoom-btn" id="cal-zoom-out"></button>
                  <span id="cal-zoom-label" style="font-size: 11px; color: hsl(var(--muted-foreground)); min-width: 36px; text-align: center; font-weight: 500;">${calibrationZoom.toFixed(1)}x</span>
                  <button class="cal-zoom-btn" id="cal-zoom-in">+</button>
                </div>
              </div>
              <div id="cal-preview-box" style="
                position: relative;
                width: 100%;
                height: 160px;
                background: 
                  linear-gradient(to right, transparent calc(50% - 1px), hsl(0 70% 50% / 0.7) calc(50% - 1px), hsl(0 70% 50% / 0.7) calc(50% + 1px), transparent calc(50% + 1px)),
                  linear-gradient(to bottom, transparent calc(50% - 1px), hsl(0 70% 50% / 0.7) calc(50% - 1px), hsl(0 70% 50% / 0.7) calc(50% + 1px), transparent calc(50% + 1px)),
                  repeating-linear-gradient(0deg, hsl(var(--foreground) / 0.03) 0px, hsl(var(--foreground) / 0.03) 1px, transparent 1px, transparent 20px),
                  repeating-linear-gradient(90deg, hsl(var(--foreground) / 0.03) 0px, hsl(var(--foreground) / 0.03) 1px, transparent 1px, transparent 20px),
                  hsl(var(--background));
                border-radius: 10px;
                overflow: hidden;
                border: 1px solid hsl(var(--border));
              ">
                <div id="cal-preview-cursor"></div>
                <div style="position: absolute; left: 50%; top: 50%; width: 10px; height: 10px; background: hsl(0 70% 50% / 0.5); border-radius: 50%; transform: translate(-50%, -50%); z-index: 10; box-shadow: 0 0 0 2px hsl(0 70% 50% / 0.3);"></div>
              </div>
              <div id="cal-preview-info" style="font-size: 12px; color: hsl(var(--muted-foreground)); margin-top: 10px; text-align: center; font-family: 'JetBrains Mono', monospace;"></div>
            </div>
            
            <!-- Cursor List -->
            <div class="cal-list" id="cal-cursor-list" style="flex: 1; overflow-y: auto; padding: 12px 16px; max-height: 280px;">
              ${cursorRows}
            </div>
            
            <!-- Footer Actions -->
            <div style="padding: 12px 16px; border-top: 1px solid hsl(var(--window-border)); display: flex; gap: 8px; justify-content: flex-end; background: hsl(var(--accent) / 0.2);">
              <button class="cal-btn cal-btn-secondary" id="cal-reset">Reset All</button>
              <button class="cal-btn cal-btn-success" id="cal-copy">Copy Config</button>
              <button class="cal-btn cal-btn-primary" id="cal-apply">Apply</button>
            </div>
          </div>
        `;
      }
      
      function setupCalibrationEvents(container) {
        const cursorTypes = Object.keys(DEFAULT_HOTSPOTS);
        
        // Zoom controls
        const zoomIn = container.querySelector('#cal-zoom-in');
        const zoomOut = container.querySelector('#cal-zoom-out');
        
        if (zoomIn) {
          zoomIn.onclick = () => {
            calibrationZoom = Math.min(5, calibrationZoom + 0.5);
            updateCalibrationPreview();
          };
        }
        
        if (zoomOut) {
          zoomOut.onclick = () => {
            calibrationZoom = Math.max(1, calibrationZoom - 0.5);
            updateCalibrationPreview();
          };
        }
        
        // Cursor list - preserve scroll position
        const cursorList = container.querySelector('#cal-cursor-list');
        if (cursorList) {
          cursorList.scrollTop = calibrationScrollPos;
          cursorList.addEventListener('scroll', () => {
            calibrationScrollPos = cursorList.scrollTop;
          });
        }
        
        // Row click handlers
        container.querySelectorAll('.cal-row').forEach(row => {
          row.addEventListener('click', (e) => {
            if (e.target.tagName === 'INPUT') return;
            
            container.querySelectorAll('.cal-row').forEach(r => r.classList.remove('selected'));
            row.classList.add('selected');
            
            selectedCalType = row.dataset.type;
            updateCalibrationPreview();
            forceCalibrationCursor();
          });
        });
        
        // Input handlers for precise XY
        cursorTypes.forEach(type => {
          const xInput = container.querySelector(`#cal-${type}-x`);
          const yInput = container.querySelector(`#cal-${type}-y`);
          
          if (xInput && yInput) {
            const handleInput = () => {
              liveHotspots[type].x = parseFloat(xInput.value) || 0;
              liveHotspots[type].y = parseFloat(yInput.value) || 0;
              if (selectedCalType === type) {
                updateCalibrationPreview();
              }
            };
            
            xInput.addEventListener('input', handleInput);
            yInput.addEventListener('input', handleInput);
            
            // Arrow key fine-tuning
            [xInput, yInput].forEach(input => {
              input.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                  e.preventDefault();
                  const step = e.shiftKey ? 1 : 0.5;
                  const delta = e.key === 'ArrowUp' ? step : -step;
                  input.value = (parseFloat(input.value) + delta).toFixed(1);
                  handleInput();
                }
              });
            });
          }
        });
        
        // Button handlers
        const applyBtn = container.querySelector('#cal-apply');
        const copyBtn = container.querySelector('#cal-copy');
        const resetBtn = container.querySelector('#cal-reset');
        
        if (applyBtn) {
          applyBtn.onclick = () => {
            cursorTypes.forEach(type => {
              const xInput = container.querySelector(`#cal-${type}-x`);
              const yInput = container.querySelector(`#cal-${type}-y`);
              if (xInput && yInput) {
                liveHotspots[type].x = parseFloat(xInput.value) || 0;
                liveHotspots[type].y = parseFloat(yInput.value) || 0;
              }
            });
            updateCalibrationPreview();
            console.log('Hotspots applied:', JSON.stringify(liveHotspots, null, 2));
          };
        }
        
        if (copyBtn) {
          copyBtn.onclick = () => {
            const config = JSON.stringify(liveHotspots, null, 2);
            navigator.clipboard.writeText(config).then(() => {
              copyBtn.textContent = 'Copied!';
              setTimeout(() => { copyBtn.textContent = 'Copy Config'; }, 1500);
            });
          };
        }
        
        if (resetBtn) {
          resetBtn.onclick = () => {
            liveHotspots = JSON.parse(JSON.stringify(DEFAULT_HOTSPOTS));
            cursorTypes.forEach(type => {
              const xInput = container.querySelector(`#cal-${type}-x`);
              const yInput = container.querySelector(`#cal-${type}-y`);
              if (xInput && yInput) {
                xInput.value = liveHotspots[type].x.toFixed(1);
                yInput.value = liveHotspots[type].y.toFixed(1);
              }
            });
            updateCalibrationPreview();
          };
        }
        
        // Note: Row selection is handled by the selectedCalType variable and CSS class in the HTML
      }
      
      // Handle calibration window close
      window.addEventListener('windowClosed', (e) => {
        if (e.detail && e.detail.id === calibrationWindowId) {
          calibrationWindowId = null;
          setCalibrationMode(false);
        }
      });

      // Keyboard shortcut: Ctrl+Shift+C
      document.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.shiftKey && e.key === 'C') {
          e.preventDefault();
          createCalibrationPanel();
        }
        
        // F11 is now handled by capture-phase listener, no need to block here
      });

      function createCursorFollower() {
        if (cursorFollower) return;

        // Calculate actual size (base 32px * scale)
        const baseSize = 32;
        const scaledSize = Math.round(baseSize * CURSOR_CONFIG.cursorScale);

        cursorFollower = document.createElement('div');
        cursorFollower.id = 'cursor-follower';
        cursorFollower.style.cssText = `
          position: fixed;
          pointer-events: none;
          z-index: 999999;
          width: ${scaledSize}px;
          height: ${scaledSize}px;
          background-size: ${scaledSize}px ${scaledSize}px;
          background-repeat: no-repeat;
          background-position: top left;
          display: none;
          left: -100px;
          top: -100px;
          image-rendering: pixelated;
          image-rendering: crisp-edges;
        `;
        document.body.appendChild(cursorFollower);
        
        console.log('Cursor follower created, size:', scaledSize);

        // Track mouse position - align click hotspot to the mouse position
        document.addEventListener('mousemove', (e) => {
          if (cursorFollower) {
            // Don't show/update cursor if pointer is locked (e.g., in games)
            if (document.pointerLockElement) {
              cursorFollower.style.display = 'none';
              return;
            }
            
            const hs = getCursorHotspot(currentCursorType);
            cursorFollower.style.left = (e.clientX - hs.x) + 'px';
            cursorFollower.style.top = (e.clientY - hs.y) + 'px';
            // Show on first move if enabled
            if (areCursorsEnabled() && cursorFollower.style.display === 'none') {
              cursorFollower.style.display = 'block';
            }
          }
        });

        // Hide when leaving window
        document.addEventListener('mouseleave', () => {
          if (cursorFollower) cursorFollower.style.display = 'none';
        });

        document.addEventListener('mouseenter', () => {
          if (cursorFollower && areCursorsEnabled() && !document.pointerLockElement) {
            cursorFollower.style.display = 'block';
          }
        });
        
        // Hide cursor follower when pointer is locked (e.g., in games like Minecraft)
        document.addEventListener('pointerlockchange', () => {
          if (cursorFollower) {
            if (document.pointerLockElement) {
              // Pointer is locked - hide the custom cursor
              cursorFollower.style.display = 'none';
            } else {
              // Pointer is unlocked - show the custom cursor if enabled
              if (areCursorsEnabled()) {
                cursorFollower.style.display = 'block';
              }
            }
          }
        });
      }

      function updateCursorFollowerImage(imageUrl) {
        if (!cursorFollower) createCursorFollower();
        if (imageUrl && imageUrl !== currentCursorImage) {
          currentCursorImage = imageUrl;
          cursorFollower.style.backgroundImage = `url('${imageUrl}')`;
          console.log('Cursor image updated');
        }
      }

      function setCursorFollowerType(type) {
        currentCursorType = type || 'normal';
      }

      function showCursorFollower(show) {
        if (!cursorFollower) createCursorFollower();
        // Don't show immediately - wait for mousemove to position it first
        if (!show) {
          cursorFollower.style.display = 'none';
        }
        // If show=true, it will be shown on first mousemove
      }

      // Get cursor data URL from localStorage or fallback
      function getCursor(filename) {
        // First check localStorage
        const stored = localStorage.getItem(`cursor_${filename}`);
        if (stored) return stored;
        
        // Fallback to embedded cursors
        if (FALLBACK_CURSORS[filename]) {
          return FALLBACK_CURSORS[filename];
        }
        
        return '';
      }

      function pickCursor(primary, fallback) {
        return primary || fallback || '';
      }

      // Check if cursors are installed in localStorage
      function areCursorsInstalled() {
        return localStorage.getItem(CURSOR_CONFIG.storageKey) === 'true';
      }

      // Check if custom cursors are enabled
      function areCursorsEnabled() {
        const enabled = localStorage.getItem(CURSOR_CONFIG.enabledKey);
        return enabled === null || enabled === 'true';
      }

      // Generate and inject cursor CSS using base64 data from localStorage or fallback
      // Uses cursor follower for 50% bigger cursors
      function injectCursorStyles() {
        // Remove existing style if present
        const existingStyle = document.getElementById(CURSOR_CONFIG.styleId);
        if (existingStyle) existingStyle.remove();

        if (!areCursorsEnabled()) {
          document.body.classList.remove('custom-cursors-enabled');
          showCursorFollower(false);
          return;
        }

        // Get cursors - getCursor now checks both localStorage AND embedded fallback
        const normal = getCursor('01-normal-select.cur');
        const help = getCursor('02-help-select.ani') || getCursor('02-help-select.cur');
        const progress = getCursor('03-working-in-background.ani') || getCursor('03-working-in-background.cur');
        const busy = getCursor('04-busy.ani') || getCursor('04-busy.cur');
        const crosshair = getCursor('05-precision-select.cur');
        const text = getCursor('06-text-select.cur');
        const handwriting = getCursor('07-handwriting.cur');
        const unavailable = getCursor('08-unavailable.ani') || getCursor('08-unavailable.cur');
        const nsResize = getCursor('09-vertical-resize.cur');
        const ewResize = getCursor('10-horizontal-resize.cur');
        const nwseResize = getCursor('11-diagonal-resize-1.cur');
        const neswResize = getCursor('12-diagonal-resize-2.cur');
        const move = getCursor('13-move.cur');
        const alternate = getCursor('14-alternate-select.cur');
        const pointer = getCursor('15-link-select.cur');

        if (!normal) {
          console.warn('[Cursor] No cursor data found (not in localStorage or fallback)');
          return;
        }
        
        console.log('[Cursor] Found cursor data, initializing cursor follower...');

        // Create cursor follower for scaled cursor display
        createCursorFollower();
        setCursorFollowerType('normal');
        updateCursorFollowerImage(normal);
        showCursorFollower(true);

        // Setup cursor type detection for different elements
        setupCursorTypeDetection({
          normal, help, progress, busy, crosshair, text,
          handwriting, unavailable, nsResize, ewResize,
          nwseResize, neswResize, move, alternate, pointer
        });

        const css = `
          /* Custom Cursor Styles - Hide native cursor, use scaled follower */
          .custom-cursors-enabled,
          .custom-cursors-enabled * {
            cursor: none !important;
          }
          
          /* Iframe cursor overlay - prevents iframe's internal cursor from showing */
          /* while still allowing all mouse events to pass through to the iframe */
          .custom-cursors-enabled .window-content iframe {
            cursor: none !important;
          }
          
          /* Add an invisible overlay on top of iframes when custom cursors are enabled */
          /* This overlay captures cursor styling but passes through all click/input events */
          .custom-cursors-enabled .browser-container::after,
          .custom-cursors-enabled .minecraft-container::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 1;
            cursor: none !important;
          }
          
          /* Ensure browser/minecraft containers are positioned for the overlay */
          .custom-cursors-enabled .browser-container,
          .custom-cursors-enabled .minecraft-container {
            position: relative;
          }
        `;

        const style = document.createElement('style');
        style.id = CURSOR_CONFIG.styleId;
        style.textContent = css;
        document.head.appendChild(style);

        document.body.classList.add('custom-cursors-enabled');
        console.log('Custom cursor styles injected - cursors are 50% bigger with ANI animation support');
      }

      // Cursor type detection for dynamic cursor changes
      function setupCursorTypeDetection(cursors) {
        const { normal, help, progress, busy, crosshair, text,
                handwriting, unavailable, nsResize, ewResize,
                nwseResize, neswResize, move, alternate, pointer } = cursors;

        // ANI cursor types that need animation
        const aniTypes = ['help', 'progress', 'busy', 'unavailable'];

        document.addEventListener('mouseover', (e) => {
          if (!areCursorsEnabled()) return;
          
          // Skip cursor detection if calibration mode is active - keep forced cursor
          if (calibrationModeActive) return;

          const target = e.target;
          let cursorImage = normal;
          let cursorType = 'normal';
          let isAniCursor = false;

          // Check element type and set appropriate cursor
          if (target.matches('a, button, [role="button"], [onclick], .dock-icon, .menubar button, .quick-settings-icon-btn, .settings-nav-item, .browser-bookmark, .wallpaper-option, .titlebar-btn, .toggle-switch, .launchpad-icon, .launchpad-item, .context-menu-item, .titlebar-button')) {
            cursorImage = pointer || normal;
            cursorType = 'pointer';
          } else if (target.matches('[data-cursor="help"], .cursor-help')) {
            cursorImage = help || pointer;
            cursorType = 'help';
            isAniCursor = true;
          } else if (target.matches('input[type="text"], input[type="search"], input[type="url"], input[type="email"], input[type="password"], textarea, .terminal-input, [contenteditable="true"]')) {
            cursorImage = text || normal;
            cursorType = 'text';
          } else if (target.matches('[data-cursor="handwriting"], .cursor-handwriting, canvas.drawing-canvas, canvas[data-drawing="true"]')) {
            cursorImage = handwriting || text;
            cursorType = 'handwriting';
          } else if (target.matches(':disabled, [aria-disabled="true"], .disabled')) {
            cursorImage = unavailable || normal;
            cursorType = 'unavailable';
            isAniCursor = true;
          } else if (target.matches('[aria-busy="true"], .loading, .is-loading, [data-cursor="busy"]')) {
            cursorImage = busy || progress;
            cursorType = 'busy';
            isAniCursor = true;
          } else if (target.matches('[data-cursor="progress"]')) {
            cursorImage = progress || busy;
            cursorType = 'progress';
            isAniCursor = true;
          } else if (target.matches('.resize-handle.n, .resize-handle.s')) {
            cursorImage = nsResize || normal;
            cursorType = 'nsResize';
          } else if (target.matches('.resize-handle.e, .resize-handle.w')) {
            cursorImage = ewResize || normal;
            cursorType = 'ewResize';
          } else if (target.matches('.resize-handle.nw, .resize-handle.se')) {
            cursorImage = nwseResize || normal;
            cursorType = 'nwseResize';
          } else if (target.matches('.resize-handle.ne, .resize-handle.sw')) {
            cursorImage = neswResize || normal;
            cursorType = 'neswResize';
          } else if (target.matches('.titlebar')) {
            cursorImage = move || normal;
            cursorType = 'move';
          } else if (target.matches('input[type="range"]')) {
            cursorImage = ewResize || normal;
            cursorType = 'ewResize';
          } else if (target.matches('.crosshair, [data-cursor="crosshair"]')) {
            cursorImage = crosshair || normal;
            cursorType = 'crosshair';
          } else if (target.matches('[data-cursor="alternate"], .cursor-alternate')) {
            cursorImage = alternate || pointer;
            cursorType = 'alternate';
          }

          setCursorFollowerType(cursorType);
          
          // Handle ANI cursors with animation
          if (isAniCursor && aniCursors[cursorType]) {
            if (currentAniType !== cursorType) {
              startAniAnimation(cursorType, aniCursors[cursorType]);
            }
          } else {
            stopAniAnimation();
            updateCursorFollowerImage(cursorImage);
          }
        });
      }

      // Download cursor file and store as base64 in localStorage
      // Handles both .cur and .ani files - parses them into PNG for browser compatibility
      async function downloadAndStoreCursor(filename) {
        console.log(`[Cursor] Attempting to download: ${filename}`);
        try {
          const url = CURSOR_CONFIG.baseUrl + filename;
          console.log(`[Cursor] Fetching from: ${url}`);
          
          const response = await fetch(url);
          console.log(`[Cursor] Response status: ${response.status}`);
          
          if (!response.ok) throw new Error(`Failed to fetch ${filename}: ${response.status}`);
          
          const arrayBuffer = await response.arrayBuffer();
          console.log(`[Cursor] Downloaded ${filename}: ${arrayBuffer.byteLength} bytes`);
          
          const isAni = filename.endsWith('.ani');
          
          if (isAni) {
            // Parse ANI file and store parsed frames as PNG data URLs
            try {
              console.log(`[Cursor] Parsing ANI file: ${filename}`);
              const aniData = await ANIParser.parse(arrayBuffer);
              if (aniData.frames.length > 0) {
                // Store the first frame as the static fallback (already PNG data URL)
                localStorage.setItem(`cursor_${filename}`, aniData.frames[0]);
                // Store full ANI data for animation
                localStorage.setItem(`cursor_ani_${filename}`, JSON.stringify(aniData));
                console.log(` Parsed ANI cursor ${filename}: ${aniData.frames.length} frames`);
                return true;
              }
              console.warn(`[Cursor] ANI file ${filename} has no frames`);
              return false;
            } catch (parseError) {
              console.warn(`[Cursor] Failed to parse ANI file ${filename}:`, parseError);
              return false;
            }
          } else {
            // Parse CUR file into PNG data URL for browser compatibility
            try {
              console.log(`[Cursor] Parsing CUR file: ${filename}`);
              const pngDataUrl = await parseCURFile(arrayBuffer);
              if (pngDataUrl) {
                localStorage.setItem(`cursor_${filename}`, pngDataUrl);
                console.log(` Parsed CUR cursor ${filename}`);
                return true;
              }
              console.warn(`[Cursor] CUR file ${filename} produced no data`);
              return false;
            } catch (parseError) {
              console.warn(`[Cursor] Failed to parse CUR file ${filename}:`, parseError);
              return false;
            }
          }
        } catch (error) {
          console.warn(`[Cursor] Failed to download cursor: ${filename}`, error);
          return false;
        }
      }
      
      // Load ANI cursor data from localStorage into memory
      function loadAniCursors() {
        const aniFiles = CURSOR_CONFIG.files.filter(f => f.endsWith('.ani'));
        const typeToFile = {
          'help': '02-help-select.ani',
          'progress': '03-working-in-background.ani',
          'busy': '04-busy.ani',
          'unavailable': '08-unavailable.ani'
        };
        
        Object.entries(typeToFile).forEach(([type, filename]) => {
          const aniDataStr = localStorage.getItem(`cursor_ani_${filename}`);
          if (aniDataStr) {
            try {
              aniCursors[type] = JSON.parse(aniDataStr);
              console.log(`Loaded ANI cursor for ${type}: ${aniCursors[type].frames.length} frames`);
            } catch (e) {
              console.warn(`Failed to parse stored ANI data for ${type}:`, e);
            }
          }
        });
      }

      // Download all cursors from GitHub
      async function installCursorsFromGitHub() {
        console.log('Installing custom cursors from GitHub (with ANI support)...');
        
        const results = await Promise.all(
          CURSOR_CONFIG.files.map(file => downloadAndStoreCursor(file))
        );
        
        const successCount = results.filter(r => r).length;
        console.log(`Installed ${successCount}/${CURSOR_CONFIG.files.length} cursors`);
        
        if (successCount > 0) {
          localStorage.setItem(CURSOR_CONFIG.storageKey, 'true');
          localStorage.setItem(CURSOR_CONFIG.enabledKey, 'true');
          loadAniCursors(); // Load ANI data into memory
          injectCursorStyles();
          return true;
        }
        return false;
      }

      // Toggle custom cursors on/off
      window.toggleCustomCursors = function toggleCustomCursors() {
        const currentState = areCursorsEnabled();
        localStorage.setItem(CURSOR_CONFIG.enabledKey, (!currentState).toString());
        injectCursorStyles();
        return !currentState;
      };

      // Reinstall cursors from GitHub
      window.reinstallCursors = async function reinstallCursors() {
        // Clear existing cursor data (both .cur and .ani)
        CURSOR_CONFIG.files.forEach(file => {
          localStorage.removeItem(`cursor_${file}`);
          localStorage.removeItem(`cursor_ani_${file}`);
        });
        localStorage.removeItem(CURSOR_CONFIG.storageKey);
        aniCursors = {}; // Clear ANI cursor cache
        stopAniAnimation();
        
        // Reinstall
        return await installCursorsFromGitHub();
      };
      
      // UI Helper: Install cursors with visual feedback
      window.installCursorsUI = async function installCursorsUI() {
        const btn = event.target;
        const originalText = btn.innerHTML;
        btn.innerHTML = ' Downloading...';
        btn.style.opacity = '0.7';
        btn.style.pointerEvents = 'none';
        
        try {
          const success = await installCursorsFromGitHub();
          if (success) {
            btn.innerHTML = ' Installed!';
            setTimeout(() => render(), 500);
          } else {
            btn.innerHTML = ' Failed';
            setTimeout(() => {
              btn.innerHTML = originalText;
              btn.style.opacity = '1';
              btn.style.pointerEvents = 'auto';
            }, 2000);
          }
        } catch (e) {
          console.error('Install failed:', e);
          btn.innerHTML = ' Error';
          setTimeout(() => {
            btn.innerHTML = originalText;
            btn.style.opacity = '1';
            btn.style.pointerEvents = 'auto';
          }, 2000);
        }
      };
      
      // UI Helper: Reinstall cursors with visual feedback
      window.reinstallCursorsUI = async function reinstallCursorsUI() {
        if (!confirm('Reinstall cursors from GitHub? This will re-download all cursor files.')) return;
        
        const btn = event.target;
        btn.innerHTML = ' Downloading...';
        btn.style.opacity = '0.7';
        
        try {
          await window.reinstallCursors();
          btn.innerHTML = ' Done!';
          setTimeout(() => render(), 500);
        } catch (e) {
          console.error('Reinstall failed:', e);
          btn.innerHTML = ' Error';
          setTimeout(() => render(), 2000);
        }
      };
      
      // UI Helper: Clear all cursor data
      window.clearCursorsUI = function clearCursorsUI() {
        if (!confirm('Remove all custom cursors? You can reinstall them later.')) return;
        
        // Clear all cursor data
        CURSOR_CONFIG.files.forEach(file => {
          localStorage.removeItem(`cursor_${file}`);
          localStorage.removeItem(`cursor_ani_${file}`);
        });
        localStorage.removeItem(CURSOR_CONFIG.storageKey);
        localStorage.removeItem(CURSOR_CONFIG.enabledKey);
        aniCursors = {};
        stopAniAnimation();
        
        // Remove cursor styles
        const existingStyle = document.getElementById(CURSOR_CONFIG.styleId);
        if (existingStyle) existingStyle.remove();
        document.body.classList.remove('custom-cursors-enabled');
        showCursorFollower(false);
        
        render();
      };

      // Check if running from local file (file:// protocol)
      function isLocalFile() {
        return window.location.protocol === 'file:';
      }

      // Initialize cursor system
      async function initCursorSystem() {
        console.log('[Cursor] Initializing cursor system...');
        console.log('[Cursor] Protocol:', window.location.protocol);
        console.log('[Cursor] Is local file:', isLocalFile());
        console.log('[Cursor] Cursors installed:', areCursorsInstalled());
        console.log('[Cursor] Cursors enabled:', areCursorsEnabled());
        
        // For local file:// protocol, always use fallback embedded cursors
        // because fetch() to GitHub will be blocked by CORS
        if (isLocalFile()) {
          console.log('[Cursor] Running as local file - using embedded fallback cursors');
          installFallbackCursors();
          loadAniCursors();
          injectCursorStyles();
          return;
        }
        
        if (!areCursorsInstalled()) {
          console.log('[Cursor] Cursors not installed, starting download from GitHub...');
          // First time: try to download from GitHub
          try {
            const success = await installCursorsFromGitHub();
            if (!success) {
              console.log('[Cursor] GitHub download failed, using fallback cursors');
              installFallbackCursors();
            }
            console.log('[Cursor] Download complete');
          } catch (e) {
            console.error('[Cursor] Failed to install cursors:', e);
            console.log('[Cursor] Using fallback cursors');
            installFallbackCursors();
          }
          loadAniCursors();
          injectCursorStyles();
        } else {
          console.log('[Cursor] Cursors already installed, loading from localStorage...');
          // Already installed: load ANI cursors and inject styles from localStorage
          loadAniCursors();
          injectCursorStyles();
        }
      }

      // Initialize cursors - wrapped in try/catch for safety
      (async function() {
        try {
          await initCursorSystem();
        } catch (e) {
          console.error('[Cursor] Init error:', e);
          // Last resort: try fallback cursors
          try {
            installFallbackCursors();
            injectCursorStyles();
          } catch (e2) {
            console.error('[Cursor] Fallback also failed:', e2);
          }
        }
      })();

      // Expose render functions globally for use throughout the application
      window.render = render;
      window.renderWindows = renderWindows;
      window.renderShell = renderShell;
      window.generateWindowsHTML = generateWindowsHTML;
      window.generateDockHTML = generateDockHTML;
      window.generateSingleWindowHTML = generateSingleWindowHTML;
      window.computeWindowState = computeWindowState;
      window.patchWindow = patchWindow;
      
      console.log('Starting init...');
      try {
        init();
        console.log('Init completed successfully');
        console.log('Split render system loaded with DOM diffing + vdom batching: render(), renderWindows(), renderShell(), vdom available');
        
        // Start the OS boot sequence
        startOS();
      } catch (e) {
        console.error('Init error:', e);
      }
    </script>
  </body>
</html>