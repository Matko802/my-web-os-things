<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Minecraft HTML Edition - Continuous Music</title>
    <meta name="description" content="Minecraft HTML Edition with continuous background music during gameplay and menus" />
    <style>
        /* General Setup & Fonts */
        body { margin: 0; overflow: hidden; font-family: 'Pixelify Sans', monospace; background: #000; }
        @import url('https://fonts.googleapis.com/css2?family=Pixelify+Sans:wght@400..700&family=Press+Start+2P&display=swap');
        canvas { display: block; cursor: none; }
        
        /* Starfield Background Canvas */
        #starfield-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 998;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        #starfield-bg.active {
            opacity: 1;
        }
        
        /* Grid Background Removed - Replaced with blocky Minecraft style */
        
        /* Enhanced Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes slideUp {
            from { transform: translateY(50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        @keyframes slideInLeft {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes slideOutLeft {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(-100%); opacity: 0; }
        }
        
        @keyframes titleEntry {
            from { 
                opacity: 0; 
                transform: translateY(-50px) scale(0.8);
            }
            to { 
                opacity: 1; 
                transform: translateY(0) scale(1);
            }
        }
        
        @keyframes buttonEntry {
            from {
                opacity: 0;
                transform: translateY(30px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }
        
        @keyframes glow {
            0%, 100% { box-shadow: 0 4px 0 0 rgba(0, 0, 0, 0.6), 0 0 15px rgba(255, 255, 255, 0.6); }
            50% { box-shadow: 0 4px 0 0 rgba(0, 0, 0, 0.6), 0 0 30px rgba(255, 255, 255, 0.9); }
        }
        
        @keyframes pixelate {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }
        
        @keyframes floatUp {
            0% {
                transform: translateY(0);
                opacity: 1;
            }
            100% {
                transform: translateY(-20px);
                opacity: 0;
            }
        }
        
        @keyframes shimmer {
            0% {
                background-position: -200% center;
            }
            100% {
                background-position: 200% center;
            }
        }
        
        @keyframes bgParallax {
            0% {
                background-position: 0 0, 10px 10px;
            }
            100% {
                background-position: 40px 40px, 50px 50px;
            }
        }
        
        /* NEW: Menu fade-in with scale animation */
        @keyframes menuFadeIn {
            0% {
                opacity: 0;
                transform: scale(0.9);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        @keyframes menuSlideIn {
            0% {
                opacity: 0;
                transform: translateY(30px) scale(0.95);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        @keyframes inventoryFadeIn {
            0% {
                opacity: 0;
                transform: scale(0.92);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        @keyframes bgParallaxFast {
            0% {
                background-position: 0 0, 10px 10px;
            }
            100% {
                background-position: 80px 80px, 90px 90px;
            }
        }
        
        /* Epic Credits Animations */
        @keyframes creditsFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
        
        @keyframes creditsGlow {
            0%, 100% { 
                box-shadow: 0 0 20px rgba(121, 192, 90, 0.3), 
                            0 0 40px rgba(121, 192, 90, 0.2),
                            inset 0 0 20px rgba(121, 192, 90, 0.1);
            }
            50% { 
                box-shadow: 0 0 40px rgba(121, 192, 90, 0.6), 
                            0 0 80px rgba(121, 192, 90, 0.4),
                            inset 0 0 30px rgba(121, 192, 90, 0.2);
            }
        }
        
        @keyframes creditsEntrance {
            0% {
                opacity: 0;
                transform: translateY(50px) scale(0.9) rotateX(10deg);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1) rotateX(0);
            }
        }
        
        @keyframes particleFloat {
            0% {
                transform: translateY(0) translateX(0) scale(1);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(-100vh) translateX(20px) scale(0.5);
                opacity: 0;
            }
        }
        
        @keyframes titleShine {
            0% {
                background-position: -200% center;
            }
            100% {
                background-position: 200% center;
            }
        }
        
        @keyframes borderGlow {
            0%, 100% {
                border-color: rgba(121, 192, 90, 0.5);
                box-shadow: 0 0 10px rgba(121, 192, 90, 0.3);
            }
            50% {
                border-color: rgba(121, 192, 90, 1);
                box-shadow: 0 0 30px rgba(121, 192, 90, 0.7);
            }
        }
        
        @keyframes roleReveal {
            0% {
                opacity: 0;
                transform: translateX(-30px);
            }
            100% {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        @keyframes nameReveal {
            0% {
                opacity: 0;
                transform: translateX(30px);
            }
            100% {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        /* Minecraft-Style Colors */
        :root {
            --mc-dirt-brown: #8B7355;
            --mc-stone-gray: #7C7C7C;
            --mc-dark-gray: #373737;
            --mc-grass-green: #79C05A;
            --mc-wood-brown: #9F814F;
            --primary-bg: rgba(0, 0, 0, 1); 
            --menu-bg-accent: transparent;
            --menu-bg-pattern: none;
            --primary-text: #FCFCFC;
            --main-action: #79C05A; 
            --main-action-hover: #6AAB4A;
            --secondary-action: #7C7C7C; 
            --secondary-action-hover: #6C6C6C;
            --warning-color: #E74C3C;
            --inventory-border: #555; 
            --item-slot-bg: #373737; 
            --hotbar-slot-bg: #282828; 
            --hotbar-border: #555; 
            --selection-glow: #FFFFFF; 
            --selection-highlight: #79C05A;
            --button-shadow: 0 4px 0 0 rgba(0, 0, 0, 0.4);
            --button-active-shadow: 0 2px 0 0 rgba(0, 0, 0, 0.4);
            --mc-button-top: rgba(255, 255, 255, 0.25);
            --mc-button-bottom: rgba(0, 0, 0, 0.25);
        }

        /* Information Overlays (FPS) */
        #ui, #fps { 
            position: absolute; 
            color: #ffffff; 
            background: none; 
            padding: 4px 8px; 
            border: none;
            pointer-events: none; 
            z-index: 5; 
            font-size: 12px;
            font-family: monospace;
            line-height: 1.5;
            text-shadow: 1px 1px 0px rgba(0, 0, 0, 0.8);
            transition: all 0.2s ease;
            display: none; /* Hidden by default until game starts */
        }
        #ui { top: 50px; left: 4px; white-space: pre; }
        #fps { top: 4px; left: 4px; }
        
        /* Health Hearts (Above Hotbar - Left Side) */
        #health-container {
            position: absolute;
            bottom: 88px;
            left: 50%;
            transform: translateX(-232px);
            display: none;
            z-index: 5;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1),
                        transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1),
                        opacity 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
        }
        
        .heart {
            display: inline-block;
            width: 18px;
            height: 18px;
            margin: 0 1px;
            position: relative;
            image-rendering: pixelated;
            transition: transform 0.2s cubic-bezier(0.4, 0.0, 0.2, 1);
        }
        
        /* Pixel art heart using box-shadow */
        .heart::before {
            content: '';
            position: absolute;
            width: 2px;
            height: 2px;
            background: currentColor;
            box-shadow: 
                /* Row 1 */
                0px 0px 0 0px currentColor,
                4px 0px 0 0px currentColor,
                10px 0px 0 0px currentColor,
                14px 0px 0 0px currentColor,
                /* Row 2 */
                -2px 2px 0 0px currentColor,
                0px 2px 0 0px currentColor,
                2px 2px 0 0px currentColor,
                4px 2px 0 0px currentColor,
                6px 2px 0 0px currentColor,
                8px 2px 0 0px currentColor,
                10px 2px 0 0px currentColor,
                12px 2px 0 0px currentColor,
                14px 2px 0 0px currentColor,
                16px 2px 0 0px currentColor,
                /* Row 3 */
                -2px 4px 0 0px currentColor,
                0px 4px 0 0px currentColor,
                2px 4px 0 0px currentColor,
                4px 4px 0 0px currentColor,
                6px 4px 0 0px currentColor,
                8px 4px 0 0px currentColor,
                10px 4px 0 0px currentColor,
                12px 4px 0 0px currentColor,
                14px 4px 0 0px currentColor,
                16px 4px 0 0px currentColor,
                /* Row 4 */
                -2px 6px 0 0px currentColor,
                0px 6px 0 0px currentColor,
                2px 6px 0 0px currentColor,
                4px 6px 0 0px currentColor,
                6px 6px 0 0px currentColor,
                8px 6px 0 0px currentColor,
                10px 6px 0 0px currentColor,
                12px 6px 0 0px currentColor,
                14px 6px 0 0px currentColor,
                16px 6px 0 0px currentColor,
                /* Row 5 */
                0px 8px 0 0px currentColor,
                2px 8px 0 0px currentColor,
                4px 8px 0 0px currentColor,
                6px 8px 0 0px currentColor,
                8px 8px 0 0px currentColor,
                10px 8px 0 0px currentColor,
                12px 8px 0 0px currentColor,
                14px 8px 0 0px currentColor,
                /* Row 6 */
                2px 10px 0 0px currentColor,
                4px 10px 0 0px currentColor,
                6px 10px 0 0px currentColor,
                8px 10px 0 0px currentColor,
                10px 10px 0 0px currentColor,
                12px 10px 0 0px currentColor,
                /* Row 7 */
                4px 12px 0 0px currentColor,
                6px 12px 0 0px currentColor,
                8px 12px 0 0px currentColor,
                10px 12px 0 0px currentColor,
                /* Row 8 */
                6px 14px 0 0px currentColor,
                8px 14px 0 0px currentColor;
        }
        
        .heart.full { color: #ff0000; }
        .heart.half { color: #ff6666; }
        .heart.empty { color: #444; }
        
        @keyframes heart-beat {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.15); }
        }
        
        .heart.low {
            animation: heart-beat 0.5s ease-in-out infinite;
        }
        
        /* Oxygen Bubbles (Above Hotbar - Right Side) */
        #oxygen-container {
            position: absolute;
            bottom: 88px;
            left: 50%;
            transform: translateX(32px);
            display: none;
            z-index: 5;
            text-align: left;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
        }
        
        /* Movement Status Indicator (Sprint/Sneak) */
        #movement-status {
            position: absolute;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 10px 20px;
            border-radius: 0px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            font-size: 14px;
            font-weight: bold;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.9);
            z-index: 5;
            pointer-events: none;
            display: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            box-shadow: 0 6px 0 0 rgba(0, 0, 0, 0.6), inset 0 2px 0 0 rgba(255, 255, 255, 0.1);
        }
        
        #movement-status.sprinting {
            color: #4af;
            border-color: #4af;
            display: block;
            opacity: 1;
            box-shadow: 0 6px 0 0 rgba(0, 0, 0, 0.6), 0 0 20px rgba(68, 170, 255, 0.5), inset 0 2px 0 0 rgba(255, 255, 255, 0.1);
        }
        
        #movement-status.sneaking {
            color: #fa4;
            border-color: #fa4;
            display: block;
            opacity: 1;
            box-shadow: 0 6px 0 0 rgba(0, 0, 0, 0.6), 0 0 20px rgba(255, 170, 68, 0.5), inset 0 2px 0 0 rgba(255, 255, 255, 0.1);
        }
        
        /* Held Item Info Display (Bottom-Right) */
        #held-item-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 14px 20px;
            border-radius: 0px;
            border: 3px solid rgba(121, 192, 90, 0.6);
            z-index: 5;
            pointer-events: none;
            display: none;
            text-align: right;
            box-shadow: 0 6px 0 0 rgba(0, 0, 0, 0.6), inset 0 2px 0 0 rgba(255, 255, 255, 0.1);
        }
        
        #held-item-info .item-name {
            font-size: 18px;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.8);
            margin-bottom: 4px;
            letter-spacing: 1px;
        }
        
        #held-item-info .item-count {
            font-size: 14px;
            color: #aaa;
            text-shadow: 1px 1px 0 rgba(0, 0, 0, 0.8);
        }
        
        #held-item-info .durability-bar-container {
            margin-top: 8px;
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 0px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        #held-item-info .durability-bar {
            height: 100%;
            transition: width 0.2s ease, background-color 0.2s ease;
        }
        
        #held-item-info .durability-bar.high {
            background: linear-gradient(90deg, #4caf50, #66bb6a);
        }
        
        #held-item-info .durability-bar.medium {
            background: linear-gradient(90deg, #ff9800, #ffa726);
        }
        
        #held-item-info .durability-bar.low {
            background: linear-gradient(90deg, #f44336, #e57373);
        }
        
        #held-item-info .durability-text {
            font-size: 11px;
            color: #ccc;
            margin-top: 4px;
            text-shadow: 1px 1px 0 rgba(0, 0, 0, 0.8);
        }
        
        .bubble {
            display: inline-block;
            width: 18px;
            height: 18px;
            margin: 0 1px;
            position: relative;
            image-rendering: pixelated;
        }
        
        /* Pixel art bubble using box-shadow */
        .bubble::before {
            content: '';
            position: absolute;
            width: 2px;
            height: 2px;
            background: currentColor;
            box-shadow: 
                /* Row 1 - top */
                4px 0px 0 0px currentColor,
                6px 0px 0 0px currentColor,
                8px 0px 0 0px currentColor,
                10px 0px 0 0px currentColor,
                /* Row 2 */
                2px 2px 0 0px currentColor,
                4px 2px 0 0px currentColor,
                10px 2px 0 0px currentColor,
                12px 2px 0 0px currentColor,
                /* Row 3 */
                0px 4px 0 0px currentColor,
                2px 4px 0 0px currentColor,
                12px 4px 0 0px currentColor,
                14px 4px 0 0px currentColor,
                /* Row 4 */
                0px 6px 0 0px currentColor,
                2px 6px 0 0px currentColor,
                12px 6px 0 0px currentColor,
                14px 6px 0 0px currentColor,
                /* Row 5 */
                0px 8px 0 0px currentColor,
                2px 8px 0 0px currentColor,
                12px 8px 0 0px currentColor,
                14px 8px 0 0px currentColor,
                /* Row 6 */
                0px 10px 0 0px currentColor,
                2px 10px 0 0px currentColor,
                12px 10px 0 0px currentColor,
                14px 10px 0 0px currentColor,
                /* Row 7 */
                2px 12px 0 0px currentColor,
                4px 12px 0 0px currentColor,
                10px 12px 0 0px currentColor,
                12px 12px 0 0px currentColor,
                /* Row 8 - bottom */
                4px 14px 0 0px currentColor,
                6px 14px 0 0px currentColor,
                8px 14px 0 0px currentColor,
                10px 14px 0 0px currentColor;
        }
        
        /* Add highlight for bubble */
        .bubble::after {
            content: '';
            position: absolute;
            width: 2px;
            height: 2px;
            background: rgba(255, 255, 255, 0.8);
            box-shadow: 
                4px 4px 0 0px rgba(255, 255, 255, 0.8),
                6px 4px 0 0px rgba(255, 255, 255, 0.8),
                4px 6px 0 0px rgba(255, 255, 255, 0.6);
        }
        
        .bubble { color: #3a9fef; }
        .bubble.popped { color: #333; opacity: 0.5; }
        
        @keyframes bubble-pop {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.5; }
            100% { transform: scale(0); opacity: 0; }
        }
        
        /* Death Screen - Blocky Style */
        #death-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(50, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1500;
        }
        
        #death-screen h1 {
            font-size: 72px;
            color: #fff;
            text-shadow: 4px 4px 0 rgba(0, 0, 0, 0.8);
            margin-bottom: 30px;
            animation: fadeIn 1s ease;
        }
        
        #death-screen p {
            font-size: 24px;
            color: #ffaaaa;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.8);
            margin-bottom: 40px;
        }
        
        #death-respawn-btn {
            padding: 20px 40px;
            font-size: 24px;
            background: linear-gradient(135deg, rgba(60, 63, 72, 0.95) 0%, rgba(40, 43, 52, 0.95) 100%);
            color: white;
            border: 3px solid rgba(121, 192, 90, 0.6);
            border-radius: 0px;
            cursor: pointer;
            box-shadow: 
                0 4px 0 0 rgba(0, 0, 0, 0.6),
                inset 0 -2px 0 0 rgba(0, 0, 0, 0.4),
                inset 0 2px 0 0 rgba(255, 255, 255, 0.15);
            font-family: 'Pixelify Sans', monospace;
            font-weight: 600;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }
        
        #death-respawn-btn::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: linear-gradient(135deg, rgba(121, 192, 90, 0.6), rgba(247, 220, 111, 0.6));
            border-radius: 0px;
            z-index: -1;
            opacity: 0;
            transition: opacity 0.4s ease;
        }
        
        #death-respawn-btn:hover::before {
            opacity: 1;
        }
        
        #death-respawn-btn:hover {
            background: linear-gradient(135deg, rgba(80, 83, 92, 0.95) 0%, rgba(60, 63, 72, 0.95) 100%);
            transform: translateY(-6px) scale(1.05);
            box-shadow: 
                0 16px 32px rgba(0, 0, 0, 0.7), 
                0 0 30px rgba(121, 192, 90, 0.6),
                inset 0 -4px 0 0 rgba(0, 0, 0, 0.3),
                inset 0 4px 0 0 rgba(255, 255, 255, 0.25);
            border-color: rgba(121, 192, 90, 0.9);
        }
        
        #death-respawn-btn:active {
            transform: translateY(1px) scale(0.97);
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.5),
                inset 0 -2px 0 0 rgba(0, 0, 0, 0.3),
                inset 0 2px 0 0 rgba(255, 255, 255, 0.1);
        }

        /* Crosshair */
        #crosshair { 
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%,-50%); 
            pointer-events: none; 
            width: 20px; height: 20px; 
            z-index: 5;
            mix-blend-mode: difference;
            display: none; /* Hidden by default until game starts */
        }
        #crosshair::before { content: ''; position: absolute; background: white; width: 20px; height: 2px; left: 0; top: 9px; }
        #crosshair::after { content: ''; position: absolute; background: white; width: 2px; height: 20px; left: 9px; top: 0; }
        
        /* MODIFIED: Fake Cursor for Inventory - Now looks like the crosshair and is centered */
        #fake-cursor {
            position: fixed; /* Changed to fixed to prevent scrolling issues */
            width: 20px; 
            height: 20px; 
            z-index: 2500; /* Higher than everything else */
            pointer-events: none; 
            display: none; 
            /* NEW: Center the cursor on the mouse coordinates */
            transform: translate(-50%, -50%); 
            will-change: transform; /* Performance optimization */
        }
        #fake-cursor::before { 
            content: ''; 
            position: absolute; 
            background: white; 
            width: 20px; 
            height: 2px; 
            left: 0; 
            top: 9px; 
        }
        #fake-cursor::after { 
            content: ''; 
            position: absolute; 
            background: white; 
            width: 2px; 
            height: 20px; 
            left: 9px; 
            top: 0; 
        }

        /* Toolbar (HUD) - 8 Slots with Connected Minecraft Style */
        #toolbar { 
            position: absolute; bottom: 20px; left: 50%; 
            transform: translateX(-50%); 
            display: none; /* Hidden by default, shown when game starts */
            gap: 0px; 
            z-index: 5;
            background: var(--hotbar-slot-bg);
            border: 4px solid var(--hotbar-border);
            border-radius: 0px;
            padding: 3px;
            box-shadow: 0 6px 0 0 rgba(0, 0, 0, 0.6), inset 0 2px 0 0 rgba(255, 255, 255, 0.1);
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
        }
        #toolbar button { 
            width: 58px; height: 58px; 
            border: 3px solid rgba(85, 85, 85, 0.4); 
            border-radius: 0px; 
            cursor: pointer; 
            font-size: 10px; 
            color: var(--primary-text); 
            background: var(--hotbar-slot-bg); 
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column; 
            justify-content: center; 
            align-items: center;
            position: relative;
            box-shadow: inset -2px -2px 0 0 rgba(0, 0, 0, 0.4), inset 2px 2px 0 0 rgba(255, 255, 255, 0.1);
            image-rendering: pixelated;
        }
        
        /* Remove gap between buttons */
        #toolbar button:not(:last-child) {
            border-right: 1px solid rgba(85, 85, 85, 0.5);
        }
        
        /* Hotbar Selection Style (Minecraft-like) */
        #toolbar button.selected { 
            border-color: var(--selection-glow);
            background: rgba(255, 255, 255, 0.2);
            animation: none;
            transform: translateY(-4px) scale(1.08);
            z-index: 1;
            box-shadow: 0 8px 0 0 rgba(0, 0, 0, 0.6), 0 0 20px rgba(255, 255, 255, 0.6), inset 0 2px 0 0 rgba(255, 255, 255, 0.2);
        }
        #toolbar button:hover:not(.selected) { 
            border-color: #999;
            transform: translateY(-2px) scale(1.04);
            background: rgba(255, 255, 255, 0.1);
            box-shadow: inset -2px -2px 0 0 rgba(0, 0, 0, 0.4), inset 2px 2px 0 0 rgba(255, 255, 255, 0.15);
        }
        
        #toolbar button:active {
            transform: translateY(0);
        }

        /* Text Content in Hotbar Buttons */
        #toolbar button .slot-item {
            font-size: 11px; 
            font-weight: bold; 
            text-shadow: 1px 1px 2px #000; 
            line-height: 1.1;
        }
        #toolbar button .slot-count {
            position: absolute;
            bottom: 2px;
            right: 4px; 
            font-size: 10px;
            font-weight: bold;
            color: #fff;
            background: rgba(0, 0, 0, 0.5);
            padding: 1px 4px;
            border-radius: 4px;
            min-width: 10px;
            text-align: center;
        }
        
        /* Menu Container Styles with Parallax Animation (No Pattern) */
        #main-menu, #pause-menu { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: transparent;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center; 
            color: var(--primary-text); 
            z-index: 1000;
            transition: opacity 0.4s cubic-bezier(0.4, 0.0, 0.2, 1),
                        transform 0.4s cubic-bezier(0.4, 0.0, 0.2, 1);
        }
        
        /* Dark overlay behind main menu when in-game (separate layer) */
        #main-menu.in-game-overlay::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.75);
            z-index: -1;
        }
        
        /* Animation when settings opened from in-game */
        #main-menu.inventory-animate {
            animation: inventoryFadeIn 0.3s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }
        
        /* Only apply parallax to main menu, not pause menu */
        #main-menu {
            animation: bgParallax 120s linear infinite;
        }
        
        /* Menu button container - dark green translucent, matching settings style */
        #main-controls {
            background: rgba(25, 50, 30, 0.85) !important;
            padding: 40px 50px;
            border-radius: 0px !important;
            border: 4px solid rgba(140, 220, 100, 0.7) !important;
            box-shadow: 0 8px 0 0 rgba(0, 0, 0, 0.3), 
                        0 0 20px rgba(140, 220, 100, 0.5),
                        inset 0 2px 0 0 rgba(140, 220, 100, 0.3),
                        inset 0 0 30px rgba(140, 220, 100, 0.1) !important;
            transition: all 0.3s ease;
        }
        
        /* Animation when menus open */
        #main-menu.menu-fade-in {
            animation: menuFadeIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards,
                       bgParallax 120s linear infinite;
        }
        
        #pause-menu.menu-fade-in {
            animation: menuFadeIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }
        
        /* Main Menu Title Styling - Blocky Minecraft Logo */
        #main-menu h1 {
            font-size: 72px;
            margin-bottom: 50px;
            text-shadow: 6px 6px 0 rgba(0, 0, 0, 0.9);
            letter-spacing: 8px;
            animation: titleEntry 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            background: linear-gradient(135deg, #79C05A 0%, #F7DC6F 50%, #79C05A 100%);
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 900;
            position: relative;
            filter: drop-shadow(4px 4px 0 rgba(0, 0, 0, 0.7));
            animation: titleEntry 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) forwards, titleShine 3s linear infinite;
        }
        
        #main-menu h1::after {
            content: 'HTML EDITION';
            display: block;
            font-size: 18px;
            color: #F7DC6F;
            text-shadow: 3px 3px 0 rgba(0, 0, 0, 0.8);
            letter-spacing: 8px;
            margin-top: 15px;
            -webkit-text-fill-color: #F7DC6F;
            font-weight: 400;
        }
        
        /* REDESIGNED: Inventory Screen (Full Layout) */
        #inventory-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: transparent; /* Overlay is separate now */
            display: none;
            align-items: center; 
            justify-content: center; 
            color: var(--primary-text); 
            z-index: 1000;
            padding: 20px;
            overflow-y: auto;
            transition: opacity 0.4s cubic-bezier(0.4, 0.0, 0.2, 1),
                        transform 0.4s cubic-bezier(0.4, 0.0, 0.2, 1);
        }
        
        /* Dark overlay behind inventory (separate layer) */
        #inventory-screen::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.75);
            z-index: -1;
        }
        
        /* Animation when inventory opens */
        #inventory-screen.inventory-animate {
            animation: inventoryFadeIn 0.3s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }

        /* REDESIGNED: Unified Inventory & Crafting Layout */
        .inventory-container {
            padding: 18px; 
            background: rgba(25, 50, 30, 0.95);
            border-radius: 0px; 
            box-shadow: 0 12px 0 0 rgba(0, 0, 0, 0.6), 
                        0 0 40px rgba(0, 0, 0, 0.8),
                        inset 0 0 60px rgba(0, 0, 0, 0.4);
            border: 6px solid rgba(140, 220, 100, 0.9);
            outline: 3px solid rgba(0, 0, 0, 0.8);
            outline-offset: -9px;
            max-width: 920px; /* Increased to accommodate wider creative panel */
            width: 95%;
            display: flex;
            flex-direction: column;
            gap: 15px;
            position: relative;
            margin: auto;
            transition: all 0.4s cubic-bezier(0.4, 0.0, 0.2, 1),
                        width 0.4s cubic-bezier(0.4, 0.0, 0.2, 1),
                        max-width 0.4s cubic-bezier(0.4, 0.0, 0.2, 1),
                        padding 0.4s cubic-bezier(0.4, 0.0, 0.2, 1),
                        transform 0.4s cubic-bezier(0.4, 0.0, 0.2, 1);
        }
        .inventory-container h2 { 
            text-align: center; 
            margin: 0 0 5px 0; 
            font-size: 22px;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.8);
            letter-spacing: 1.5px;
            color: var(--main-action);
        }
        
        /* REDESIGNED: Inventory Main Layout */
        .inventory-main-section {
            display: flex;
            gap: 15px;
            align-items: flex-start;
        }

        .inventory-storage-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
            border: 4px solid rgba(140, 220, 100, 0.7);
            padding: 12px;
            background: rgba(0, 0, 0, 0.2);
            box-shadow: 0 0 20px rgba(140, 220, 100, 0.5),
                        inset 0 2px 0 0 rgba(140, 220, 100, 0.3),
                        inset 0 0 30px rgba(140, 220, 100, 0.1);
        }

        /* Main Inventory Grid (8x3) */
        #main-inventory-grid {
            display: grid;
            grid-template-columns: repeat(8, 50px); 
            gap: 5px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.5);
            border: 3px solid var(--inventory-border);
            border-radius: 0px; 
            pointer-events: all; 
            box-shadow: inset 0 4px 10px rgba(0, 0, 0, 0.6), 0 2px 0 rgba(255, 255, 255, 0.05);
            justify-content: center;
        }

        /* HUD Inventory Grid (8 Slots, Perfectly Aligned) */
        #hud-inventory-grid {
            display: grid;
            grid-template-columns: repeat(8, 50px); 
            gap: 5px;
            padding: 12px;
            background: linear-gradient(135deg, rgba(121, 192, 90, 0.15) 0%, rgba(121, 192, 90, 0.1) 100%);
            border: 4px solid var(--main-action); 
            border-radius: 0px; 
            pointer-events: all;
            box-shadow: 0 6px 0 0 rgba(0, 0, 0, 0.6), 0 0 20px rgba(121, 192, 90, 0.4), inset 0 3px 0 0 rgba(255, 255, 255, 0.1);
            justify-content: center;
            position: relative;
        }

        
        /* Section Labels */
        .inventory-section-label {
            font-size: 11px;
            font-weight: bold;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-align: left;
            margin: 0;
            padding: 4px 6px;
            background: rgba(0, 0, 0, 0.3);
            border-left: 2px solid var(--main-action);
            border-radius: 2px;
        }

        /* NEW: Game Mode Toggle Button (Minecraft Style) */
        #gameModeToggleBtn {
            width: 100%;
            padding: 12px 20px;
            font-size: 14px;
            font-family: 'Pixelify Sans', monospace;
            background: linear-gradient(135deg, rgba(60, 63, 72, 0.95) 0%, rgba(40, 43, 52, 0.95) 100%);
            border: 3px solid rgba(121, 192, 90, 0.6);
            border-radius: 0px;
            color: white;
            cursor: pointer;
            margin-top: 10px;
            transition: all 0.2s ease;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            box-shadow: 
                0 4px 0 0 rgba(0, 0, 0, 0.6),
                inset 0 -2px 0 0 rgba(0, 0, 0, 0.4),
                inset 0 2px 0 0 rgba(255, 255, 255, 0.15);
            font-weight: 600;
            position: relative;
            overflow: hidden;
        }
        
        #gameModeToggleBtn::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: linear-gradient(135deg, rgba(121, 192, 90, 0.6), rgba(247, 220, 111, 0.6));
            border-radius: 0px;
            z-index: -1;
            opacity: 0;
            transition: opacity 0.4s ease;
        }
        
        #gameModeToggleBtn:hover::before {
            opacity: 1;
        }
        
        #gameModeToggleBtn:hover { 
            background: linear-gradient(135deg, rgba(80, 83, 92, 0.95) 0%, rgba(60, 63, 72, 0.95) 100%);
            transform: translateY(-4px) scale(1.03);
            box-shadow: 
                0 12px 24px rgba(0, 0, 0, 0.7), 
                0 0 20px rgba(121, 192, 90, 0.6),
                inset 0 -4px 0 0 rgba(0, 0, 0, 0.3),
                inset 0 4px 0 0 rgba(255, 255, 255, 0.25);
            border-color: rgba(121, 192, 90, 0.9);
        }
        
        #gameModeToggleBtn:active {
            transform: translateY(1px) scale(0.97);
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.5),
                inset 0 -2px 0 0 rgba(0, 0, 0, 0.3),
                inset 0 2px 0 0 rgba(255, 255, 255, 0.1);
        }
        
        /* NEW: Creative Panel (Integrated within inventory) - FIXED HEIGHT */
        #creative-panel {
            display: none;
            flex-direction: row;
            gap: 12px;
            align-items: flex-start;
            padding: 10px;
            background: rgba(15, 30, 18, 0.5);
            border-radius: 0px;
            border: 2px solid rgba(140, 220, 100, 0.4);
            box-shadow: inset 0 0 20px rgba(140, 220, 100, 0.05);
        }

        /* Show panel when inventory is open in creative mode */
        #inventory-screen.creative-mode #creative-panel {
            display: flex;
        }

        /* Creative Block Picker (Integrated) - FIXED HEIGHT */
        #creative-block-picker {
            display: grid;
            grid-template-columns: repeat(8, 52px); /* 8 columns for better layout */
            gap: 4px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            border: 2px solid #555;
            height: 220px; /* Increased height for better visibility */
            overflow-y: scroll;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.4);
            justify-content: start; /* Align items to start */
            align-content: start; /* Align rows to start */
        }
        
        #creative-block-picker .inventory-slot {
            width: 52px;
            height: 52px;
            border-color: var(--hotbar-border);
        }
        
        /* Larger text for creative picker slots */
        #creative-block-picker .inventory-slot .slot-item {
            font-size: 12px;
        }
        
        #creative-block-picker .inventory-slot .slot-count {
            font-size: 12px;
        }
        
        /* Creative Picker Wrapper */
        #creative-picker-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 480px; /* Ensure enough width for 8-column grid */
        }
        
        /* Category Tabs */
        #category-tabs {
            display: flex;
            gap: 2px;
            margin-bottom: 5px;
            flex-wrap: wrap;
        }
        
        .category-tab {
            flex: 1;
            min-width: 75px;
            padding: 12px 16px;
            font-size: 12px;
            font-weight: 600;
            color: var(--primary-text);
            background: linear-gradient(135deg, rgba(60, 63, 72, 0.95) 0%, rgba(40, 43, 52, 0.95) 100%);
            border: 3px solid rgba(121, 192, 90, 0.5);
            border-radius: 0px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            font-family: 'Pixelify Sans', monospace;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.9);
            box-shadow: 
                0 4px 0 0 rgba(0, 0, 0, 0.6),
                inset 0 2px 0 0 rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }
        
        .category-tab::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: linear-gradient(135deg, rgba(121, 192, 90, 0.6), rgba(247, 220, 111, 0.6));
            border-radius: 0px;
            z-index: -1;
            opacity: 0;
            transition: opacity 0.4s ease;
        }
        
        .category-tab:hover::before {
            opacity: 1;
        }
        
        .category-tab:hover {
            background: linear-gradient(135deg, rgba(80, 83, 92, 0.95) 0%, rgba(60, 63, 72, 0.95) 100%);
            border-color: rgba(121, 192, 90, 0.9);
            color: #fff;
            box-shadow: 
                0 6px 0 0 rgba(0, 0, 0, 0.6), 
                0 0 20px rgba(121, 192, 90, 0.6),
                inset 0 3px 0 0 rgba(255, 255, 255, 0.2);
            transform: translateY(-4px);
        }
        
        .category-tab.active {
            background: linear-gradient(135deg, rgba(121, 192, 90, 0.95) 0%, rgba(90, 143, 60, 0.95) 100%);
            border-color: rgba(140, 220, 100, 1);
            color: #fff;
            box-shadow: 
                0 6px 0 0 rgba(0, 0, 0, 0.6),
                0 0 25px rgba(140, 220, 100, 0.8),
                inset 0 3px 0 0 rgba(255, 255, 255, 0.2);
        }
        
        .category-tab:active {
            transform: translateY(1px);
            box-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.5),
                inset 0 2px 0 0 rgba(0, 0, 0, 0.3);
        }
        
        /* Scrollbar Styling */
        #creative-block-picker::-webkit-scrollbar {
            width: 14px;
        }
        #creative-block-picker::-webkit-scrollbar-track {
            background: rgba(15, 30, 18, 0.8);
            border: 2px solid rgba(140, 220, 100, 0.3);
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.8);
        }
        #creative-block-picker::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, rgba(50, 80, 55, 0.9) 0%, rgba(30, 60, 35, 0.9) 50%, rgba(50, 80, 55, 0.9) 100%);
            border: 2px solid rgba(140, 220, 100, 0.5);
            box-shadow: inset 0 1px 0 rgba(140, 220, 100, 0.3),
                        inset 0 -1px 0 rgba(0, 0, 0, 0.5),
                        0 0 8px rgba(140, 220, 100, 0.3),
                        0 2px 4px rgba(0, 0, 0, 0.5);
        }
        #creative-block-picker::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, rgba(70, 100, 75, 1) 0%, rgba(50, 80, 55, 1) 50%, rgba(70, 100, 75, 1) 100%);
            border-color: rgba(140, 220, 100, 0.8);
            box-shadow: inset 0 1px 0 rgba(140, 220, 100, 0.5),
                        inset 0 -1px 0 rgba(0, 0, 0, 0.6),
                        0 0 15px rgba(140, 220, 100, 0.6),
                        0 2px 6px rgba(0, 0, 0, 0.6);
        }
        
        /* Delete Slot Wrapper */
        #delete-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        
        /* REDESIGNED: Delete Slot (Enhanced) */
        #delete-slot {
            width: 54px;
            height: 54px;
            background: linear-gradient(135deg, rgba(217, 83, 79, 0.2) 0%, var(--item-slot-bg) 100%);
            border: 3px solid var(--warning-color);
            border-radius: 0px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 6px 0 0 rgba(0, 0, 0, 0.6), inset 0 2px 0 0 rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
            position: relative;
        }
        
        /* Enhanced Pixelated X */
        #delete-slot::before,
        #delete-slot::after {
            content: '';
            position: absolute;
            background: var(--warning-color);
            box-shadow: 0 0 10px var(--warning-color);
        }
        
        #delete-slot::before {
            width: 6px;
            height: 34px;
            transform: rotate(45deg);
        }
        
        #delete-slot::after {
            width: 6px;
            height: 34px;
            transform: rotate(-45deg);
        }
        
        #delete-slot:hover {
            transform: scale(1.12);
            box-shadow: 0 8px 0 0 rgba(0, 0, 0, 0.6), 0 0 25px var(--warning-color);
            background: linear-gradient(135deg, rgba(217, 83, 79, 0.4) 0%, var(--item-slot-bg) 100%);
            border-color: #ff5555;
        }
        
        #delete-slot:active {
            transform: scale(1.05) translateY(2px);
            box-shadow: 0 3px 0 0 rgba(0, 0, 0, 0.6);
        }

        /* REDESIGNED: Default Slot Styling (Enhanced) */
        .inventory-slot {
            width: 50px;
            height: 50px;
            border: 3px solid var(--hotbar-border);
            background: var(--hotbar-slot-bg);
            border-radius: 0px; 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            color: #ccc;
            transition: all 0.15s ease;
            position: relative; 
            cursor: pointer;
            box-shadow: inset -2px -2px 0 0 rgba(0, 0, 0, 0.4), inset 2px 2px 0 0 rgba(255, 255, 255, 0.1);
            image-rendering: pixelated;
        }
        
        .inventory-slot:hover {
            border-color: #999;
            transform: translateY(-3px) scale(1.05);
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 6px 0 0 rgba(0, 0, 0, 0.4), inset 0 2px 0 0 rgba(255, 255, 255, 0.15);
        }
        
        .inventory-slot:active {
            transform: translateY(1px);
            box-shadow: inset 0 4px 8px rgba(0, 0, 0, 0.6);
        }
        
        /* Block picker slots - removed duplicate styling */

        /* HUD Slot Styling */
        .inventory-slot.hud-slot {
            background: var(--hotbar-slot-bg); 
            border: 3px solid var(--hotbar-border);
            width: 50px;
            height: 50px;
        }
        
        /* Selection Highlight */
        .slot-selected {
            border-color: var(--selection-glow) !important; 
            background: linear-gradient(135deg, rgba(0, 191, 255, 0.3) 0%, rgba(60, 63, 72, 0.9) 100%);
            box-shadow: 0 6px 0 0 rgba(0, 0, 0, 0.6), 0 0 20px rgba(0, 191, 255, 0.9), inset 0 2px 0 0 rgba(0, 191, 255, 0.3);
        }
        
        /* Text Content in Inventory Slots */
        .inventory-slot .slot-item { 
            font-size: 11px; 
            font-weight: bold;
            color: white; 
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.8); 
            text-align: center;
            line-height: 1;
            pointer-events: none;
        }
        
        .inventory-slot .slot-count { 
            position: absolute;
            bottom: 3px;
            right: 5px;
            font-size: 11px; 
            font-weight: bold;
            color: white; 
            background: rgba(0, 0, 0, 0.6);
            padding: 2px 5px;
            border-radius: 3px;
            min-width: 18px;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.9);
            pointer-events: none;
        }
        
        /* Durability bar for tools */
        .inventory-slot .slot-durability {
            position: absolute;
            bottom: 12px;
            left: 4px;
            right: 4px;
            height: 4px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 0px;
            overflow: hidden;
            pointer-events: none;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .inventory-slot .slot-durability-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444 0%, #ffaa00 50%, #44ff44 100%);
            transition: width 0.3s ease;
        }

        /* NEW: Tooltip styling for inventory items */
        .inventory-slot-tooltip {
            position: absolute;
            bottom: 110%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 8px 12px;
            border-radius: 0px;
            font-size: 11px;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 3000;
            border: 2px solid rgba(121, 192, 90, 0.6);
            box-shadow: 0 6px 0 0 rgba(0, 0, 0, 0.6);
        }

        .inventory-slot:hover .inventory-slot-tooltip {
            opacity: 1;
        }

        .inventory-slot-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 0;
            width: 0;
            height: 0;
        }

        /* MODIFIED: Item held by the fake mouse (Minecraft Style) */
        #picked-up-item {
            width: 50px;
            height: 50px;
            border: 4px solid var(--main-action);
            background: var(--item-slot-bg);
            border-radius: 0px; 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #ccc;
            position: fixed; /* Changed to fixed to prevent scrolling issues */
            z-index: 2600; /* Higher than fake cursor */
            pointer-events: none;
            box-shadow: 0 6px 0 0 rgba(0, 0, 0, 0.6), 0 0 20px var(--main-action), inset 0 2px 0 0 rgba(255, 255, 255, 0.2);
            transform: translate(-50%, -50%);
            will-change: transform; /* Performance optimization */
        }
        
        /* Menu Control/Button Styles with Enhanced Minecraft Look */
        .menu-view { 
            display: flex; flex-direction: column; align-items: center; 
            padding: 50px 60px; 
            background: var(--menu-bg-accent); 
            border-radius: 0px; 
            box-shadow: 0 8px 0 0 rgba(0, 0, 0, 0.8), inset 0 2px 0 0 rgba(255, 255, 255, 0.1);
            border: 4px solid #666;
            transition: all 0.2s ease;
            max-width: 90%;
            width: auto;
        }
        
        /* Animation when menu view is shown */
        .menu-view.menu-animate {
            animation: menuSlideIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }
        
        /* Dark green translucent background for all menu views */
        #creation-view, #saved-worlds-view, #settings-view, #credits-view, 
        #video-settings-view, #controls-settings-view, #audio-settings-view, #theme-settings-view {
            background: rgba(25, 50, 30, 0.85) !important;
            border: 4px solid rgba(140, 220, 100, 0.7) !important;
            box-shadow: 0 8px 0 0 rgba(0, 0, 0, 0.3), 
                        0 0 20px rgba(140, 220, 100, 0.5),
                        inset 0 2px 0 0 rgba(140, 220, 100, 0.3),
                        inset 0 0 30px rgba(140, 220, 100, 0.1) !important;
            border-radius: 0px !important;
            position: relative;
            overflow: hidden;
            transition: all 0.2s ease;
        }
        
        /* Scrollable Settings View */
        #settings-view {
            max-height: 80vh;
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 50px; /* Space for scrollbar */
            transition: max-height 0.4s cubic-bezier(0.4, 0.0, 0.2, 1),
                        padding 0.4s cubic-bezier(0.4, 0.0, 0.2, 1);
        }
        
        /* Custom scrollbar for settings */
        #settings-view::-webkit-scrollbar {
            width: 14px;
        }
        
        #settings-view::-webkit-scrollbar-track {
            background: rgba(15, 30, 18, 0.8);
            border: 2px solid rgba(140, 220, 100, 0.3);
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.8);
        }
        
        #settings-view::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, rgba(50, 80, 55, 0.9) 0%, rgba(30, 60, 35, 0.9) 50%, rgba(50, 80, 55, 0.9) 100%);
            border: 2px solid rgba(140, 220, 100, 0.5);
            box-shadow: inset 0 1px 0 rgba(140, 220, 100, 0.3),
                        inset 0 -1px 0 rgba(0, 0, 0, 0.5),
                        0 0 8px rgba(140, 220, 100, 0.3),
                        0 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        #settings-view::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, rgba(70, 100, 75, 1) 0%, rgba(50, 80, 55, 1) 50%, rgba(70, 100, 75, 1) 100%);
            border-color: rgba(140, 220, 100, 0.8);
            box-shadow: inset 0 1px 0 rgba(140, 220, 100, 0.5),
                        inset 0 -1px 0 rgba(0, 0, 0, 0.6),
                        0 0 15px rgba(140, 220, 100, 0.6),
                        0 2px 6px rgba(0, 0, 0, 0.6);
        }
        
        /* Settings History Scrollbar */
        #settings-history::-webkit-scrollbar {
            width: 12px;
        }
        
        #settings-history::-webkit-scrollbar-track {
            background: rgba(15, 30, 18, 0.6);
            border: 1px solid rgba(140, 220, 100, 0.3);
        }
        
        #settings-history::-webkit-scrollbar-thumb {
            background: rgba(50, 80, 55, 0.8);
            border: 2px solid rgba(140, 220, 100, 0.5);
            box-shadow: 0 0 6px rgba(140, 220, 100, 0.3);
        }
        
        #settings-history::-webkit-scrollbar-thumb:hover {
            background: rgba(70, 100, 75, 1);
            border-color: rgba(140, 220, 100, 0.8);
            box-shadow: 0 0 12px rgba(140, 220, 100, 0.6);
        }
        
        /* Scrollbar for all settings sub-views */
        #video-settings-view::-webkit-scrollbar,
        #audio-settings-view::-webkit-scrollbar,
        #controls-settings-view::-webkit-scrollbar,
        #theme-settings-view::-webkit-scrollbar,
        #credits-view::-webkit-scrollbar {
            width: 14px;
        }
        
        #video-settings-view::-webkit-scrollbar-track,
        #audio-settings-view::-webkit-scrollbar-track,
        #controls-settings-view::-webkit-scrollbar-track,
        #theme-settings-view::-webkit-scrollbar-track,
        #credits-view::-webkit-scrollbar-track {
            background: rgba(15, 30, 18, 0.8);
            border: 2px solid rgba(140, 220, 100, 0.3);
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.8);
        }
        
        #video-settings-view::-webkit-scrollbar-thumb,
        #audio-settings-view::-webkit-scrollbar-thumb,
        #controls-settings-view::-webkit-scrollbar-thumb,
        #theme-settings-view::-webkit-scrollbar-thumb,
        #credits-view::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, rgba(50, 80, 55, 0.9) 0%, rgba(30, 60, 35, 0.9) 50%, rgba(50, 80, 55, 0.9) 100%);
            border: 2px solid rgba(140, 220, 100, 0.5);
            box-shadow: inset 0 1px 0 rgba(140, 220, 100, 0.3),
                        inset 0 -1px 0 rgba(0, 0, 0, 0.5),
                        0 0 8px rgba(140, 220, 100, 0.3),
                        0 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        #video-settings-view::-webkit-scrollbar-thumb:hover,
        #audio-settings-view::-webkit-scrollbar-thumb:hover,
        #controls-settings-view::-webkit-scrollbar-thumb:hover,
        #theme-settings-view::-webkit-scrollbar-thumb:hover,
        #credits-view::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, rgba(70, 100, 75, 1) 0%, rgba(50, 80, 55, 1) 50%, rgba(70, 100, 75, 1) 100%);
            border-color: rgba(140, 220, 100, 0.8);
            box-shadow: inset 0 1px 0 rgba(140, 220, 100, 0.5),
                        inset 0 -1px 0 rgba(0, 0, 0, 0.6),
                        0 0 15px rgba(140, 220, 100, 0.6),
                        0 2px 6px rgba(0, 0, 0, 0.6);
        }
        
        /* Graphics Preset Dropdown Styling */
        #graphicsPreset {
            background: rgba(0, 0, 0, 0.8) !important;
            z-index: 100;
            transition: all 0.2s ease;
        }
        
        #graphicsPreset:hover {
            border-color: var(--main-action);
            background: rgba(0, 0, 0, 0.9) !important;
        }
        
        #graphicsPreset:focus {
            outline: none;
            border-color: var(--main-action);
            box-shadow: 0 0 10px rgba(121, 192, 90, 0.3);
        }
        
        #graphicsPreset option {
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 10px;
        }
        
        #graphicsPreset option:hover {
            background: var(--main-action);
        }
        
        /* Custom Minecraft-style scrollbar for saved worlds list */
        #saved-worlds-list::-webkit-scrollbar {
            width: 16px;
        }
        
        #saved-worlds-list::-webkit-scrollbar-track {
            background: rgba(15, 30, 18, 0.9);
            border: 2px solid rgba(140, 220, 100, 0.3);
            box-shadow: inset 0 0 12px rgba(0, 0, 0, 0.9);
        }
        
        #saved-worlds-list::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, rgba(60, 90, 65, 1) 0%, rgba(40, 70, 45, 1) 50%, rgba(60, 90, 65, 1) 100%);
            border: 2px solid rgba(140, 220, 100, 0.6);
            box-shadow: inset 0 1px 0 rgba(140, 220, 100, 0.4), 
                        inset 0 -1px 0 rgba(0, 0, 0, 0.6),
                        0 0 10px rgba(140, 220, 100, 0.4),
                        0 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        #saved-worlds-list::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, rgba(80, 110, 85, 1) 0%, rgba(60, 90, 65, 1) 50%, rgba(80, 110, 85, 1) 100%);
            border-color: rgba(140, 220, 100, 0.9);
            box-shadow: inset 0 1px 0 rgba(140, 220, 100, 0.6), 
                        inset 0 -1px 0 rgba(0, 0, 0, 0.7),
                        0 0 18px rgba(140, 220, 100, 0.7),
                        0 2px 6px rgba(0, 0, 0, 0.6);
        }
        
        #saved-worlds-list::-webkit-scrollbar-thumb:active {
            background: linear-gradient(180deg, rgba(50, 75, 55, 1) 0%, rgba(30, 55, 35, 1) 50%, rgba(50, 75, 55, 1) 100%);
            box-shadow: inset 0 1px 0 rgba(140, 220, 100, 0.3),
                        0 0 8px rgba(140, 220, 100, 0.5);
        }
        
        /* Saved World Card Styles */
        .saved-world-card {
            background: var(--menu-bg-accent);
            border: 4px solid #444;
            border-radius: 0px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 4px 0 0 rgba(0, 0, 0, 0.8), inset 0 2px 0 0 rgba(255, 255, 255, 0.1);
            transition: all 0.2s ease;
            display: flex;
            gap: 15px;
            align-items: center;
        }
        
        .saved-world-card:hover {
            border-color: var(--main-action);
            transform: translateY(-2px);
            box-shadow: 0 6px 0 0 rgba(0, 0, 0, 0.8), 0 0 20px rgba(121, 192, 90, 0.4);
        }
        
        .world-preview {
            width: 120px;
            height: 90px;
            border: 3px solid #555;
            border-radius: 0px;
            object-fit: cover;
            image-rendering: pixelated;
            background: var(--mc-dark-gray);
            flex-shrink: 0;
        }
        
        .world-info {
            flex: 1;
            text-align: left;
        }
        
        .world-name {
            font-size: 18px;
            font-weight: bold;
            color: var(--primary-text);
            margin-bottom: 8px;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.8);
            cursor: pointer;
            display: inline-block;
        }
        
        .world-name:hover {
            color: var(--main-action);
        }
        
        .world-details {
            font-size: 12px;
            color: #AAA;
            line-height: 1.6;
        }
        
        .world-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .world-action-btn {
            padding: 14px 22px;
            font-size: 14px;
            border: 4px solid rgba(121, 192, 90, 0.6);
            border-radius: 0px;
            color: var(--primary-text);
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            font-family: 'Pixelify Sans', monospace;
            font-weight: 600;
            text-shadow: 3px 3px 0 rgba(0, 0, 0, 0.9);
            box-shadow: 
                0 6px 0 0 rgba(0, 0, 0, 0.6),
                inset 0 3px 0 0 rgba(255, 255, 255, 0.15);
            position: relative;
            overflow: hidden;
            background: linear-gradient(135deg, rgba(60, 63, 72, 0.95) 0%, rgba(40, 43, 52, 0.95) 100%);
        }
        
        .world-action-btn::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: linear-gradient(135deg, rgba(121, 192, 90, 0.6), rgba(247, 220, 111, 0.6));
            border-radius: 0px;
            z-index: -1;
            opacity: 0;
            transition: opacity 0.4s ease;
        }
        
        .world-action-btn:hover::before {
            opacity: 1;
        }
        
        .world-action-btn:hover {
            transform: translateY(-5px) scale(1.04);
            box-shadow: 
                0 14px 28px rgba(0, 0, 0, 0.8), 
                0 0 25px rgba(121, 192, 90, 0.7),
                inset 0 4px 0 0 rgba(255, 255, 255, 0.25);
            border-color: rgba(121, 192, 90, 1);
            background: linear-gradient(135deg, rgba(80, 83, 92, 0.95) 0%, rgba(60, 63, 72, 0.95) 100%);
        }
        
        .world-action-btn:active {
            transform: translateY(2px) scale(0.96);
            box-shadow: 
                0 3px 6px rgba(0, 0, 0, 0.5),
                inset 0 2px 0 0 rgba(0, 0, 0, 0.4);
        }
        
        .world-action-btn.load {
            background: linear-gradient(135deg, rgba(121, 192, 90, 0.9) 0%, rgba(90, 143, 60, 0.9) 100%);
            border-color: rgba(121, 192, 90, 0.8);
        }
        
        .world-action-btn.load:hover {
            background: linear-gradient(135deg, rgba(140, 220, 100, 0.95) 0%, rgba(121, 192, 90, 0.95) 100%);
        }
        
        .world-action-btn.delete {
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.9) 0%, rgba(192, 57, 43, 0.9) 100%);
            border-color: rgba(231, 76, 60, 0.8);
        }
        
        .world-action-btn.delete:hover {
            background: linear-gradient(135deg, rgba(255, 100, 80, 0.95) 0%, rgba(231, 76, 60, 0.95) 100%);
        }
        
        /* Rename Modal */
        .rename-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(25, 50, 30, 0.95);
            border: 4px solid rgba(140, 220, 100, 0.8);
            border-radius: 0px;
            padding: 35px;
            z-index: 3000;
            box-shadow: 0 8px 0 0 rgba(0, 0, 0, 0.6), 0 0 40px rgba(0, 0, 0, 0.8), inset 0 3px 0 0 rgba(255, 255, 255, 0.1);
            transition: all 0.2s ease;
        }
        
        .rename-modal h3 {
            margin-bottom: 25px;
            text-shadow: 4px 4px 0 rgba(0, 0, 0, 0.9);
            font-size: 24px;
        }
        
        .rename-modal input {
            width: 320px;
            padding: 14px;
            font-size: 17px;
            border: 3px solid rgba(121, 192, 90, 0.6);
            background: rgba(0, 0, 0, 0.5);
            color: var(--primary-text);
            border-radius: 0px;
            margin-bottom: 25px;
            font-family: 'Pixelify Sans', monospace;
            box-shadow: inset 0 4px 8px rgba(0, 0, 0, 0.6);
            transition: all 0.2s ease;
        }
        
        .rename-modal input:focus {
            outline: none;
            border-color: var(--main-action);
            box-shadow: inset 0 4px 8px rgba(0, 0, 0, 0.6), 0 0 0 3px rgba(121, 192, 90, 0.3);
        }
        
        .rename-modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        .menu-view::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.05) 0%, transparent 50%, rgba(255, 255, 255, 0.05) 100%);
            pointer-events: none;
        }
        
        .menu-view h1, .menu-view h2 {
            text-shadow: 4px 4px 0 rgba(0, 0, 0, 0.8);
            letter-spacing: 3px;
            position: relative;
            z-index: 1;
        }
        .menu-control { margin: 10px 0; font-size: 16px; display: flex; align-items: center; justify-content: space-between; width: 350px; padding: 5px; }
        .menu-control label { text-align: right; padding-right: 15px; text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.5); }
        .menu-control input { 
            padding: 12px; font-size: 16px; 
            border: 3px solid #555; 
            background: #1a1a1a; 
            color: var(--primary-text); 
            width: 200px; text-align: center; 
            border-radius: 0px;
            box-shadow: inset 0 3px 6px rgba(0, 0, 0, 0.6);
            transition: all 0.2s ease;
        }
        
        .menu-control input:focus {
            outline: none;
            border-color: var(--main-action);
            box-shadow: inset 0 3px 6px rgba(0, 0, 0, 0.6), 0 0 0 2px rgba(121, 192, 90, 0.3);
        }
        .main-menu-btn { 
            padding: 18px 32px; 
            font-size: 17px; 
            border: 4px solid rgba(121, 192, 90, 0.6); 
            border-radius: 0px; 
            color: var(--primary-text); 
            cursor: pointer; 
            margin: 12px 0; 
            width: 340px;
            transition: all 0.2s ease;
            text-shadow: 3px 3px 0 rgba(0, 0, 0, 0.9);
            box-shadow: 
                0 6px 0 0 rgba(0, 0, 0, 0.6),
                inset 0 3px 0 0 rgba(255, 255, 255, 0.15);
            position: relative;
            font-family: 'Pixelify Sans', monospace;
            font-weight: 700;
            opacity: 1;
            letter-spacing: 1.5px;
            overflow: hidden;
            image-rendering: pixelated;
            background: linear-gradient(135deg, rgba(60, 63, 72, 0.95) 0%, rgba(40, 43, 52, 0.95) 100%);
        }
        
        /* Staggered animation delays for menu buttons - DISABLED */
        /* #main-controls button:nth-child(1) { animation-delay: 0.1s; }
        #main-controls button:nth-child(2) { animation-delay: 0.15s; }
        #main-controls button:nth-child(3) { animation-delay: 0.2s; }
        #main-controls button:nth-child(4) { animation-delay: 0.25s; }
        #main-controls button:nth-child(5) { animation-delay: 0.3s; } */
        
        /* Button shine effect overlay */
        .main-menu-btn::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: linear-gradient(135deg, rgba(121, 192, 90, 0.6), rgba(247, 220, 111, 0.6));
            border-radius: 8px;
            z-index: -1;
            opacity: 0;
            transition: opacity 0.4s cubic-bezier(0.4, 0.0, 0.2, 1),
                        transform 0.4s cubic-bezier(0.4, 0.0, 0.2, 1);
        }
        
        .main-menu-btn:hover::before {
            opacity: 1;
            animation: borderGlow 2s ease-in-out infinite;
        }
        
        .main-menu-btn:hover {
            transform: translateY(-8px) scale(1.06);
            box-shadow: 0 18px 36px rgba(0, 0, 0, 0.8), 
                        0 0 35px rgba(121, 192, 90, 0.7),
                        inset 0 4px 0 0 rgba(255, 255, 255, 0.25);
            border-color: rgba(121, 192, 90, 1);
            background: linear-gradient(135deg, rgba(80, 83, 92, 0.95) 0%, rgba(60, 63, 72, 0.95) 100%);
        }
        
        /* Fixed back buttons - OUTSIDE window, fixed to viewport */
        .fixed-back-btn {
            position: fixed !important;
            bottom: 30px !important;
            left: 50% !important;
            transform: translateX(-50%) !important;
            z-index: 10000 !important;
            margin: 0 !important;
        }
        
        .fixed-back-btn:hover {
            transform: translateX(-50%) !important;
            filter: brightness(1.1);
            border-color: rgba(121, 192, 90, 0.9);
        }
        
        .fixed-back-btn:active {
            transform: translateX(-50%) !important;
            filter: brightness(0.9);
        }
        
        .main-menu-btn:active {
            transform: translateY(2px) scale(0.96);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.5),
                        inset 0 2px 0 0 rgba(0, 0, 0, 0.5);
        }
        
        /* Settings category buttons with enhanced hover */
        .settings-category-btn {
            background: linear-gradient(135deg, rgba(60, 63, 72, 0.95) 0%, rgba(40, 43, 52, 0.95) 100%);
            border: 4px solid rgba(121, 192, 90, 0.6);
            padding: 18px;
            border-radius: 0px;
            transition: all 0.2s ease;
            position: relative;
            box-shadow: 
                0 6px 0 0 rgba(0, 0, 0, 0.6),
                inset 0 3px 0 0 rgba(255, 255, 255, 0.15);
            overflow: hidden;
        }
        
        .settings-category-btn::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: linear-gradient(135deg, rgba(121, 192, 90, 0.6), rgba(247, 220, 111, 0.6));
            border-radius: 0px;
            z-index: -1;
            opacity: 0;
            transition: opacity 0.4s ease;
        }
        
        .settings-category-btn:hover::before {
            opacity: 1;
        }
        
        .settings-category-btn:hover {
            background: linear-gradient(135deg, rgba(80, 83, 92, 0.95) 0%, rgba(60, 63, 72, 0.95) 100%);
            transform: translateY(-5px) scale(1.03);
            box-shadow: 
                0 14px 28px rgba(0, 0, 0, 0.8), 
                0 0 25px rgba(121, 192, 90, 0.7),
                inset 0 4px 0 0 rgba(255, 255, 255, 0.25);
            border-color: rgba(121, 192, 90, 1);
        }
        
        .settings-category-btn > div {
            position: relative;
            z-index: 1;
        }
        
        /* Settings search input enhancement */
        #settingsSearchInput::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }
        
        #settingsSearchInput:focus {
            outline: none;
            box-shadow: 0 0 15px rgba(121, 192, 90, 0.5);
        }
        
        #main-controls button:first-child { 
            background: linear-gradient(135deg, var(--main-action) 0%, var(--main-action-hover) 100%);
            border-color: rgba(121, 192, 90, 0.6);
        }
        #main-controls button:first-child:hover { 
            background: linear-gradient(135deg, var(--main-action-hover) 0%, var(--main-action) 100%);
        }
        
        /* ==================== EPIC CREDITS STYLING ==================== */
        
        /* Credits View Container - Dark Green Translucent */
        .epic-credits-view {
            background: rgba(25, 50, 30, 0.85) !important;
            border: 4px solid rgba(140, 220, 100, 0.7) !important;
            box-shadow: 0 8px 0 0 rgba(0, 0, 0, 0.3),
                        0 0 20px rgba(140, 220, 100, 0.5),
                        inset 0 4px 0 0 rgba(140, 220, 100, 0.3),
                        inset 0 -4px 0 0 rgba(0, 0, 0, 0.5),
                        inset 0 0 30px rgba(140, 220, 100, 0.1) !important;
            position: relative;
            overflow: hidden;
            min-height: 600px;
            perspective: 1000px;
            border-radius: 0px !important;
        }
        
        /* Floating Particles Background */
        .credits-particles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            pointer-events: none;
            z-index: 0;
            transition: transform 0.1s cubic-bezier(0.4, 0.0, 0.2, 1);
            will-change: transform;
        }
        
        .credits-particles::before,
        .credits-particles::after {
            content: '';
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(121, 192, 90, 0.6);
            border-radius: 50%;
            box-shadow: 
                0 0 10px rgba(121, 192, 90, 0.8),
                100px 200px 0 rgba(121, 192, 90, 0.5),
                200px 50px 0 rgba(247, 220, 111, 0.5),
                300px 300px 0 rgba(121, 192, 90, 0.6),
                150px 400px 0 rgba(247, 220, 111, 0.4),
                400px 150px 0 rgba(121, 192, 90, 0.5),
                250px 250px 0 rgba(247, 220, 111, 0.6),
                350px 450px 0 rgba(121, 192, 90, 0.4),
                450px 100px 0 rgba(247, 220, 111, 0.5),
                50px 350px 0 rgba(121, 192, 90, 0.6);
            animation: particleFloat 20s linear infinite;
        }
        
        .credits-particles::after {
            animation-delay: -10s;
            animation-duration: 25s;
        }
        
        /* Epic Credits Title */
        .credits-title {
            font-size: 48px !important;
            font-weight: 900 !important;
            background: linear-gradient(135deg, #79C05A 0%, #F7DC6F 50%, #79C05A 100%);
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titleShine 3s linear infinite, creditsFloat 3s ease-in-out infinite;
            margin-bottom: 40px !important;
            text-shadow: none !important;
            position: relative;
            z-index: 2;
            filter: drop-shadow(0 0 20px rgba(121, 192, 90, 0.6));
            transform-style: preserve-3d;
            transition: transform 0.1s cubic-bezier(0.4, 0.0, 0.2, 1);
            will-change: transform;
            cursor: pointer;
            user-select: none;
        }
        
        /* Credits Container */
        .credits-container {
            display: flex;
            flex-direction: column;
            gap: 30px;
            width: 100%;
            max-width: 500px;
            position: relative;
            z-index: 2;
            padding: 20px;
            transform-style: preserve-3d;
            transition: all 0.15s cubic-bezier(0.4, 0.0, 0.2, 1);
            will-change: transform;
        }
        
        /* Music Visualizer */
        .music-visualizer {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: 8px;
            align-items: flex-end;
            height: 80px;
            z-index: 1;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            border: 2px solid rgba(121, 192, 90, 0.3);
            box-shadow: 0 0 20px rgba(121, 192, 90, 0.3);
        }
        
        .visualizer-bar {
            width: 8px;
            height: 20%;
            background: linear-gradient(180deg, #79C05A 0%, #F7DC6F 100%);
            border-radius: 4px;
            transition: height 0.15s cubic-bezier(0.4, 0.0, 0.2, 1);
            box-shadow: 0 0 10px rgba(121, 192, 90, 0.6);
            animation: creditsFloat 2s ease-in-out infinite;
        }
        
        .visualizer-bar:nth-child(1) { animation-delay: 0s; }
        .visualizer-bar:nth-child(2) { animation-delay: 0.1s; }
        .visualizer-bar:nth-child(3) { animation-delay: 0.2s; }
        .visualizer-bar:nth-child(4) { animation-delay: 0.3s; }
        .visualizer-bar:nth-child(5) { animation-delay: 0.4s; }
        .visualizer-bar:nth-child(6) { animation-delay: 0.5s; }
        .visualizer-bar:nth-child(7) { animation-delay: 0.6s; }
        .visualizer-bar:nth-child(8) { animation-delay: 0.7s; }
        
        /* Individual Credit Card - Blocky Minecraft Style */
        .credit-card {
            background: linear-gradient(135deg, rgba(121, 192, 90, 0.2) 0%, rgba(121, 192, 90, 0.1) 100%);
            border: 3px solid rgba(121, 192, 90, 0.6);
            border-radius: 0px;
            padding: 25px;
            position: relative;
            overflow: hidden;
            transform-style: preserve-3d;
            animation: creditsEntrance 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            opacity: 0;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 20px;
            box-shadow: 0 4px 0 0 rgba(0, 0, 0, 0.6), inset 0 2px 0 0 rgba(255, 255, 255, 0.1);
        }
        
        .credit-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: transparent;
            z-index: -1;
            opacity: 0;
            transition: opacity 0.4s;
        }
        
        .credit-card:hover {
            transform: translateY(-2px);
            border-color: rgba(121, 192, 90, 0.9);
            box-shadow: 
                0 6px 0 0 rgba(0, 0, 0, 0.6),
                0 0 20px rgba(121, 192, 90, 0.5),
                inset 0 2px 0 0 rgba(255, 255, 255, 0.2);
            background: linear-gradient(135deg, rgba(121, 192, 90, 0.25) 0%, rgba(121, 192, 90, 0.15) 100%);
        }
        
        .credit-card:hover::before {
            opacity: 1;
            animation: borderGlow 2s ease-in-out infinite;
        }
        
        /* Animated Glow Effect */
        .credit-glow {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(121, 192, 90, 0.3) 0%, transparent 70%);
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: opacity 0.6s;
            pointer-events: none;
        }
        
        .credit-card:hover .credit-glow {
            opacity: 1;
            animation: pulse 2s ease-in-out infinite;
        }
        
        /* Credit Icon - Large Emoji with Glow */
        .credit-icon {
            font-size: 48px;
            filter: drop-shadow(0 0 15px rgba(121, 192, 90, 0.6));
            animation: creditsFloat 3s ease-in-out infinite;
            transition: all 0.4s cubic-bezier(0.4, 0.0, 0.2, 1);
            flex-shrink: 0;
            cursor: pointer;
            user-select: none;
        }
        
        .credit-card:hover .credit-icon {
            transform: scale(1.2) rotate(10deg);
            filter: drop-shadow(0 0 25px rgba(121, 192, 90, 0.9));
        }
        
        /* Credit Content */
        .credit-content {
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex: 1;
            text-align: left;
        }
        
        /* Credit Role - Title */
        .credit-role {
            font-weight: 700;
            font-size: 16px;
            color: #F7DC6F;
            text-shadow: 
                2px 2px 4px rgba(0, 0, 0, 0.8),
                0 0 10px rgba(247, 220, 111, 0.5);
            letter-spacing: 1px;
            text-transform: uppercase;
            animation: roleReveal 0.6s ease-out forwards;
            animation-delay: inherit;
            opacity: 0;
        }
        
        .credit-card:hover .credit-role {
            color: #79C05A;
            text-shadow: 
                2px 2px 4px rgba(0, 0, 0, 0.8),
                0 0 15px rgba(121, 192, 90, 0.8);
        }
        
        /* Credit Name - Person/Entity */
        .credit-name {
            font-size: 18px;
            font-weight: 600;
            color: #FFFFFF;
            text-shadow: 2px 2px 6px rgba(0, 0, 0, 0.9);
            animation: nameReveal 0.6s ease-out forwards;
            animation-delay: calc(var(--delay, 0s) + 0.2s);
            opacity: 0;
            line-height: 1.4;
        }
        
        .credit-card:nth-child(1) .credit-role,
        .credit-card:nth-child(1) .credit-name { animation-delay: 0.4s; }
        
        .credit-card:nth-child(2) .credit-role,
        .credit-card:nth-child(2) .credit-name { animation-delay: 0.6s; }
        
        .credit-card:nth-child(3) .credit-role,
        .credit-card:nth-child(3) .credit-name { animation-delay: 0.8s; }
        
        /* Epic Back Button */
        .credits-back-btn {
            margin-top: 40px !important;
            position: relative;
            z-index: 2;
            padding: 16px 28px;
            font-size: 16px;
            border: 3px solid rgba(121, 192, 90, 0.6);
            border-radius: 0px;
            color: var(--primary-text);
            cursor: pointer;
            font-family: 'Pixelify Sans', monospace;
            font-weight: 700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            background: linear-gradient(135deg, rgba(60, 63, 72, 0.95) 0%, rgba(40, 43, 52, 0.95) 100%);
            box-shadow: 
                0 4px 0 0 rgba(0, 0, 0, 0.6),
                inset 0 -2px 0 0 rgba(0, 0, 0, 0.4),
                inset 0 2px 0 0 rgba(255, 255, 255, 0.15);
            transition: all 0.2s ease;
            overflow: hidden;
            animation: buttonEntry 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) 1s forwards;
            opacity: 0;
        }
        
        .credits-back-btn::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: linear-gradient(135deg, rgba(121, 192, 90, 0.6), rgba(247, 220, 111, 0.6));
            border-radius: 0px;
            z-index: -1;
            opacity: 0;
            transition: opacity 0.4s ease;
        }
        
        .credits-back-btn:hover::before {
            opacity: 1;
        }
        
        .credits-back-btn:hover {
            background: linear-gradient(135deg, rgba(80, 83, 92, 0.95) 0%, rgba(60, 63, 72, 0.95) 100%);
            transform: translateY(-6px) scale(1.05);
            box-shadow: 
                0 16px 32px rgba(0, 0, 0, 0.7), 
                0 0 30px rgba(121, 192, 90, 0.6),
                inset 0 -4px 0 0 rgba(0, 0, 0, 0.3),
                inset 0 4px 0 0 rgba(255, 255, 255, 0.25);
            border-color: rgba(121, 192, 90, 0.9);
        }
        
        .credits-back-btn:active {
            transform: translateY(1px) scale(0.97);
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.5),
                inset 0 -2px 0 0 rgba(0, 0, 0, 0.3),
                inset 0 2px 0 0 rgba(255, 255, 255, 0.1);
        }
        
        /* ==================== END EPIC CREDITS STYLING ==================== */
        
        /* MODIFIED: Pause Menu Styling (Minecraft Style) */
        #pause-menu { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: transparent; /* Overlay is separate now */
            display: none;
            flex-direction: column; 
            align-items: center; justify-content: center; 
            color: var(--primary-text); 
            z-index: 1000;
            font-size: 18px;
            animation: none !important; /* Force disable any parallax animation */
        }
        
        /* Dark overlay behind pause menu (separate layer) */
        #pause-menu::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.75);
            z-index: -1;
        }
        
        /* Animation when pause menu opens */
        #pause-menu.inventory-animate {
            animation: inventoryFadeIn 0.3s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }
        
        /* MODIFIED: Menu View for Pause Menu - dark green translucent with clear frame */
        #pause-menu .menu-view {
            padding: 40px 50px; 
            background: rgba(25, 50, 30, 0.95);
            border-radius: 0px;
            box-shadow: 0 12px 0 0 rgba(0, 0, 0, 0.6), 
                        0 0 40px rgba(0, 0, 0, 0.8),
                        inset 0 0 60px rgba(0, 0, 0, 0.4);
            border: 6px solid rgba(140, 220, 100, 0.9);
            outline: 3px solid rgba(0, 0, 0, 0.8);
            outline-offset: -9px;
            width: 450px;
            text-align: center;
            position: relative;
        }

        #pause-menu h2 { 
            font-size: 28px; 
            margin-bottom: 25px; 
            color: var(--warning-color);
            text-shadow: 3px 3px 0 rgba(0, 0, 0, 0.8);
            letter-spacing: 2px;
        }

        #pause-menu p { 
            max-width: 400px; 
            text-align: center; 
            margin-top: 10px; 
            font-size: 16px;
            color: #ccc;
            text-shadow: 1px 1px 0 rgba(0, 0, 0, 0.5);
        }

        #pause-menu .menu-control { 
            margin: 15px 0; 
            width: 100%;
        }

        #progress-warning { 
            color: var(--primary-text);
            background: var(--warning-color); 
            padding: 8px 15px;
            border-radius: 4px;
            font-weight: bold; 
            margin-top: 20px; 
            margin-bottom: 25px;
            box-shadow: 0 4px 0 0 rgba(0, 0, 0, 0.4);
        }
        
        
        /* MODIFIED: Simplified Bottom Right Version Text */
        #version-text { 
            position: absolute; 
            bottom: 5px; 
            right: 5px; 
            color: rgba(255, 255, 255, 0.5); 
            font-size: 10px; 
            pointer-events: none; 
            z-index: 5; 
            text-align: right; 
        }
        
        /* Enhanced Music Toast Notification with Progress & Visualizer */
        #music-toast {
            position: fixed;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(20, 20, 20, 0.95) 100%);
            color: white;
            padding: 16px 20px;
            border-radius: 12px;
            border: 3px solid rgba(121, 192, 90, 0.5);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6), 
                        0 0 20px rgba(121, 192, 90, 0.3),
                        inset 0 -2px 0 rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.1);
            font-family: 'Pixelify Sans', monospace;
            font-size: 14px;
            font-weight: 600;
            z-index: 10000;
            pointer-events: none;
            display: none;
            animation: slideInLeft 0.3s ease-out;
            min-width: 320px;
            backdrop-filter: blur(10px);
            transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        /* Position variants */
        #music-toast.position-top-left {
            top: 20px;
            left: 20px;
        }
        
        #music-toast.position-top-right {
            top: 20px;
            right: 20px;
        }
        
        #music-toast.position-bottom-left {
            bottom: 20px;
            left: 20px;
        }
        
        #music-toast.position-bottom-right {
            bottom: 20px;
            right: 20px;
        }
        
        #music-toast.menu-mode {
            display: flex !important;
            flex-direction: column;
            gap: 12px;
            padding: 16px 20px;
            min-width: 320px;
            border-radius: 12px;
            animation: expandBounce 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        /* Pill Mode - Compact view for in-game */
        #music-toast.pill-mode {
            display: flex !important;
            flex-direction: column;
            align-items: stretch;
            gap: 6px;
            padding: 8px 12px 6px 12px;
            min-width: auto;
            width: auto;
            max-width: 220px;
            border-radius: 50px;
            background: rgba(32, 34, 37, 0.85);
            border: 1.5px solid rgba(121, 192, 90, 0.3);
            box-shadow: 
                0 2px 8px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            animation: shrinkBounce 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            cursor: pointer;
            pointer-events: auto;
        }
        
        #music-toast.pill-mode:hover {
            transform: scale(1.05);
            border-color: rgba(121, 192, 90, 0.5);
            box-shadow: 
                0 4px 12px rgba(0, 0, 0, 0.6),
                inset 0 1px 0 rgba(255, 255, 255, 0.15),
                0 0 20px rgba(121, 192, 90, 0.3);
        }
        
        /* Pill mode positioning offsets */
        #music-toast.pill-mode.position-top-left {
            top: 10px;
            left: 10px;
        }
        
        #music-toast.pill-mode.position-top-right {
            top: 10px;
            right: 10px;
        }
        
        #music-toast.pill-mode.position-bottom-left {
            bottom: 10px;
            left: 10px;
        }
        
        #music-toast.pill-mode.position-bottom-right {
            bottom: 10px;
            right: 10px;
        }
        
        /* Expanded state when clicked */
        #music-toast.expanded {
            max-width: 350px !important;
            padding: 16px 20px !important;
            border-radius: 12px !important;
            animation: expandSmooth 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards !important;
            pointer-events: auto !important;
        }
        
        #music-toast.expanded #music-toast-header {
            gap: 12px !important;
        }
        
        #music-toast.expanded #music-toast-text {
            font-size: 15px !important;
            opacity: 1 !important;
            width: auto !important;
            max-width: 100% !important;
        }
        
        #music-toast.expanded #music-toast-icon {
            font-size: 24px !important;
        }
        
        #music-toast.expanded #music-toast-time {
            font-size: 11px !important;
            opacity: 1 !important;
            margin-left: 0 !important;
        }
        
        #music-toast.expanded #music-toast-info {
            flex-direction: column !important;
            gap: 4px !important;
        }
        
        #music-toast.expanded #music-progress-container {
            display: block !important;
        }
        
        #music-toast.expanded #music-visualizer-toast {
            display: flex !important;
        }
        
        @keyframes expandSmooth {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        #music-toast.hiding {
            animation: slideOutLeft 0.3s ease-in forwards;
        }
        
        /* Smoother animations */
        @keyframes shrinkBounce {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            40% {
                transform: scale(0.9);
            }
            60% {
                transform: scale(1.03);
            }
            80% {
                transform: scale(0.97);
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        @keyframes expandBounce {
            0% {
                transform: scale(1);
            }
            40% {
                transform: scale(1.05);
            }
            60% {
                transform: scale(0.98);
            }
            80% {
                transform: scale(1.01);
            }
            100% {
                transform: scale(1);
            }
        }
        
        #music-toast-header {
            display: flex;
            align-items: center;
            gap: 12px;
            transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        #music-toast.pill-mode #music-toast-header {
            gap: 6px;
        }
        
        #music-toast-icon {
            display: inline-block;
            font-size: 24px;
            animation: pulse 2s ease-in-out infinite;
            transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        #music-toast.pill-mode #music-toast-icon {
            font-size: 14px;
        }
        
        #music-toast-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
            transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        #music-toast.pill-mode #music-toast-info {
            flex-direction: row;
            align-items: center;
            gap: 4px;
        }
        
        #music-toast-text {
            font-size: 15px;
            font-weight: 700;
            color: #79C05A;
            text-shadow: 0 0 10px rgba(121, 192, 90, 0.5);
            transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            white-space: nowrap;
            overflow: hidden;
        }
        
        #music-toast.pill-mode #music-toast-text {
            font-size: 11px;
            width: auto;
            opacity: 1;
            max-width: 180px;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
        }
        
        #music-toast-time {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.6);
            font-weight: 500;
            transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        #music-toast.pill-mode #music-toast-time {
            display: none;
        }
        
        /* Expanded state when clicked */
        #music-toast.expanded {
            max-width: 350px !important;
            padding: 20px !important;
            animation: expandSmooth 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards !important;
        }
        
        #music-toast.expanded #music-toast-text {
            font-size: 15px !important;
            opacity: 1 !important;
            width: auto !important;
            max-width: 100% !important;
        }
        
        #music-toast.expanded #music-toast-icon {
            font-size: 24px !important;
        }
        
        #music-toast.expanded #music-toast-time {
            font-size: 11px !important;
            opacity: 1 !important;
        }
        
        #music-toast.expanded #music-toast-info {
            flex-direction: column !important;
            gap: 4px !important;
        }
        
        #music-toast.expanded #music-progress-container {
            display: block !important;
        }
        
        #music-toast.expanded #music-visualizer-toast {
            display: flex !important;
        }
        
        @keyframes expandSmooth {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        /* Cursor pointer for pill mode */
        #music-toast.pill-mode {
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        #music-toast.pill-mode:hover {
            transform: scale(1.05);
            border-color: rgba(121, 192, 90, 0.5);
            box-shadow: 
                0 4px 12px rgba(0, 0, 0, 0.6),
                inset 0 1px 0 rgba(255, 255, 255, 0.15),
                0 0 20px rgba(121, 192, 90, 0.3);
        }
        
        /* Progress Bar Container */
        #music-progress-container {
            width: 100%;
            height: 6px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 3px;
            border: 1px solid rgba(121, 192, 90, 0.3);
            overflow: hidden;
            position: relative;
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        
        #music-toast.pill-mode #music-progress-container {
            display: block !important;
            height: 3px;
            opacity: 1;
            margin-top: 0;
            background: rgba(0, 0, 0, 0.6);
            border: none;
        }
        
        #music-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #79C05A 0%, #F7DC6F 50%, #79C05A 100%);
            background-size: 200% 100%;
            border-radius: 3px;
            width: 0%;
            transition: width 0.5s linear;
            box-shadow: 0 0 10px rgba(121, 192, 90, 0.6);
            animation: shimmer 2s linear infinite;
        }
        
        @keyframes shimmer {
            0% { background-position: 200% center; }
            100% { background-position: -200% center; }
        }
        
        /* Music Visualizer in Toast */
        #music-visualizer-toast {
            display: flex;
            gap: 4px;
            align-items: flex-end;
            height: 40px;
            justify-content: center;
            padding: 8px 0;
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        
        #music-toast.pill-mode #music-visualizer-toast {
            height: 0;
            opacity: 0;
            padding: 0;
            overflow: hidden;
        }
        
        .visualizer-bar-toast {
            width: 6px;
            background: linear-gradient(180deg, #79C05A 0%, #F7DC6F 100%);
            border-radius: 3px;
            box-shadow: 0 0 8px rgba(121, 192, 90, 0.6);
            animation: musicPulse 0.5s ease-in-out infinite;
        }
        
        @keyframes musicPulse {
            0%, 100% { height: 20%; opacity: 0.6; }
            50% { height: 80%; opacity: 1; }
        }
        
        .visualizer-bar-toast:nth-child(1) { animation-delay: 0s; }
        .visualizer-bar-toast:nth-child(2) { animation-delay: 0.1s; }
        .visualizer-bar-toast:nth-child(3) { animation-delay: 0.2s; }
        .visualizer-bar-toast:nth-child(4) { animation-delay: 0.3s; }
        .visualizer-bar-toast:nth-child(5) { animation-delay: 0.4s; }
        .visualizer-bar-toast:nth-child(6) { animation-delay: 0.5s; }
        .visualizer-bar-toast:nth-child(7) { animation-delay: 0.6s; }
        .visualizer-bar-toast:nth-child(8) { animation-delay: 0.7s; }
        
        /* Custom Minecraft-Style Slider */
        .custom-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.5);
            outline: none;
            border: 2px solid #555;
            border-radius: 0;
            position: relative;
            cursor: pointer;
            box-shadow: inset -2px -2px 0 0 rgba(0, 0, 0, 0.6), inset 2px 2px 0 0 rgba(255, 255, 255, 0.1);
        }
        
        /* Slider track fill */
        .custom-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #888 0%, #666 100%);
            cursor: pointer;
            border: 3px solid #aaa;
            box-shadow: inset -2px -2px 0 0 rgba(0, 0, 0, 0.6), inset 2px 2px 0 0 rgba(255, 255, 255, 0.3), 0 3px 0 0 rgba(0, 0, 0, 0.5);
            position: relative;
        }
        
        .custom-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #888 0%, #666 100%);
            cursor: pointer;
            border: 3px solid #aaa;
            box-shadow: inset -2px -2px 0 0 rgba(0, 0, 0, 0.6), inset 2px 2px 0 0 rgba(255, 255, 255, 0.3), 0 3px 0 0 rgba(0, 0, 0, 0.5);
            border-radius: 0;
        }
        
        .custom-slider:hover::-webkit-slider-thumb {
            background: linear-gradient(135deg, #999 0%, #777 100%);
            border-color: #bbb;
        }
        
        .custom-slider:hover::-moz-range-thumb {
            background: linear-gradient(135deg, #999 0%, #777 100%);
            border-color: #bbb;
        }
        
        .custom-slider:active::-webkit-slider-thumb {
            box-shadow: inset -2px -2px 0 0 rgba(0, 0, 0, 0.8), inset 2px 2px 0 0 rgba(255, 255, 255, 0.2), 0 1px 0 0 rgba(0, 0, 0, 0.5);
            transform: translateY(2px);
        }
        
        .custom-slider:active::-moz-range-thumb {
            box-shadow: inset -2px -2px 0 0 rgba(0, 0, 0, 0.8), inset 2px 2px 0 0 rgba(255, 255, 255, 0.2), 0 1px 0 0 rgba(0, 0, 0, 0.5);
        }
        
        /* Toggle Switch */
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            transition: .3s;
            border: 2px solid #555;
            box-shadow: inset -2px -2px 0 0 rgba(0, 0, 0, 0.6), inset 2px 2px 0 0 rgba(255, 255, 255, 0.1);
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background: linear-gradient(135deg, #888 0%, #666 100%);
            transition: .3s;
            border: 2px solid #aaa;
            box-shadow: inset -1px -1px 0 0 rgba(0, 0, 0, 0.6), inset 1px 1px 0 0 rgba(255, 255, 255, 0.3);
        }
        
        input:checked + .slider {
            background: rgba(121, 192, 90, 0.6);
            border-color: rgba(121, 192, 90, 0.8);
        }
        
        input:checked + .slider:before {
            transform: translateX(24px);
            background: linear-gradient(135deg, #79C05A 0%, #5a9040 100%);
            border-color: #8dd060;
        }
        
        .slider.round {
            border-radius: 24px;
        }
        
        .slider.round:before {
            border-radius: 50%;
        }
        
        /* Settings Grid Layout */
        .settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            width: 100%;
            max-width: 800px;
            margin: 20px 0;
        }
        
        .settings-category {
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #555;
            border-radius: 6px;
            padding: 20px;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .settings-category h3 {
            margin: 0 0 15px 0;
            font-size: 18px;
            color: var(--main-action);
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.8);
            letter-spacing: 1px;
            border-bottom: 2px solid #555;
            padding-bottom: 10px;
        }
        
        .setting-item {
            margin-bottom: 15px;
        }
        
        .setting-item:last-child {
            margin-bottom: 0;
        }
        
        .setting-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 14px;
            color: #fff;
            text-shadow: 1px 1px 0 rgba(0, 0, 0, 0.8);
        }
        
        .setting-value {
            font-weight: bold;
            color: var(--main-action);
            min-width: 50px;
            text-align: right;
        }
        
        .setting-description {
            font-size: 11px;
            color: #999;
            margin-top: 5px;
            line-height: 1.4;
        }
        
        /* Keybind section styling */
        .keybind-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .keybind-item label {
            font-size: 13px;
            color: #ccc;
            font-weight: 600;
        }
        
        .keybind-btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, rgba(60, 63, 72, 0.95) 0%, rgba(40, 43, 52, 0.95) 100%);
            border: 3px solid rgba(121, 192, 90, 0.6);
            color: var(--primary-text);
            border-radius: 0px;
            cursor: pointer;
            font-family: 'Pixelify Sans', monospace;
            font-weight: 600;
            min-width: 100px;
            text-align: center;
            transition: all 0.2s ease;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            font-size: 12px;
            box-shadow: 
                0 4px 0 0 rgba(0, 0, 0, 0.6),
                inset 0 -2px 0 0 rgba(0, 0, 0, 0.4),
                inset 0 2px 0 0 rgba(255, 255, 255, 0.15);
            position: relative;
            overflow: hidden;
        }
        
        .keybind-btn::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: linear-gradient(135deg, rgba(121, 192, 90, 0.6), rgba(247, 220, 111, 0.6));
            border-radius: 0px;
            z-index: -1;
            opacity: 0;
            transition: opacity 0.4s ease;
        }
        
        .keybind-btn:hover::before {
            opacity: 1;
        }
        
        .keybind-btn:hover {
            background: linear-gradient(135deg, rgba(80, 83, 92, 0.95) 0%, rgba(60, 63, 72, 0.95) 100%);
            transform: translateY(-3px) scale(1.03);
            box-shadow: 
                0 10px 20px rgba(0, 0, 0, 0.7), 
                0 0 15px rgba(121, 192, 90, 0.5),
                inset 0 -3px 0 0 rgba(0, 0, 0, 0.3),
                inset 0 3px 0 0 rgba(255, 255, 255, 0.2);
            border-color: rgba(121, 192, 90, 0.9);
        }
        
        .keybind-btn:active {
            transform: translateY(1px) scale(0.97);
            box-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.5),
                inset 0 -1px 0 0 rgba(0, 0, 0, 0.3),
                inset 0 1px 0 0 rgba(255, 255, 255, 0.1);
        }
        
        /* Full-width category for master volume */
        .settings-category.full-width {
            grid-column: 1 / -1;
        }
        
        /* REDESIGNED: Crafting Panel (Integrated Side-by-Side) */
        #crafting-panel {
            background: transparent;
            border: none;
            border-radius: 0px;
            padding: 12px;
            box-shadow: none;
            min-width: 260px;
            max-width: 260px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        #crafting-title {
            text-align: center;
            font-size: 14px;
            font-weight: bold;
            margin: 0;
            color: var(--main-action);
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.8);
            letter-spacing: 1px;
            padding-bottom: 6px;
            border-bottom: none;
        }
        
        .crafting-area {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 10px;
            background: transparent;
            border-radius: 0px;
            border: none;
        }
        
        #crafting-grid {
            display: grid;
            grid-template-columns: repeat(3, 44px);
            grid-template-rows: repeat(3, 44px);
            gap: 3px;
        }
        
        .crafting-slot {
            width: 44px;
            height: 44px;
            border: 2px solid var(--hotbar-border);
            background: var(--hotbar-slot-bg);
            border-radius: 0px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #ccc;
            cursor: pointer;
            transition: all 0.15s ease;
            position: relative;
            box-shadow: inset -1px -1px 0 0 rgba(0, 0, 0, 0.3), inset 1px 1px 0 0 rgba(255, 255, 255, 0.1);
        }
        
        .crafting-slot:hover {
            border-color: #999;
            transform: translateY(-2px) scale(1.03);
            background: rgba(255, 255, 255, 0.1);
        }
        
        #crafting-arrow {
            text-align: center;
            font-size: 24px;
            color: var(--main-action);
            filter: drop-shadow(0 0 4px var(--main-action));
            animation: pulse 2s ease-in-out infinite;
        }
        
        #crafting-output {
            width: 50px;
            height: 50px;
            border: 2px solid var(--hotbar-border);
            background: var(--hotbar-slot-bg);
            border-radius: 0px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #ccc;
            cursor: pointer;
            transition: all 0.2s ease;
            animation: glow 1.5s ease-in-out infinite;
            position: relative;
            box-shadow: inset -1px -1px 0 0 rgba(0, 0, 0, 0.3), inset 1px 1px 0 0 rgba(255, 255, 255, 0.1);
        }
        
        #crafting-output:hover {
            transform: translateY(-2px) scale(1.03);
            background: rgba(255, 255, 255, 0.1);
            border-color: #999;
        }
        
        /* Custom Recipe List Container */
        #crafting-recipes-wrapper {
            margin-top: 5px;
            padding-top: 8px;
            border-top: none;
            height: 180px;
            position: relative;
        }
        
        #crafting-recipes {
            height: 100%;
            overflow: hidden;
            padding-right: 20px;
            position: relative;
        }
        
        #crafting-recipes-content {
            transition: transform 0.1s ease-out;
            padding-right: 5px;
        }
        
        /* Custom Scrollbar */
        .custom-scrollbar {
            position: absolute;
            right: 5px;
            top: 5px;
            bottom: 5px;
            width: 10px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            z-index: 1900; /* Below fake cursor and picked-up item */
            pointer-events: all; /* Ensure it receives events */
        }
        
        .custom-scrollbar-thumb {
            position: absolute;
            width: 100%;
            background: var(--main-action);
            border-radius: 2px;
            cursor: grab;
            transition: background 0.2s;
            border: 1px solid rgba(255, 255, 255, 0.3);
            pointer-events: all; /* Ensure it receives events */
        }
        
        .custom-scrollbar-thumb:hover {
            background: var(--main-action-hover);
        }
        
        .custom-scrollbar-thumb.dragging {
            background: var(--main-action-hover);
            cursor: grabbing;
        }
        
        .recipe-list-header {
            font-size: 10px;
            color: #888;
            text-align: center;
            margin-bottom: 5px;
            letter-spacing: 0.5px;
        }
        
        .recipe-item {
            background: linear-gradient(135deg, rgba(60, 63, 72, 0.8) 0%, rgba(40, 43, 52, 0.8) 100%);
            padding: 10px 12px;
            margin-bottom: 6px;
            border-radius: 0px;
            border: 2px solid rgba(121, 192, 90, 0.4);
            font-size: 11px;
            color: var(--primary-text);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'Pixelify Sans', monospace;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            box-shadow: 
                0 2px 0 0 rgba(0, 0, 0, 0.6),
                inset 0 -1px 0 0 rgba(0, 0, 0, 0.3),
                inset 0 1px 0 0 rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }
        
        .recipe-item::before {
            content: '';
            font-size: 14px;
        }
        
        .recipe-item::after {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(135deg, rgba(121, 192, 90, 0.6), rgba(247, 220, 111, 0.6));
            border-radius: 0px;
            z-index: -1;
            opacity: 0;
            transition: opacity 0.4s ease;
        }
        
        .recipe-item:hover::after {
            opacity: 1;
        }
        
        .recipe-item:hover {
            background: linear-gradient(135deg, rgba(80, 83, 92, 0.95) 0%, rgba(60, 63, 72, 0.95) 100%);
            border-color: rgba(121, 192, 90, 0.8);
            transform: translateX(4px) scale(1.02);
            box-shadow: 
                0 6px 12px rgba(0, 0, 0, 0.6), 
                0 0 15px rgba(121, 192, 90, 0.5),
                inset 0 -2px 0 0 rgba(0, 0, 0, 0.3),
                inset 0 2px 0 0 rgba(255, 255, 255, 0.15);
        }
        
        .recipe-item.unavailable {
            opacity: 0.4;
            cursor: not-allowed;
            filter: grayscale(1);
        }
        
        .recipe-item.unavailable:hover {
            background: linear-gradient(135deg, rgba(60, 63, 72, 0.8) 0%, rgba(40, 43, 52, 0.8) 100%);
            border-color: rgba(121, 192, 90, 0.4);
            transform: none;
            box-shadow: 
                0 2px 0 0 rgba(0, 0, 0, 0.6),
                inset 0 -1px 0 0 rgba(0, 0, 0, 0.3),
                inset 0 1px 0 0 rgba(255, 255, 255, 0.1);
        }
        
        .recipe-item.unavailable:hover::after {
            opacity: 0;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <canvas id="c"></canvas>
    <canvas id="starfield-bg"></canvas>
    
    <div id="main-menu">
        <div id="main-controls" class="menu-view">
            <h1>MINECRAFT</h1>
            <button id="showCreationBtn" class="main-menu-btn"> CREATE WORLD</button>
            <button id="showSavedWorldsBtn" class="main-menu-btn"> SAVED WORLDS</button>
            <button id="showSettingsBtn" class="main-menu-btn"> SETTINGS</button>
            <button id="showCreditsBtn" class="main-menu-btn"> CREDITS</button>
        </div>
        <div id="creation-view" class="menu-view" style="display: none;">
            <h2> CREATE NEW WORLD</h2>
            <p style="font-size: 12px; color: #AAA; margin-bottom: 20px;">Customize your world settings</p>
            
            <div class="menu-control" style="margin-bottom: 15px;">
                <label for="seedInput" style="display: block; margin-bottom: 5px; font-size: 14px; color: #F7DC6F;"> World Seed</label>
                <input type="number" id="seedInput" placeholder="Random seed" style="width: 100%; padding: 10px; background: rgba(0,0,0,0.4); border: 2px solid rgba(255,255,255,0.2); color: white; font-family: 'Pixelify Sans', monospace; border-radius: 2px;">
            </div>
            
            <div class="menu-control" style="margin-bottom: 15px;">
                <label for="worldSizeSlider" style="display: block; margin-bottom: 5px; font-size: 14px; color: #F7DC6F;">
                     World Size: <span id="worldSizeValue" style="color: white;">40</span> Chunks
                </label>
                <input type="range" id="worldSizeSlider" min="20" max="100" value="40" step="10" style="width: 100%; height: 30px; cursor: pointer; background: #333; border: none; padding: 0;">
                <p style="font-size: 11px; color: #888; margin-top: 5px;"> Larger worlds may impact performance</p>
            </div>
            
            <div class="menu-control" style="margin-bottom: 25px;">
                <label for="flatWorldCheckbox" style="cursor: pointer; display: flex; align-items: center; gap: 10px; background: rgba(0,0,0,0.3); padding: 12px; border-radius: 2px; border: 2px solid rgba(255,255,255,0.1);">
                    <label class="switch" style="margin-left: auto;">
                        <input type="checkbox" id="flatWorldCheckbox">
                        <span class="slider round"></span>
                    </label>
                    <span> Flat World (Superflat terrain)</span>
                </label>
            </div>
            
            <div class="menu-control" style="margin-bottom: 25px;">
                <label for="worldBorderCheckbox" style="cursor: pointer; display: flex; align-items: center; gap: 10px; background: rgba(0,0,0,0.3); padding: 12px; border-radius: 2px; border: 2px solid rgba(255,255,255,0.1);">
                    <label class="switch" style="margin-left: auto;">
                        <input type="checkbox" id="worldBorderCheckbox" checked>
                        <span class="slider round"></span>
                    </label>
                    <span> World Border (Invisible barrier at world edge)</span>
                </label>
                <p style="font-size: 11px; color: #888; margin-top: 5px;"> Prevents falling off the edge of the world</p>
            </div>
            
            <button id="createWorldBtn" class="main-menu-btn" style="background: var(--main-action); margin-bottom: 8px;"> START GAME</button>
            <button id="backFromCreationBtn" class="main-menu-btn"> BACK</button>
        </div>
        
        <!-- Fixed Back Button - OUTSIDE all menus, fixed to viewport -->
        <button id="backFromSettingsBtn" class="main-menu-btn fixed-back-btn" style="display: none; padding: 16px 40px; font-size: 16px; font-weight: 700; box-shadow: 0 6px 20px rgba(0,0,0,0.6); background: var(--main-action); border: 3px solid rgba(255,255,255,0.3);"> BACK TO MAIN MENU</button>
        <button id="backToSettingsBtn" class="main-menu-btn fixed-back-btn" onclick="backToSettingsMenu()" style="display: none; padding: 16px 40px; font-size: 16px; font-weight: 700; box-shadow: 0 6px 20px rgba(0,0,0,0.6); background: var(--main-action); border: 3px solid rgba(255,255,255,0.3);"> BACK TO SETTINGS</button>
        
        <!-- Settings Main Menu -->
        <div id="settings-view" class="menu-view" style="display: none;">
            <h2> SETTINGS</h2>
            
            <!-- Search Bar -->
            <div style="margin-bottom: 20px;">
                <input 
                    type="text" 
                    id="settingsSearchInput" 
                    placeholder=" Search any setting..." 
                    style="width: 100%; max-width: 1200px; padding: 12px 16px; background: rgba(0,0,0,0.6); border: 2px solid rgba(255,255,255,0.3); border-radius: 4px; color: white; font-family: inherit; font-size: 14px;"
                    oninput="searchSettings(this.value)"
                />
                <div id="searchResults" style="display: none; margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.8); border-radius: 4px; max-width: 1200px;"></div>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; max-width: 1200px; width: 100%; align-items: start;">
                <!-- Left Column: Quick Settings & Detailed Settings -->
                <div>
                    <!-- Graphics Presets -->
                    <div style="margin-bottom: 25px; padding: 20px; background: rgba(0,0,0,0.4); border-radius: 4px; border: 2px solid rgba(255,255,255,0.15);">
                        <h3 style="font-size: 16px; color: var(--main-action); margin: 0 0 15px 0; letter-spacing: 1px;"> GRAPHICS PRESETS</h3>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <select id="graphicsPreset" style="flex: 1; padding: 12px; background: rgba(0,0,0,0.6); border: 2px solid rgba(255,255,255,0.3); border-radius: 4px; color: white; font-family: inherit; font-size: 14px; cursor: pointer;">
                                <option value="">Select a preset...</option>
                                <option value="ultra">ULTRA (Best Quality)</option>
                                <option value="high">HIGH</option>
                                <option value="medium">MEDIUM</option>
                                <option value="low">LOW</option>
                                <option value="potato">POTATO (Best Performance)</option>
                            </select>
                            <button id="comparePresetBtn" class="main-menu-btn" style="margin: 0; padding: 12px 20px; font-size: 13px;" onclick="showPresetComparison()"> COMPARE</button>
                        </div>
                    </div>
                    
                    <!-- Quick Settings (Customizable) - Enhanced -->
                    <div style="margin-bottom: 30px; padding: 25px; background: rgba(0, 191, 255, 0.08); border-radius: 8px; border: 2px solid var(--main-action); box-shadow: 0 0 15px rgba(0, 191, 255, 0.2);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 18px;">
                            <h3 style="font-size: 18px; color: var(--main-action); margin: 0; letter-spacing: 1px; text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.8);"> QUICK SETTINGS</h3>
                            <button class="main-menu-btn" style="margin: 0; padding: 10px 18px; font-size: 13px; background: var(--main-action); font-weight: 600;" onclick="customizeQuickSettings()"> CUSTOMIZE</button>
                        </div>
                        <div id="quickSettingsContainer" style="display: grid; grid-template-columns: 1fr; gap: 18px;">
                            <!-- Quick settings will be dynamically populated -->
                        </div>
                    </div>
                    
        <!-- Detailed Settings Categories - Redesigned Grid -->
        <div style="margin-bottom: 20px;">
            <h3 style="font-size: 16px; color: var(--main-action); margin: 0 0 15px 0; letter-spacing: 1px;"> DETAILED SETTINGS</h3>
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
                <button class="main-menu-btn" onclick="showVideoSettings()" style="padding: 20px 15px; font-size: 14px; display: flex; flex-direction: column; align-items: center; gap: 8px; transition: all 0.2s ease;">
                    <span style="font-size: 28px;"></span>
                    <span style="font-weight: 600;">VIDEO</span>
                </button>
                <button class="main-menu-btn" onclick="showControlSettings()" style="padding: 20px 15px; font-size: 14px; display: flex; flex-direction: column; align-items: center; gap: 8px; transition: all 0.2s ease;">
                    <span style="font-size: 28px;"></span>
                    <span style="font-weight: 600;">CONTROLS</span>
                </button>
                <button class="main-menu-btn" onclick="showAudioSettings()" style="padding: 20px 15px; font-size: 14px; display: flex; flex-direction: column; align-items: center; gap: 8px; transition: all 0.2s ease;">
                    <span style="font-size: 28px;"></span>
                    <span style="font-weight: 600;">AUDIO</span>
                </button>
                <button class="main-menu-btn" onclick="openModelCustomizer()" style="padding: 20px 15px; font-size: 14px; display: flex; flex-direction: column; align-items: center; gap: 8px; transition: all 0.2s ease;">
                    <span style="font-size: 28px;"></span>
                    <span style="font-weight: 600;">CUSTOMIZE MODEL</span>
                </button>
            </div>
        </div>
                </div>
                
                <!-- Right Column: History & Backup -->
                <div>
                    <!-- Settings History -->
                    <div style="margin-bottom: 20px; padding: 20px; background: rgba(0,0,0,0.4); border-radius: 4px; border: 2px solid rgba(255,255,255,0.15);">
                        <h3 style="font-size: 16px; color: var(--main-action); margin: 0 0 15px 0; letter-spacing: 1px;"> CHANGE HISTORY</h3>
                        <div id="settings-history" style="max-height: 350px; overflow-y: auto; font-size: 12px; margin-bottom: 12px;">
                            <p style="font-size: 12px; color: #666; text-align: center; padding: 20px;">No recent changes</p>
                        </div>
                        <button class="main-menu-btn" onclick="clearSettingsHistory()" style="width: 100%; font-size: 12px; padding: 10px; margin-top: 8px;"> CLEAR HISTORY</button>
                    </div>
                    
                    <!-- Backup & Restore -->
                    <div style="padding: 15px; background: rgba(0,0,0,0.4); border-radius: 4px; border: 2px solid rgba(255,255,255,0.15);">
                        <h3 style="font-size: 14px; color: var(--main-action); margin: 0 0 10px 0; letter-spacing: 1px;"> BACKUP</h3>
                        <div style="display: flex; flex-direction: column; gap: 6px;">
                            <button class="main-menu-btn" onclick="exportSettings()" style="width: 100%; font-size: 11px; padding: 8px;">
                                 SETTINGS
                            </button>
                            <button class="main-menu-btn" onclick="exportWorlds()" style="width: 100%; font-size: 11px; padding: 8px;">
                                 WORLDS
                            </button>
                            <button class="main-menu-btn" onclick="exportAll()" style="width: 100%; font-size: 11px; padding: 8px; background: var(--main-action);">
                                 ALL DATA
                            </button>
                            <button class="main-menu-btn" onclick="document.getElementById('importFileInput').click()" style="width: 100%; font-size: 11px; padding: 8px;">
                                 IMPORT
                            </button>
                        </div>
                        <input type="file" id="importFileInput" accept=".json" style="display: none;" onchange="importData(event)">
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Video Settings Category -->
        <div id="video-settings-view" class="menu-view" style="display: none;">
            <h2> VIDEO SETTINGS</h2>
            
            <div class="settings-category" style="margin: 20px 0; max-width: 1000px; width: 100%;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div class="setting-item">
                        <div class="setting-label">
                            <span>Render Distance</span>
                            <span class="setting-value" id="renderDistanceValue">20</span><span style="color: #999;"> blocks</span>
                            <span style="color: #79C05A; font-size: 0.9em; margin-left: 8px;" id="renderDistanceDefault"> Default</span>
                        </div>
                        <input type="range" class="custom-slider" id="renderDistanceSlider" min="10" max="50" value="20" step="1">
                        <div class="setting-description">How far you can see. Higher values impact performance.</div>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-label">
                            <span>Field of View</span>
                            <span class="setting-value" id="fovValue">75</span><span style="color: #999;"></span>
                            <span style="color: #79C05A; font-size: 0.9em; margin-left: 8px;" id="fovDefault"> Default</span>
                        </div>
                        <input type="range" class="custom-slider" id="fovSlider" min="50" max="110" value="75" step="1">
                        <div class="setting-description">Camera zoom. Higher values show more.</div>
                    </div>
                </div>
                
                <div style="margin-top: 30px;">
                    <div class="setting-item">
                        <div style="display: flex; align-items: center; justify-content: space-between;">
                            <div>
                                <div class="setting-label">
                                    <span>Enable Shadows</span>
                                    <span style="color: #ff6b6b; font-size: 0.8em; margin-left: 8px;"> EXPERIMENTAL</span>
                                </div>
                                <div class="setting-description">Toggle shadows (experimental and buggy).</div>
                            </div>
                            <label class="switch">
                                <input type="checkbox" id="shadowsToggle">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Reset Button -->
            <button class="main-menu-btn" id="resetVideoBtn" style="margin-top: 20px; max-width: 800px; width: 100%; margin-bottom: 80px;"> RESET TO DEFAULTS</button>
        </div>
        
        <!-- Controls Settings Category -->
        <div id="controls-settings-view" class="menu-view" style="display: none;">
            <h2> CONTROLS</h2>
            
            <div class="settings-category" style="margin: 20px 0; max-width: 1000px; width: 100%;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div class="setting-item">
                        <div class="setting-label">
                            <span>Mouse Sensitivity</span>
                            <span class="setting-value" id="sensitivityValue">100</span><span style="color: #999;">%</span>
                            <span style="color: #79C05A; font-size: 0.9em; margin-left: 8px;" id="sensitivityDefault"> Default</span>
                        </div>
                        <input type="range" class="custom-slider" id="sensitivitySlider" min="25" max="200" value="100" step="1">
                        <div class="setting-description">Camera rotation speed when moving mouse.</div>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-label">
                            <span>Keybinds</span>
                            <button id="openKeybindsModalBtn" style="padding: 10px 20px; background: var(--main-action); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; font-size: 14px;">CUSTOMIZE</button>
                        </div>
                        <div class="setting-description">Customize movement and action keys.</div>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-label">
                            <span>Fullscreen Mode</span>
                            <button id="fullscreenBtn" style="padding: 10px 20px; background: var(--main-action); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; font-size: 14px; transition: all 0.2s ease;">ENTER FULLSCREEN</button>
                        </div>
                        <div class="setting-description">Press F11 or click to toggle. Locks keyboard for game controls.</div>
                    </div>
                </div>
                
                <h3 style="margin: 30px 0 20px 0; color: var(--main-action); text-align: center;">Hand Settings</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px;">
                    <div class="setting-item">
                        <div class="setting-label">
                            <span>Bob Intensity</span>
                            <span class="setting-value" id="handBobIntensityValue">100</span><span style="color: #999;">%</span>
                            <span style="color: #79C05A; font-size: 0.9em; margin-left: 8px;" id="handBobIntensityDefault"> Default</span>
                        </div>
                        <input type="range" class="custom-slider" id="handBobIntensitySlider" min="0" max="200" value="100" step="1">
                        <div class="setting-description">How much the hand moves while walking.</div>
                    </div>
                </div>
            </div>
            
            <!-- Reset Button -->
            <button class="main-menu-btn" id="resetControlsBtn" style="margin-top: 20px; max-width: 800px; width: 100%; margin-bottom: 80px;"> RESET TO DEFAULTS</button>
        </div>
        
        <!-- Audio Settings Category -->
        <div id="audio-settings-view" class="menu-view" style="display: none;">
            <h2> AUDIO SETTINGS</h2>
            
            <div class="settings-category" style="margin: 20px 0; max-width: 1000px; width: 100%;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div class="setting-item">
                        <div class="setting-label">
                            <span>Master Volume</span>
                            <span class="setting-value" id="masterVolumeValue">100</span><span style="color: #999;">%</span>
                            <span style="color: #79C05A; font-size: 0.9em; margin-left: 8px;" id="masterVolumeDefault"> Default</span>
                        </div>
                        <input type="range" class="custom-slider" id="masterVolumeSlider" min="0" max="100" value="100" step="1">
                        <div class="setting-description">Controls all game audio.</div>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-label">
                            <span>Music Volume</span>
                            <span class="setting-value" id="musicVolumeValue">50</span><span style="color: #999;">%</span>
                            <span style="color: #79C05A; font-size: 0.9em; margin-left: 8px;" id="musicVolumeDefault"> Default</span>
                        </div>
                        <input type="range" class="custom-slider" id="musicVolumeSlider" min="0" max="100" value="50" step="1">
                        <div class="setting-description">Background music in menus and pause.</div>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-label">
                            <span>SFX Volume</span>
                            <span class="setting-value" id="sfxVolumeValue">70</span><span style="color: #999;">%</span>
                            <span style="color: #79C05A; font-size: 0.9em; margin-left: 8px;" id="sfxVolumeDefault"> Default</span>
                        </div>
                        <input type="range" class="custom-slider" id="sfxVolumeSlider" min="0" max="100" value="70" step="1">
                        <div class="setting-description">Button clicks and game sounds.</div>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-label">
                            <span>Tab Out Mute</span>
                            <span class="setting-value" id="tabOutMuteValue">100</span><span style="color: #999;">%</span>
                            <span style="color: #79C05A; font-size: 0.9em; margin-left: 8px;" id="tabOutMuteDefault"> Default</span>
                        </div>
                        <input type="range" class="custom-slider" id="tabOutMuteSlider" min="0" max="100" value="100" step="1">
                        <div class="setting-description">Audio reduction when tabbed out (0% = no mute, 100% = silent).</div>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-label">
                            <span>Show Music Toast</span>
                            <label class="switch" style="margin-left: auto;">
                                <input type="checkbox" id="showMusicToastToggle" checked>
                                <span class="slider round"></span>
                            </label>
                        </div>
                        <div class="setting-description">Show/hide music notification during gameplay. Can only be disabled from pause menu.</div>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-label">
                            <span>Music Toast Position</span>
                            <select id="musicToastPositionSelector" style="padding: 8px 12px; background: rgba(0,0,0,0.6); color: white; border: 2px solid rgba(255,255,255,0.3); border-radius: 4px; cursor: pointer; font-family: inherit; font-size: 14px; min-width: 150px; margin-left: auto;">
                                <option value="top-left"> Top Left</option>
                                <option value="top-right"> Top Right</option>
                                <option value="bottom-left"> Bottom Left</option>
                                <option value="bottom-right"> Bottom Right</option>
                            </select>
                        </div>
                        <div class="setting-description">Choose where the music toast appears on screen</div>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-label">
                            <span>Music Track</span>
                            <select id="musicTrackSelector" style="padding: 8px 12px; background: rgba(0,0,0,0.6); color: white; border: 2px solid rgba(255,255,255,0.3); border-radius: 4px; cursor: pointer; font-family: inherit; font-size: 14px; min-width: 200px;">
                                <option value="random"> Random</option>
                                <option value="0"> Peaceful Dawn</option>
                                <option value="1"> Sunny Meadow</option>
                                <option value="2"> Moonlit Cave</option>
                                <option value="3"> Starry Night</option>
                                <option value="4"> Autumn Forest</option>
                                <option value="5"> Mountain Peak</option>
                            </select>
                        </div>
                        <div class="setting-description">Choose which music track plays in menus.</div>
                    </div>
                </div>
            </div>
            
            <!-- Reset Button -->
            <button class="main-menu-btn" id="resetAudioBtn" style="margin-top: 20px; max-width: 800px; width: 100%; margin-bottom: 80px;"> RESET TO DEFAULTS</button>
        </div>
        
        <!-- Theme Settings Category -->
        <div id="theme-settings-view" class="menu-view" style="display: none;">
            <h2> THEME SETTINGS</h2>
            
            <div class="settings-category" style="margin: 20px 0; max-width: 1000px; width: 100%;">
                <div style="display: grid; grid-template-columns: 1fr; gap: 25px;">
                    <div class="setting-item">
                        <div class="setting-label">
                            <span>Parallax Effect Color</span>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-top: 10px;">
                            <button class="theme-color-btn" data-color="transparent" style="background: transparent; height: 50px; border: 3px solid #666; border-radius: 4px; cursor: pointer; transition: all 0.2s;" onclick="setParallaxColor('transparent')">Clear</button>
                            <button class="theme-color-btn" data-color="rgba(50, 0, 100, 0.7)" style="background: rgba(50, 0, 100, 0.7); height: 50px; border: 3px solid #666; border-radius: 4px; cursor: pointer; transition: all 0.2s;" onclick="setParallaxColor('rgba(50, 0, 100, 0.7)')">Purple</button>
                            <button class="theme-color-btn" data-color="rgba(0, 100, 50, 0.7)" style="background: rgba(0, 100, 50, 0.7); height: 50px; border: 3px solid #666; border-radius: 4px; cursor: pointer; transition: all 0.2s;" onclick="setParallaxColor('rgba(0, 100, 50, 0.7)')">Green</button>
                            <button class="theme-color-btn" data-color="rgba(0, 50, 100, 0.7)" style="background: rgba(0, 50, 100, 0.7); height: 50px; border: 3px solid #666; border-radius: 4px; cursor: pointer; transition: all 0.2s;" onclick="setParallaxColor('rgba(0, 50, 100, 0.7)')">Blue</button>
                            <button class="theme-color-btn" data-color="rgba(100, 100, 0, 0.7)" style="background: rgba(100, 100, 0, 0.7); height: 50px; border: 3px solid #666; border-radius: 4px; cursor: pointer; transition: all 0.2s;" onclick="setParallaxColor('rgba(100, 100, 0, 0.7)')">Yellow</button>
                            <button class="theme-color-btn" data-color="rgba(100, 50, 0, 0.7)" style="background: rgba(100, 50, 0, 0.7); height: 50px; border: 3px solid #666; border-radius: 4px; cursor: pointer; transition: all 0.2s;" onclick="setParallaxColor('rgba(100, 50, 0, 0.7)')">Orange</button>
                            <button class="theme-color-btn" data-color="rgba(50, 50, 50, 0.7)" style="background: rgba(50, 50, 50, 0.7); height: 50px; border: 3px solid #666; border-radius: 4px; cursor: pointer; transition: all 0.2s;" onclick="setParallaxColor('rgba(50, 50, 50, 0.7)')">Gray</button>
                            <button class="theme-color-btn" data-color="rgba(0, 0, 0, 0.9)" style="background: rgba(0, 0, 0, 0.9); height: 50px; border: 3px solid #666; border-radius: 4px; cursor: pointer; transition: all 0.2s;" onclick="setParallaxColor('rgba(0, 0, 0, 0.9)')">Black</button>
                        </div>
                        <div class="setting-description">Choose the background color for parallax animation.</div>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-label">
                            <span>Parallax Speed</span>
                            <span class="setting-value" id="parallaxSpeedValue">120</span><span style="color: #999;">s</span>
                        </div>
                        <input type="range" class="custom-slider" id="parallaxSpeedSlider" min="20" max="200" value="120" step="10">
                        <div class="setting-description">Animation speed (lower = faster, higher = slower).</div>
                    </div>
                    
                    
                </div>
            </div>
            
            <!-- Reset Button -->
            <button class="main-menu-btn" onclick="resetThemeSettings()" style="margin-top: 20px; max-width: 800px; width: 100%; margin-bottom: 80px;"> RESET TO DEFAULTS</button>
        </div>
        
        <div id="saved-worlds-view" class="menu-view" style="display: none;">
            <h2> SAVED WORLDS</h2>
            <p style="font-size: 12px; color: #AAA; margin-bottom: 20px;">Load or manage your saved worlds</p>
            <div id="saved-worlds-list" style="max-height: 400px; overflow-y: auto; width: 100%; margin-bottom: 20px; padding: 5px;">
                <!-- Saved worlds will be listed here -->
            </div>
            <button id="backFromSavedWorldsBtn" class="main-menu-btn"> BACK</button>
        </div>
        <div id="credits-view" class="menu-view epic-credits-view" style="display: none;">
            <div class="credits-particles"></div>
            
            <!-- Music Visualizer -->
            <div class="music-visualizer">
                <div class="visualizer-bar"></div>
                <div class="visualizer-bar"></div>
                <div class="visualizer-bar"></div>
                <div class="visualizer-bar"></div>
                <div class="visualizer-bar"></div>
                <div class="visualizer-bar"></div>
                <div class="visualizer-bar"></div>
                <div class="visualizer-bar"></div>
            </div>
            
            <h2 class="credits-title"> CREDITS</h2>
            <div class="credits-container">
                <div class="credit-card" style="animation-delay: 0.2s;">
                    <div class="credit-icon"></div>
                    <div class="credit-content">
                        <div class="credit-role">Concept & Direction</div>
                        <div class="credit-name"><a href="#" style="color: inherit; text-decoration: none;" onmouseover="this.style.color='#79C05A'" onmouseout="this.style.color='#FFFFFF'">Matko802</a></div>
                    </div>
                    <div class="credit-glow"></div>
                </div>
                
                <div class="credit-card" style="animation-delay: 0.4s;">
                    <div class="credit-icon"></div>
                    <div class="credit-content">
                        <div class="credit-role">Code Implementation</div>
                        <div class="credit-name">Gemini (Google), Lovable</div>
                    </div>
                    <div class="credit-glow"></div>
                </div>
                
                <div class="credit-card" style="animation-delay: 0.6s;">
                    <div class="credit-icon"></div>
                    <div class="credit-content">
                        <div class="credit-role">Inspired By</div>
                        <div class="credit-name">Minecraft (Original Game by Mojang AB)</div>
                    </div>
                    <div class="credit-glow"></div>
                </div>
            </div>
            <button id="backFromCreditsBtn" class="main-menu-btn credits-back-btn"> BACK</button>
        </div>
    </div>
    
    <div id="inventory-screen">
        <div class="inventory-container">
            <h2>INVENTORY & CRAFTING</h2>
            
            <div class="inventory-main-section">
                <!-- Left Side: Storage & Hotbar -->
                <div class="inventory-storage-area">
                    <div class="inventory-section-label">Storage (24 slots)</div>
                    <div id="main-inventory-grid"></div>
                    
                    <div class="inventory-section-label">Hotbar (Quick Access)</div>
                    <div id="hud-inventory-grid"></div>
                    
                    <div id="creative-panel">
                        <div id="creative-picker-wrapper">
                            <div class="inventory-section-label"> Creative Items</div>
                            <div id="category-tabs">
                                <button class="category-tab active" data-category="all"> All</button>
                                <button class="category-tab" data-category="blocks"> Blocks</button>
                                <button class="category-tab" data-category="nature"> Nature</button>
                                <button class="category-tab" data-category="decorative"> Decorative</button>
                                <button class="category-tab" data-category="tools"> Tools</button>
                                <button class="category-tab" data-category="liquids"> Liquids</button>
                            </div>
                            <div id="creative-block-picker"></div>
                        </div>
                        <div id="delete-wrapper">
                            <div class="inventory-section-label" style="color: var(--warning-color);"> Delete</div>
                            <div id="delete-slot"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Right Side: Crafting -->
                <div id="crafting-panel">
                    <div id="crafting-title"> CRAFTING TABLE</div>
                    
                    <div class="crafting-area">
                        <div id="crafting-grid"></div>
                        <div id="crafting-arrow"></div>
                        <div id="crafting-output"></div>
                    </div>
                    
                    <div class="recipe-list-header"> AVAILABLE RECIPES</div>
                    <div id="crafting-recipes-wrapper">
                        <div id="crafting-recipes">
                            <div id="crafting-recipes-content"></div>
                        </div>
                        <div class="custom-scrollbar">
                            <div class="custom-scrollbar-thumb"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <button id="gameModeToggleBtn">Switch to Survival</button>
            
            <!-- Helper Text -->
            <div style="text-align: center; font-size: 10px; color: #888; margin-top: 5px; line-height: 1.4;">
                 <strong>Tips:</strong> Click items to pick up  Right-click to split stacks  Hover for details
            </div>
        </div>
        
        <div id="picked-up-item"></div> 
    </div>

    
    <div id="fake-cursor"></div> <div id="ui"></div>
    <div id="fps"></div>
    <div id="debug-info" style="position: absolute; top: 4px; right: 4px; color: #ffffff; background: none; padding: 4px 8px; border: none; font-size: 12px; font-family: monospace; line-height: 1.5; text-shadow: 1px 1px 0px rgba(0, 0, 0, 0.8); display: none; z-index: 5; pointer-events: none; text-align: right;">DEBUG MODE: Hitbox ON</div>
    <div id="looking-at-info" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, calc(-50% + 40px)); color: #ffffff; background: rgba(0, 0, 0, 0.7); padding: 4px 12px; border-radius: 4px; font-size: 14px; display: none; z-index: 5; pointer-events: none; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8); border: 1px solid rgba(255, 255, 255, 0.3);"></div>
    <div id="crosshair"></div>
    <div id="health-container"></div>
    <div id="oxygen-container"></div>
    <div id="movement-status"></div>
    <div id="toolbar"></div>
    <div id="held-item-info">
        <div class="item-name"></div>
        <div class="item-count"></div>
        <div class="durability-bar-container" style="display: none;">
            <div class="durability-bar"></div>
        </div>
        <div class="durability-text"></div>
    </div>
    
    <div id="death-screen">
        <h1>YOU DIED</h1>
        <p>Score: <span id="death-score">0</span></p>
        <button id="death-respawn-btn">RESPAWN</button>
    </div>
    
    <div id="pause-menu">
        <div class="menu-view">
            <h2>GAME STOPPED</h2>
            <div class="menu-control" style="width: 300px;">
                <label for="settingsSeedInput">Current Seed:</label>
                <input type="number" id="settingsSeedInput" readonly>
            </div>
            <p id="current-world-name" style="font-size: 14px; color: #aaa; margin-top: 10px;"></p>
            
            <button id="main-menu-btn-pause" class="main-menu-btn" style="background: var(--main-action); width: 300px; margin-top: 20px;">
                CONTINUE GAME (ESC)
            </button>
            <button id="respawn-btn" class="main-menu-btn" style="background: #FF9800; width: 300px; margin-top: 10px;">
                RESPAWN
            </button>
            <button id="save-world-btn" class="main-menu-btn" style="background: #2196F3; width: 300px; margin-top: 10px;">
                SAVE WORLD
            </button>
            <button id="pause-settings-btn" class="main-menu-btn" style="width: 300px; margin-top: 10px;">
                 SETTINGS
            </button>
            <button id="exit-to-menu-btn" class="main-menu-btn" style="background: var(--warning-color); width: 300px; margin-top: 10px;">
                EXIT TO MAIN MENU
            </button>
        </div>
    </div>

    <div id="version-text">Dev Test v1.8.0</div>
    
    <!-- Enhanced Music Toast with Progress & Visualizer -->
    <div id="music-toast">
        <div id="music-toast-header">
            <span id="music-toast-icon"></span>
            <div id="music-toast-info">
                <span id="music-toast-text">Now Playing: Peaceful Dawn</span>
                <span id="music-toast-time">0:00 / 1:20</span>
            </div>
        </div>
        <div id="music-progress-container">
            <div id="music-progress-bar"></div>
        </div>
        <div id="music-visualizer-toast">
            <div class="visualizer-bar-toast"></div>
            <div class="visualizer-bar-toast"></div>
            <div class="visualizer-bar-toast"></div>
            <div class="visualizer-bar-toast"></div>
            <div class="visualizer-bar-toast"></div>
            <div class="visualizer-bar-toast"></div>
            <div class="visualizer-bar-toast"></div>
            <div class="visualizer-bar-toast"></div>
        </div>
    </div>

    <!-- Keybinds Customization Modal -->
    <div id="keybinds-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 3000; align-items: center; justify-content: center;">
        <div style="background: var(--menu-bg-accent); padding: 40px; border-radius: 8px; border: 3px solid #666; max-width: 700px; width: 90%; text-align: center;">
            <h2 style="color: white; margin-bottom: 10px; text-shadow: 3px 3px 0 rgba(0, 0, 0, 0.8);"> CUSTOMIZE KEYBINDS</h2>
            <p style="color: #aaa; margin-bottom: 30px; font-size: 14px;">Click any button below and press a key to rebind</p>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 30px;">
                <div class="keybind-item">
                    <label style="color: white; display: block; margin-bottom: 8px; font-size: 14px;">Forward:</label>
                    <button class="keybind-btn" data-action="forward" style="width: 100%; padding: 12px; background: rgba(0, 191, 255, 0.2); color: white; border: 2px solid var(--main-action); border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; font-size: 14px; transition: all 0.2s;">W</button>
                </div>
                
                <div class="keybind-item">
                    <label style="color: white; display: block; margin-bottom: 8px; font-size: 14px;">Backward:</label>
                    <button class="keybind-btn" data-action="backward" style="width: 100%; padding: 12px; background: rgba(0, 191, 255, 0.2); color: white; border: 2px solid var(--main-action); border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; font-size: 14px; transition: all 0.2s;">S</button>
                </div>
                
                <div class="keybind-item">
                    <label style="color: white; display: block; margin-bottom: 8px; font-size: 14px;">Left:</label>
                    <button class="keybind-btn" data-action="left" style="width: 100%; padding: 12px; background: rgba(0, 191, 255, 0.2); color: white; border: 2px solid var(--main-action); border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; font-size: 14px; transition: all 0.2s;">A</button>
                </div>
                
                <div class="keybind-item">
                    <label style="color: white; display: block; margin-bottom: 8px; font-size: 14px;">Right:</label>
                    <button class="keybind-btn" data-action="right" style="width: 100%; padding: 12px; background: rgba(0, 191, 255, 0.2); color: white; border: 2px solid var(--main-action); border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; font-size: 14px; transition: all 0.2s;">D</button>
                </div>
                
                <div class="keybind-item">
                    <label style="color: white; display: block; margin-bottom: 8px; font-size: 14px;">Jump / Swim Up:</label>
                    <button class="keybind-btn" data-action="jump" style="width: 100%; padding: 12px; background: rgba(0, 191, 255, 0.2); color: white; border: 2px solid var(--main-action); border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; font-size: 14px; transition: all 0.2s;">SPACE</button>
                </div>
                
                <div class="keybind-item">
                    <label style="color: white; display: block; margin-bottom: 8px; font-size: 14px;">Sneak / Swim Down:</label>
                    <button class="keybind-btn" data-action="sneak" style="width: 100%; padding: 12px; background: rgba(0, 191, 255, 0.2); color: white; border: 2px solid var(--main-action); border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; font-size: 14px; transition: all 0.2s;">SHIFT</button>
                </div>
                
                <div class="keybind-item">
                    <label style="color: white; display: block; margin-bottom: 8px; font-size: 14px;">Inventory:</label>
                    <button class="keybind-btn" data-action="inventory" style="width: 100%; padding: 12px; background: rgba(0, 191, 255, 0.2); color: white; border: 2px solid var(--main-action); border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; font-size: 14px; transition: all 0.2s;">E</button>
                </div>
                
                <div class="keybind-item">
                    <label style="color: white; display: block; margin-bottom: 8px; font-size: 14px;">Pause Menu:</label>
                    <button class="keybind-btn" data-action="pause" style="width: 100%; padding: 12px; background: rgba(0, 191, 255, 0.2); color: white; border: 2px solid var(--main-action); border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; font-size: 14px; transition: all 0.2s;">ESC</button>
                </div>
            </div>
            
            <div style="display: flex; gap: 15px; justify-content: center;">
                <button class="main-menu-btn" id="resetKeybindsBtn" style="width: 200px; padding: 12px;"> RESET KEYBINDS</button>
                <button class="main-menu-btn" id="closeKeybindsModalBtn" style="width: 200px; padding: 12px; background: var(--main-action);"> DONE</button>
            </div>
        </div>
    </div>

    <!-- Preset Comparison Modal -->
    <div id="preset-comparison-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 3000; align-items: center; justify-content: center;">
        <div style="background: var(--menu-bg-accent); padding: 30px; border-radius: 8px; border: 3px solid #666; max-width: 700px; width: 90%;">
            <h2 style="color: white; margin-bottom: 20px; text-shadow: 3px 3px 0 rgba(0, 0, 0, 0.8);"> PRESET COMPARISON</h2>
            
            <div style="margin-bottom: 20px;">
                <label style="color: white; display: block; margin-bottom: 10px;">Select Preset to Compare:</label>
                <select id="presetCompareSelect" style="width: 100%; padding: 12px; background: rgba(0,0,0,0.6); border: 2px solid rgba(255,255,255,0.3); border-radius: 4px; color: white; font-family: inherit; font-size: 14px;">
                    <option value="ultra">ULTRA</option>
                    <option value="high">HIGH</option>
                    <option value="medium">MEDIUM</option>
                    <option value="low">LOW</option>
                    <option value="potato">POTATO</option>
                </select>
            </div>
            
            <div id="comparisonTable" style="background: rgba(0,0,0,0.4); padding: 15px; border-radius: 4px; margin-bottom: 20px;">
                <!-- Comparison table will be generated here -->
            </div>
            
            <div style="display: flex; gap: 15px; justify-content: center;">
                <button class="main-menu-btn" onclick="applyComparedPreset()" style="width: 200px; padding: 12px; background: var(--main-action);"> APPLY PRESET</button>
                <button class="main-menu-btn" onclick="closePresetComparison()" style="width: 200px; padding: 12px;"> CANCEL</button>
            </div>
        </div>
    </div>

    <!-- Quick Settings Customization Modal -->
    <div id="quick-settings-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 3000; align-items: center; justify-content: center;">
        <div style="background: var(--menu-bg-accent); padding: 30px; border-radius: 8px; border: 3px solid #666; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto;">
            <h2 style="color: white; margin-bottom: 20px; text-shadow: 3px 3px 0 rgba(0, 0, 0, 0.8);"> CUSTOMIZE QUICK SETTINGS</h2>
            <p style="color: #aaa; margin-bottom: 20px; font-size: 13px;">Select up to 6 settings to show in Quick Settings</p>
            
            <div id="quickSettingsOptions" style="display: grid; grid-template-columns: 1fr; gap: 10px;">
                <!-- Options will be generated here -->
            </div>
            
            <div style="display: flex; gap: 15px; justify-content: center; margin-top: 20px;">
                <button class="main-menu-btn" onclick="saveQuickSettings()" style="width: 200px; padding: 12px; background: var(--main-action);"> SAVE</button>
                <button class="main-menu-btn" onclick="closeQuickSettingsModal()" style="width: 200px; padding: 12px;"> CANCEL</button>
            </div>
        </div>
    </div>

    <!-- Model Texture Customization Modal -->
    <div id="model-customizer-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 3000; align-items: center; justify-content: center;">
        <div style="background: var(--menu-bg-accent); padding: 30px; border-radius: 8px; border: 3px solid #666; max-width: 800px; width: 95%; max-height: 90vh; overflow-y: auto;">
            <h2 style="color: white; margin-bottom: 15px; text-shadow: 3px 3px 0 rgba(0, 0, 0, 0.8);"> CUSTOMIZE MODEL TEXTURES</h2>
            <p style="color: #aaa; margin-bottom: 20px; font-size: 13px;">Paint textures for each body part and side. Click pixels to paint!</p>
            
            <!-- Body Part Selector -->
            <div style="margin-bottom: 20px; text-align: center;">
                <label style="color: white; display: block; margin-bottom: 10px; font-weight: 600;">Select Body Part:</label>
                <div style="display: flex; gap: 8px; justify-content: center; flex-wrap: wrap;">
                    <button class="part-selector-btn" data-part="head" onclick="selectBodyPart('head')" style="padding: 10px 20px; background: var(--main-action); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s;">Head</button>
                    <button class="part-selector-btn" data-part="headLayer" onclick="selectBodyPart('headLayer')" style="padding: 10px 20px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s;">Hat</button>
                    <button class="part-selector-btn" data-part="torso" onclick="selectBodyPart('torso')" style="padding: 10px 20px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s;">Torso</button>
                    <button class="part-selector-btn" data-part="torsoLayer" onclick="selectBodyPart('torsoLayer')" style="padding: 10px 20px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s;">Jacket</button>
                    <button class="part-selector-btn" data-part="leftArm" onclick="selectBodyPart('leftArm')" style="padding: 10px 20px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s;">Left Arm</button>
                    <button class="part-selector-btn" data-part="leftArmLayer" onclick="selectBodyPart('leftArmLayer')" style="padding: 10px 20px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s;">L Sleeve</button>
                    <button class="part-selector-btn" data-part="rightArm" onclick="selectBodyPart('rightArm')" style="padding: 10px 20px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s;">Right Arm</button>
                    <button class="part-selector-btn" data-part="rightArmLayer" onclick="selectBodyPart('rightArmLayer')" style="padding: 10px 20px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s;">R Sleeve</button>
                    <button class="part-selector-btn" data-part="leftLeg" onclick="selectBodyPart('leftLeg')" style="padding: 10px 20px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s;">Left Leg</button>
                    <button class="part-selector-btn" data-part="leftLegLayer" onclick="selectBodyPart('leftLegLayer')" style="padding: 10px 20px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s;">L Pants</button>
                    <button class="part-selector-btn" data-part="rightLeg" onclick="selectBodyPart('rightLeg')" style="padding: 10px 20px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s;">Right Leg</button>
                    <button class="part-selector-btn" data-part="rightLegLayer" onclick="selectBodyPart('rightLegLayer')" style="padding: 10px 20px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s;">R Pants</button>
                </div>
            </div>
            
            <!-- Side Selector -->
            <div style="margin-bottom: 20px; text-align: center;">
                <label style="color: white; display: block; margin-bottom: 10px; font-weight: 600;">Select Side:</label>
                <div style="display: flex; gap: 8px; justify-content: center; flex-wrap: wrap;">
                    <button class="side-selector-btn" data-side="front" onclick="selectTextureSide('front')" style="padding: 8px 16px; background: var(--main-action); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s; font-size: 12px;">Front</button>
                    <button class="side-selector-btn" data-side="back" onclick="selectTextureSide('back')" style="padding: 8px 16px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s; font-size: 12px;">Back</button>
                    <button class="side-selector-btn" data-side="left" onclick="selectTextureSide('left')" style="padding: 8px 16px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s; font-size: 12px;">Left</button>
                    <button class="side-selector-btn" data-side="right" onclick="selectTextureSide('right')" style="padding: 8px 16px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s; font-size: 12px;">Right</button>
                    <button class="side-selector-btn" data-side="top" onclick="selectTextureSide('top')" style="padding: 8px 16px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s; font-size: 12px;">Top</button>
                    <button class="side-selector-btn" data-side="bottom" onclick="selectTextureSide('bottom')" style="padding: 8px 16px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s; font-size: 12px;">Bottom</button>
                </div>
            </div>
            
            <!-- Display Options -->
            <div style="margin-bottom: 20px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 8px; border: 2px solid rgba(121, 192, 90, 0.3);">
                <h3 style="color: white; margin-bottom: 15px; font-size: 14px; text-align: center; text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.8);">Display Options</h3>
                
                <!-- Show Skin Layers -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 4px;">
                    <span style="color: white; font-size: 13px;">Show Skin Layers</span>
                    <label class="switch" style="margin-left: auto;">
                        <input type="checkbox" id="showSkinLayersToggle" checked>
                        <span class="slider round"></span>
                    </label>
                </div>
                
                <!-- Always Show FPS -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 4px;">
                    <span style="color: white; font-size: 13px;">Always Show FPS</span>
                    <label class="switch" style="margin-left: auto;">
                        <input type="checkbox" id="fpsAlwaysVisibleToggle">
                        <span class="slider round"></span>
                    </label>
                </div>
                
                <!-- Player Skin Upload -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 4px; gap: 8px;">
                    <span style="color: white; font-size: 13px;">Player Skin</span>
                    <div style="display: flex; gap: 8px; margin-left: auto;">
                        <button id="uploadSkinBtn" style="padding: 6px 12px; background: var(--main-action); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: 'Pixelify Sans', monospace; font-size: 12px;"> Upload</button>
                        <button id="exportSkinBtn" style="padding: 6px 12px; background: #7C7C7C; color: white; border: none; border-radius: 4px; cursor: pointer; font-family: 'Pixelify Sans', monospace; font-size: 12px;"> Export</button>
                    </div>
                    <input type="file" id="skinFileInput" accept="image/png" style="display: none;">
                </div>
                
                <!-- Slim Skin Toggle -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 4px;">
                    <span style="color: white; font-size: 13px;">Slim Arms (2px)</span>
                    <label class="switch" style="margin-left: auto;">
                        <input type="checkbox" id="slimSkinToggle">
                        <span class="slider round"></span>
                    </label>
                </div>
                
                <!-- Show Item in Hand -->
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 4px;">
                    <span style="color: white; font-size: 13px;">Show Item in Hand</span>
                    <label class="switch" style="margin-left: auto;">
                        <input type="checkbox" id="showHandToggle">
                        <span class="slider round"></span>
                    </label>
                </div>
            </div>
            
            <!-- Texture Editor with 3D Preview -->
            <div style="display: flex; gap: 30px; justify-content: center; margin-bottom: 20px; flex-wrap: wrap; align-items: flex-start;">
                <!-- Left Panel: 2D Texture Editor -->
                <div style="background: rgba(0,0,0,0.4); padding: 20px; border-radius: 10px; border: 2px solid rgba(121, 192, 90, 0.4);">
                    <h3 style="color: white; text-align: center; margin-bottom: 15px; font-size: 14px;">2D Texture Editor</h3>
                    <div style="display: flex; flex-direction: column; gap: 15px; align-items: center;">
                        <!-- Pixel Grid -->
                        <div style="text-align: center;">
                            <canvas id="texturePixelGrid" width="192" height="192" style="border: 3px solid #666; cursor: crosshair; image-rendering: pixelated; background: repeating-conic-gradient(#555 0% 25%, #444 0% 50%) 50% / 16px 16px; box-shadow: 0 4px 10px rgba(0,0,0,0.5);"></canvas>
                            <p style="color: #aaa; font-size: 11px; margin-top: 8px;">Click to paint  Shift+Click to erase</p>
                        </div>
                        
                        <!-- Color Palette -->
                        <div style="text-align: center; width: 100%;">
                            <label style="color: white; font-size: 12px; display: block; margin-bottom: 8px; font-weight: 600;">Color Palette</label>
                            <div id="textureColorPalette" style="display: grid; grid-template-columns: repeat(8, 28px); gap: 4px; margin-bottom: 10px; justify-content: center;">
                                <!-- Colors will be generated -->
                            </div>
                            <input type="color" id="textureCustomColor" value="#d4a574" style="width: 100%; height: 40px; cursor: pointer; border: 2px solid #666; border-radius: 6px; background: #222;">
                            <label style="color: white; font-size: 11px; display: block; margin-top: 5px;">Custom Color Picker</label>
                        </div>
                    </div>
                </div>
                
                <!-- Right Panel: 3D Preview -->
                <div style="background: rgba(0,0,0,0.4); padding: 20px; border-radius: 10px; border: 2px solid rgba(121, 192, 90, 0.4);">
                    <h3 style="color: white; text-align: center; margin-bottom: 15px; font-size: 14px;">3D Preview</h3>
                    <div style="position: relative;">
                        <canvas id="texturePreview3D" width="300" height="400" style="border: 3px solid #666; background: linear-gradient(180deg, #87CEEB 0%, #B0E0E6 50%, #98D8C8 100%); border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.5);"></canvas>
                        <div style="position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.7); padding: 6px 10px; border-radius: 4px; font-size: 10px; color: white;">
                             Auto-Rotating
                        </div>
                    </div>
                    <div style="margin-top: 12px; text-align: center;">
                        <label class="switch" style="display: inline-flex; align-items: center; gap: 8px;">
                            <span style="color: white; font-size: 11px;">Auto-Rotate</span>
                            <input type="checkbox" id="autoRotateToggle" checked>
                            <span class="slider round"></span>
                        </label>
                    </div>
                </div>
            </div>
            
            <div style="display: flex; gap: 12px; justify-content: center; margin-top: 20px; flex-wrap: wrap;">
                <button class="main-menu-btn" onclick="clearCurrentTexture()" style="padding: 10px 20px; background: rgba(255,100,100,0.8); font-size: 13px;"> CLEAR</button>
                <button class="main-menu-btn" onclick="resetAllTextures()" style="padding: 10px 20px; background: rgba(255,150,50,0.8); font-size: 13px;"> RESET ALL</button>
                <button class="main-menu-btn" onclick="saveModelTextures()" style="padding: 10px 20px; background: var(--main-action); font-size: 13px;"> SAVE</button>
                <button class="main-menu-btn" onclick="closeModelCustomizer()" style="padding: 10px 20px; font-size: 13px;"> CANCEL</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== AUDIO SYSTEM (WEB AUDIO API) ====================
        
        // Audio Context
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();
        
        // Master volumes
        let masterVolume = 1.0;
        let musicVolume = 0.5;
        let sfxVolume = 0.7;
        
        // Default values for reset functionality
        const DEFAULT_MASTER_VOLUME = 100;
        const DEFAULT_MUSIC_VOLUME = 50;
        const DEFAULT_SFX_VOLUME = 70;
        const DEFAULT_TAB_OUT_MUTE = 100;
        
        // Video settings defaults
        const DEFAULT_RENDER_DISTANCE = 20;
        const DEFAULT_FOV = 75;
        
        // Controls settings defaults
        const DEFAULT_MOUSE_SENSITIVITY = 100;
        const DEFAULT_HAND_BOB_INTENSITY = 100;
        
        // Tab-out mute settings
        let tabOutMuteLevel = 1.0; // 100% mute by default (0 = no mute, 1 = full mute)
        let isWindowFocused = true;
        let activeVolumeTransition = null;
        
        // FPS Display Setting
        var fpsAlwaysVisible = true; // Always visible during gameplay, hidden in menus
        
        // Keybind System - Define before loadSettings
        const DEFAULT_KEYBINDS = {
            forward: 'KeyW',
            backward: 'KeyS',
            left: 'KeyA',
            right: 'KeyD',
            jump: 'Space',
            sneak: 'ShiftLeft',
            inventory: 'KeyE',
            pause: 'Escape'
        };
        let keybinds = {...DEFAULT_KEYBINDS};
        
        // Background music gain node
        const musicGainNode = audioCtx.createGain();
        musicGainNode.connect(audioCtx.destination);
        musicGainNode.gain.value = musicVolume * masterVolume;
        
        // SFX gain node
        const sfxGainNode = audioCtx.createGain();
        sfxGainNode.connect(audioCtx.destination);
        sfxGainNode.gain.value = sfxVolume * masterVolume;
        
        // Background music oscillators (ambient Minecraft-style music)
        let musicOscillators = [];
        let isMusicPlaying = false;
        let selectedMusicTrack = 'random'; // Track selection: 'random' or 0-5
        const musicTrackNames = [
            ' Peaceful Dawn',
            ' Sunny Meadow', 
            ' Moonlit Cave',
            ' Starry Night',
            ' Autumn Forest',
            ' Mountain Peak'
        ];
        
        // Function to create button click sound (satisfying and pleasant)
        function playClickSound() {
            const now = audioCtx.currentTime;
            
            // Create a rich, layered click sound
            // Base tone - warm and full
            const osc1 = audioCtx.createOscillator();
            const gain1 = audioCtx.createGain();
            osc1.connect(gain1);
            gain1.connect(sfxGainNode);
            osc1.type = 'sine';
            osc1.frequency.setValueAtTime(520, now); // C5 note
            osc1.frequency.exponentialRampToValueAtTime(260, now + 0.15);
            gain1.gain.setValueAtTime(0.25, now);
            gain1.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
            osc1.start(now);
            osc1.stop(now + 0.15);
            
            // Harmonic layer - adds richness
            const osc2 = audioCtx.createOscillator();
            const gain2 = audioCtx.createGain();
            osc2.connect(gain2);
            gain2.connect(sfxGainNode);
            osc2.type = 'triangle';
            osc2.frequency.setValueAtTime(780, now); // G5 note (perfect fifth)
            osc2.frequency.exponentialRampToValueAtTime(390, now + 0.12);
            gain2.gain.setValueAtTime(0.15, now);
            gain2.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
            osc2.start(now);
            osc2.stop(now + 0.12);
            
            // Transient click - adds punch
            const osc3 = audioCtx.createOscillator();
            const gain3 = audioCtx.createGain();
            osc3.connect(gain3);
            gain3.connect(sfxGainNode);
            osc3.type = 'square';
            osc3.frequency.setValueAtTime(1200, now);
            osc3.frequency.exponentialRampToValueAtTime(100, now + 0.04);
            gain3.gain.setValueAtTime(0.2, now);
            gain3.gain.exponentialRampToValueAtTime(0.001, now + 0.04);
            osc3.start(now);
            osc3.stop(now + 0.04);
        }
        
        // Function to create button hover sound (gentle and inviting)
        function playHoverSound() {
            const now = audioCtx.currentTime;
            
            // Soft, pleasant hover tone
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            osc.connect(gainNode);
            gainNode.connect(sfxGainNode);
            
            osc.type = 'sine';
            osc.frequency.setValueAtTime(880, now); // A5 note
            osc.frequency.exponentialRampToValueAtTime(1320, now + 0.08); // E6 note (rises up)
            
            gainNode.gain.setValueAtTime(0.08, now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
            
            osc.start(now);
            osc.stop(now + 0.08);
        }
        
        // Function to start background music
        // Track looping configuration
        let currentLoopCount = 0;
        const LOOPS_PER_TRACK = 5; // Each track plays 5 times (80-100 seconds) before switching
        
        // Music progress tracking
        let musicStartTime = 0;
        let currentTrackDuration = 0;
        let currentTrackIndex = 0;
        let progressUpdateInterval = null;
        let isInMenu = true; // Track if we're in menu or gameplay
        
        // Format time helper
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        // Update progress bar and time display
        function updateMusicProgress() {
            const currentTime = audioCtx.currentTime - musicStartTime;
            const totalDuration = currentTrackDuration * LOOPS_PER_TRACK;
            const progress = (currentTime / totalDuration) * 100;
            
            const progressBar = document.getElementById('music-progress-bar');
            const timeDisplay = document.getElementById('music-toast-time');
            
            if (progressBar) {
                progressBar.style.width = `${Math.min(progress, 100)}%`;
            }
            
            if (timeDisplay) {
                timeDisplay.textContent = `${formatTime(currentTime)} / ${formatTime(totalDuration)}`;
            }
        }
        
        // Music keepalive monitor - restart music if it stops unexpectedly
        let musicKeepaliveInterval = null;
        let lastMusicCheck = 0;
        
        function startMusicKeepalive() {
            if (musicKeepaliveInterval) {
                clearInterval(musicKeepaliveInterval);
            }
            
            musicKeepaliveInterval = setInterval(() => {
                // Check if music should be playing but isn't
                if (musicVolume > 0 && masterVolume > 0 && !isMusicPlaying) {
                    console.log(' Music keepalive: Restarting stopped music');
                    startBackgroundMusic();
                }
                
                // Resume audio context if suspended
                if (audioCtx.state === 'suspended' && isMusicPlaying) {
                    console.log(' Music keepalive: Resuming suspended audio context');
                    audioCtx.resume().catch(err => console.error('Keepalive resume error:', err));
                }
            }, 3000); // Check every 3 seconds
        }
        
        // Start keepalive when page loads
        if (typeof window !== 'undefined') {
            setTimeout(startMusicKeepalive, 1000);
        }
        
        // Game State Management for Toast
        const GAME_STATE = {
            MAIN_MENU: 'main_menu',
            CREATE_WORLD: 'create_world',
            SAVED_WORLDS: 'saved_worlds',
            CREDITS: 'credits',
            LOADING: 'loading',
            IN_GAME: 'in_game',
            PAUSE_MENU: 'pause_menu',
            SETTINGS: 'settings'
        };
        
        let currentGameState = GAME_STATE.MAIN_MENU;
        
        // Set game state and update toast
        function setGameState(newState) {
            if (currentGameState === newState) return;
            
            console.log(` State: ${currentGameState}  ${newState}`);
            currentGameState = newState;
            
            // Immediately update toast when entering/leaving game
            updateToastVisibility();
        }
        
        // Show/hide toast based on game state
        function updateToastVisibility() {
            const toast = document.getElementById('music-toast');
            const showMusicToastToggle = document.getElementById('showMusicToastToggle');
            
            if (!toast) return;
            
            // Hide toast completely if music volume is 0%
            if (musicVolume === 0) {
                toast.style.display = 'none';
                toast.style.opacity = '0';
                toast.style.visibility = 'hidden';
                console.log(' Hiding toast - Music volume is 0%');
                return;
            }
            
            // Check if user disabled toast (only affects IN_GAME state)
            const isToastEnabledInGame = !showMusicToastToggle || showMusicToastToggle.checked;
            
            console.log(' Toast Visibility Update - State:', currentGameState, 'Toggle:', isToastEnabledInGame);
            
            // Remove mode classes but preserve position classes
            toast.classList.remove('menu-mode', 'pill-mode', 'hiding', 'expanded');
            
            // Apply appropriate mode based on state
            switch (currentGameState) {
                case GAME_STATE.MAIN_MENU:
                case GAME_STATE.PAUSE_MENU:
                    // Main menu and pause menu: ALWAYS show in expanded mode (ignore toggle)
                    toast.classList.add('menu-mode');
                    toast.style.display = 'flex';
                    toast.style.opacity = '1';
                    toast.style.visibility = 'visible';
                    isInMenu = true;
                    console.log(' Showing toast in MENU MODE (always visible)');
                    break;
                    
                case GAME_STATE.CREATE_WORLD:
                case GAME_STATE.SAVED_WORLDS:
                case GAME_STATE.CREDITS:
                case GAME_STATE.SETTINGS:
                    // Submenus: ALWAYS show in compact pill mode (ignore toggle)
                    toast.classList.add('pill-mode');
                    toast.style.display = 'flex';
                    toast.style.opacity = '1';
                    toast.style.visibility = 'visible';
                    isInMenu = false;
                    console.log(' Showing toast in PILL MODE (always visible)');
                    break;
                    
                case GAME_STATE.LOADING:
                case GAME_STATE.IN_GAME:
                default:
                    // IN-GAME: Only here does the toggle matter
                    if (isToastEnabledInGame) {
                        toast.classList.add('pill-mode');
                        toast.style.display = 'flex';
                        toast.style.opacity = '1';
                        toast.style.visibility = 'visible';
                        console.log(' Showing toast IN-GAME (toggle ON)');
                    } else {
                        // Completely invisible during gameplay
                        toast.style.display = 'none';
                        toast.style.opacity = '0';
                        toast.style.visibility = 'hidden';
                        console.log(' Hiding toast IN-GAME (toggle OFF)');
                    }
                    isInMenu = false;
                    break;
            }
        }
        
        function startBackgroundMusic() {
            if (isMusicPlaying || musicVolume === 0) return;
            
            // Resume audio context if suspended (browser autoplay policy)
            if (audioCtx.state === 'suspended') {
                audioCtx.resume().then(() => {
                    console.log(' Audio context resumed');
                }).catch(err => {
                    console.error('Failed to resume audio context:', err);
                });
            }
            
            isMusicPlaying = true;
            currentLoopCount = 0; // Reset loop counter
            
            // Define multiple ambient music tracks
            const musicTracks = [
                // Track 1: C major progression (peaceful)
                {
                    notes: [
                        { freq: 261.63, start: 0, duration: 4 },
                        { freq: 329.63, start: 0.5, duration: 4 },
                        { freq: 392.00, start: 1, duration: 4 },
                        { freq: 220.00, start: 4, duration: 4 },
                        { freq: 261.63, start: 4.5, duration: 4 },
                        { freq: 329.63, start: 5, duration: 4 },
                        { freq: 174.61, start: 8, duration: 4 },
                        { freq: 220.00, start: 8.5, duration: 4 },
                        { freq: 261.63, start: 9, duration: 4 },
                        { freq: 196.00, start: 12, duration: 4 },
                        { freq: 246.94, start: 12.5, duration: 4 },
                        { freq: 293.66, start: 13, duration: 4 },
                    ],
                    duration: 16
                },
                // Track 2: G major progression (uplifting)
                {
                    notes: [
                        { freq: 196.00, start: 0, duration: 5 },
                        { freq: 246.94, start: 0.6, duration: 5 },
                        { freq: 293.66, start: 1.2, duration: 5 },
                        { freq: 329.63, start: 5, duration: 5 },
                        { freq: 392.00, start: 5.6, duration: 5 },
                        { freq: 261.63, start: 6.2, duration: 5 },
                        { freq: 146.83, start: 10, duration: 5 },
                        { freq: 196.00, start: 10.6, duration: 5 },
                        { freq: 246.94, start: 11.2, duration: 5 },
                    ],
                    duration: 18
                },
                // Track 3: D minor progression (contemplative)
                {
                    notes: [
                        { freq: 293.66, start: 0, duration: 4 },
                        { freq: 349.23, start: 0.7, duration: 4 },
                        { freq: 220.00, start: 1.4, duration: 4 },
                        { freq: 261.63, start: 5, duration: 4 },
                        { freq: 329.63, start: 5.7, duration: 4 },
                        { freq: 196.00, start: 6.4, duration: 4 },
                        { freq: 174.61, start: 10, duration: 4 },
                        { freq: 220.00, start: 10.7, duration: 4 },
                        { freq: 293.66, start: 11.4, duration: 4 },
                        { freq: 246.94, start: 14, duration: 3 },
                        { freq: 293.66, start: 14.5, duration: 3 },
                    ],
                    duration: 17
                },
                // Track 4: E minor progression (mysterious)
                {
                    notes: [
                        { freq: 164.81, start: 0, duration: 6 },
                        { freq: 196.00, start: 0.8, duration: 6 },
                        { freq: 246.94, start: 1.6, duration: 6 },
                        { freq: 293.66, start: 6, duration: 6 },
                        { freq: 329.63, start: 6.8, duration: 6 },
                        { freq: 220.00, start: 7.6, duration: 6 },
                        { freq: 261.63, start: 12, duration: 5 },
                        { freq: 196.00, start: 12.8, duration: 5 },
                        { freq: 164.81, start: 13.6, duration: 5 },
                    ],
                    duration: 20
                },
                // Track 5: A minor progression (melancholic)
                {
                    notes: [
                        { freq: 220.00, start: 0, duration: 4.5 },
                        { freq: 261.63, start: 0.5, duration: 4.5 },
                        { freq: 329.63, start: 1, duration: 4.5 },
                        { freq: 196.00, start: 4.5, duration: 4.5 },
                        { freq: 246.94, start: 5, duration: 4.5 },
                        { freq: 293.66, start: 5.5, duration: 4.5 },
                        { freq: 174.61, start: 9, duration: 4.5 },
                        { freq: 220.00, start: 9.5, duration: 4.5 },
                        { freq: 261.63, start: 10, duration: 4.5 },
                        { freq: 329.63, start: 13.5, duration: 3 },
                        { freq: 220.00, start: 14, duration: 3 },
                    ],
                    duration: 17
                },
                // Track 6: F major progression (warm)
                {
                    notes: [
                        { freq: 174.61, start: 0, duration: 5 },
                        { freq: 220.00, start: 0.6, duration: 5 },
                        { freq: 261.63, start: 1.2, duration: 5 },
                        { freq: 196.00, start: 5, duration: 5 },
                        { freq: 246.94, start: 5.6, duration: 5 },
                        { freq: 293.66, start: 6.2, duration: 5 },
                        { freq: 261.63, start: 10, duration: 5 },
                        { freq: 329.63, start: 10.6, duration: 5 },
                        { freq: 392.00, start: 11.2, duration: 5 },
                        { freq: 220.00, start: 15, duration: 4 },
                        { freq: 174.61, start: 15.5, duration: 4 },
                    ],
                    duration: 19
                },
            ];
            
            // Function to show music toast notification (enhanced with progress tracking)
            function showMusicToast(trackIndex) {
                const toast = document.getElementById('music-toast');
                const toastText = document.getElementById('music-toast-text');
                
                if (toast && toastText) {
                    currentTrackIndex = trackIndex;
                    toastText.textContent = `Now Playing: ${musicTrackNames[trackIndex]}`;
                    
                    // Check if in menu
                    updateToastVisibility();
                    
                    // Reset progress
                    musicStartTime = audioCtx.currentTime;
                    
                    // Clear existing interval
                    if (progressUpdateInterval) {
                        clearInterval(progressUpdateInterval);
                    }
                    
                    // Update progress every 500ms
                    progressUpdateInterval = setInterval(updateMusicProgress, 500);
                }
            }
            
            // Select track based on preference
            let trackIndex;
            if (selectedMusicTrack === 'random') {
                trackIndex = Math.floor(Math.random() * musicTracks.length);
            } else {
                trackIndex = parseInt(selectedMusicTrack);
            }
            
            const currentTrack = musicTracks[trackIndex];
            const notes = currentTrack.notes;
            const loopDuration = currentTrack.duration;
            currentTrackDuration = loopDuration; // Store for progress tracking
            
            // Show toast notification
            showMusicToast(trackIndex);
            
            function playMusicLoop() {
                if (!isMusicPlaying) return;
                
                // Ensure audio context is running
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume().catch(err => console.error('Audio resume error:', err));
                }
                
                notes.forEach(note => {
                    const osc = audioCtx.createOscillator();
                    const gainNode = audioCtx.createGain();
                    const filter = audioCtx.createBiquadFilter();
                    
                    osc.connect(filter);
                    filter.connect(gainNode);
                    gainNode.connect(musicGainNode);
                    
                    osc.type = 'sine';
                    osc.frequency.value = note.freq;
                    
                    filter.type = 'lowpass';
                    filter.frequency.value = 2000;
                    filter.Q.value = 1;
                    
                    const startTime = audioCtx.currentTime + note.start;
                    const endTime = startTime + note.duration;
                    
                    gainNode.gain.setValueAtTime(0, startTime);
                    gainNode.gain.linearRampToValueAtTime(0.08, startTime + 0.5);
                    gainNode.gain.linearRampToValueAtTime(0.06, endTime - 0.5);
                    gainNode.gain.linearRampToValueAtTime(0, endTime);
                    
                    osc.start(startTime);
                    osc.stop(endTime);
                    
                    musicOscillators.push(osc);
                });
                
                // Schedule next loop
                setTimeout(() => {
                    if (!isMusicPlaying) return; // Check again before continuing
                    
                    currentLoopCount++;
                    
                    // After LOOPS_PER_TRACK loops, switch to a new track
                    if (currentLoopCount >= LOOPS_PER_TRACK) {
                        currentLoopCount = 0;
                        
                        // Select new track based on preference
                        let nextTrackIndex;
                        if (selectedMusicTrack === 'random') {
                            nextTrackIndex = Math.floor(Math.random() * musicTracks.length);
                        } else {
                            nextTrackIndex = parseInt(selectedMusicTrack);
                        }
                        
                        const nextTrack = musicTracks[nextTrackIndex];
                        notes.length = 0;
                        notes.push(...nextTrack.notes);
                        currentTrackDuration = nextTrack.duration; // Update duration for progress tracking
                        showMusicToast(nextTrackIndex); // Show toast when switching tracks
                        playMusicLoop();
                    } else {
                        // Same track, just loop it again (no toast)
                        playMusicLoop();
                    }
                }, loopDuration * 1000);
            }
            
            playMusicLoop();
        }
        
        // Function to stop background music
        function stopBackgroundMusic() {
            isMusicPlaying = false;
            musicOscillators.forEach(osc => {
                try {
                    osc.stop();
                } catch (e) {
                    // Already stopped
                }
            });
            musicOscillators = [];
        }
        
        // Update volume functions
        function updateMasterVolume(value) {
            masterVolume = value / 100;
            // Update both music and SFX with master volume (and tab-out mute if applicable)
            const muteMultiplier = isWindowFocused ? 1 : (1 - tabOutMuteLevel);
            musicGainNode.gain.value = musicVolume * masterVolume * muteMultiplier;
            sfxGainNode.gain.value = sfxVolume * masterVolume * muteMultiplier;
            
            if (masterVolume === 0 && isMusicPlaying) {
                stopBackgroundMusic();
            } else if (masterVolume > 0 && musicVolume > 0 && !isMusicPlaying) {
                startBackgroundMusic();
            }
        }
        
        function updateMusicVolume(value) {
            musicVolume = value / 100;
            const muteMultiplier = isWindowFocused ? 1 : (1 - tabOutMuteLevel);
            musicGainNode.gain.value = musicVolume * masterVolume * muteMultiplier;
            
            // Update toast visibility when volume changes
            updateToastVisibility();
            
            if (musicVolume === 0 && isMusicPlaying) {
                stopBackgroundMusic();
            } else if (musicVolume > 0 && masterVolume > 0 && !isMusicPlaying) {
                startBackgroundMusic();
            }
        }
        
        function updateSFXVolume(value) {
            sfxVolume = value / 100;
            sfxGainNode.gain.value = sfxVolume * masterVolume * (isWindowFocused ? 1 : (1 - tabOutMuteLevel));
        }
        
        function updateTabOutMuteLevel(value) {
            tabOutMuteLevel = value / 100;
            // Apply immediately if window is not focused
            if (!isWindowFocused) {
                applyTabOutMute(false);
            }
        }
        
        // Smooth volume transition function
        function smoothVolumeTransition(targetMusicVolume, targetSfxVolume, duration = 1000) {
            // Cancel any existing transition
            if (activeVolumeTransition) {
                clearInterval(activeVolumeTransition);
            }
            
            const startMusicVolume = musicGainNode.gain.value;
            const startSfxVolume = sfxGainNode.gain.value;
            const startTime = Date.now();
            
            activeVolumeTransition = setInterval(() => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Ease-in-out cubic for smooth transition
                const eased = progress < 0.5 
                    ? 4 * progress * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 3) / 2;
                
                musicGainNode.gain.value = startMusicVolume + (targetMusicVolume - startMusicVolume) * eased;
                sfxGainNode.gain.value = startSfxVolume + (targetSfxVolume - startSfxVolume) * eased;
                
                if (progress >= 1) {
                    clearInterval(activeVolumeTransition);
                    activeVolumeTransition = null;
                }
            }, 16); // ~60fps
        }
        
        // Apply tab-out mute
        function applyTabOutMute(smooth = true) {
            const muteMultiplier = 1 - tabOutMuteLevel;
            const targetMusicVolume = musicVolume * masterVolume * muteMultiplier;
            const targetSfxVolume = sfxVolume * masterVolume * muteMultiplier;
            
            if (smooth) {
                smoothVolumeTransition(targetMusicVolume, targetSfxVolume, 1000);
            } else {
                musicGainNode.gain.value = targetMusicVolume;
                sfxGainNode.gain.value = targetSfxVolume;
            }
        }
        
        // Remove tab-out mute (restore normal volume)
        function removeTabOutMute(smooth = true) {
            const targetMusicVolume = musicVolume * masterVolume;
            const targetSfxVolume = sfxVolume * masterVolume;
            
            if (smooth) {
                smoothVolumeTransition(targetMusicVolume, targetSfxVolume, 1000);
            } else {
                musicGainNode.gain.value = targetMusicVolume;
                sfxGainNode.gain.value = targetSfxVolume;
            }
        }
        
        // Window focus/blur event listeners
        window.addEventListener('focus', () => {
            isWindowFocused = true;
            removeTabOutMute(true);
        });
        
        window.addEventListener('blur', () => {
            isWindowFocused = false;
            applyTabOutMute(true);
        });
        
        // ==================== SETTINGS VARIABLES (MUST BE DECLARED FIRST) ====================
        var renderDistance = 20;
        var mouseSensitivity = 1.0;
        var fieldOfView = 75;
        var handBobEnabled = true;
        var handBobIntensity = 100; // 0-200%
        var showItemInHand = true;
        var customHandTexture = null; // Will store 16x16 custom texture data for the arm
        var customSkinTexture = null; // Will store full 64x64 skin texture with layers
        var showSkinLayers = true; // Toggle for second layer visibility
        var shadowsEnabled = false; // Enable/disable shadows (OFF by default - experimental)
        
        // Flag to track if we opened settings from pause menu
        var openedSettingsFromPause = false;
        
        // ==================== LOCALSTORAGE SAVE/LOAD SYSTEM ====================
        
        // Save settings to localStorage
        function saveSettings() {
            const settings = {
                renderDistance: renderDistance,
                mouseSensitivity: mouseSensitivity,
                fieldOfView: fieldOfView,
                masterVolume: masterVolume * 100,
                musicVolume: musicVolume * 100,
                sfxVolume: sfxVolume * 100,
                tabOutMuteLevel: tabOutMuteLevel * 100,
                handBobEnabled: handBobEnabled,
                handBobIntensity: handBobIntensity,
                showItemInHand: showItemInHand,
                customHandTexture: customHandTexture,
                customSkinTexture: customSkinTexture,
                showSkinLayers: showSkinLayers,
                keybinds: keybinds,
                shadowsEnabled: shadowsEnabled,
                selectedMusicTrack: selectedMusicTrack,
                fpsAlwaysVisible: fpsAlwaysVisible,
                isSlimSkin: isSlimSkin
            };
            localStorage.setItem('minecraftSettings', JSON.stringify(settings));
            console.log(' SAVED SETTINGS:', settings);
        }
        
        // Load settings from localStorage
        function loadSettings() {
            const savedSettings = localStorage.getItem('minecraftSettings');
            console.log(' RAW LOCALSTORAGE:', savedSettings);
            if (savedSettings) {
                try {
                    const settings = JSON.parse(savedSettings);
                    console.log(' LOADED SETTINGS:', settings);
                    renderDistance = settings.renderDistance || 20;
                    mouseSensitivity = settings.mouseSensitivity || 1.0;
                    fieldOfView = settings.fieldOfView || 75;
                    handBobEnabled = settings.handBobEnabled !== undefined ? settings.handBobEnabled : true;
                    handBobIntensity = settings.handBobIntensity || 100;
                    showItemInHand = settings.showItemInHand !== undefined ? settings.showItemInHand : true;
                    customHandTexture = settings.customHandTexture || null;
                    customSkinTexture = settings.customSkinTexture || null;
                    showSkinLayers = settings.showSkinLayers !== undefined ? settings.showSkinLayers : true;
                    shadowsEnabled = settings.shadowsEnabled !== undefined ? settings.shadowsEnabled : false;
                    fpsAlwaysVisible = settings.fpsAlwaysVisible !== undefined ? settings.fpsAlwaysVisible : false;
                    isSlimSkin = settings.isSlimSkin !== undefined ? settings.isSlimSkin : false;
                    
                    // Load keybinds
                    if (settings.keybinds) {
                        keybinds = {...DEFAULT_KEYBINDS, ...settings.keybinds};
                    }
                    
                    // Load audio settings - only update the values, UI will be initialized separately
                    if (settings.masterVolume !== undefined) {
                        masterVolume = settings.masterVolume / 100;
                        console.log(' Loaded masterVolume:', masterVolume);
                    }
                    if (settings.musicVolume !== undefined) {
                        musicVolume = settings.musicVolume / 100;
                        console.log(' Loaded musicVolume:', musicVolume);
                    }
                    if (settings.sfxVolume !== undefined) {
                        sfxVolume = settings.sfxVolume / 100;
                        console.log(' Loaded sfxVolume:', sfxVolume);
                    }
                    if (settings.tabOutMuteLevel !== undefined) {
                        tabOutMuteLevel = settings.tabOutMuteLevel / 100;
                        console.log(' Loaded tabOutMuteLevel:', tabOutMuteLevel);
                    }
                    
                    // Load music track selection
                    if (settings.selectedMusicTrack !== undefined) {
                        selectedMusicTrack = settings.selectedMusicTrack;
                        console.log(' Loaded selectedMusicTrack:', selectedMusicTrack);
                    }
                    
                    console.log(' FINAL VOLUME VALUES - Master:', masterVolume, 'Music:', musicVolume, 'SFX:', sfxVolume, 'TabMute:', tabOutMuteLevel);
                    
                    // Update audio gain nodes with loaded values
                    musicGainNode.gain.value = musicVolume * masterVolume;
                    sfxGainNode.gain.value = sfxVolume * masterVolume;
                    
                    // Load hand settings UI
                    const handBobToggle = document.getElementById('handBobToggle');
                    const handBobSlider = document.getElementById('handBobIntensitySlider');
                    const showHandToggle = document.getElementById('showHandToggle');
                    const showSkinLayersToggle = document.getElementById('showSkinLayersToggle');
                    
                    if (handBobToggle) handBobToggle.checked = handBobEnabled;
                    if (handBobSlider) {
                        handBobSlider.value = handBobIntensity;
                        const handBobIntensityValue = document.getElementById('handBobIntensityValue');
                        if (handBobIntensityValue) handBobIntensityValue.textContent = handBobIntensity;
                    }
                    if (showHandToggle) showHandToggle.checked = showItemInHand;
                    if (showSkinLayersToggle) showSkinLayersToggle.checked = showSkinLayers;
                    
                    // Load music track selector UI
                    const musicTrackSelector = document.getElementById('musicTrackSelector');
                    if (musicTrackSelector) {
                        musicTrackSelector.value = selectedMusicTrack;
                    }
                    
                    // Update camera FOV
                    if (camera) {
                        camera.fov = fieldOfView;
                        camera.updateProjectionMatrix();
                    }
                    
                    // Load shadows toggle UI
                    const shadowsToggle = document.getElementById('shadowsToggle');
                    if (shadowsToggle) {
                        shadowsToggle.checked = shadowsEnabled;
                    }
                    
                    // Load FPS always visible toggle UI
                    const fpsToggle = document.getElementById('fpsAlwaysVisibleToggle');
                    if (fpsToggle) {
                        fpsToggle.checked = fpsAlwaysVisible;
                    }
                    
                    // Apply shadows setting to renderer if it exists
                    if (renderer) {
                        renderer.shadowMap.enabled = shadowsEnabled;
                    }
                } catch (e) {
                    console.error('Failed to load settings:', e);
                }
            }
        }
        
        // ==================== EXPORT/IMPORT SYSTEM ====================
        
        // Helper function to download data as JSON file
        function downloadJSON(data, filename) {
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // Export settings only
        function exportSettings() {
            const settings = localStorage.getItem('minecraftSettings');
            if (!settings) {
                alert(' No settings found to export!');
                return;
            }
            const data = {
                type: 'settings',
                exportedAt: new Date().toISOString(),
                settings: JSON.parse(settings)
            };
            downloadJSON(data, `minecraft-settings-${Date.now()}.json`);
            alert(' Settings exported successfully!');
        }
        
        // Export worlds only
        function exportWorlds() {
            const worlds = localStorage.getItem('minecraftSaves');
            if (!worlds) {
                alert(' No worlds found to export!');
                return;
            }
            const parsedWorlds = JSON.parse(worlds);
            const worldCount = Object.keys(parsedWorlds).length;
            const data = {
                type: 'worlds',
                exportedAt: new Date().toISOString(),
                worldCount: worldCount,
                worlds: parsedWorlds
            };
            downloadJSON(data, `minecraft-worlds-${Date.now()}.json`);
            alert(` ${worldCount} world(s) exported successfully!`);
        }
        
        // Export everything (settings + worlds)
        function exportAll() {
            const settings = localStorage.getItem('minecraftSettings');
            const worlds = localStorage.getItem('minecraftSaves');
            
            if (!settings && !worlds) {
                alert(' No data found to export!');
                return;
            }
            
            const data = {
                type: 'complete',
                exportedAt: new Date().toISOString(),
                settings: settings ? JSON.parse(settings) : null,
                worlds: worlds ? JSON.parse(worlds) : null
            };
            
            downloadJSON(data, `minecraft-complete-backup-${Date.now()}.json`);
            alert(' Complete backup exported successfully!');
        }
        
        // Import data from JSON file
        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // Validate data type
                    if (!data.type || !['settings', 'worlds', 'complete'].includes(data.type)) {
                        alert(' Invalid file format! Please select a valid export file.');
                        return;
                    }
                    
                    let importedItems = [];
                    
                    // Import settings
                    if ((data.type === 'settings' || data.type === 'complete') && data.settings) {
                        localStorage.setItem('minecraftSettings', JSON.stringify(data.settings));
                        loadSettings(); // Reload settings immediately
                        importedItems.push('Settings');
                    }
                    
                    // Import worlds
                    if ((data.type === 'worlds' || data.type === 'complete') && data.worlds) {
                        const existingWorlds = JSON.parse(localStorage.getItem('minecraftSaves') || '{}');
                        const worldCount = Object.keys(data.worlds).length;
                        
                        // Ask user about merge or replace
                        const hasExisting = Object.keys(existingWorlds).length > 0;
                        let shouldMerge = true;
                        
                        if (hasExisting) {
                            shouldMerge = confirm(
                                `You have existing worlds. Do you want to merge them with imported worlds?\n\n` +
                                `Click OK to MERGE (keep both)\n` +
                                `Click Cancel to REPLACE (overwrite existing)`
                            );
                        }
                        
                        if (shouldMerge) {
                            // Merge: keep existing and add new ones
                            const mergedWorlds = { ...existingWorlds, ...data.worlds };
                            localStorage.setItem('minecraftSaves', JSON.stringify(mergedWorlds));
                        } else {
                            // Replace: overwrite all
                            localStorage.setItem('minecraftSaves', JSON.stringify(data.worlds));
                        }
                        
                        importedItems.push(`${worldCount} World(s)`);
                    }
                    
                    if (importedItems.length > 0) {
                        alert(` Successfully imported:\n${importedItems.join(', ')}\n\nExported: ${new Date(data.exportedAt).toLocaleString()}`);
                    } else {
                        alert(' No data was imported.');
                    }
                    
                } catch (error) {
                    console.error('Import error:', error);
                    alert(' Failed to import data. Please check the file format.');
                }
            };
            
            reader.readAsText(file);
            // Reset file input so same file can be imported again
            event.target.value = '';
        }
        
        // Capture world preview screenshot
        function captureWorldPreview() {
            try {
                renderer.render(scene, camera);
                return renderer.domElement.toDataURL('image/jpeg', 0.5);
            } catch (e) {
                console.error('Failed to capture preview:', e);
                return null;
            }
        }
        
        // Save world data to localStorage
        function saveWorld(worldName) {
            if (!worldName) {
                worldName = 'World_' + WORLD_SEED + '_' + Date.now();
            }
            
            // Convert world object to serializable format
            const worldData = {};
            const doorData = {}; // Store door-specific data
            for (let k in world) {
                worldData[k] = world[k].userData.blockType;
                
                // Save door rotation and state
                if (world[k].userData.isDoor) {
                    doorData[k] = {
                        rotation: world[k].userData.doorRotation,
                        open: world[k].userData.doorOpen
                    };
                }
            }
            
            // Capture preview image
            const previewImage = captureWorldPreview();
            
            const saveData = {
                name: worldName,
                seed: WORLD_SEED,
                worldSize: ws,
                isFlatWorld: isFlatWorld,
                worldBorderEnabled: worldBorderEnabled,
                worldData: worldData,
                doorData: doorData, // Save door metadata
                playerPosition: { px, py, pz, rx, ry },
                inventory: inventoryData,
                isCreativeMode: isCreativeMode,
                dayTime: dayTime,
                dayCounter: dayCounter,
                moonPhase: moonPhase,
                preview: previewImage,
                savedAt: new Date().toISOString()
            };
            
            try {
                // Get existing saves
                const saves = JSON.parse(localStorage.getItem('minecraftSaves') || '{}');
                saves[worldName] = saveData;
                localStorage.setItem('minecraftSaves', JSON.stringify(saves));
                
                console.log('World saved:', worldName);
                return worldName;
            } catch (e) {
                if (e.name === 'QuotaExceededError') {
                    // Storage quota exceeded
                    console.error('Storage quota exceeded!');
                    alert(' STORAGE FULL!\n\nYou have too many worlds saved. Please delete some old worlds from the "LOAD WORLD" menu to free up space.\n\nTip: Your browser only allows about 5-10MB of saved data.');
                    return null;
                } else {
                    console.error('Error saving world:', e);
                    alert(' Error saving world: ' + e.message);
                    return null;
                }
            }
        }
        
        // Load world data from localStorage
        function loadWorld(worldName) {
            const saves = JSON.parse(localStorage.getItem('minecraftSaves') || '{}');
            const saveData = saves[worldName];
            
            if (!saveData) {
                console.error('World not found:', worldName);
                return false;
            }
            
            // Clear existing world
            for(var k in world) { 
                scene.remove(world[k]); 
            }
            world = {};
            
            // Restore world settings
            WORLD_SEED = saveData.seed;
            ws = saveData.worldSize;
            isFlatWorld = saveData.isFlatWorld || false;
            worldBorderEnabled = saveData.worldBorderEnabled !== undefined ? saveData.worldBorderEnabled : true; // Default to enabled
            isCreativeMode = saveData.isCreativeMode || false;
            dayTime = saveData.dayTime || (6 / 24) * 1440; // Default to 6:00 AM if not saved
            dayCounter = saveData.dayCounter || 1; // Default to day 1 if not saved
            moonPhase = saveData.moonPhase || 0; // Default to phase 0 if not saved
            
            // Restore world blocks
            for (let k in saveData.worldData) {
                const [x, y, z] = k.split(',').map(Number);
                add(x, y, z, saveData.worldData[k]);
            }
            
            // Restore door states and rotations
            if (saveData.doorData) {
                for (let k in saveData.doorData) {
                    const [x, y, z] = k.split(',').map(Number);
                    const doorMesh = world[k];
                    if (doorMesh && doorMesh.userData.isDoor) {
                        doorMesh.userData.doorRotation = saveData.doorData[k].rotation;
                        doorMesh.rotation.y = saveData.doorData[k].rotation;
                        doorMesh.userData.doorOpen = saveData.doorData[k].open;
                        
                        // If door was open, apply the open rotation
                        if (saveData.doorData[k].open) {
                            doorMesh.rotation.y = saveData.doorData[k].rotation + Math.PI / 2;
                        }
                    }
                }
            }
            
            // Restore player position
            if (saveData.playerPosition) {
                px = saveData.playerPosition.px;
                py = saveData.playerPosition.py;
                pz = saveData.playerPosition.pz;
                rx = saveData.playerPosition.rx;
                ry = saveData.playerPosition.ry;
                camera.position.set(px, py, pz);
                camera.rotation.set(rx, ry, 0, 'YXZ');
            }
            
            // Restore inventory
            if (saveData.inventory) {
                inventoryData = saveData.inventory;
            }
            
            // Update UI
            updateGameModeButtonText();
            inventoryScreen.classList.toggle('creative-mode', isCreativeMode);
            updateInventoryUI();
            updateToolbarSelection();
            
            // Initialize game start time
            window.gameStartTime = Date.now();
            
            console.log('World loaded:', worldName);
            return true;
        }
        
        // Delete world from localStorage
        function deleteWorld(worldName) {
            const saves = JSON.parse(localStorage.getItem('minecraftSaves') || '{}');
            delete saves[worldName];
            localStorage.setItem('minecraftSaves', JSON.stringify(saves));
            console.log('World deleted:', worldName);
        }
        
        // Get list of saved worlds
        function getSavedWorlds() {
            const saves = JSON.parse(localStorage.getItem('minecraftSaves') || '{}');
            return Object.keys(saves).map(name => ({
                name: name,
                ...saves[name]
            }));
        }
        
        // Rename world function
        function renameWorld(oldName, newName) {
            if (!newName || newName.trim() === '') {
                alert('World name cannot be empty');
                return false;
            }
            
            const saves = JSON.parse(localStorage.getItem('minecraftSaves') || '{}');
            
            if (saves[newName] && newName !== oldName) {
                alert('A world with this name already exists');
                return false;
            }
            
            if (saves[oldName]) {
                saves[newName] = { ...saves[oldName], name: newName };
                delete saves[oldName];
                localStorage.setItem('minecraftSaves', JSON.stringify(saves));
                
                // Update current world name if it's the one being renamed
                if (currentWorldName === oldName) {
                    currentWorldName = newName;
                }
                
                return true;
            }
            return false;
        }
        
        // Show rename modal
        function showRenameModal(worldName) {
            const modal = document.createElement('div');
            modal.className = 'rename-modal';
            modal.innerHTML = `
                <h3> Rename World</h3>
                <input type="text" id="rename-input" value="${worldName}" maxlength="30">
                <div class="rename-modal-buttons">
                    <button class="main-menu-btn" onclick="confirmRename('${worldName}')" style="background: var(--main-action); padding: 10px 24px;">SAVE</button>
                    <button class="main-menu-btn" onclick="closeRenameModal()" style="padding: 10px 24px;">CANCEL</button>
                </div>
            `;
            modal.id = 'rename-modal';
            document.body.appendChild(modal);
            const renameInput = document.getElementById('rename-input');
            if (renameInput) {
                renameInput.focus();
                renameInput.select();
            }
        }
        
        function confirmRename(oldName) {
            const renameInput = document.getElementById('rename-input');
            if (!renameInput) return;
            const newName = renameInput.value.trim();
            if (renameWorld(oldName, newName)) {
                closeRenameModal();
                displaySavedWorlds();
            }
        }
        
        function closeRenameModal() {
            const modal = document.getElementById('rename-modal');
            if (modal) {
                modal.remove();
            }
        }
        
        // Display saved worlds list
        function displaySavedWorlds() {
            const savedWorldsList = document.getElementById('saved-worlds-list');
            const worlds = getSavedWorlds();
            
            if (worlds.length === 0) {
                savedWorldsList.innerHTML = '<p style="color: #aaa; text-align: center; padding: 20px;">No saved worlds yet. Create a world to get started!</p>';
                return;
            }
            
            savedWorldsList.innerHTML = '';
            
            worlds.forEach(world => {
                const card = document.createElement('div');
                card.className = 'saved-world-card';
                
                const preview = document.createElement('img');
                preview.className = 'world-preview';
                preview.src = world.preview || 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="120" height="90"><rect width="120" height="90" fill="%23373737"/><text x="60" y="45" text-anchor="middle" fill="%23888" font-size="12" font-family="monospace">No Preview</text></svg>';
                preview.alt = world.name;
                
                const info = document.createElement('div');
                info.className = 'world-info';
                
                const name = document.createElement('div');
                name.className = 'world-name';
                name.textContent = world.name;
                name.title = 'Click to rename';
                name.onclick = () => showRenameModal(world.name);
                
                const details = document.createElement('div');
                details.className = 'world-details';
                const savedDate = new Date(world.savedAt).toLocaleString();
                details.innerHTML = `
                    <div> Seed: ${world.seed}</div>
                    <div> Size: ${world.worldSize}</div>
                    <div> Mode: ${world.isCreativeMode ? 'Creative' : 'Survival'}</div>
                    <div> Border: ${world.worldBorderEnabled !== false ? 'Enabled' : 'Disabled'}</div>
                    <div> Saved: ${savedDate}</div>
                `;
                
                info.appendChild(name);
                info.appendChild(details);
                
                const actions = document.createElement('div');
                actions.className = 'world-actions';
                
                const loadBtn = document.createElement('button');
                loadBtn.textContent = ' LOAD';
                loadBtn.className = 'world-action-btn load';
                loadBtn.onclick = () => {
                    if (loadWorld(world.name)) {
                        generateInventorySlots();
                        updateToolbarSelection();
                        startAutoSave(world.name);
                        const mainMenu = document.getElementById('main-menu');
                        mainMenu.style.display = 'none';
                        // Stop parallax animation completely during gameplay
                        mainMenu.style.animation = 'none';
                        mainMenu.style.backgroundColor = 'transparent';
                        
                        // Music continues playing during gameplay
                        setGameState(GAME_STATE.IN_GAME); // Set state when loading completes
                        
                        // Hide parallax/starfield effect when game starts
                        const starfieldCanvas = document.getElementById('starfield-bg');
                        if (starfieldCanvas) {
                            starfieldCanvas.classList.remove('active');
                            starfieldCanvas.style.opacity = '0';
                        }
                        
                        // Request pointer lock and show all HUD elements
                        requestLock(renderer.domElement);
                        const crosshair = document.getElementById('crosshair');
                        const toolbar = document.getElementById('toolbar');
                        if (crosshair) crosshair.style.display = 'block';
                        if (toolbar) toolbar.style.display = 'flex';
                        if (!isCreativeMode) {
                            const healthContainer = document.getElementById('health-container');
                            const oxygenContainer = document.getElementById('oxygen-container');
                            if (healthContainer) healthContainer.style.display = 'block';
                            if (oxygenContainer) oxygenContainer.style.display = 'block';
                        }
                        // Respect FPS and UI visibility settings when loading world
                        const fpsElement = document.getElementById('fps');
                        if (fpsElement) {
                            // Show FPS only when in game and setting is enabled
                            fpsElement.style.display = (fpsAlwaysVisible && currentGameState === GAME_STATE.IN_GAME) || showHitbox ? 'block' : 'none';
                        }
                        if (uiElement) {
                            uiElement.style.display = showHitbox ? 'block' : 'none';
                        }
                        const debugInfoElement = document.getElementById('debug-info');
                        if (debugInfoElement) {
                            debugInfoElement.style.display = showHitbox ? 'block' : 'none';
                        }
                        
                        locked = false;
                        paused = false;
                        if (!window.gameLoopStarted) {
                            loop();
                            window.gameLoopStarted = true;
                        }
                    }
                };
                
                const renameBtn = document.createElement('button');
                renameBtn.textContent = ' RENAME';
                renameBtn.className = 'world-action-btn';
                renameBtn.onclick = () => showRenameModal(world.name);
                
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = ' DELETE';
                deleteBtn.className = 'world-action-btn delete';
                deleteBtn.onclick = () => {
                    if (confirm(`Are you sure you want to delete "${world.name}"?`)) {
                        deleteWorld(world.name);
                        displaySavedWorlds();
                    }
                };
                
                actions.appendChild(loadBtn);
                actions.appendChild(renameBtn);
                actions.appendChild(deleteBtn);
                
                card.appendChild(preview);
                card.appendChild(info);
                card.appendChild(actions);
                
                savedWorldsList.appendChild(card);
            });
        }
        
        // Auto-save current world every 30 seconds
        let autoSaveInterval = null;
        let currentWorldName = null;
        
        function startAutoSave(worldName) {
            currentWorldName = worldName;
            if (autoSaveInterval) clearInterval(autoSaveInterval);
            
            autoSaveInterval = setInterval(() => {
                if (!paused && currentWorldName) {
                    saveWorld(currentWorldName);
                    console.log('Auto-saved world');
                }
            }, 30000); // Every 30 seconds
        }
        
        function stopAutoSave() {
            if (autoSaveInterval) {
                clearInterval(autoSaveInterval);
                autoSaveInterval = null;
            }
        }
        
        // ==================== END LOCALSTORAGE SYSTEM ====================

        // NEW: Cross-browser Pointer Lock Request function
        function requestLock(element) {
            (element.requestPointerLock ||
             element.mozRequestPointerLock ||
             element.webkitRequestPointerLock).call(element);
        }
        
        // --- GAME STATE ---
        let isCreativeMode = false; // MODIFIED: Survival is now default
        let isFlatWorld = false; // NEW: Flat world option

        // --- DAY/NIGHT CYCLE VARIABLES ---
        // Start at 6:00 AM (6 hours into the 24-hour cycle = 25% of dayLength)
        let dayTime = (6 / 24) * 1440; // Starting at 6:00 AM (360 seconds)
        const dayLength = 1440; // 24 minutes for a full day cycle (20 minutes in real Minecraft)
        let dayCounter = 1; // Track game days starting from day 1
        let moonPhase = 0; // Track moon phase (0-7, cycles through 8 phases)
        
        // --- INVENTORY CONSTANTS & DATA ---
        const MAIN_INV_WIDTH = 8;
        const MAIN_INV_HEIGHT = 3; // Rows 0, 1, 2
        const HUD_WIDTH = 8; 
        const HUD_Y = MAIN_INV_HEIGHT; // Row 3 is the HUD row
        
        const MAIN_SLOTS = MAIN_INV_WIDTH * MAIN_INV_HEIGHT; // 24
        const TOTAL_SLOTS = MAIN_SLOTS + HUD_WIDTH; // 32 slots total
        const MAX_STACK = 64;
        
        // MODIFIED: Initial Inventory Data is now empty
        let inventoryData = Array(TOTAL_SLOTS).fill(null);

        // Inventory state variables
        let cursorX = 0; 
        let cursorY = 0; 
        let pickedUpItem = null; // This is the movable part (data only)
        
        // NEW: Fake Cursor variables
        let fakeCursorX = window.innerWidth / 2;
        let fakeCursorY = window.innerHeight / 2;
        let fakeCursorElement = null; // Will be assigned after DOM loads
        
        // Element references
        const mainInventoryGrid = document.getElementById('main-inventory-grid');
        const hudInventoryGrid = document.getElementById('hud-inventory-grid');
        let pickedUpItemElement = null; // MODIFIED: Assigned later
        const gameModeToggleBtn = document.getElementById('gameModeToggleBtn');
        const creativeBlockPicker = document.getElementById('creative-block-picker');
        
        // --- SEED HANDLING VAR ---
        var WORLD_SEED; 

        var toolbar = document.getElementById('toolbar');
        
        // MODIFIED: Added 'LEAVES', 'GLASS', 'DOOR', 'TORCH', and 'PLANKS'
        var blockNames = ['GRASS', 'DIRT', 'STONE', 'WOOD', 'SAND', 'BEDROCK', 'LEAVES', 'GLASS', 'DOOR', 'TORCH', 'WATER', 'LAVA', 'PLANKS'];
        var numBlocks = blockNames.length;
        var btns = [];
        
        // --- BLOCK TYPE CONSTANTS ---
        const SAND_TYPE = 4;
        const BEDROCK_TYPE = 5;
        const WOOD_TYPE = 3; 
        const LEAVES_TYPE = 6;
        const PLANKS_TYPE = 12;
        const GLASS_TYPE = 7;
        const DOOR_TYPE = 8;
        const TORCH_TYPE = 9;
        const WATER_TYPE = 10;
        const LAVA_TYPE = 11;
        // Check every 100ms for gravity effect
        const SAND_FALL_CHECK_INTERVAL = 0.1; 
        let sandFallTimer = 0;

        // --- NEW GRASS SPREAD CONSTANTS ---
        const GRASS_TYPE = 0;   // Grass is block type 0
        const DIRT_TYPE = 1;    // Dirt is block type 1
        const GRASS_SPREAD_CHECK_INTERVAL = 1.0; // Check for growth every 1 second
        let grassSpreadTimer = 0;
        // Max time in seconds (1 to 5 minutes -> aiming for 5 minutes max average, 300 seconds)
        // Chance is 1 / 300 checks in the current setup (1 check per second)
        const GRASS_SPREAD_CHANCE_MAX_SECONDS = 3; 
        // ----------------------------------
        
        // --- LIQUID FLOW SYSTEM (Water & Lava) ---
        const LIQUID_FLOW_INTERVAL = 0.3; // Check for flow every 300ms
        let liquidFlowTimer = 0;
        const COBBLESTONE_TYPE = 2; // Stone type for cobblestone
        // ----------------------------------
        
        // --- UTILITY FUNCTIONS ---
        function getBlockDisplay(type) {
            // Check if it's an item (negative numbers) or block
            if (type < 0) {
                const item = itemDefinitions[type];
                return item ? { name: item.name, color: item.color || '#fff' } : { name: '?', color: 'red' };
            }
            return blockNames[type] ? { name: blockNames[type], color: '#fff' } : { name: '?', color: 'red' };
        }
        
        // --- CRAFTING SYSTEM ---
        // Item definitions (negative numbers for tools/items)
        const ITEM_WOODEN_PICKAXE = -1;
        const ITEM_WOODEN_AXE = -2;
        const ITEM_WOODEN_SWORD = -3;
        const ITEM_STONE_PICKAXE = -4;
        const ITEM_STONE_AXE = -5;
        const ITEM_STONE_SWORD = -6;
        const ITEM_STICK = -7;
        const ITEM_PLANKS = -8;
        
        const itemDefinitions = {
            [ITEM_WOODEN_PICKAXE]: { 
                name: 'W.PICK', 
                color: '#8b5a2b', 
                isPickaxe: true, 
                miningSpeed: 2, 
                durability: 60,
                maxDurability: 60,
                maxStack: 1,
                isTool: true
            },
            [ITEM_WOODEN_AXE]: { 
                name: 'W.AXE', 
                color: '#8b5a2b', 
                isAxe: true, 
                miningSpeed: 2, 
                durability: 60,
                maxDurability: 60,
                maxStack: 1,
                isTool: true
            },
            [ITEM_WOODEN_SWORD]: { 
                name: 'W.SWORD', 
                color: '#8b5a2b', 
                isSword: true, 
                damage: 4, 
                durability: 60,
                maxDurability: 60,
                maxStack: 1,
                isTool: true
            },
            [ITEM_STONE_PICKAXE]: { 
                name: 'S.PICK', 
                color: '#7a7a7a', 
                isPickaxe: true, 
                miningSpeed: 3, 
                durability: 132,
                maxDurability: 132,
                maxStack: 1,
                isTool: true
            },
            [ITEM_STONE_AXE]: { 
                name: 'S.AXE', 
                color: '#7a7a7a', 
                isAxe: true, 
                miningSpeed: 3, 
                durability: 132,
                maxDurability: 132,
                maxStack: 1,
                isTool: true
            },
            [ITEM_STONE_SWORD]: { 
                name: 'S.SWORD', 
                color: '#7a7a7a', 
                isSword: true, 
                damage: 6, 
                durability: 132,
                maxDurability: 132,
                maxStack: 1,
                isTool: true
            },
            [ITEM_STICK]: { 
                name: 'STICK', 
                color: '#a0826d', 
                isStick: true 
            },
            [ITEM_PLANKS]: { 
                name: 'PLANKS', 
                color: '#daa560', 
                isPlaceable: true 
            }
        };
        
        // Crafting recipes: grid is 3x3, read left-to-right, top-to-bottom
        // null means empty slot, use block type or item type
        const craftingRecipes = [
            // Wood -> Planks (any position)
            {
                pattern: [null, null, null, null, WOOD_TYPE, null, null, null, null],
                result: { type: ITEM_PLANKS, count: 4 },
                name: '4x Planks'
            },
            // Planks -> Sticks (vertical)
            {
                pattern: [null, null, null, null, ITEM_PLANKS, null, null, ITEM_PLANKS, null],
                result: { type: ITEM_STICK, count: 4 },
                name: '4x Sticks'
            },
            // Wooden Pickaxe
            {
                pattern: [ITEM_PLANKS, ITEM_PLANKS, ITEM_PLANKS, null, ITEM_STICK, null, null, ITEM_STICK, null],
                result: { type: ITEM_WOODEN_PICKAXE, count: 1 },
                name: 'Wooden Pickaxe'
            },
            // Wooden Axe
            {
                pattern: [ITEM_PLANKS, ITEM_PLANKS, null, ITEM_PLANKS, ITEM_STICK, null, null, ITEM_STICK, null],
                result: { type: ITEM_WOODEN_AXE, count: 1 },
                name: 'Wooden Axe'
            },
            // Wooden Sword
            {
                pattern: [null, ITEM_PLANKS, null, null, ITEM_PLANKS, null, null, ITEM_STICK, null],
                result: { type: ITEM_WOODEN_SWORD, count: 1 },
                name: 'Wooden Sword'
            },
            // Stone Pickaxe
            {
                pattern: [2, 2, 2, null, ITEM_STICK, null, null, ITEM_STICK, null],
                result: { type: ITEM_STONE_PICKAXE, count: 1 },
                name: 'Stone Pickaxe'
            },
            // Stone Axe
            {
                pattern: [2, 2, null, 2, ITEM_STICK, null, null, ITEM_STICK, null],
                result: { type: ITEM_STONE_AXE, count: 1 },
                name: 'Stone Axe'
            },
            // Stone Sword
            {
                pattern: [null, 2, null, null, 2, null, null, ITEM_STICK, null],
                result: { type: ITEM_STONE_SWORD, count: 1 },
                name: 'Stone Sword'
            }
        ];
        
        // Crafting grid state (9 slots)
        let craftingGrid = Array(9).fill(null);
        let craftingOutput = null;
        
        // Initialize crafting UI
        function initCraftingUI() {
            const craftingGridElement = document.getElementById('crafting-grid');
            craftingGridElement.innerHTML = '';
            
            for (let i = 0; i < 9; i++) {
                const slot = document.createElement('div');
                slot.classList.add('crafting-slot');
                slot.dataset.index = i;
                
                // Add hover sound effect
                let isHovering = false;
                slot.addEventListener('mouseenter', function() {
                    if (!isHovering) {
                        isHovering = true;
                        playHoverSound();
                    }
                });
                slot.addEventListener('mouseleave', function() {
                    isHovering = false;
                });
                
                craftingGridElement.appendChild(slot);
            }
            
            updateCraftingUI();
            updateRecipeList();
        }
        
        // Update crafting UI
        function updateCraftingUI() {
            const slots = document.querySelectorAll('.crafting-slot');
            slots.forEach((slot, i) => {
                const item = craftingGrid[i];
                if (item) {
                    const display = getBlockDisplay(item.type);
                    slot.innerHTML = `
                        <span class="slot-item" style="color:${display.color}">${display.name}</span>
                        <span class="slot-count">${item.count}</span>
                    `;
                } else {
                    slot.innerHTML = '';
                }
            });
            
            // Check for valid recipe
            craftingOutput = checkCraftingRecipe();
            const outputSlot = document.getElementById('crafting-output');
            if (craftingOutput) {
                const display = getBlockDisplay(craftingOutput.type);
                outputSlot.innerHTML = `
                    <span class="slot-item" style="color:${display.color}">${display.name}</span>
                    <span class="slot-count">${craftingOutput.count}</span>
                `;
            } else {
                outputSlot.innerHTML = '';
            }
        }
        
        // Check if current grid matches a recipe
        function checkCraftingRecipe() {
            const gridTypes = craftingGrid.map(item => item ? item.type : null);
            
            for (const recipe of craftingRecipes) {
                if (matchesPattern(gridTypes, recipe.pattern)) {
                    return { ...recipe.result };
                }
            }
            return null;
        }
        
        // Pattern matching with rotation support
        function matchesPattern(grid, pattern) {
            // Exact match
            if (grid.every((val, i) => val === pattern[i])) return true;
            
            // Try all rotations for 2x2 and 2x3 patterns
            const rotations = getPatternRotations(pattern);
            for (const rotated of rotations) {
                if (grid.every((val, i) => val === rotated[i])) return true;
            }
            
            return false;
        }
        
        // Get all rotations and flips of a pattern
        function getPatternRotations(pattern) {
            // This is simplified - in a full implementation, 
            // you'd want to support all rotations/flips
            return [pattern]; // Just return original for now
        }
        
        // Update recipe list display
        function updateRecipeList() {
            const recipesContentElement = document.getElementById('crafting-recipes-content');
            recipesContentElement.innerHTML = '<div style="font-size: 12px; color: #aaa; margin-bottom: 8px;"> Recipes:</div>';
            
            craftingRecipes.forEach((recipe, index) => {
                const recipeItem = document.createElement('div');
                recipeItem.classList.add('recipe-item');
                
                // Check if player has materials
                const canCraft = canCraftRecipe(recipe);
                if (!canCraft) {
                    recipeItem.classList.add('unavailable');
                }
                
                recipeItem.textContent = recipe.name;
                recipeItem.onclick = () => {
                    if (canCraft) {
                        showRecipeInGrid(recipe);
                    }
                };
                
                recipesContentElement.appendChild(recipeItem);
            });
            
            // Initialize custom scrollbar after recipes are loaded
            initCustomScrollbar();
        }
        
        // Custom Scrollbar Initialization
        function initCustomScrollbar() {
            const wrapper = document.getElementById('crafting-recipes-wrapper');
            const container = document.getElementById('crafting-recipes');
            const content = document.getElementById('crafting-recipes-content');
            const scrollbar = wrapper.querySelector('.custom-scrollbar');
            const thumb = wrapper.querySelector('.custom-scrollbar-thumb');
            
            if (!wrapper || !container || !content || !scrollbar || !thumb) return;
            
            let scrollPosition = 0;
            let scrollDragStartY = 0;
            let scrollDragStartScroll = 0;
            
            function updateScrollbar() {
                const containerHeight = container.clientHeight;
                const contentHeight = content.scrollHeight;
                const maxScroll = Math.max(0, contentHeight - containerHeight);
                
                if (maxScroll === 0) {
                    scrollbar.style.display = 'none';
                    return;
                }
                
                scrollbar.style.display = 'block';
                
                const thumbHeight = Math.max(20, (containerHeight / contentHeight) * containerHeight);
                const maxThumbPosition = containerHeight - thumbHeight;
                const thumbPosition = (scrollPosition / maxScroll) * maxThumbPosition;
                
                thumb.style.height = thumbHeight + 'px';
                thumb.style.transform = `translateY(${thumbPosition}px)`;
                content.style.transform = `translateY(-${scrollPosition}px)`;
            }
            
            function setScroll(newScroll) {
                const containerHeight = container.clientHeight;
                const contentHeight = content.scrollHeight;
                const maxScroll = Math.max(0, contentHeight - containerHeight);
                
                scrollPosition = Math.max(0, Math.min(newScroll, maxScroll));
                updateScrollbar();
            }
            
            // Expose scrollbar drag handler to global scope
            window.handleScrollbarDrag = function(cursorY) {
                const deltaY = cursorY - scrollDragStartY;
                const containerHeight = container.clientHeight;
                const contentHeight = content.scrollHeight;
                const maxScroll = contentHeight - containerHeight;
                const thumbHeight = Math.max(20, (containerHeight / contentHeight) * containerHeight);
                const maxThumbPosition = containerHeight - thumbHeight;
                
                const scrollDelta = (deltaY / maxThumbPosition) * maxScroll;
                setScroll(scrollDragStartScroll + scrollDelta);
            };
            
            // Scrollbar thumb drag - works with fake cursor
            thumb.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();
                window.isDraggingScrollbar = true;
                scrollDragStartY = fakeCursorY; // Use fake cursor position
                scrollDragStartScroll = scrollPosition;
                thumb.classList.add('dragging');
            });
            
            document.addEventListener('mouseup', () => {
                if (window.isDraggingScrollbar) {
                    window.isDraggingScrollbar = false;
                    thumb.classList.remove('dragging');
                }
            });
            
            // Mouse wheel scrolling - detect if fake cursor is over wrapper
            document.addEventListener('wheel', (e) => {
                const rect = wrapper.getBoundingClientRect();
                const isOverWrapper = fakeCursorX >= rect.left && fakeCursorX <= rect.right &&
                                     fakeCursorY >= rect.top && fakeCursorY <= rect.bottom;
                
                if (isOverWrapper && inventoryOpen) {
                    e.preventDefault();
                    setScroll(scrollPosition + e.deltaY);
                }
            });
            
            // Click on scrollbar track
            scrollbar.addEventListener('click', (e) => {
                if (e.target === scrollbar) {
                    const rect = scrollbar.getBoundingClientRect();
                    const clickY = e.clientY - rect.top;
                    const containerHeight = container.clientHeight;
                    const contentHeight = content.scrollHeight;
                    const maxScroll = contentHeight - containerHeight;
                    
                    const targetScroll = (clickY / containerHeight) * maxScroll;
                    setScroll(targetScroll);
                }
            });
            
            updateScrollbar();
        }
        
        // Check if player has materials for a recipe
        function canCraftRecipe(recipe) {
            const required = {};
            recipe.pattern.forEach(type => {
                if (type !== null) {
                    required[type] = (required[type] || 0) + 1;
                }
            });
            
            const available = {};
            inventoryData.forEach(item => {
                if (item) {
                    available[item.type] = (available[item.type] || 0) + item.count;
                }
            });
            
            for (const type in required) {
                if ((available[type] || 0) < required[type]) {
                    return false;
                }
            }
            return true;
        }
        
        // Show recipe pattern in crafting grid (helper)
        function showRecipeInGrid(recipe) {
            // This would auto-fill the grid with the recipe pattern
            // For now, players craft manually
        }
        
        // Craft item from output
        function craftItem() {
            if (!craftingOutput) return;
            
            // Remove materials from grid
            craftingGrid = craftingGrid.map(item => {
                if (!item) return null;
                if (item.count > 1) {
                    return { ...item, count: item.count - 1 };
                }
                return null;
            });
            
            // Create result item with proper properties
            const resultType = craftingOutput.type;
            const resultCount = craftingOutput.count;
            
            // If it's a tool, initialize with full durability
            if (resultType < 0 && itemDefinitions[resultType] && itemDefinitions[resultType].isTool) {
                // Add tool to inventory with durability
                const itemDef = itemDefinitions[resultType];
                for (let i = 0; i < resultCount; i++) {
                    // Find empty slot and add tool with full durability
                    let added = false;
                    // Try hotbar first (24-31)
                    for (let j = MAIN_SLOTS; j < TOTAL_SLOTS; j++) {
                        if (!inventoryData[j]) {
                            inventoryData[j] = { 
                                type: resultType, 
                                count: 1, 
                                durability: itemDef.maxDurability 
                            };
                            added = true;
                            break;
                        }
                    }
                    // Then try main inventory (0-23)
                    if (!added) {
                        for (let j = 0; j < MAIN_SLOTS; j++) {
                            if (!inventoryData[j]) {
                                inventoryData[j] = { 
                                    type: resultType, 
                                    count: 1, 
                                    durability: itemDef.maxDurability 
                                };
                                break;
                            }
                        }
                    }
                }
            } else {
                // Regular item, use normal addToInventory
                addToInventory(resultType, resultCount);
            }
            
            // Update UI
            updateCraftingUI();
            updateInventoryUI();
            updateToolbarSelection();
            updateRecipeList();
            
            // Play crafting sound
            playPlaceSound(2); // Stone sound for crafting
        }
        
        // Get tool mining speed bonus
        function getToolMiningSpeed(toolType, blockType) {
            if (toolType === null || toolType === undefined) return 1;
            
            const tool = itemDefinitions[toolType];
            if (!tool) return 1;
            
            // Pickaxes are good for stone, axes for wood
            if (tool.isPickaxe && blockType === 2) return tool.miningSpeed;
            if (tool.isAxe && (blockType === 3 || blockType === 6)) return tool.miningSpeed;
            
            return tool.miningSpeed || 1;
        }
        
        // Maps X, Y (0-7, 0-2) to the main inventory array index (0-23)
        function getMainSlotIndex(x, y) {
            return y * MAIN_INV_WIDTH + x;
        }

        // Maps HUD selection (0-7) to the inventoryData array index (24-31)
        function getHUDIndex(hudSlot) {
            return MAIN_SLOTS + hudSlot;
        }

        // Gets the universal index (0-31) based on cursor position
        function getSlotIndexFromCursor() {
            if (cursorY < MAIN_INV_HEIGHT) {
                return getMainSlotIndex(cursorX, cursorY);
            } else {
                return getHUDIndex(cursorX);
            }
        }
        
        // Helper function to get max stack size for an item type
        function getMaxStack(type) {
            if (type < 0) {
                const itemDef = itemDefinitions[type];
                return itemDef && itemDef.maxStack ? itemDef.maxStack : MAX_STACK;
            }
            return MAX_STACK;
        }
        
        // MODIFIED: Block collection now prioritizes HUD slots (24-31) over Main Inventory slots (0-23).
        function addToInventory(type, count = 1) {
            // In creative mode, we don't need to add destroyed blocks
            if (isCreativeMode) return; 
            
            let remaining = count;
            const maxStack = getMaxStack(type);
            
            // Helper function to iterate over a range of slots
            const trySlots = (start, end, action) => {
                for (let i = start; i < end; i++) {
                    if (remaining === 0) return;
                    action(i);
                }
            };
            
            // 1. Try to stack with existing items
            
            // 1a. Prioritize HUD slots (24 to 31)
            trySlots(MAIN_SLOTS, TOTAL_SLOTS, (i) => {
                const item = inventoryData[i];
                if (item && item.type === type && item.count < maxStack) {
                    const space = maxStack - item.count;
                    const transfer = Math.min(remaining, space);
                    item.count += transfer;
                    remaining -= transfer;
                }
            });
            
            // 1b. Then Main inventory slots (0 to 23)
            trySlots(0, MAIN_SLOTS, (i) => {
                const item = inventoryData[i];
                if (item && item.type === type && item.count < maxStack) {
                    const space = maxStack - item.count;
                    const transfer = Math.min(remaining, space);
                    item.count += transfer;
                    remaining -= transfer;
                }
            });
            
            // 2. Place remaining items in empty slots
            if (remaining > 0) {
                
                // 2a. Prioritize empty HUD slots (24 to 31)
                trySlots(MAIN_SLOTS, TOTAL_SLOTS, (i) => {
                    if (!inventoryData[i]) {
                        const transfer = Math.min(remaining, maxStack);
                        inventoryData[i] = { type: type, count: transfer };
                        remaining -= transfer;
                    }
                });

                // 2b. Then empty Main inventory slots (0 to 23)
                trySlots(0, MAIN_SLOTS, (i) => {
                    if (!inventoryData[i]) {
                        const transfer = Math.min(remaining, maxStack);
                        inventoryData[i] = { type: type, count: transfer };
                        remaining -= transfer;
                    }
                });
            }
            
            updateInventoryUI();
            updateToolbarSelection(); 
        }
        
        // Find block in inventory and return slot info
        function findBlockInInventory(blockType) {
            // First check hotbar (24-31)
            for (let i = MAIN_SLOTS; i < TOTAL_SLOTS; i++) {
                const item = inventoryData[i];
                if (item && item.type === blockType) {
                    return { found: true, slotIndex: i, isHotbar: true, hotbarSlot: i - MAIN_SLOTS };
                }
            }
            
            // Then check main inventory (0-23)
            for (let i = 0; i < MAIN_SLOTS; i++) {
                const item = inventoryData[i];
                if (item && item.type === blockType) {
                    return { found: true, slotIndex: i, isHotbar: false };
                }
            }
            
            return { found: false };
        }
        
        // Middle-click block picker
        function handleMiddleClickBlockPick(blockType) {
            const result = findBlockInInventory(blockType);
            
            if (result.found) {
                if (result.isHotbar) {
                    // Block is in hotbar, just switch to it
                    sel = result.hotbarSlot;
                    updateToolbarSelection();
                } else {
                    // Block is in main inventory, move to current hotbar slot
                    const currentHotbarIndex = getHUDIndex(sel);
                    const item = inventoryData[result.slotIndex];
                    
                    if (isCreativeMode) {
                        // In creative, just place it in hotbar
                        const isTool = blockType < 0 && itemDefinitions[blockType] && itemDefinitions[blockType].isTool;
                        if (isTool) {
                            const itemDef = itemDefinitions[blockType];
                            inventoryData[currentHotbarIndex] = { 
                                type: blockType, 
                                count: 1,
                                durability: itemDef.maxDurability 
                            };
                        } else {
                            inventoryData[currentHotbarIndex] = { type: blockType, count: 64 };
                        }
                    } else {
                        // In survival, swap or move the item
                        inventoryData[currentHotbarIndex] = item;
                        inventoryData[result.slotIndex] = null;
                    }
                    
                    updateInventoryUI();
                    updateToolbarSelection();
                }
            } else {
                // Block not found in inventory
                if (isCreativeMode) {
                    // In creative, add it to current hotbar slot
                    const currentHotbarIndex = getHUDIndex(sel);
                    const isTool = blockType < 0 && itemDefinitions[blockType] && itemDefinitions[blockType].isTool;
                    if (isTool) {
                        const itemDef = itemDefinitions[blockType];
                        inventoryData[currentHotbarIndex] = { 
                            type: blockType, 
                            count: 1,
                            durability: itemDef.maxDurability 
                        };
                    } else {
                        inventoryData[currentHotbarIndex] = { type: blockType, count: 64 };
                    }
                    updateInventoryUI();
                    updateToolbarSelection();
                }
                // In survival, do nothing if block not found
            }
        }
        
        /**
         * Generates a simple tree structure.
         */
        function generateTree(startX, startY, startZ) {
            // Simple tree parameters
            const trunkHeight = Math.floor(Math.random() * 3) + 4; // 4 to 6 tall trunk
            
            // 1. Create Trunk (WOOD_TYPE = 3)
            for (let y = 0; y < trunkHeight; y++) {
                add(startX, startY + y, startZ, WOOD_TYPE);
            }
            
            // 2. Create Leaves Canopy (LEAVES_TYPE = 6)
            const leavesBaseY = startY + trunkHeight - 2; // Start leaves 2 blocks down from the top of the trunk
            
            // Layer 1 and 2 (bottom layers, 5x5-ish)
            for (let ly = 0; ly < 2; ly++) {
                for (let lx = -2; lx <= 2; lx++) {
                    for (let lz = -2; lz <= 2; lz++) {
                        // Skip corners for a diamond/rounded shape
                        if ((Math.abs(lx) === 2 && Math.abs(lz) === 2)) continue; 
                        
                        add(startX + lx, leavesBaseY + ly, startZ + lz, LEAVES_TYPE);
                    }
                }
            }

            // Layer 3 and 4 (top layers, 3x3)
            for (let ly = 2; ly < 4; ly++) {
                for (let lx = -1; lx <= 1; lx++) {
                    for (let lz = -1; lz <= 1; lz++) {
                        add(startX + lx, leavesBaseY + ly, startZ + lz, LEAVES_TYPE);
                    }
                }
            }
        }


        // --- INVENTORY UI & NAVIGATION ---
        
        function moveCursor(dx, dy) {
            // Navigable area is 8x4 (3 main rows + 1 HUD row)
            const MAX_Y = MAIN_INV_HEIGHT; // 3
            
            cursorX = Math.max(0, Math.min(MAIN_INV_WIDTH - 1, cursorX + dx));
            cursorY = Math.max(0, Math.min(MAX_Y, cursorY + dy)); 

            updateInventoryUI();
        }

        function updateToolbarSelection() {
            // Loop for the 8 HUD buttons
            btns.forEach((b, index) => {
                const hudIndex = getHUDIndex(index);
                const item = inventoryData[hudIndex];

                // 1. Update Visuals (sel is 0-7)
                b.classList.toggle('selected', index === sel);
                
                // 2. Update Content
                if (item) {
                    const display = getBlockDisplay(item.type);
                    const countDisplay = isCreativeMode ? '' : item.count; // Mode-dependent count
                    b.innerHTML = `
                        <span class="slot-item" style="color:${display.color}">${display.name}</span>
                        <span class="slot-count">${countDisplay}</span>
                    `;
                } else {
                     b.innerHTML = `<span style="font-size: 14px; opacity: 0.5;">${index + 1}</span>`;
                }
            });

            // 3. Update the global block placement variable (Active Block Type)
            const activeItem = inventoryData[getHUDIndex(sel)];
            window.activeBlockType = activeItem ? activeItem.type : null;
            
            // 4. Update held item in hand
            updateHeldItem();
        }

        function updateInventoryUI() {
            if (!mainInventoryGrid || !hudInventoryGrid) return; // Safety check
            const mainSlots = mainInventoryGrid.querySelectorAll('.inventory-slot');
            const hudSlots = hudInventoryGrid.querySelectorAll('.inventory-slot');
            const currentCursorSlotIndex = getSlotIndexFromCursor(); // Get the 0-31 index of the slot under the cursor
            
            // 1. Update all slot contents and clear selection/red classes
            const allSlots = [...mainSlots, ...hudSlots];
            allSlots.forEach((slot, index) => {
                let item = inventoryData[index]; // Item data from inventory array
                
                slot.innerHTML = '';
                slot.classList.remove('slot-selected');
                
                if (item) {
                    const display = getBlockDisplay(item.type);
                    const countDisplay = isCreativeMode ? '' : item.count; // Mode-dependent count
                    slot.innerHTML = `
                        <span class="slot-item" style="color:${display.color}">${display.name}</span>
                        <span class="slot-count">${countDisplay}</span>
                    `;
                }
            });

            // 2. NEW: Update the picked-up item element
            if (pickedUpItemElement) {
                if (pickedUpItem) {
                    const display = getBlockDisplay(pickedUpItem.type);
                    const countDisplay = isCreativeMode ? '' : pickedUpItem.count;
                    pickedUpItemElement.innerHTML = `
                        <span class="slot-item" style="color:${display.color}">${display.name}</span>
                        <span class="slot-count">${countDisplay}</span>
                    `;
                    pickedUpItemElement.style.display = 'flex';
                } else {
                    pickedUpItemElement.style.display = 'none';
                    pickedUpItemElement.innerHTML = '';
                }
            }
        }
        
        // Item categories for organized creative menu
        const itemCategories = {
            blocks: [1, 2, 5, 12], // DIRT, STONE, BEDROCK, PLANKS
            nature: [0, 3, 4, 6], // GRASS, WOOD, SAND, LEAVES
            decorative: [7, 8, 9], // GLASS, DOOR, TORCH
            tools: [-1, -2, -3, -4, -5, -6, -7, -8], // All tools and items
            liquids: [10, 11], // WATER, LAVA
        };
        
        // Current selected category
        let currentCategory = 'all';
        
        // NEW: Generate the creative block picker with category filtering
        function generateBlockPicker(category = 'all') {
            if (!creativeBlockPicker) return; // Safety check
            creativeBlockPicker.innerHTML = '';
            
            // Helper function to check if item should be shown
            const shouldShowItem = (type) => {
                if (category === 'all') return true;
                return itemCategories[category] && itemCategories[category].includes(type);
            };
            
            // Add all blocks first
            blockNames.forEach((name, type) => {
                if (!shouldShowItem(type)) return;
                
                const slot = document.createElement('div');
                slot.classList.add('inventory-slot');
                slot.dataset.type = type;

                const display = getBlockDisplay(type);
                slot.innerHTML = `
                    <span class="slot-item" style="color:${display.color}">${display.name}</span>
                    <span class="slot-count"></span>
                `;
                
                // Add hover sound effect
                let isHovering = false;
                slot.addEventListener('mouseenter', function() {
                    if (!isHovering) {
                        isHovering = true;
                        playHoverSound();
                    }
                });
                slot.addEventListener('mouseleave', function() {
                    isHovering = false;
                });
                
                creativeBlockPicker.appendChild(slot);
            });
            
            // Add all items/tools
            Object.keys(itemDefinitions).forEach(itemType => {
                const itemNum = parseInt(itemType);
                if (!shouldShowItem(itemNum)) return;
                
                const itemDef = itemDefinitions[itemNum];
                
                const slot = document.createElement('div');
                slot.classList.add('inventory-slot');
                slot.dataset.type = itemNum;
                
                slot.innerHTML = `
                    <span class="slot-item" style="color:${itemDef.color}">${itemDef.name}</span>
                    <span class="slot-count"></span>
                `;
                
                // Add hover sound effect
                let isHovering = false;
                slot.addEventListener('mouseenter', function() {
                    if (!isHovering) {
                        isHovering = true;
                        playHoverSound();
                    }
                });
                slot.addEventListener('mouseleave', function() {
                    isHovering = false;
                });
                
                creativeBlockPicker.appendChild(slot);
            });
        }
        
        // Initialize category tabs
        function initCategoryTabs() {
            const tabs = document.querySelectorAll('.category-tab');
            tabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    const category = this.dataset.category;
                    currentCategory = category;
                    
                    // Update active tab
                    tabs.forEach(t => t.classList.remove('active'));
                    this.classList.add('active');
                    
                    // Regenerate picker with new category
                    generateBlockPicker(category);
                    
                    // Play click sound
                    playClickSound();
                });
            });
        }
        
        function generateInventorySlots() {
            if (!mainInventoryGrid || !hudInventoryGrid) return; // Safety check
            mainInventoryGrid.innerHTML = '';
            hudInventoryGrid.innerHTML = '';
            
            let slotIndexCounter = 0;

            // Generate Main Inventory Slots (8x3)
            for (let y = 0; y < MAIN_INV_HEIGHT; y++) {
                for (let x = 0; x < MAIN_INV_WIDTH; x++) {
                    const slot = document.createElement('div');
                    slot.classList.add('inventory-slot');
                    
                    slot.dataset.x = x;
                    slot.dataset.y = y;
                    slot.dataset.index = slotIndexCounter;
                    
                    // Add hover sound effect
                    let isHovering = false;
                    slot.addEventListener('mouseenter', function() {
                        if (!isHovering) {
                            isHovering = true;
                            playHoverSound();
                        }
                    });
                    slot.addEventListener('mouseleave', function() {
                        isHovering = false;
                    });
                    
                    mainInventoryGrid.appendChild(slot);
                    slotIndexCounter++;
                }
            }
            
            // Generate HUD Inventory Slots (8 slots)
            for (let i = 0; i < HUD_WIDTH; i++) {
                const slot = document.createElement('div');
                slot.classList.add('inventory-slot', 'hud-slot');
                
                slot.dataset.x = i; 
                slot.dataset.y = HUD_Y; 
                slot.dataset.index = slotIndexCounter; 

                // Add hover sound effect
                let isHovering = false;
                slot.addEventListener('mouseenter', function() {
                    if (!isHovering) {
                        isHovering = true;
                        playHoverSound();
                    }
                });
                slot.addEventListener('mouseleave', function() {
                    isHovering = false;
                });

                hudInventoryGrid.appendChild(slot);
                slotIndexCounter++;
            }

            updateInventoryUI();
            generateBlockPicker(currentCategory); // Also generate the creative picker
            initCraftingUI(); // Initialize crafting system
            initCategoryTabs(); // Initialize category tabs
        }

        
        function swapItems(slotIndex) {
             let slotItem = inventoryData[slotIndex];
             
             // --- REFACTORED: Creative and Survival inventory moving is identical ---
             // This logic *moves* items, it does not copy.
             if (pickedUpItem) {
                // SECOND CLICK/SPACE: Placing/Stacking
                const maxStack = getMaxStack(pickedUpItem.type);
                const slotMaxStack = slotItem ? getMaxStack(slotItem.type) : MAX_STACK;
                
                if (slotItem && pickedUpItem.type === slotItem.type && slotItem.count < slotMaxStack && !isCreativeMode) { // Stack only in survival
                    // Stack items (respecting maxStack)
                    const space = slotMaxStack - slotItem.count;
                    const transfer = Math.min(pickedUpItem.count, space);
                    slotItem.count += transfer;
                    pickedUpItem.count -= transfer;

                    if (pickedUpItem.count === 0) {
                        pickedUpItem = null;
                    }
                } else {
                    // Standard Swap
                    const tempItem = pickedUpItem;
                    pickedUpItem = slotItem;
                    inventoryData[slotIndex] = tempItem;
                }

             } else {
                 // FIRST CLICK/SPACE: Picking up
                 if (slotItem) {
                     pickedUpItem = slotItem;
                     inventoryData[slotIndex] = null; // Item is now only in the pickedUpItem container
                 }
             }
             
             updateInventoryUI();
             updateToolbarSelection(); 
        }

        // --- NEW: Right-click handling function ---
        function handleInventoryRightClick(slotIndex) {
            if (isCreativeMode) {
                // Creative right-click: Same as left-click (pick up stack)
                swapItems(slotIndex);
            } else {
                // --- Survival Right-Click Logic (Split/Place One) ---
                let slotItem = inventoryData[slotIndex];
                
                if (pickedUpItem) {
                    // Placing one item down
                    const maxStack = getMaxStack(pickedUpItem.type);
                    const slotMaxStack = slotItem ? getMaxStack(slotItem.type) : MAX_STACK;
                    
                    if (!slotItem) {
                        // Place one in empty slot
                        inventoryData[slotIndex] = { type: pickedUpItem.type, count: 1 };
                        // Copy durability if it's a tool
                        if (pickedUpItem.durability !== undefined) {
                            inventoryData[slotIndex].durability = pickedUpItem.durability;
                        }
                        pickedUpItem.count--;
                    } else if (slotItem.type === pickedUpItem.type && slotItem.count < slotMaxStack) {
                        // Stack one (only if not a tool, tools have maxStack of 1)
                        slotItem.count++;
                        pickedUpItem.count--;
                    }
                    if (pickedUpItem.count === 0) pickedUpItem = null;
                    
                } else if (slotItem) {
                    // Picking up half stack (tools with maxStack 1 can't be split)
                    const maxStack = getMaxStack(slotItem.type);
                    if (maxStack === 1) {
                        // Can't split tools, pick up the whole item
                        pickedUpItem = slotItem;
                        inventoryData[slotIndex] = null;
                    } else {
                        const half = Math.ceil(slotItem.count / 2);
                        pickedUpItem = { type: slotItem.type, count: half };
                        slotItem.count -= half;
                        if (slotItem.count === 0) inventoryData[slotIndex] = null;
                    }
                }
                updateInventoryUI();
                updateToolbarSelection();
            }
        }
        
        // --- REFACTORED: Mouse Up listener ---
        document.addEventListener('mouseup', function(e) {
            if (!inventoryOpen || !pickedUpItem) return;

            // Get element under fake cursor
            fakeCursorElement.style.display = 'none';
            let elementUnderCursor = document.elementFromPoint(fakeCursorX, fakeCursorY);
            fakeCursorElement.style.display = 'block';
            
            // Check if mouse is outside all valid drop zones
            const targetInv = elementUnderCursor ? elementUnderCursor.closest('.inventory-container') : null;
            const targetPicker = elementUnderCursor ? elementUnderCursor.closest('#creative-block-picker') : null;
            const targetDelete = elementUnderCursor ? elementUnderCursor.closest('#delete-slot') : null;
            
            if (!targetInv && !targetPicker && !targetDelete) { // MODIFIED
                // Dropped item outside inventory
                if (!isCreativeMode) {
                    // In survival, add it back
                    addToInventory(pickedUpItem.type, pickedUpItem.count);
                }
                // In creative or survival, the item is dropped from cursor
                pickedUpItem = null; 
                updateInventoryUI();
                updateToolbarSelection();
            }
        });


        // --- Three.js & World Logic ---
        
        // ==================== MINECRAFT-STYLE AABB HITBOX SYSTEM ====================
        
        // AABB (Axis-Aligned Bounding Box) class for Minecraft-style collision
        class AABB {
            constructor(minX, minY, minZ, maxX, maxY, maxZ) {
                this.minX = minX;
                this.minY = minY;
                this.minZ = minZ;
                this.maxX = maxX;
                this.maxY = maxY;
                this.maxZ = maxZ;
            }
            
            // Create AABB from center position and dimensions
            static fromCenter(x, y, z, width, height, depth = null) {
                if (depth === null) depth = width;
                const halfWidth = width / 2;
                const halfDepth = depth / 2;
                return new AABB(
                    x - halfWidth,
                    y,
                    z - halfDepth,
                    x + halfWidth,
                    y + height,
                    z + halfDepth
                );
            }
            
            // Check if this AABB intersects with another
            intersects(other) {
                return this.minX < other.maxX && this.maxX > other.minX &&
                       this.minY < other.maxY && this.maxY > other.minY &&
                       this.minZ < other.maxZ && this.maxZ > other.minZ;
            }
            
            // Move the AABB by offset
            offset(dx, dy, dz) {
                return new AABB(
                    this.minX + dx,
                    this.minY + dy,
                    this.minZ + dz,
                    this.maxX + dx,
                    this.maxY + dy,
                    this.maxZ + dz
                );
            }
            
            // Expand the AABB
            expand(x, y, z) {
                return new AABB(
                    this.minX - x,
                    this.minY - y,
                    this.minZ - z,
                    this.maxX + x,
                    this.maxY + y,
                    this.maxZ + z
                );
            }
            
            // Calculate collision on X axis
            calculateXOffset(other, offsetX) {
                if (other.maxY > this.minY && other.minY < this.maxY &&
                    other.maxZ > this.minZ && other.minZ < this.maxZ) {
                    if (offsetX > 0 && other.maxX <= this.minX) {
                        const max = this.minX - other.maxX;
                        if (max < offsetX) offsetX = max;
                    } else if (offsetX < 0 && other.minX >= this.maxX) {
                        const max = this.maxX - other.minX;
                        if (max > offsetX) offsetX = max;
                    }
                }
                return offsetX;
            }
            
            // Calculate collision on Y axis
            calculateYOffset(other, offsetY) {
                if (other.maxX > this.minX && other.minX < this.maxX &&
                    other.maxZ > this.minZ && other.minZ < this.maxZ) {
                    if (offsetY > 0 && other.maxY <= this.minY) {
                        const max = this.minY - other.maxY;
                        if (max < offsetY) offsetY = max;
                    } else if (offsetY < 0 && other.minY >= this.maxY) {
                        const max = this.maxY - other.minY;
                        if (max > offsetY) offsetY = max;
                    }
                }
                return offsetY;
            }
            
            // Calculate collision on Z axis
            calculateZOffset(other, offsetZ) {
                if (other.maxX > this.minX && other.minX < this.maxX &&
                    other.maxY > this.minY && other.minY < this.maxY) {
                    if (offsetZ > 0 && other.maxZ <= this.minZ) {
                        const max = this.minZ - other.maxZ;
                        if (max < offsetZ) offsetZ = max;
                    } else if (offsetZ < 0 && other.minZ >= this.maxZ) {
                        const max = this.maxZ - other.minZ;
                        if (max > offsetZ) offsetZ = max;
                    }
                }
                return offsetZ;
            }
        }
        
        // Raycast from player's eye to detect what block they're looking at
        function raycastFromEye(eyeX, eyeY, eyeZ, dirX, dirY, dirZ, maxDistance) {
            const step = 0.1;
            const steps = Math.floor(maxDistance / step);
            
            for (let i = 0; i < steps; i++) {
                const t = i * step;
                const x = eyeX + dirX * t;
                const y = eyeY + dirY * t;
                const z = eyeZ + dirZ * t;
                
                const bx = Math.floor(x / bs);
                const by = Math.floor(y / bs);
                const bz = Math.floor(z / bs);
                
                const blockKey = key(bx, by, bz);
                const block = world[blockKey];
                
                if (block && !block.userData.isTorch) {
                    // Skip transparent blocks
                    if (block.userData.blockType === WATER_TYPE || 
                        block.userData.blockType === LAVA_TYPE) {
                        continue;
                    }
                    
                    // Skip open doors
                    if (block.userData.blockType === DOOR_TYPE && block.userData.doorOpen) {
                        continue;
                    }
                    
                    // Found a solid block
                    return {
                        hit: true,
                        blockX: bx,
                        blockY: by,
                        blockZ: bz,
                        block: block,
                        distance: t,
                        hitX: x,
                        hitY: y,
                        hitZ: z
                    };
                }
            }
            
            return { hit: false };
        }
        
        // Get all block AABBs that could collide with the given AABB
        function getCollidingBlockAABBs(aabb) {
            const blockAABBs = [];
            
            const minBlockX = Math.floor(aabb.minX / bs);
            const minBlockY = Math.floor(aabb.minY / bs);
            const minBlockZ = Math.floor(aabb.minZ / bs);
            const maxBlockX = Math.ceil(aabb.maxX / bs);
            const maxBlockY = Math.ceil(aabb.maxY / bs);
            const maxBlockZ = Math.ceil(aabb.maxZ / bs);
            
            for (let bx = minBlockX; bx <= maxBlockX; bx++) {
                for (let by = minBlockY; by <= maxBlockY; by++) {
                    for (let bz = minBlockZ; bz <= maxBlockZ; bz++) {
                        const blockKey = key(bx, by, bz);
                        const block = world[blockKey];
                        
                        if (!block) continue;
                        
                        // Skip non-solid blocks
                        if (block.userData.isTorch) continue;
                        if (block.userData.blockType === WATER_TYPE || 
                            block.userData.blockType === LAVA_TYPE) continue;
                        if (block.userData.blockType === DOOR_TYPE && block.userData.doorOpen) continue;
                        
                        // Create AABB for this block
                        const blockAABB = new AABB(
                            bx * bs - bs/2,
                            by * bs - bs/2,
                            bz * bs - bs/2,
                            bx * bs + bs/2,
                            by * bs + bs/2,
                            bz * bs + bs/2
                        );
                        
                        blockAABBs.push(blockAABB);
                    }
                }
            }
            
            return blockAABBs;
        }
        
        // Minecraft-style per-axis collision with step-up
        function moveWithCollision(aabb, dx, dy, dz, stepHeight = 0) {
            const originalY = dy;
            
            // Get all potentially colliding blocks
            const expandedAABB = aabb.expand(
                Math.abs(dx) + 0.1,
                Math.abs(dy) + stepHeight + 0.1,
                Math.abs(dz) + 0.1
            );
            const blockAABBs = getCollidingBlockAABBs(expandedAABB);
            
            // Y axis first (vertical)
            let newDY = dy;
            for (const blockAABB of blockAABBs) {
                newDY = blockAABB.calculateYOffset(aabb, newDY);
            }
            const afterYAABB = aabb.offset(0, newDY, 0);
            
            // X axis
            let newDX = dx;
            for (const blockAABB of blockAABBs) {
                newDX = blockAABB.calculateXOffset(afterYAABB, newDX);
            }
            const afterXAABB = afterYAABB.offset(newDX, 0, 0);
            
            // Z axis
            let newDZ = dz;
            for (const blockAABB of blockAABBs) {
                newDZ = blockAABB.calculateZOffset(afterXAABB, newDZ);
            }
            
            // Step-up logic (Minecraft-style)
            let onGround = (originalY < 0 && newDY !== originalY);
            
            if (stepHeight > 0 && onGround && (newDX !== dx || newDZ !== dz)) {
                // Try to step up
                const stepUpAABB = aabb.offset(0, stepHeight, 0);
                
                let stepDX = dx;
                let stepDZ = dz;
                
                for (const blockAABB of blockAABBs) {
                    stepDX = blockAABB.calculateXOffset(stepUpAABB, stepDX);
                }
                const afterStepXAABB = stepUpAABB.offset(stepDX, 0, 0);
                
                for (const blockAABB of blockAABBs) {
                    stepDZ = blockAABB.calculateZOffset(afterStepXAABB, stepDZ);
                }
                
                // If stepping up allows more movement, use it
                const normalDistSq = newDX * newDX + newDZ * newDZ;
                const stepDistSq = stepDX * stepDX + stepDZ * stepDZ;
                
                if (stepDistSq > normalDistSq) {
                    newDX = stepDX;
                    newDZ = stepDZ;
                    newDY = stepHeight;
                    
                    // Move down until we hit the ground
                    let downY = -stepHeight;
                    const afterStepAABB = aabb.offset(newDX, newDY, newDZ);
                    for (const blockAABB of blockAABBs) {
                        downY = blockAABB.calculateYOffset(afterStepAABB, downY);
                    }
                    newDY += downY;
                }
            }
            
            return {
                dx: newDX,
                dy: newDY,
                dz: newDZ,
                collidedX: newDX !== dx,
                collidedY: newDY !== originalY,
                collidedZ: newDZ !== dz,
                onGround: onGround
            };
        }
        
        // Entity list for pushing mechanics
        let entities = [];
        
        // Simple entity pushing when AABBs overlap
        function handleEntityPushing(playerAABB, playerVelX, playerVelZ) {
            for (const entity of entities) {
                if (!entity.aabb) continue;
                
                if (playerAABB.intersects(entity.aabb)) {
                    // Calculate overlap
                    const overlapX = Math.min(playerAABB.maxX - entity.aabb.minX, entity.aabb.maxX - playerAABB.minX);
                    const overlapZ = Math.min(playerAABB.maxZ - entity.aabb.minZ, entity.aabb.maxZ - playerAABB.minZ);
                    
                    // Push entity away from player
                    const centerX = (playerAABB.minX + playerAABB.maxX) / 2;
                    const centerZ = (playerAABB.minZ + playerAABB.maxZ) / 2;
                    const entityCenterX = (entity.aabb.minX + entity.aabb.maxX) / 2;
                    const entityCenterZ = (entity.aabb.minZ + entity.aabb.maxZ) / 2;
                    
                    const pushDirX = entityCenterX - centerX;
                    const pushDirZ = entityCenterZ - centerZ;
                    const pushDist = Math.sqrt(pushDirX * pushDirX + pushDirZ * pushDirZ);
                    
                    if (pushDist > 0.01) {
                        const pushStrength = 0.05;
                        entity.x += (pushDirX / pushDist) * pushStrength;
                        entity.z += (pushDirZ / pushDist) * pushStrength;
                        
                        // Update entity AABB
                        if (entity.width && entity.height) {
                            entity.aabb = AABB.fromCenter(entity.x, entity.y, entity.z, entity.width, entity.height);
                        }
                    }
                }
            }
        }
        
        // ==================== END HITBOX SYSTEM ====================
        
        // Generate the 8 HUD buttons
        for (var bi = 0; bi < HUD_WIDTH; bi++) {
            var btn = document.createElement('button');
            btn.id = 'btn' + bi;
            btn.dataset.hudSlot = bi;
            toolbar.appendChild(btn);
            btns.push(btn);
        }

        var c = document.getElementById('c');
        var scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        // Fog starts much further away and ends beyond render distance so blocks don't disappear
        scene.fog = new THREE.Fog(0x87CEEB, 500, 1000);

        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        // --- FRUSTUM FOR OPTIMIZED CULLING ---
        var frustum = new THREE.Frustum();
        var cameraViewProjectionMatrix = new THREE.Matrix4();
        
        // --- DEBUG HITBOX VISUALIZATION ---
        var showHitbox = false; // Hidden by default, toggle with F3
        
        // Create wireframe box for player hitbox visualization
        const hitboxWidth = PLAYER_RADIUS * 2; // 0.6 blocks wide
        const hitboxHeight = PLAYER_TOTAL_HEIGHT; // 1.8 blocks tall
        const hitboxGeometry = new THREE.BoxGeometry(hitboxWidth, hitboxHeight, hitboxWidth);
        const hitboxMaterial = new THREE.LineBasicMaterial({ 
            color: 0x00ff00, // Bright green outline
            linewidth: 3,
            depthTest: false, // Always visible through blocks
            depthWrite: false,
            transparent: true,
            opacity: 1.0
        });
        const hitboxEdges = new THREE.EdgesGeometry(hitboxGeometry);
        const hitboxWireframe = new THREE.LineSegments(hitboxEdges, hitboxMaterial);
        hitboxWireframe.renderOrder = 999; // Render on top
        hitboxWireframe.visible = false; // Hidden by default, toggle with F3
        scene.add(hitboxWireframe);
        // --- END DEBUG HITBOX VISUALIZATION ---
        
        // --- PERSPECTIVE SWITCHING SYSTEM ---
        var perspectiveMode = 0; // 0 = first person, 1 = third person back, 2 = third person front (DEFAULT: FIRST PERSON)
        const THIRD_PERSON_DISTANCE = 5.0; // Distance from player in third person (increased for better view)
        const CAMERA_COLLISION_PADDING = 0.3; // Extra space between camera and blocks
        
        // Walking animation variables
        let walkAnimationTimer = 0;
        const WALK_ANIMATION_SPEED = 8.0; // Speed of limb swinging
        const ARM_SWING_AMPLITUDE = 0.8; // How far arms swing (radians)
        const LEG_SWING_AMPLITUDE = 0.6; // How far legs swing (radians)
        
        // Idle animation variables (like Minecraft)
        let idleAnimationTimer = 0;
        const IDLE_ANIMATION_SPEED = 1.5; // Slow breathing/sway speed
        const IDLE_ARM_SWAY = 0.05; // Subtle arm sway
        const IDLE_HEAD_BOB = 0.015; // Subtle head bob
        const IDLE_BODY_SWAY = 0.008; // Very subtle body rotation
        
        // Create enhanced player model for third-person view (BIGGER & MORE VISIBLE)
        const playerModelGroup = new THREE.Group();
        
        // SCALE FACTOR: Make character 1.5x bigger for better visibility
        const modelScale = 1.5;
        
        // Layer meshes (second layer) - stored globally
        let headLayerMesh = null;
        let bodyLayerMesh = null;
        let leftArmLayerMesh = null;
        let rightArmLayerMesh = null;
        let leftLegLayerMesh = null;
        let rightLegLayerMesh = null;
        
        // Skin type: false = classic (4px arms), true = slim (2px arms)
        let isSlimSkin = false;
        
        // Body (8x12x4 pixels in Minecraft scaled up)
        const bodyGeometry = new THREE.BoxGeometry(0.5 * modelScale, 0.75 * modelScale, 0.25 * modelScale);
        const bodyMaterial = new THREE.MeshLambertMaterial({ 
            color: 0x3a7bc8,
            emissive: 0x1a3a5a,
            emissiveIntensity: 0.2
        }); // Enhanced blue shirt with subtle glow
        const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
        bodyMesh.position.set(0, -0.5 * modelScale, 0);
        bodyMesh.castShadow = true;
        bodyMesh.receiveShadow = true;
        bodyMesh.renderOrder = 0; // Base layer
        playerModelGroup.add(bodyMesh);
        
        // Head (8x8x8 pixels scaled up)
        const headGeometry = new THREE.BoxGeometry(0.5 * modelScale, 0.5 * modelScale, 0.5 * modelScale);
        const headMaterial = new THREE.MeshLambertMaterial({ 
            color: 0xf4c49a,
            emissive: 0x8b6f47,
            emissiveIntensity: 0.1
        }); // Enhanced skin tone with warmth
        const headMesh = new THREE.Mesh(headGeometry, headMaterial);
        headMesh.position.set(0, 0.125 * modelScale, 0);
        headMesh.castShadow = true;
        headMesh.receiveShadow = true;
        headMesh.renderOrder = 0; // Base layer
        playerModelGroup.add(headMesh);
        
        // Legs (4x12x4 pixels each scaled up) - Standard Minecraft proportions
        const legGeometry = new THREE.BoxGeometry(0.25 * modelScale, 0.75 * modelScale, 0.25 * modelScale);
        const legMaterial = new THREE.MeshLambertMaterial({ 
            color: 0x2d3e6f,
            emissive: 0x0f1a2e,
            emissiveIntensity: 0.15
        }); // Enhanced blue pants with depth
        
        // LEFT LEG: 4px wide, attached at left side of 8px wide body
        // Body spans x: -0.25 to +0.25 (8px = 0.5 units)
        // Left leg spans x: -0.25 to 0 (4px = 0.25 units, left half of body width)
        const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
        leftLeg.position.set(0, -0.375 * modelScale, 0); // Leg hangs down from pivot point
        leftLeg.castShadow = true;
        leftLeg.receiveShadow = true;
        leftLeg.renderOrder = 0; // Base layer
        const leftLegPivot = new THREE.Group();
        // Pivot at top-center of left leg (which is bottom-left quarter of body)
        leftLegPivot.position.set(-0.125 * modelScale, -0.875 * modelScale, 0);
        leftLegPivot.add(leftLeg);
        playerModelGroup.add(leftLegPivot);
        
        // RIGHT LEG: 4px wide, attached at right side of 8px wide body
        // Right leg spans x: 0 to +0.25 (4px = 0.25 units, right half of body width)
        const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
        rightLeg.position.set(0, -0.375 * modelScale, 0); // Leg hangs down from pivot point
        rightLeg.castShadow = true;
        rightLeg.receiveShadow = true;
        rightLeg.renderOrder = 0; // Base layer
        const rightLegPivot = new THREE.Group();
        // Pivot at top-center of right leg (which is bottom-right quarter of body)
        rightLegPivot.position.set(0.125 * modelScale, -0.875 * modelScale, 0);
        rightLegPivot.add(rightLeg);
        playerModelGroup.add(rightLegPivot);
        
        // ARMS - created dynamically based on slim skin setting
        let leftArm = null;
        let rightArm = null;
        let leftArmPivot = null;
        let rightArmPivot = null;
        
        // Function to create or recreate arms based on skin type
        function createArms() {
            // Store old materials to preserve textures
            const oldLeftArmMaterial = leftArm ? leftArm.material : null;
            const oldRightArmMaterial = rightArm ? rightArm.material : null;
            const oldLeftArmLayerMaterial = leftArmLayerMesh ? leftArmLayerMesh.material : null;
            const oldRightArmLayerMaterial = rightArmLayerMesh ? rightArmLayerMesh.material : null;
            
            // Remove old arms if they exist
            if (leftArmPivot) {
                playerModelGroup.remove(leftArmPivot);
                if (leftArm) {
                    leftArm.geometry.dispose();
                    // Don't dispose materials - we're reusing them
                }
                if (leftArmLayerMesh) {
                    leftArmPivot.remove(leftArmLayerMesh);
                    leftArmLayerMesh.geometry.dispose();
                    // Don't dispose materials - we're reusing them
                    leftArmLayerMesh = null;
                }
            }
            if (rightArmPivot) {
                playerModelGroup.remove(rightArmPivot);
                if (rightArm) {
                    rightArm.geometry.dispose();
                    // Don't dispose materials - we're reusing them
                }
                if (rightArmLayerMesh) {
                    rightArmPivot.remove(rightArmLayerMesh);
                    rightArmLayerMesh.geometry.dispose();
                    // Don't dispose materials - we're reusing them
                    rightArmLayerMesh = null;
                }
            }
            
            // Create new arms with proper dimensions matching Minecraft skin layout
            // Classic: 4px wide (0.25 units), Slim: 3px wide (0.1875 units)
            const armWidth = isSlimSkin ? 0.1875 * modelScale : 0.25 * modelScale;
            const armGeometry = new THREE.BoxGeometry(armWidth, 0.75 * modelScale, 0.25 * modelScale);
            
            // Use old materials if available, otherwise create new default material
            const armMaterial = oldLeftArmMaterial || new THREE.MeshLambertMaterial({ 
                color: 0xf4c49a,
                emissive: 0x8b6f47,
                emissiveIntensity: 0.1
            });
            
            // LEFT ARM: Attached to left side of body at shoulder (top of body)
            // Body: 8px wide (0.5 units), spans x: -0.25 to +0.25
            // Left arm attaches at x: -0.25 (left edge of body)
            leftArm = new THREE.Mesh(armGeometry, oldLeftArmMaterial || armMaterial);
            leftArm.position.set(0, -0.375 * modelScale, 0); // Arm hangs down from pivot (shoulder)
            leftArm.castShadow = true;
            leftArm.receiveShadow = true;
            leftArm.renderOrder = 0; // Base layer
            leftArmPivot = new THREE.Group();
            // Calculate positioning: body edge (-0.25) minus arm half-width
            const bodyHalfWidth = 0.25 * modelScale; // Half of 8px body width
            const armHalfWidth = armWidth / 2; // Half of arm width (2px for classic, 1.5px for slim)
            // Pivot at shoulder (top of body side, center of arm width)
            leftArmPivot.position.set(-(bodyHalfWidth + armHalfWidth), -0.125 * modelScale, 0);
            leftArmPivot.add(leftArm);
            playerModelGroup.add(leftArmPivot);
            
            // RIGHT ARM: Attached to right side of body at shoulder (top of body)
            // Right arm attaches at x: +0.25 (right edge of body)
            rightArm = new THREE.Mesh(armGeometry, oldRightArmMaterial || armMaterial);
            rightArm.position.set(0, -0.375 * modelScale, 0); // Arm hangs down from pivot (shoulder)
            rightArm.castShadow = true;
            rightArm.receiveShadow = true;
            rightArm.renderOrder = 0; // Base layer
            rightArmPivot = new THREE.Group();
            // Pivot at shoulder (top of body side, center of arm width)
            rightArmPivot.position.set(bodyHalfWidth + armHalfWidth, -0.125 * modelScale, 0);
            rightArmPivot.add(rightArm);
            playerModelGroup.add(rightArmPivot);
            
            // Recreate arm layers after arms are recreated
            if (typeof createBodyLayers === 'function') {
                createBodyLayers();
            }
        }
        
        // Function to create or recreate all body part layers
        function createBodyLayers() {
            // Helper to create fully transparent default materials (layers invisible until textures applied)
            const createDefaultLayerMaterial = () => {
                return new THREE.MeshLambertMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0, // Completely invisible by default
                    visible: false // Hidden until texture is applied
                });
            };
            
            // HEAD LAYER (hat) - 3D offset with proper spacing
            if (headLayerMesh) {
                playerModelGroup.remove(headLayerMesh);
                headLayerMesh.geometry.dispose();
                if (Array.isArray(headLayerMesh.material)) {
                    headLayerMesh.material.forEach(m => m.dispose());
                } else {
                    headLayerMesh.material.dispose();
                }
            }
            // Layer is 0.5px larger on each side (1px total larger), making it 9x9x9 vs 8x8x8 base
            const headLayerGeometry = new THREE.BoxGeometry(0.5625 * modelScale, 0.5625 * modelScale, 0.5625 * modelScale);
            headLayerMesh = new THREE.Mesh(headLayerGeometry, createDefaultLayerMaterial());
            headLayerMesh.position.copy(headMesh.position);
            headLayerMesh.visible = false; // Invisible until texture is applied
            headLayerMesh.renderOrder = 1; // Render on top of base layer
            playerModelGroup.add(headLayerMesh);
            
            // BODY LAYER (jacket) - 3D offset with proper spacing
            if (bodyLayerMesh) {
                playerModelGroup.remove(bodyLayerMesh);
                bodyLayerMesh.geometry.dispose();
                if (Array.isArray(bodyLayerMesh.material)) {
                    bodyLayerMesh.material.forEach(m => m.dispose());
                } else {
                    bodyLayerMesh.material.dispose();
                }
            }
            // Body: 8x12x4 base, layer adds 0.5px on each side
            const bodyLayerGeometry = new THREE.BoxGeometry(0.5625 * modelScale, 0.8125 * modelScale, 0.3125 * modelScale);
            bodyLayerMesh = new THREE.Mesh(bodyLayerGeometry, createDefaultLayerMaterial());
            bodyLayerMesh.position.copy(bodyMesh.position);
            bodyLayerMesh.visible = false; // Invisible until texture is applied
            bodyLayerMesh.renderOrder = 1; // Render on top of base layer
            playerModelGroup.add(bodyLayerMesh);
            
            // ARM LAYERS (sleeves) - 3D offset with proper spacing
            if (leftArmPivot && leftArm) {
                if (leftArmLayerMesh) {
                    leftArmPivot.remove(leftArmLayerMesh);
                    leftArmLayerMesh.geometry.dispose();
                    if (Array.isArray(leftArmLayerMesh.material)) {
                        leftArmLayerMesh.material.forEach(m => m.dispose());
                    } else {
                        leftArmLayerMesh.material.dispose();
                    }
                }
                // Arm layers: add 0.5px on each side
                // Classic: 4px arm becomes 5px layer, Slim: 3px arm becomes 4px layer
                const leftArmLayerWidth = isSlimSkin ? 0.25 * modelScale : 0.3125 * modelScale;
                const leftArmLayerGeometry = new THREE.BoxGeometry(leftArmLayerWidth, 0.8125 * modelScale, 0.3125 * modelScale);
                leftArmLayerMesh = new THREE.Mesh(leftArmLayerGeometry, createDefaultLayerMaterial());
                leftArmLayerMesh.position.copy(leftArm.position);
                leftArmLayerMesh.visible = false; // Invisible until texture is applied
                leftArmLayerMesh.renderOrder = 1; // Render on top of base layer
                leftArmPivot.add(leftArmLayerMesh);
            }
            
            if (rightArmPivot && rightArm) {
                if (rightArmLayerMesh) {
                    rightArmPivot.remove(rightArmLayerMesh);
                    rightArmLayerMesh.geometry.dispose();
                    if (Array.isArray(rightArmLayerMesh.material)) {
                        rightArmLayerMesh.material.forEach(m => m.dispose());
                    } else {
                        rightArmLayerMesh.material.dispose();
                    }
                }
                const rightArmLayerWidth = isSlimSkin ? 0.25 * modelScale : 0.3125 * modelScale;
                const rightArmLayerGeometry = new THREE.BoxGeometry(rightArmLayerWidth, 0.8125 * modelScale, 0.3125 * modelScale);
                rightArmLayerMesh = new THREE.Mesh(rightArmLayerGeometry, createDefaultLayerMaterial());
                rightArmLayerMesh.position.copy(rightArm.position);
                rightArmLayerMesh.visible = false; // Invisible until texture is applied
                rightArmLayerMesh.renderOrder = 1; // Render on top of base layer
                rightArmPivot.add(rightArmLayerMesh);
            }
            
            // LEG LAYERS (pants) - 3D offset with proper spacing
            if (leftLegLayerMesh) {
                leftLegPivot.remove(leftLegLayerMesh);
                leftLegLayerMesh.geometry.dispose();
                if (Array.isArray(leftLegLayerMesh.material)) {
                    leftLegLayerMesh.material.forEach(m => m.dispose());
                } else {
                    leftLegLayerMesh.material.dispose();
                }
            }
            // Leg: 4x12x4 base becomes 5x13x5 layer (0.5px added on each side)
            const leftLegLayerGeometry = new THREE.BoxGeometry(0.3125 * modelScale, 0.8125 * modelScale, 0.3125 * modelScale);
            leftLegLayerMesh = new THREE.Mesh(leftLegLayerGeometry, createDefaultLayerMaterial());
            leftLegLayerMesh.position.copy(leftLeg.position);
            leftLegLayerMesh.visible = false; // Invisible until texture is applied
            leftLegLayerMesh.renderOrder = 1; // Render on top of base layer
            leftLegPivot.add(leftLegLayerMesh);
            
            if (rightLegLayerMesh) {
                rightLegPivot.remove(rightLegLayerMesh);
                rightLegLayerMesh.geometry.dispose();
                if (Array.isArray(rightLegLayerMesh.material)) {
                    rightLegLayerMesh.material.forEach(m => m.dispose());
                } else {
                    rightLegLayerMesh.material.dispose();
                }
            }
            const rightLegLayerGeometry = new THREE.BoxGeometry(0.3125 * modelScale, 0.8125 * modelScale, 0.3125 * modelScale);
            rightLegLayerMesh = new THREE.Mesh(rightLegLayerGeometry, createDefaultLayerMaterial());
            rightLegLayerMesh.position.copy(rightLeg.position);
            rightLegLayerMesh.visible = false; // Invisible until texture is applied
            rightLegLayerMesh.renderOrder = 1; // Render on top of base layer
            rightLegPivot.add(rightLegLayerMesh);
        }
        
        // Initial arm creation
        createArms();
        
        // Create all body layers initially
        createBodyLayers();
        
        // Function to update skin layer visibility
        function updateSkinLayers() {
            if (headLayerMesh) headLayerMesh.visible = showSkinLayers;
            if (bodyLayerMesh) bodyLayerMesh.visible = showSkinLayers;
            if (leftArmLayerMesh) leftArmLayerMesh.visible = showSkinLayers;
            if (rightArmLayerMesh) rightArmLayerMesh.visible = showSkinLayers;
            if (leftLegLayerMesh) leftLegLayerMesh.visible = showSkinLayers;
            if (rightLegLayerMesh) rightLegLayerMesh.visible = showSkinLayers;
            if (fpHandLayerMesh) fpHandLayerMesh.visible = showSkinLayers;
        }
        
        playerModelGroup.visible = false; // Hidden by default (first person)
        playerModelGroup.castShadow = true;
        playerModelGroup.receiveShadow = true;
        scene.add(playerModelGroup);
        
        // Load and apply custom textures if available
        setTimeout(() => {
            try {
                // Always initialize textures first (creates defaults if none exist)
                if (Object.keys(modelTextures).length === 0) {
                    initializeModelTextures();
                }
                // Load saved textures (will merge with defaults)
                loadModelTextures();
                // Apply textures to all models including hand
                applyTexturesToModels();
            } catch (e) {
                console.error('Error initializing textures:', e);
            }
        }, 100);
        // --- END PERSPECTIVE SYSTEM ---
        
        // --- HELD ITEM IN HAND SYSTEM ---
        // Create a separate scene and camera for the held item (overlay rendering)
        const handScene = new THREE.Scene();
        const handCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 10);
        
        // Hand position and animation variables
        let heldItemMesh = null;
        let fpHandMesh = null; // Permanent first-person hand mesh
        let fpHandLayerMesh = null; // Second layer (sleeve) for hand
        let handBobTimer = 0;
        let isMovingForBob = false;
        let handSwingTimer = 0;
        let isSwinging = false;
        const SWING_DURATION = 0.25; // Duration of swing animation in seconds
        
        // Minecraft Skin System - Extract texture regions from 64x64 skin
        function extractSkinRegion(skinCanvas, x, y, width, height, flipVertical = false) {
            const regionCanvas = document.createElement('canvas');
            regionCanvas.width = width;
            regionCanvas.height = height;
            const ctx = regionCanvas.getContext('2d');
            
            if (flipVertical) {
                // Flip the texture upside down (180 degree rotation)
                ctx.save();
                ctx.translate(width / 2, height / 2);
                ctx.rotate(Math.PI); // 180 degrees
                ctx.drawImage(skinCanvas, x, y, width, height, -width / 2, -height / 2, width, height);
                ctx.restore();
            } else {
                ctx.drawImage(skinCanvas, x, y, width, height, 0, 0, width, height);
            }
            
            return regionCanvas;
        }
        
        // Create UV-mapped materials for a body part from skin texture
        function createBodyPartMaterials(skinCanvas, uvMap, isLayer = false, flipVertical = false) {
            // uvMap format: { right, left, top, bottom, front, back }
            // Each entry has { x, y, w, h } coordinates in the skin texture
            const materials = [];
            const faces = ['right', 'left', 'top', 'bottom', 'front', 'back'];
            
            faces.forEach(face => {
                const uv = uvMap[face];
                const faceCanvas = extractSkinRegion(skinCanvas, uv.x, uv.y, uv.w, uv.h, flipVertical);
                const texture = new THREE.CanvasTexture(faceCanvas);
                texture.magFilter = THREE.NearestFilter;
                texture.minFilter = THREE.NearestFilter;
                materials.push(new THREE.MeshLambertMaterial({ 
                    map: texture,
                    transparent: isLayer,
                    alphaTest: isLayer ? 0.1 : 0,
                    depthWrite: !isLayer
                }));
            });
            
            return materials;
        }
        
        // Function to get arm UV maps based on skin type - EXACT Minecraft 64x64 skin format
        // Based on official Minecraft skin schematic
        function getArmUVMaps() {
            if (isSlimSkin) {
                // Slim arms: 3px wide (Alex model)
                // Right arm base: front at (44,20), layer at (44,36)
                // Left arm base: front at (36,52), layer at (52,52)
                return {
                    rightArm: {
                        right: { x: 47, y: 20, w: 3, h: 12 },  // Right side (viewer's left)
                        left: { x: 44, y: 20, w: 3, h: 12 },   // Left side (viewer's right)
                        top: { x: 44, y: 16, w: 3, h: 4 },
                        bottom: { x: 47, y: 16, w: 3, h: 4 },
                        front: { x: 44, y: 20, w: 3, h: 12 },
                        back: { x: 50, y: 20, w: 3, h: 12 }
                    },
                    rightArmLayer: {
                        right: { x: 47, y: 36, w: 3, h: 12 },
                        left: { x: 44, y: 36, w: 3, h: 12 },
                        top: { x: 44, y: 32, w: 3, h: 4 },
                        bottom: { x: 47, y: 32, w: 3, h: 4 },
                        front: { x: 44, y: 36, w: 3, h: 12 },
                        back: { x: 50, y: 36, w: 3, h: 12 }
                    },
                    leftArm: {
                        right: { x: 39, y: 52, w: 3, h: 12 },  // Right side (viewer's left)
                        left: { x: 36, y: 52, w: 3, h: 12 },   // Left side (viewer's right)
                        top: { x: 36, y: 48, w: 3, h: 4 },
                        bottom: { x: 39, y: 48, w: 3, h: 4 },
                        front: { x: 36, y: 52, w: 3, h: 12 },
                        back: { x: 42, y: 52, w: 3, h: 12 }
                    },
                    leftArmLayer: {
                        right: { x: 55, y: 52, w: 3, h: 12 },
                        left: { x: 52, y: 52, w: 3, h: 12 },
                        top: { x: 52, y: 48, w: 3, h: 4 },
                        bottom: { x: 55, y: 48, w: 3, h: 4 },
                        front: { x: 52, y: 52, w: 3, h: 12 },
                        back: { x: 58, y: 52, w: 3, h: 12 }
                    }
                };
            } else {
                // Classic arms: 4px wide (Steve model) - EXACT Minecraft 64x64 coordinates
                // Right arm: front at (44,20), right at (48,20), left at (40,20), back at (52,20)
                // Left arm: front at (36,52), right at (40,52), left at (32,52), back at (44,52)
                // Layers offset by +32 on X axis
                return {
                    rightArm: {
                        right: { x: 48, y: 20, w: 4, h: 12 },  // Right side of right arm (viewer's left)
                        left: { x: 40, y: 20, w: 4, h: 12 },   // Left side of right arm (viewer's right)
                        top: { x: 44, y: 16, w: 4, h: 4 },
                        bottom: { x: 48, y: 16, w: 4, h: 4 },
                        front: { x: 44, y: 20, w: 4, h: 12 },
                        back: { x: 52, y: 20, w: 4, h: 12 }
                    },
                    rightArmLayer: {
                        right: { x: 48, y: 36, w: 4, h: 12 },  // Layer offset +16 on Y axis
                        left: { x: 40, y: 36, w: 4, h: 12 },
                        top: { x: 44, y: 32, w: 4, h: 4 },
                        bottom: { x: 48, y: 32, w: 4, h: 4 },
                        front: { x: 44, y: 36, w: 4, h: 12 },
                        back: { x: 52, y: 36, w: 4, h: 12 }
                    },
                    leftArm: {
                        right: { x: 40, y: 52, w: 4, h: 12 },  // Right side of left arm (viewer's left)
                        left: { x: 32, y: 52, w: 4, h: 12 },   // Left side of left arm (viewer's right)
                        top: { x: 36, y: 48, w: 4, h: 4 },
                        bottom: { x: 40, y: 48, w: 4, h: 4 },
                        front: { x: 36, y: 52, w: 4, h: 12 },
                        back: { x: 44, y: 52, w: 4, h: 12 }
                    },
                    leftArmLayer: {
                        right: { x: 56, y: 52, w: 4, h: 12 },  // Layer offset +32 on X axis (48+8=56)
                        left: { x: 48, y: 52, w: 4, h: 12 },
                        top: { x: 52, y: 48, w: 4, h: 4 },
                        bottom: { x: 56, y: 48, w: 4, h: 4 },
                        front: { x: 52, y: 52, w: 4, h: 12 },
                        back: { x: 60, y: 52, w: 4, h: 12 }
                    }
                };
            }
        }
        
        const armUVs = getArmUVMaps();
        
        // Complete UV mappings for all body parts - EXACT Minecraft 64x64 skin format
        // Based on official Minecraft skin schematic
        // Three.js BoxGeometry face order: [right, left, top, bottom, front, back]
        // Minecraft texture mapping: right side of model = left side of texture (when viewing front)
        const skinUVMaps = {
            // HEAD: 8x8 pixels, front at (8,8) in 64x64 texture
            head: {
                right: { x: 0, y: 8, w: 8, h: 8 },    // Right side of head (left in texture)
                left: { x: 16, y: 8, w: 8, h: 8 },    // Left side of head (right in texture)
                top: { x: 8, y: 0, w: 8, h: 8 },
                bottom: { x: 16, y: 0, w: 8, h: 8 },
                front: { x: 8, y: 8, w: 8, h: 8 },
                back: { x: 24, y: 8, w: 8, h: 8 }
            },
            // HEAD LAYER (HAT): 8x8 pixels, offset +32 on X axis
            headLayer: {
                right: { x: 32, y: 8, w: 8, h: 8 },
                left: { x: 48, y: 8, w: 8, h: 8 },
                top: { x: 40, y: 0, w: 8, h: 8 },
                bottom: { x: 48, y: 0, w: 8, h: 8 },
                front: { x: 40, y: 8, w: 8, h: 8 },
                back: { x: 56, y: 8, w: 8, h: 8 }
            },
            // BODY (TORSO): 8x12 pixels, front at (20,20)
            body: {
                right: { x: 16, y: 20, w: 4, h: 12 },  // Right side of body (left in texture)
                left: { x: 28, y: 20, w: 4, h: 12 },   // Left side of body (right in texture)
                top: { x: 20, y: 16, w: 8, h: 4 },
                bottom: { x: 28, y: 16, w: 8, h: 4 },
                front: { x: 20, y: 20, w: 8, h: 12 },
                back: { x: 32, y: 20, w: 8, h: 12 }
            },
            // BODY LAYER (JACKET): 8x12 pixels, offset +16 on Y axis
            bodyLayer: {
                right: { x: 16, y: 36, w: 4, h: 12 },
                left: { x: 28, y: 36, w: 4, h: 12 },
                top: { x: 20, y: 32, w: 8, h: 4 },
                bottom: { x: 28, y: 32, w: 8, h: 4 },
                front: { x: 20, y: 36, w: 8, h: 12 },
                back: { x: 32, y: 36, w: 8, h: 12 }
            },
            rightArm: armUVs.rightArm,
            rightArmLayer: armUVs.rightArmLayer,
            leftArm: armUVs.leftArm,
            leftArmLayer: armUVs.leftArmLayer,
            // RIGHT LEG: 4x12 pixels, front at (4,20)
            rightLeg: {
                right: { x: 0, y: 20, w: 4, h: 12 },   // Right side of right leg
                left: { x: 8, y: 20, w: 4, h: 12 },   // Left side of right leg
                top: { x: 4, y: 16, w: 4, h: 4 },
                bottom: { x: 8, y: 16, w: 4, h: 4 },
                front: { x: 4, y: 20, w: 4, h: 12 },
                back: { x: 12, y: 20, w: 4, h: 12 }
            },
            // RIGHT LEG LAYER (PANTS): 4x12 pixels, offset +16 on Y axis
            rightLegLayer: {
                right: { x: 0, y: 36, w: 4, h: 12 },
                left: { x: 8, y: 36, w: 4, h: 12 },
                top: { x: 4, y: 32, w: 4, h: 4 },
                bottom: { x: 8, y: 32, w: 4, h: 4 },
                front: { x: 4, y: 36, w: 4, h: 12 },
                back: { x: 12, y: 36, w: 4, h: 12 }
            },
            // LEFT LEG: 4x12 pixels, front at (20,52)
            leftLeg: {
                right: { x: 16, y: 52, w: 4, h: 12 },  // Right side of left leg
                left: { x: 24, y: 52, w: 4, h: 12 },   // Left side of left leg
                top: { x: 20, y: 48, w: 4, h: 4 },
                bottom: { x: 24, y: 48, w: 4, h: 4 },
                front: { x: 20, y: 52, w: 4, h: 12 },
                back: { x: 28, y: 52, w: 4, h: 12 }
            },
            // LEFT LEG LAYER (PANTS): 4x12 pixels, offset +32 on X axis (moves to left side)
            leftLegLayer: {
                right: { x: 0, y: 52, w: 4, h: 12 },
                left: { x: 8, y: 52, w: 4, h: 12 },
                top: { x: 4, y: 48, w: 4, h: 4 },
                bottom: { x: 8, y: 48, w: 4, h: 4 },
                front: { x: 4, y: 52, w: 4, h: 12 },
                back: { x: 12, y: 52, w: 4, h: 12 }
            }
        };
        
        // Create held item mesh based on type
        // Create a Minecraft character right hand with customizable skin texture and layers
        function createHandMesh() {
            const group = new THREE.Group();
            
            // Minecraft character's right arm proportions - slim: 3x12x4 pixels, classic: 4x12x4 pixels
            const handWidth = isSlimSkin ? 0.06 : 0.08; // 3px or 4px
            const handGeometry = new THREE.BoxGeometry(handWidth, 0.24, 0.08);
            
            let materials;
            let layerMaterials;
            
            if (customSkinTexture && customSkinTexture.data) {
                // Create canvas from stored skin data
                const skinCanvas = document.createElement('canvas');
                skinCanvas.width = customSkinTexture.width;
                skinCanvas.height = customSkinTexture.height;
                const ctx = skinCanvas.getContext('2d');
                const imageData = ctx.createImageData(skinCanvas.width, skinCanvas.height);
                
                for (let i = 0; i < customSkinTexture.data.length; i++) {
                    imageData.data[i] = customSkinTexture.data[i];
                }
                ctx.putImageData(imageData, 0, 0);
                
                // Create materials for first layer (base skin) using proper UV maps - NOT flipped for first-person view
                materials = createBodyPartMaterials(skinCanvas, skinUVMaps.rightArm, false, false);
                
                // Create materials for second layer (sleeve) using proper UV maps - NOT flipped for first-person view
                layerMaterials = createBodyPartMaterials(skinCanvas, skinUVMaps.rightArmLayer, true, false);
            } else if (customHandTexture) {
                // Fallback to old texture system
                const canvas = document.createElement('canvas');
                canvas.width = 16;
                canvas.height = 16;
                const ctx = canvas.getContext('2d');
                const imageData = ctx.createImageData(16, 16);
                
                for (let i = 0; i < customHandTexture.length; i++) {
                    imageData.data[i] = customHandTexture[i];
                }
                ctx.putImageData(imageData, 0, 0);
                
                const createFaceCanvas = (sx, sy, sw, sh) => {
                    const faceCanvas = document.createElement('canvas');
                    faceCanvas.width = sw;
                    faceCanvas.height = sh;
                    const faceCtx = faceCanvas.getContext('2d');
                    faceCtx.drawImage(canvas, sx, sy, sw, sh, 0, 0, sw, sh);
                    return faceCanvas;
                };
                
                materials = [
                    new THREE.MeshLambertMaterial({ map: new THREE.CanvasTexture(createFaceCanvas(0, 0, 4, 12)) }),
                    new THREE.MeshLambertMaterial({ map: new THREE.CanvasTexture(createFaceCanvas(8, 0, 4, 12)) }),
                    new THREE.MeshLambertMaterial({ map: new THREE.CanvasTexture(createFaceCanvas(4, 12, 4, 4)) }),
                    new THREE.MeshLambertMaterial({ map: new THREE.CanvasTexture(createFaceCanvas(8, 12, 4, 4)) }),
                    new THREE.MeshLambertMaterial({ map: new THREE.CanvasTexture(createFaceCanvas(4, 0, 4, 12)) }),
                    new THREE.MeshLambertMaterial({ map: new THREE.CanvasTexture(createFaceCanvas(12, 0, 4, 12)) })
                ];
                
                materials.forEach(mat => {
                    if (mat.map) {
                        mat.map.magFilter = THREE.NearestFilter;
                        mat.map.minFilter = THREE.NearestFilter;
                    }
                });
            } else {
                // Default Steve's skin tone
                const defaultMaterial = new THREE.MeshLambertMaterial({ color: 0xd4a574 });
                materials = [defaultMaterial, defaultMaterial, defaultMaterial, defaultMaterial, defaultMaterial, defaultMaterial];
            }
            
            // Create base hand mesh
            const handMesh = new THREE.Mesh(handGeometry, materials);
            handMesh.castShadow = false;
            handMesh.receiveShadow = false;
            handMesh.renderOrder = 0; // Base layer
            group.add(handMesh);
            
            // Create second layer (sleeve) - 3D SKIN LAYERS MOD STYLE with actual depth
            if (layerMaterials) {
                // Hand: base is 4px or 3px (slim), layer adds MORE depth like 3D Skin Layers mod
                const layerWidth = isSlimSkin ? 0.075 : 0.095; // Much thicker for 3D effect
                const layerHeight = 0.265; // Taller than base
                const layerDepth = 0.095; // Deeper than base
                const layerGeometry = new THREE.BoxGeometry(layerWidth, layerHeight, layerDepth);
                fpHandLayerMesh = new THREE.Mesh(layerGeometry, layerMaterials);
                fpHandLayerMesh.castShadow = false;
                fpHandLayerMesh.receiveShadow = false;
                fpHandLayerMesh.visible = showSkinLayers;
                fpHandLayerMesh.renderOrder = 1; // Render on top of base layer
                
                // Offset the layer slightly for 3D depth effect (like 3D Skin Layers mod)
                fpHandLayerMesh.position.set(0, 0, 0.008); // Push layer out slightly
                
                group.add(fpHandLayerMesh);
            }
            
            return group;
        }
        
        function createHeldItemMesh(itemType) {
            if (itemType === null || itemType === undefined) return null;
            
            let geometry, material;
            
            // Check if it's a tool (negative number)
            if (itemType < 0) {
                const itemDef = itemDefinitions[itemType];
                if (!itemDef) return null;
                
                // Create tool representation
                if (itemDef.isPickaxe || itemDef.isAxe) {
                    // Tool head (small cube)
                    const headGeometry = new THREE.BoxGeometry(0.15, 0.1, 0.05);
                    const headMaterial = new THREE.MeshLambertMaterial({ 
                        color: itemDef.isPickaxe ? 0x7a7a7a : 0x8b5a2b 
                    });
                    const head = new THREE.Mesh(headGeometry, headMaterial);
                    head.position.set(0, 0.12, 0);
                    
                    // Handle (stick)
                    const handleGeometry = new THREE.BoxGeometry(0.03, 0.25, 0.03);
                    const handleMaterial = new THREE.MeshLambertMaterial({ color: 0x8b5a2b });
                    const handle = new THREE.Mesh(handleGeometry, handleMaterial);
                    handle.position.set(0, -0.05, 0);
                    
                    const tool = new THREE.Group();
                    tool.add(head);
                    tool.add(handle);
                    return tool;
                    
                } else if (itemDef.isSword) {
                    // Blade
                    const bladeGeometry = new THREE.BoxGeometry(0.05, 0.3, 0.02);
                    const bladeMaterial = new THREE.MeshLambertMaterial({ 
                        color: itemType === ITEM_STONE_SWORD ? 0x7a7a7a : 0x8b5a2b 
                    });
                    const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                    blade.position.set(0, 0.1, 0);
                    
                    // Handle
                    const handleGeometry = new THREE.BoxGeometry(0.03, 0.1, 0.03);
                    const handleMaterial = new THREE.MeshLambertMaterial({ color: 0x8b5a2b });
                    const handle = new THREE.Mesh(handleGeometry, handleMaterial);
                    handle.position.set(0, -0.1, 0);
                    
                    // Guard
                    const guardGeometry = new THREE.BoxGeometry(0.15, 0.02, 0.03);
                    const guardMaterial = new THREE.MeshLambertMaterial({ color: 0x4a4a4a });
                    const guard = new THREE.Mesh(guardGeometry, guardMaterial);
                    guard.position.set(0, -0.05, 0);
                    
                    const sword = new THREE.Group();
                    sword.add(blade);
                    sword.add(handle);
                    sword.add(guard);
                    return sword;
                    
                } else if (itemDef.isStick) {
                    // Simple stick
                    geometry = new THREE.BoxGeometry(0.03, 0.25, 0.03);
                    material = new THREE.MeshLambertMaterial({ color: 0x8b5a2b });
                    return new THREE.Mesh(geometry, material);
                } else if (itemDef.isPlaceable) {
                    // Planks or other placeable items - render as small block with proper texture
                    geometry = new THREE.BoxGeometry(0.15, 0.15, 0.15);
                    
                    // Use the actual planks material if available (mats[12] is PLANKS_TYPE)
                    if (itemType === ITEM_PLANKS && mats[PLANKS_TYPE]) {
                        material = mats[PLANKS_TYPE].clone();
                    } else {
                        material = new THREE.MeshLambertMaterial({ 
                            color: itemDef.color ? parseInt(itemDef.color.replace('#', '0x')) : 0xdaa560 
                        });
                    }
                    
                    return new THREE.Mesh(geometry, material);
                }
            }
            
            // It's a block - use existing material or create cube
            if (itemType >= 0 && itemType < mats.length && mats[itemType]) {
                geometry = new THREE.BoxGeometry(0.15, 0.15, 0.15);
                
                // Handle array materials (like grass blocks) or single materials
                if (Array.isArray(mats[itemType])) {
                    // Clone each material in the array
                    material = mats[itemType].map(mat => mat.clone());
                } else {
                    material = mats[itemType].clone();
                }
                
                const block = new THREE.Mesh(geometry, material);
                return block;
            }
            
            return null;
        }
        
        // Update held item info display
        function updateHeldItemInfo() {
            const heldItemInfoDiv = document.getElementById('held-item-info');
            const hudIndex = getHUDIndex(sel);
            const item = inventoryData[hudIndex];
            
            if (!item || inventoryOpen || paused || isDead) {
                heldItemInfoDiv.style.display = 'none';
                return;
            }
            
            const display = getBlockDisplay(item.type);
            const itemNameEl = heldItemInfoDiv.querySelector('.item-name');
            const itemCountEl = heldItemInfoDiv.querySelector('.item-count');
            const durabilityBarContainer = heldItemInfoDiv.querySelector('.durability-bar-container');
            const durabilityBar = heldItemInfoDiv.querySelector('.durability-bar');
            const durabilityText = heldItemInfoDiv.querySelector('.durability-text');
            
            itemNameEl.textContent = display.name;
            itemNameEl.style.color = display.color;
            
            // Check if it's a tool with durability
            const isTool = item.type < 0 && itemDefinitions[item.type] && itemDefinitions[item.type].isTool;
            
            if (isTool && !isCreativeMode) {
                // Hide count for tools
                itemCountEl.style.display = 'none';
                
                // Show durability bar
                const itemDef = itemDefinitions[item.type];
                const currentDurability = item.durability !== undefined ? item.durability : itemDef.maxDurability;
                const maxDurability = itemDef.maxDurability;
                const durabilityPercent = (currentDurability / maxDurability) * 100;
                
                durabilityBarContainer.style.display = 'block';
                durabilityBar.style.width = durabilityPercent + '%';
                
                // Color based on durability level
                durabilityBar.classList.remove('high', 'medium', 'low');
                if (durabilityPercent > 50) {
                    durabilityBar.classList.add('high');
                } else if (durabilityPercent > 25) {
                    durabilityBar.classList.add('medium');
                } else {
                    durabilityBar.classList.add('low');
                }
                
                durabilityText.textContent = `${currentDurability} / ${maxDurability}`;
                durabilityText.style.display = 'block';
            } else {
                // Show count for regular items
                itemCountEl.style.display = 'block';
                if (isCreativeMode) {
                    itemCountEl.textContent = '';
                } else {
                    itemCountEl.textContent = `x${item.count}`;
                }
                durabilityBarContainer.style.display = 'none';
                durabilityText.style.display = 'none';
            }
            
            heldItemInfoDiv.style.display = 'block';
        }
        
        // Update held item
        function updateHeldItem() {
            // Remove old item (but keep hand)
            if (heldItemMesh) {
                handScene.remove(heldItemMesh);
                heldItemMesh = null;
            }
            
            // Get current item
            const hudIndex = getHUDIndex(sel);
            const item = inventoryData[hudIndex];
            
            // Initialize permanent hand if not exists
            if (!fpHandMesh) {
                fpHandMesh = createHandMesh();
                if (fpHandMesh) {
                    // Make hand bigger and move to bottom-right corner
                    fpHandMesh.scale.set(1.5, 1.5, 1.5); // 1.5x bigger
                    fpHandMesh.userData.basePosition = { x: 0.4, y: -0.3, z: -0.5 }; 
                    fpHandMesh.userData.baseRotation = { x: -0.15, y: -1.05, z: 3.2 }; 
                    fpHandMesh.position.set(0.4, -0.35, -0.5);
                    fpHandMesh.rotation.set(0.15, -0.2, 0.0);
                    handScene.add(fpHandMesh);
                    // Apply textures after creating (safely)
                    try {
                        if (modelTextures && Object.keys(modelTextures).length > 0) {
                            applyTexturesToModels();
                        }
                    } catch (e) {
                        console.error('Error applying textures to hand:', e);
                    }
                }
            }
            
            // Show hand ONLY when NOT holding any item AND showItemInHand is enabled
            if (fpHandMesh) {
                fpHandMesh.visible = showItemInHand && !item;
            }
            
            if (!item) {
                // No item - just show hand (if enabled)
                updateHeldItemInfo();
                return;
            }
            
            // Create new item mesh when holding something
            heldItemMesh = createHeldItemMesh(item.type);
            
            if (heldItemMesh) {
                // Position to match Minecraft - blocks held at different angle than hand
                heldItemMesh.userData.basePosition = { x: 0.25, y: -0.2, z: -0.45 };
                heldItemMesh.userData.baseRotation = { x: 0.3, y: -0.5, z: 0.1 };
                heldItemMesh.position.set(0.25, -0.2, -0.45);
                heldItemMesh.rotation.set(0.3, -0.5, 0.1);
                handScene.add(heldItemMesh);
            }
            
            // Update held item info display
            updateHeldItemInfo();
        }
        
        // Add light to hand scene
        const handLight = new THREE.DirectionalLight(0xffffff, 1);
        handLight.position.set(1, 1, 1);
        handScene.add(handLight);
        const handAmbient = new THREE.AmbientLight(0xffffff, 0.6);
        handScene.add(handAmbient);
        
        // Load settings from localStorage on page load
        loadSettings();
        
        // Recreate arms if slim skin was loaded from settings
        if (isSlimSkin) {
            createArms();
            // Update UV maps for slim arms
            const armUVs = getArmUVMaps();
            skinUVMaps.rightArm = armUVs.rightArm;
            skinUVMaps.rightArmLayer = armUVs.rightArmLayer;
            skinUVMaps.leftArm = armUVs.leftArm;
            skinUVMaps.leftArmLayer = armUVs.leftArmLayer;
        }
        
        var renderer = new THREE.WebGLRenderer({ 
            canvas: c, 
            antialias: false, // Disabled antialiasing for blocky look
            powerPreference: "high-performance", // Request high-performance GPU
            precision: "mediump", // Medium precision for better performance
            stencil: false, // Disable stencil buffer
            depth: true // Keep depth buffer for proper rendering
        }); 
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap pixel ratio for performance
        renderer.shadowMap.enabled = shadowsEnabled; // Use setting value
        renderer.shadowMap.type = THREE.BasicShadowMap; // Blocky shadows like Minecraft
        renderer.sortObjects = false; // Disable sorting for performance
        document.body.appendChild(renderer.domElement);
        
        // NEW: Assign fakeCursorElement now that DOM is ready
        fakeCursorElement = document.getElementById('fake-cursor');
        pickedUpItemElement = document.getElementById('picked-up-item'); // MODIFIED: Assigned here

        // --- Lights and Materials (Optimized for performance) ---
        var aLight = new THREE.AmbientLight(0xffffff, 0.5); // Slightly brighter ambient
        scene.add(aLight);
        var dLight = new THREE.DirectionalLight(0xffffff, 0.6); // Brighter directional
        dLight.position.set(50, 100, 50);
        dLight.castShadow = true;
        // Optimized shadow settings - only directional light casts shadows for performance
        dLight.shadow.mapSize.width = 1024; // Improved shadow quality
        dLight.shadow.mapSize.height = 1024;
        dLight.shadow.camera.near = 0.5;
        dLight.shadow.camera.far = 500;
        dLight.shadow.camera.left = -50;
        dLight.shadow.camera.right = 50;
        dLight.shadow.camera.top = 50;
        dLight.shadow.camera.bottom = -50;
        scene.add(dLight);
        
        // --- 2D PIXEL ART SUN AND MOON SPRITES (MINECRAFT STYLE) ---
        const celestialDistance = 150; // Distance from camera
        
        // Function to create pixel art sun texture (bright and glowy like Minecraft)
        function createSunTexture() {
            const size = 128; // Larger for better quality
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            // Clear background
            ctx.clearRect(0, 0, size, size);
            
            // Add outer glow (multiple layers for gradient effect)
            const glowLayers = [
                { color: 'rgba(255, 255, 200, 0.15)', size: 58 },
                { color: 'rgba(255, 255, 150, 0.25)', size: 52 },
                { color: 'rgba(255, 255, 100, 0.35)', size: 46 },
                { color: 'rgba(255, 245, 80, 0.45)', size: 40 }
            ];
            
            glowLayers.forEach(layer => {
                ctx.fillStyle = layer.color;
                const offset = (size - layer.size) / 2;
                ctx.fillRect(offset, offset, layer.size, layer.size);
            });
            
            // Sun core - very bright white/yellow
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(36, 36, 56, 56);
            
            // Inner bright core
            ctx.fillStyle = '#FFFFD0';
            ctx.fillRect(42, 42, 44, 44);
            
            // Center highlight
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(52, 52, 24, 24);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            return texture;
        }
        
        // Function to create moon texture based on phase (0-7)
        // 0 = Full Moon, 1 = Waning Gibbous, 2 = Last Quarter, 3 = Waning Crescent
        // 4 = New Moon, 5 = Waxing Crescent, 6 = First Quarter, 7 = Waxing Gibbous
        function createMoonTexture(phase) {
            const size = 64;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            // Clear background
            ctx.clearRect(0, 0, size, size);
            
            const moonSize = 28;
            const moonX = 18;
            const moonY = 18;
            
            // Draw moon base (light gray)
            ctx.fillStyle = '#CCCCCC';
            ctx.fillRect(moonX, moonY, moonSize, moonSize);
            
            // Add highlights
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(moonX + 8, moonY + 4, 8, 8);
            
            // Add craters
            ctx.fillStyle = '#999999';
            ctx.fillRect(moonX + 4, moonY + 16, 4, 4);
            ctx.fillRect(moonX + 16, moonY + 10, 6, 6);
            ctx.fillRect(moonX + 20, moonY + 20, 3, 3);
            
            // Apply shadow based on phase
            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)'; // Dark shadow
            
            switch(phase) {
                case 0: // Full Moon - no shadow
                    break;
                case 1: // Waning Gibbous - shadow on left edge
                    ctx.fillRect(moonX, moonY, 7, moonSize);
                    break;
                case 2: // Last Quarter - shadow on left half
                    ctx.fillRect(moonX, moonY, 14, moonSize);
                    break;
                case 3: // Waning Crescent - mostly shadow, thin crescent on right
                    ctx.fillRect(moonX, moonY, 21, moonSize);
                    break;
                case 4: // New Moon - completely dark
                    ctx.fillRect(moonX, moonY, moonSize, moonSize);
                    break;
                case 5: // Waxing Crescent - thin crescent on left
                    ctx.fillRect(moonX + 7, moonY, 21, moonSize);
                    break;
                case 6: // First Quarter - shadow on right half
                    ctx.fillRect(moonX + 14, moonY, 14, moonSize);
                    break;
                case 7: // Waxing Gibbous - shadow on right edge
                    ctx.fillRect(moonX + 21, moonY, 7, moonSize);
                    break;
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            return texture;
        }
        
        // Function to create pixel art moon texture
        function createMoonTexture() {
            const size = 64;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            // Clear background
            ctx.clearRect(0, 0, size, size);
            
            // Moon base - light gray
            ctx.fillStyle = '#CCCCCC';
            ctx.fillRect(18, 18, 28, 28);
            
            // Add highlights (white)
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(28, 24, 8, 8);
            
            // Add craters (darker gray)
            ctx.fillStyle = '#999999';
            ctx.fillRect(24, 36, 4, 4);
            ctx.fillRect(36, 28, 6, 6);
            ctx.fillRect(40, 40, 3, 3);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            return texture;
        }
        
        // Create sun as flat plane with brighter appearance
        const sunTexture = createSunTexture();
        const sunGeometry = new THREE.PlaneGeometry(40, 40); // Larger sun
        const sunMaterial = new THREE.MeshBasicMaterial({ 
            map: sunTexture,
            transparent: true,
            side: THREE.DoubleSide,
            depthWrite: false,
            opacity: 1.0
        });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        scene.add(sun);
        
        // Create moon as flat plane - starts with full moon
        let moonTexture = createMoonTexture(0);
        const moonGeometry = new THREE.PlaneGeometry(25, 25);
        const moonMaterial = new THREE.MeshBasicMaterial({ 
            map: moonTexture,
            transparent: true,
            side: THREE.DoubleSide,
            depthWrite: false
        });
        const moon = new THREE.Mesh(moonGeometry, moonMaterial);
        scene.add(moon);
        
        // Function to update moon texture based on current phase
        function updateMoonPhase() {
            const newTexture = createMoonTexture(moonPhase);
            moonMaterial.map = newTexture;
            moonMaterial.needsUpdate = true;
            if (moonTexture) moonTexture.dispose(); // Clean up old texture
            moonTexture = newTexture;
        }
        scene.add(moon);
        
        // --- ENHANCED SOUND SYSTEM WITH BLOCK-SPECIFIC SOUNDS ---
        // Use the existing audioCtx instead of creating a new one
        
        // Sound profiles for each block type
        const blockSounds = {
            0: { // GRASS
                break: { duration: 0.15, freq: 800, volume: 0.25, noise: 'brown' },
                place: { duration: 0.12, freq: 600, volume: 0.2, noise: 'brown' },
                step: { duration: 0.08, freq: 400, volume: 0.12, noise: 'brown', highFreq: 1200 }
            },
            1: { // DIRT
                break: { duration: 0.15, freq: 700, volume: 0.25, noise: 'brown' },
                place: { duration: 0.12, freq: 550, volume: 0.2, noise: 'brown' },
                step: { duration: 0.08, freq: 380, volume: 0.12, noise: 'brown', highFreq: 1100 }
            },
            2: { // STONE
                break: { duration: 0.2, freq: 600, volume: 0.3, noise: 'white' },
                place: { duration: 0.15, freq: 450, volume: 0.25, noise: 'white' },
                step: { duration: 0.06, freq: 200, volume: 0.15, noise: 'white', highFreq: 2000 }
            },
            3: { // WOOD
                break: { duration: 0.18, freq: 500, volume: 0.28, noise: 'brown' },
                place: { duration: 0.14, freq: 400, volume: 0.22, noise: 'brown' },
                step: { duration: 0.09, freq: 350, volume: 0.13, noise: 'brown', highFreq: 900 }
            },
            4: { // SAND
                break: { duration: 0.12, freq: 900, volume: 0.22, noise: 'white' },
                place: { duration: 0.1, freq: 700, volume: 0.18, noise: 'white' },
                step: { duration: 0.07, freq: 500, volume: 0.1, noise: 'white', highFreq: 1500 }
            },
            5: { // BEDROCK
                break: { duration: 0.25, freq: 400, volume: 0.35, noise: 'white' },
                place: { duration: 0.2, freq: 300, volume: 0.3, noise: 'white' },
                step: { duration: 0.05, freq: 150, volume: 0.16, noise: 'white', highFreq: 2200 }
            },
            6: { // LEAVES
                break: { duration: 0.1, freq: 1200, volume: 0.2, noise: 'white' },
                place: { duration: 0.08, freq: 1000, volume: 0.15, noise: 'white' },
                step: { duration: 0.09, freq: 800, volume: 0.08, noise: 'white', highFreq: 1800 }
            },
            7: { // GLASS
                break: { duration: 0.15, freq: 2000, volume: 0.3, noise: 'white' },
                place: { duration: 0.12, freq: 1500, volume: 0.25, noise: 'white' },
                step: { duration: 0.06, freq: 1000, volume: 0.1, noise: 'white', highFreq: 2500 }
            },
            8: { // DOOR (use wood sounds)
                break: { duration: 0.18, freq: 500, volume: 0.28, noise: 'brown' },
                place: { duration: 0.14, freq: 400, volume: 0.22, noise: 'brown' },
                step: { duration: 0.09, freq: 350, volume: 0.13, noise: 'brown', highFreq: 900 }
            },
            9: { // TORCH (light crackling sound)
                break: { duration: 0.1, freq: 800, volume: 0.15, noise: 'white' },
                place: { duration: 0.08, freq: 600, volume: 0.12, noise: 'white' },
                step: { duration: 0.07, freq: 500, volume: 0.08, noise: 'white', highFreq: 1200 }
            },
            12: { // PLANKS (similar to wood but slightly different pitch)
                break: { duration: 0.18, freq: 520, volume: 0.27, noise: 'brown' },
                place: { duration: 0.14, freq: 420, volume: 0.21, noise: 'brown' },
                step: { duration: 0.09, freq: 370, volume: 0.12, noise: 'brown', highFreq: 950 }
            },
            10: { // WATER (splashing sound)
                break: { duration: 0.1, freq: 1500, volume: 0.2, noise: 'white' },
                place: { duration: 0.08, freq: 1200, volume: 0.18, noise: 'white' },
                step: { duration: 0.05, freq: 800, volume: 0.08, noise: 'white', highFreq: 1600 }
            },
            10: { // WATER (splash/flowing sound)
                break: { duration: 0.15, freq: 600, volume: 0.25, noise: 'white' },
                place: { duration: 0.12, freq: 500, volume: 0.2, noise: 'white' },
                step: { duration: 0.08, freq: 400, volume: 0.12, noise: 'white', highFreq: 1000 }
            },
            11: { // LAVA (bubbling/crackling sound)
                break: { duration: 0.2, freq: 300, volume: 0.3, noise: 'brown' },
                place: { duration: 0.15, freq: 250, volume: 0.25, noise: 'brown' },
                step: { duration: 0.1, freq: 200, volume: 0.15, noise: 'brown', highFreq: 600 }
            }
        };
        
        // Create realistic noise-based sounds like Minecraft
        function createNoiseBuffer(duration, type = 'white') {
            const sampleRate = audioCtx.sampleRate;
            const length = sampleRate * duration;
            const buffer = audioCtx.createBuffer(1, length, sampleRate);
            const data = buffer.getChannelData(0);
            
            if (type === 'white') {
                // White noise for realistic stone/sand/leaves sounds
                for (let i = 0; i < length; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
            } else if (type === 'brown') {
                // Brown noise for deeper, earthier sounds (dirt, grass, wood)
                let lastOut = 0;
                for (let i = 0; i < length; i++) {
                    const white = Math.random() * 2 - 1;
                    data[i] = (lastOut + (0.02 * white)) / 1.02;
                    lastOut = data[i];
                    data[i] *= 3.5;
                }
            }
            return buffer;
        }
        
        function playRealisticSound(duration, filterFreq, volume = 0.2, noiseType = 'white') {
            const source = audioCtx.createBufferSource();
            source.buffer = createNoiseBuffer(duration, noiseType);
            
            // Apply low-pass filter for more natural sound
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(filterFreq, audioCtx.currentTime);
            
            const gainNode = audioCtx.createGain();
            gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            
            source.connect(filter);
            filter.connect(gainNode);
            // FIXED: Connect to sfxGainNode to apply master volume and SFX volume
            gainNode.connect(sfxGainNode);
            
            source.start(audioCtx.currentTime);
        }
        
        function playBreakSound(blockType = 0) {
            const sound = blockSounds[blockType] || blockSounds[0];
            const s = sound.break;
            
            // Main break sound
            playRealisticSound(s.duration, s.freq + Math.random() * 400, s.volume, s.noise);
            
            // Secondary crack sound for emphasis
            setTimeout(() => {
                playRealisticSound(s.duration * 0.5, s.freq * 0.7 + Math.random() * 300, s.volume * 0.6, s.noise);
            }, 30);
        }
        
        function playPlaceSound(blockType = 0) {
            const sound = blockSounds[blockType] || blockSounds[0];
            const s = sound.place;
            
            // Main place sound
            playRealisticSound(s.duration, s.freq + Math.random() * 200, s.volume, s.noise);
            
            // Secondary settling sound
            setTimeout(() => {
                playRealisticSound(s.duration * 0.5, s.freq * 0.7 + Math.random() * 150, s.volume * 0.6, s.noise);
            }, 40);
        }
        
        function playStepSound(blockType = 0) {
            const sound = blockSounds[blockType] || blockSounds[0];
            const s = sound.step;
            const variation = Math.random() * 200;
            
            // Main footstep sound
            playRealisticSound(s.duration, s.freq + variation, s.volume, s.noise);
            
            // High-frequency texture (grass rustling, stone scraping, etc.)
            if (s.highFreq) {
                setTimeout(() => {
                    playRealisticSound(s.duration * 0.5, s.highFreq + variation, s.volume * 0.6, 'white');
                }, 15);
            }
        }
        
        function playJumpSound(blockType = 0) {
            const sound = blockSounds[blockType] || blockSounds[0];
            const s = sound.step;
            
            // Jump uses a slightly modified step sound
            playRealisticSound(s.duration * 1.2, s.freq * 1.2 + Math.random() * 300, s.volume * 1.2, s.noise);
        }
        
        // Damage/hurt sound effect
        function playDamageSound() {
            const now = audioCtx.currentTime;
            
            // Sharp pain sound - descending pitch
            const osc1 = audioCtx.createOscillator();
            const gain1 = audioCtx.createGain();
            osc1.connect(gain1);
            gain1.connect(sfxGainNode);
            osc1.type = 'sawtooth';
            osc1.frequency.setValueAtTime(800, now);
            osc1.frequency.exponentialRampToValueAtTime(200, now + 0.3);
            gain1.gain.setValueAtTime(0.35, now);
            gain1.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
            osc1.start(now);
            osc1.stop(now + 0.3);
            
            // Impact/thud component
            const osc2 = audioCtx.createOscillator();
            const gain2 = audioCtx.createGain();
            osc2.connect(gain2);
            gain2.connect(sfxGainNode);
            osc2.type = 'square';
            osc2.frequency.setValueAtTime(120, now);
            osc2.frequency.exponentialRampToValueAtTime(50, now + 0.2);
            gain2.gain.setValueAtTime(0.25, now);
            gain2.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
            osc2.start(now);
            osc2.stop(now + 0.2);
            
            // High-frequency pain component
            const osc3 = audioCtx.createOscillator();
            const gain3 = audioCtx.createGain();
            osc3.connect(gain3);
            gain3.connect(sfxGainNode);
            osc3.type = 'triangle';
            osc3.frequency.setValueAtTime(1500, now);
            osc3.frequency.exponentialRampToValueAtTime(500, now + 0.15);
            gain3.gain.setValueAtTime(0.2, now);
            gain3.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
            osc3.start(now);
            osc3.stop(now + 0.15);
        }
        
        // Helper function to get block type player is standing on
        function getBlockUnderPlayer() {
            const feetY = py - EYE_HEIGHT;
            const blockX = Math.round(px / bs);
            const blockY = Math.round(feetY / bs) - 1; // Block directly under feet
            const blockZ = Math.round(pz / bs);
            
            const blockKey = key(blockX, blockY, blockZ);
            const block = world[blockKey];
            
            return block ? block.userData.blockType : 0; // Default to grass sound
        }
        
        // Walking sound state
        let stepTimer = 0;
        const stepInterval = 0.4; // Time between steps in seconds
        let wasMoving = false;

        // --- PIXEL TEXTURE GENERATION ---
        function createPixelTexture(baseColor, pattern) {
            const canvas = document.createElement('canvas');
            canvas.width = 16;
            canvas.height = 16;
            const ctx = canvas.getContext('2d');
            
            // Fill base color
            ctx.fillStyle = baseColor;
            ctx.fillRect(0, 0, 16, 16);
            
            // Apply pattern
            pattern.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, p.w || 1, p.h || 1);
            });
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            texture.needsUpdate = true;
            return texture;
        }
        
        // Dirt Texture Pattern (brown with darker spots)
        const dirtPattern = [
            { x: 2, y: 1, color: '#5a3419' }, { x: 5, y: 2, color: '#5a3419' }, { x: 9, y: 3, color: '#5a3419' },
            { x: 12, y: 5, color: '#7a5030' }, { x: 3, y: 7, color: '#5a3419' }, { x: 8, y: 8, color: '#7a5030' },
            { x: 14, y: 9, color: '#5a3419' }, { x: 1, y: 11, color: '#7a5030' }, { x: 6, y: 12, color: '#5a3419' },
            { x: 11, y: 13, color: '#7a5030' }, { x: 4, y: 14, color: '#5a3419' }
        ];
        
        // Grass Top Texture Pattern (green with varied shades)
        const grassPattern = [
            { x: 1, y: 0, color: '#4a7a2e' }, { x: 4, y: 1, color: '#6a9c4e' }, { x: 7, y: 1, color: '#4a7a2e' },
            { x: 10, y: 2, color: '#6a9c4e' }, { x: 2, y: 3, color: '#4a7a2e' }, { x: 13, y: 4, color: '#6a9c4e' },
            { x: 5, y: 5, color: '#4a7a2e' }, { x: 8, y: 6, color: '#6a9c4e' }, { x: 11, y: 7, color: '#4a7a2e' },
            { x: 3, y: 9, color: '#6a9c4e' }, { x: 14, y: 10, color: '#4a7a2e' }, { x: 6, y: 11, color: '#6a9c4e' },
            { x: 9, y: 12, color: '#4a7a2e' }, { x: 1, y: 14, color: '#6a9c4e' }
        ];
        
        // Stone Texture Pattern (gray with darker cracks)
        const stonePattern = [
            { x: 3, y: 2, w: 2, color: '#606060' }, { x: 8, y: 1, color: '#909090' }, { x: 12, y: 3, color: '#606060' },
            { x: 1, y: 5, color: '#909090' }, { x: 6, y: 6, w: 2, color: '#606060' }, { x: 14, y: 7, color: '#909090' },
            { x: 4, y: 9, color: '#606060' }, { x: 10, y: 10, w: 2, color: '#909090' }, { x: 2, y: 12, color: '#606060' },
            { x: 13, y: 13, color: '#909090' }, { x: 7, y: 14, color: '#606060' }
        ];
        
        // Wood Texture Pattern - SIDES (brown with vertical grain lines)
        const woodSidePattern = [
            { x: 3, y: 0, h: 16, color: '#734a1a' }, { x: 8, y: 0, h: 16, color: '#9b6a3b' },
            { x: 12, y: 0, h: 16, color: '#734a1a' }, { x: 6, y: 4, w: 2, h: 1, color: '#6b421a' },
            { x: 10, y: 8, w: 2, h: 1, color: '#6b421a' }, { x: 5, y: 12, w: 2, h: 1, color: '#6b421a' }
        ];
        
        // Wood Texture Pattern - TOP/BOTTOM (rings pattern, lighter brown like Minecraft)
        const woodTopPattern = [
            // Outer ring
            { x: 2, y: 2, w: 12, h: 1, color: '#6b421a' },
            { x: 2, y: 13, w: 12, h: 1, color: '#6b421a' },
            { x: 2, y: 3, w: 1, h: 10, color: '#6b421a' },
            { x: 13, y: 3, w: 1, h: 10, color: '#6b421a' },
            // Middle ring
            { x: 4, y: 4, w: 8, h: 1, color: '#9b6a3b' },
            { x: 4, y: 11, w: 8, h: 1, color: '#9b6a3b' },
            { x: 4, y: 5, w: 1, h: 6, color: '#9b6a3b' },
            { x: 11, y: 5, w: 1, h: 6, color: '#9b6a3b' },
            // Inner ring
            { x: 6, y: 6, w: 4, h: 1, color: '#734a1a' },
            { x: 6, y: 9, w: 4, h: 1, color: '#734a1a' },
            { x: 6, y: 7, w: 1, h: 2, color: '#734a1a' },
            { x: 9, y: 7, w: 1, h: 2, color: '#734a1a' },
            // Center
            { x: 7, y: 7, w: 2, h: 2, color: '#8b5a2b' }
        ];
        
        // Planks Texture Pattern (horizontal wooden planks - distinct from log texture)
        const planksPattern = [
            // Horizontal plank boards (lighter color than logs)
            { x: 0, y: 0, w: 16, h: 4, color: '#b8936d' },
            { x: 0, y: 4, w: 16, h: 1, color: '#8b6f47' },
            { x: 0, y: 5, w: 16, h: 3, color: '#c9a876' },
            { x: 0, y: 8, w: 16, h: 1, color: '#8b6f47' },
            { x: 0, y: 9, w: 16, h: 3, color: '#b8936d' },
            { x: 0, y: 12, w: 16, h: 1, color: '#8b6f47' },
            { x: 0, y: 13, w: 16, h: 3, color: '#c9a876' },
            // Nail/joint details on planks
            { x: 2, y: 1, w: 1, h: 1, color: '#5a4a30' },
            { x: 13, y: 1, w: 1, h: 1, color: '#5a4a30' },
            { x: 5, y: 6, w: 1, h: 1, color: '#5a4a30' },
            { x: 10, y: 6, w: 1, h: 1, color: '#5a4a30' },
            { x: 2, y: 10, w: 1, h: 1, color: '#5a4a30' },
            { x: 13, y: 10, w: 1, h: 1, color: '#5a4a30' },
            { x: 7, y: 14, w: 1, h: 1, color: '#5a4a30' }
        ];
        
        // Create textured materials
        var mats = [];
        var dirtTexture = createPixelTexture('#6b4423', dirtPattern);
        var grassTexture = createPixelTexture('#5a8c3e', grassPattern);
        var stoneTexture = createPixelTexture('#7a7a7a', stonePattern);
        var woodSideTexture = createPixelTexture('#8b5a2b', woodSidePattern);
        var woodTopTexture = createPixelTexture('#c0926a', woodTopPattern);
        var planksTexture = createPixelTexture('#daa560', planksPattern);
        var sandTexture = createPixelTexture('#ddc28f', [
            { x: 2, y: 2, color: '#eed29f' }, { x: 6, y: 3, color: '#ccb07f' }, { x: 10, y: 5, color: '#eed29f' },
            { x: 13, y: 7, color: '#ccb07f' }, { x: 4, y: 9, color: '#eed29f' }, { x: 8, y: 11, color: '#ccb07f' }
        ]);
        var bedrockTexture = createPixelTexture('#222222', [
            { x: 1, y: 1, color: '#333333' }, { x: 5, y: 2, color: '#111111' }, { x: 9, y: 4, color: '#333333' },
            { x: 12, y: 6, color: '#111111' }, { x: 3, y: 8, color: '#333333' }, { x: 14, y: 11, color: '#111111' }
        ]);
        
        // Leaves Texture Pattern (green with darker spots)
        var leavesTexture = createPixelTexture('#38761d', [
            { x: 1, y: 1, color: '#2a5a15' }, { x: 4, y: 2, color: '#468c25' }, { x: 7, y: 1, color: '#2a5a15' },
            { x: 10, y: 3, color: '#468c25' }, { x: 2, y: 5, color: '#2a5a15' }, { x: 13, y: 4, color: '#468c25' },
            { x: 5, y: 7, color: '#2a5a15' }, { x: 9, y: 8, color: '#468c25' }, { x: 12, y: 9, color: '#2a5a15' },
            { x: 3, y: 11, color: '#468c25' }, { x: 14, y: 12, color: '#2a5a15' }, { x: 6, y: 13, color: '#468c25' },
            { x: 8, y: 14, color: '#2a5a15' }, { x: 11, y: 15, color: '#468c25' }
        ]);
        
        var matDirt = new THREE.MeshLambertMaterial({ map: dirtTexture });
        var matGrassTop = new THREE.MeshLambertMaterial({ map: grassTexture });
        var matStone = new THREE.MeshLambertMaterial({ map: stoneTexture });
        var matWoodSide = new THREE.MeshLambertMaterial({ map: woodSideTexture });
        var matWoodTop = new THREE.MeshLambertMaterial({ map: woodTopTexture });
        var matPlanks = new THREE.MeshLambertMaterial({ map: planksTexture });
        var matSand = new THREE.MeshLambertMaterial({ map: sandTexture });
        var matBedrock = new THREE.MeshLambertMaterial({ map: bedrockTexture });
        
        // NEW LEAVES MATERIAL with texture and transparency
        var matLeaves = new THREE.MeshLambertMaterial({ map: leavesTexture, transparent: true, opacity: 0.85 });
        
        // Glass Texture Pattern (light blue/white with frame only - more transparent)
        var glassTexture = createPixelTexture('rgba(200, 230, 255, 0.2)', [
            // White frame around edges only
            { x: 0, y: 0, w: 16, h: 1, color: '#ffffff' },  // Top
            { x: 0, y: 15, w: 16, h: 1, color: '#ffffff' }, // Bottom
            { x: 0, y: 0, w: 1, h: 16, color: '#ffffff' },  // Left
            { x: 15, y: 0, w: 1, h: 16, color: '#ffffff' }  // Right
            // Cross pattern removed for better transparency
        ]);
        var matGlass = new THREE.MeshLambertMaterial({ 
            map: glassTexture, 
            transparent: true, 
            opacity: 0.4,
            side: THREE.DoubleSide
        });
        
        // Door Texture Pattern (wooden door with planks)
        var doorTexture = createPixelTexture('#8b5a2b', [
            { x: 0, y: 0, w: 16, h: 1, color: '#6b4a1b' },  // Top edge
            { x: 0, y: 15, w: 16, h: 1, color: '#6b4a1b' }, // Bottom edge
            { x: 0, y: 0, w: 1, h: 16, color: '#6b4a1b' },  // Left edge
            { x: 15, y: 0, w: 1, h: 16, color: '#6b4a1b' }, // Right edge
            // Horizontal planks
            { x: 2, y: 2, w: 12, h: 1, color: '#734a1a' },
            { x: 2, y: 5, w: 12, h: 1, color: '#734a1a' },
            { x: 2, y: 8, w: 12, h: 1, color: '#734a1a' },
            { x: 2, y: 11, w: 12, h: 1, color: '#734a1a' },
            { x: 2, y: 14, w: 12, h: 1, color: '#734a1a' },
            // Door handle
            { x: 12, y: 7, w: 2, h: 2, color: '#444444' }
        ]);
        var matDoor = new THREE.MeshLambertMaterial({ 
            map: doorTexture,
            side: THREE.DoubleSide
        });
        
        // Torch Texture Pattern (proper Minecraft torch look)
        var torchTexture = createPixelTexture('#000000', [
            // Dark wooden stick (bottom 7 pixels)
            { x: 7, y: 0, w: 2, h: 7, color: '#5c3c1f' },
            { x: 6, y: 1, w: 1, h: 5, color: '#4a2f19' },
            { x: 9, y: 1, w: 1, h: 5, color: '#6b4423' },
            // Flame base (pixels 8-10)
            { x: 6, y: 7, w: 4, h: 1, color: '#ff8800' },
            { x: 5, y: 8, w: 6, h: 1, color: '#ffaa00' },
            { x: 6, y: 9, w: 4, h: 1, color: '#ffdd00' },
            // Bright flame tip (pixels 11-12)
            { x: 6, y: 10, w: 4, h: 2, color: '#ffffaa' },
            { x: 7, y: 12, w: 2, h: 2, color: '#ffff88' }
        ]);
        var matTorch = new THREE.MeshLambertMaterial({ 
            map: torchTexture,
            emissive: 0xffaa00,
            emissiveIntensity: 0.5
        });
        
        // Water Texture Pattern (blue/cyan with subtle waves)
        var waterTexture = createPixelTexture('#3a5fcd', [
            { x: 1, y: 1, color: '#4a6fdd' }, { x: 4, y: 2, color: '#5a7fed' }, { x: 7, y: 1, color: '#4a6fdd' },
            { x: 10, y: 3, color: '#6a8ffd' }, { x: 2, y: 5, color: '#4a6fdd' }, { x: 13, y: 4, color: '#5a7fed' },
            { x: 5, y: 7, color: '#6a8ffd' }, { x: 9, y: 8, color: '#4a6fdd' }, { x: 12, y: 9, color: '#5a7fed' },
            { x: 3, y: 11, color: '#6a8ffd' }, { x: 14, y: 12, color: '#4a6fdd' }, { x: 6, y: 13, color: '#5a7fed' }
        ]);
        waterTexture.wrapS = waterTexture.wrapT = THREE.RepeatWrapping; // Enable wrapping for animation
        var matWater = new THREE.MeshLambertMaterial({ 
            map: waterTexture,
            transparent: true,
            opacity: 0.6,
            depthWrite: false
        });
        
        // Lava Texture Pattern (orange/red with bright spots)
        var lavaTexture = createPixelTexture('#cc4400', [
            { x: 1, y: 1, color: '#ff6600' }, { x: 4, y: 2, color: '#ff8800' }, { x: 7, y: 1, color: '#dd5500' },
            { x: 10, y: 3, color: '#ffaa00' }, { x: 2, y: 5, color: '#dd5500' }, { x: 13, y: 4, color: '#ff6600' },
            { x: 5, y: 7, color: '#ff8800' }, { x: 9, y: 8, color: '#dd5500' }, { x: 12, y: 9, color: '#ffaa00' },
            { x: 3, y: 11, color: '#ff6600' }, { x: 14, y: 12, color: '#dd5500' }, { x: 6, y: 13, color: '#ff8800' },
            // Bright lava spots
            { x: 8, y: 5, color: '#ffdd00' }, { x: 11, y: 10, color: '#ffdd00' }, { x: 4, y: 14, color: '#ffdd00' }
        ]);
        lavaTexture.wrapS = lavaTexture.wrapT = THREE.RepeatWrapping; // Enable wrapping for animation
        var matLava = new THREE.MeshLambertMaterial({ 
            map: lavaTexture,
            transparent: true,
            opacity: 0.9,
            emissive: 0xff6600,
            emissiveIntensity: 0.7,
            depthWrite: false
        });

        mats[0] = [matDirt, matDirt, matGrassTop, matDirt, matDirt, matDirt];
        mats[1] = matDirt;
        mats[2] = matStone;
        mats[3] = [matWoodSide, matWoodSide, matWoodTop, matWoodTop, matWoodSide, matWoodSide]; // Wood with top/bottom rings
        mats[4] = matSand;
        mats[5] = matBedrock;
        mats[6] = matLeaves;
        mats[7] = matGlass;
        mats[8] = matDoor;
        mats[9] = matTorch;
        mats[10] = matWater;
        mats[11] = matLava;
        mats[12] = matPlanks; // Planks - horizontal wooden boards

        // --- World Data and Basic Functions ---
        var world = {}; 
        var bs = 2; // Block Size
        var ws = 40; // World Size (in chunks)
        var worldBorderEnabled = true; // World border setting (default enabled)
        // renderDistance, mouseSensitivity, fieldOfView are declared at top of script
        var sel = 0; // HUD selection index (0-7)

        function key(x, y, z) { return Math.round(x) + "," + Math.round(y) + "," + Math.round(z); }

        // Optimization: Reuse geometries and materials
        var blockGeometry = new THREE.BoxGeometry(bs, bs, bs);
        var doorGeometry = new THREE.BoxGeometry(bs * 0.25, bs * 2, bs); // Thin door, 2 blocks tall
        var torchGeometry = new THREE.BoxGeometry(bs * 0.125, bs * 0.625, bs * 0.125); // Minecraft-like torch: 2x10x2 pixels
        
        // --- FACE CULLING GEOMETRY BUILDER ---
        // Creates a box geometry with only visible faces (for water/lava/block face culling)
        function createCulledGeometry(x, y, z, blockType) {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const normals = [];
            const uvs = [];
            const indices = [];
            const groups = [];
            
            const half = bs / 2;
            let vertexCount = 0;
            
            // Define the 6 faces: right, left, top, bottom, front, back
            const faces = [
                { dir: [1, 0, 0], vertices: [[half, -half, -half], [half, half, -half], [half, half, half], [half, -half, half]], normal: [1, 0, 0] },  // Right (+X)
                { dir: [-1, 0, 0], vertices: [[-half, -half, half], [-half, half, half], [-half, half, -half], [-half, -half, -half]], normal: [-1, 0, 0] }, // Left (-X)
                { dir: [0, 1, 0], vertices: [[-half, half, -half], [-half, half, half], [half, half, half], [half, half, -half]], normal: [0, 1, 0] },   // Top (+Y)
                { dir: [0, -1, 0], vertices: [[-half, -half, -half], [half, -half, -half], [half, -half, half], [-half, -half, half]], normal: [0, -1, 0] }, // Bottom (-Y)
                { dir: [0, 0, 1], vertices: [[-half, -half, half], [half, -half, half], [half, half, half], [-half, half, half]], normal: [0, 0, 1] },   // Front (+Z)
                { dir: [0, 0, -1], vertices: [[half, -half, -half], [-half, -half, -half], [-half, half, -half], [half, half, -half]], normal: [0, 0, -1] }  // Back (-Z)
            ];
            
            // Check each face
            faces.forEach((face, faceIndex) => {
                const [dx, dy, dz] = face.dir;
                const neighborKey = key(x + dx, y + dy, z + dz);
                const neighborBlock = world[neighborKey];
                
                // Determine if this face should be culled
                let shouldCull = false;
                
                if (neighborBlock) {
                    const neighborType = neighborBlock.userData.blockType;
                    
                    // Never cull faces against doors
                    if (neighborBlock.userData.isDoor || neighborType === DOOR_TYPE) {
                        shouldCull = false;
                    } else {
                        // For transparent blocks, handle culling
                        const isCurrentTransparent = [WATER_TYPE, LAVA_TYPE, GLASS_TYPE].includes(blockType);
                        const isNeighborTransparent = [WATER_TYPE, LAVA_TYPE, GLASS_TYPE, LEAVES_TYPE, TORCH_TYPE, DOOR_TYPE].includes(neighborType);
                        
                        if (isCurrentTransparent) {
                            // Water culls with water, lava culls with lava (regardless of flow level)
                            if (blockType === WATER_TYPE && neighborType === WATER_TYPE) {
                                shouldCull = true;
                            } else if (blockType === LAVA_TYPE && neighborType === LAVA_TYPE) {
                                shouldCull = true;
                            } else if (blockType === neighborType) {
                                shouldCull = true;
                            }
                        } else if (!isNeighborTransparent) {
                            // Solid block next to solid block: cull
                            shouldCull = true;
                        }
                    }
                }
                
                // Add face if not culled
                if (!shouldCull) {
                    const startVertex = vertexCount;
                    
                    // UV coordinates for this face (standard texture mapping)
                    const faceUVs = [
                        [0, 0], [0, 1], [1, 1], [1, 0]
                    ];
                    
                    // Add vertices for this face
                    face.vertices.forEach((v, i) => {
                        vertices.push(...v);
                        normals.push(...face.normal);
                        uvs.push(...faceUVs[i]);
                    });
                    
                    // Add indices (two triangles per face)
                    indices.push(
                        startVertex, startVertex + 1, startVertex + 2,
                        startVertex, startVertex + 2, startVertex + 3
                    );
                    
                    // Add material group for this face
                    groups.push({
                        start: (startVertex / 4) * 6, // Each face has 6 indices (2 triangles)
                        count: 6,
                        materialIndex: faceIndex
                    });
                    
                    vertexCount += 4;
                }
            });
            
            // If no faces are visible, return null
            if (vertices.length === 0) return null;
            
            // Set attributes
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            geometry.setIndex(indices);
            
            // Set groups for multi-material
            groups.forEach(group => {
                geometry.addGroup(group.start, group.count, group.materialIndex);
            });
            
            geometry.computeBoundingSphere();
            
            return geometry;
        }
        
        // --- BLOCK OUTLINE ---
        const outlineGeometry = new THREE.EdgesGeometry(new THREE.BoxGeometry(bs + 0.02, bs + 0.02, bs + 0.02));
        const doorOutlineGeometry = new THREE.EdgesGeometry(new THREE.BoxGeometry(bs * 0.25 + 0.02, bs * 2 + 0.02, bs + 0.02));
        const outlineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
        const blockOutline = new THREE.LineSegments(outlineGeometry, outlineMaterial);
        blockOutline.visible = false;
        scene.add(blockOutline);
        
        // --- PARTICLE SYSTEM ---
        const particles = [];
        const particleGeometry = new THREE.PlaneGeometry(0.3, 0.3);
        
        function createBreakParticles(x, y, z, blockType) {
            const particleMaterial = mats[blockType];
            const mat = Array.isArray(particleMaterial) ? particleMaterial[0] : particleMaterial;
            
            for (let i = 0; i < 8; i++) {
                const particle = new THREE.Mesh(particleGeometry, mat.clone());
                particle.position.set(
                    x * bs + (Math.random() - 0.5) * bs,
                    y * bs + (Math.random() - 0.5) * bs,
                    z * bs + (Math.random() - 0.5) * bs
                );
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 5,
                    Math.random() * 8 + 2,
                    (Math.random() - 0.5) * 5
                );
                particle.lifetime = 1.0;
                scene.add(particle);
                particles.push(particle);
            }
        }
        
        // Helper function to check if a block position has a solid neighbor
        function hasSolidBlockAt(x, y, z) {
            var blockKey = key(x, y, z);
            var block = world[blockKey];
            if (!block) return false;
            
            var blockType = block.userData.blockType;
            // Transparent/non-solid blocks don't count as occluders
            if (blockType === GLASS_TYPE || blockType === LEAVES_TYPE || 
                blockType === WATER_TYPE || blockType === LAVA_TYPE || 
                blockType === TORCH_TYPE || blockType === DOOR_TYPE) {
                return false;
            }
            
            return true;
        }
        
        // Check if a block is completely surrounded by solid blocks (hidden face culling)
        function isBlockCompletelyHidden(x, y, z) {
            // Check all 6 neighbors
            return hasSolidBlockAt(x + 1, y, z) &&
                   hasSolidBlockAt(x - 1, y, z) &&
                   hasSolidBlockAt(x, y + 1, z) &&
                   hasSolidBlockAt(x, y - 1, z) &&
                   hasSolidBlockAt(x, y, z + 1) &&
                   hasSolidBlockAt(x, y, z - 1);
        }
        
        function add(x, y, z, t, facingAngle = 0) {
            var k = key(x, y, z);
            // Allow placing blocks through water or lava
            const existingBlock = world[k];
            if (existingBlock) {
                const existingType = existingBlock.userData.blockType;
                // If it's water or lava, allow block placement (replace liquid)
                if ((existingType === WATER_TYPE || existingType === LAVA_TYPE) && 
                    t !== WATER_TYPE && t !== LAVA_TYPE) {
                    scene.remove(existingBlock);
                    if (existingBlock.geometry) existingBlock.geometry.dispose();
                    delete world[k];
                } else {
                    return; // Can't place if occupied by non-liquid block
                }
            }
            
            var m = mats[t];
            var mesh;
            
            // Special handling for doors - single mesh spanning 2 blocks
            if (t === DOOR_TYPE) {
                // Check if there's space for 2 blocks tall (allow replacing liquids)
                var kAbove = key(x, y + 1, z);
                if (world[kAbove]) {
                    const above = world[kAbove];
                    const aboveType = above.userData.blockType;
                    const aboveIsLiquid = (aboveType === WATER_TYPE || aboveType === LAVA_TYPE);
                    if (aboveIsLiquid) {
                        scene.remove(above);
                        if (above.geometry) above.geometry.dispose();
                        delete world[kAbove];
                    } else {
                        return; // Occupied by non-liquid
                    }
                }
                
                // Create single mesh positioned between y and y+1
                const geom = doorGeometry.clone();
                mesh = new THREE.Mesh(geom, m);
                
                // Determine door rotation based on camera angle
                // Round to nearest 90-degree angle and rotate 90 so door faces the player
                const doorRotation = Math.round(facingAngle / (Math.PI / 2)) * (Math.PI / 2) + Math.PI / 2;
                
                // Position door at block center when closed (no offset)
                mesh.position.set(x * bs, y * bs + bs / 2, z * bs);
                mesh.rotation.y = doorRotation; // Set initial rotation based on placement angle
                
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.userData.blockType = t;
                mesh.userData.isDoor = true;
                mesh.userData.doorOpen = false;
                mesh.userData.doorBottomY = y; // Store bottom position
                mesh.userData.doorRotation = doorRotation; // Store initial rotation
                mesh.userData.baseX = x * bs; // Store base block position
                mesh.userData.baseZ = z * bs;
                scene.add(mesh);
                
                // Store in both block positions but pointing to same mesh
                world[k] = mesh;
                world[kAbove] = mesh;
                
                // Play place sound if not silent
                if (!mesh.userData.silentPlace) {
                    playPlaceSound(t);
                }
            } else if (t === TORCH_TYPE) {
                // Torch positioned at same height as normal blocks
                mesh = new THREE.Mesh(torchGeometry, m);
                mesh.position.set(x * bs, y * bs, z * bs);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.userData.blockType = t;
                mesh.userData.isTorch = true; // Flag for no collision
                scene.add(mesh);
                world[k] = mesh;
                
                // Add bright point light at torch position (optimized - no shadows for performance)
                var torchLight = new THREE.PointLight(0xffaa00, 2.0, 20); // Increased intensity and range
                torchLight.position.set(x * bs, y * bs + bs * 0.3, z * bs);
                torchLight.castShadow = false; // Disabled for performance - allows multiple torches
                scene.add(torchLight);
                mesh.userData.light = torchLight;
                
                // Play place sound if not silent
                if (!mesh.userData.silentPlace) {
                    playPlaceSound(t);
                }
            } else {
                // Regular block, water, or lava - use face culling
                // For water and lava, we want per-face culling
                // For solid blocks, we keep the existing full culling optimization
                
                if (t === WATER_TYPE || t === LAVA_TYPE) {
                    // Water and lava: use per-face culling
                    const culledGeometry = createCulledGeometry(x, y, z, t);
                    
                    if (culledGeometry) {
                        // Create mesh with culled geometry
                        mesh = new THREE.Mesh(culledGeometry, Array.isArray(m) ? m : [m, m, m, m, m, m]); 
                        mesh.position.set(x * bs, y * bs, z * bs);
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        mesh.userData.blockType = t;
                        scene.add(mesh);
                    } else {
                        // All faces culled - create placeholder
                        mesh = new THREE.Object3D();
                        mesh.position.set(x * bs, y * bs, z * bs);
                        mesh.userData.blockType = t;
                        mesh.userData.isHidden = true;
                    }
                } else {
                    // Solid blocks: check if completely hidden for optimization
                    var isHidden = isBlockCompletelyHidden(x, y, z);
                    
                    if (!isHidden) {
                        // Use per-face culling for solid blocks too
                        const culledGeometry = createCulledGeometry(x, y, z, t);
                        
                        if (culledGeometry) {
                            mesh = new THREE.Mesh(culledGeometry, Array.isArray(m) ? m : [m, m, m, m, m, m]); 
                            mesh.position.set(x * bs, y * bs, z * bs);
                            mesh.castShadow = true;
                            mesh.receiveShadow = true;
                            mesh.userData.blockType = t;
                            scene.add(mesh);
                        } else {
                            // All faces culled - create placeholder
                            mesh = new THREE.Object3D();
                            mesh.position.set(x * bs, y * bs, z * bs);
                            mesh.userData.blockType = t;
                            mesh.userData.isHidden = true;
                        }
                    } else {
                        // Block is completely hidden - create a minimal placeholder
                        mesh = new THREE.Object3D();
                        mesh.position.set(x * bs, y * bs, z * bs);
                        mesh.userData.blockType = t;
                        mesh.userData.isHidden = true;
                    }
                }
            }
            
            // Store in world (both visible and hidden blocks need to be tracked)
            world[k] = mesh;
            
            // After placing a block, refresh neighboring blocks' geometry (for face culling)
            refreshNeighborFaces(x, y, z);
            
            // After placing a block, check if any neighbors become completely hidden
            hideNeighbors(x, y, z);
            
            // Play place sound only when player places (not during world generation or grass spreading)
            if (locked && !paused && !mesh.userData.silentPlace && !mesh.userData.isHidden) {
                playPlaceSound(t);
            }
            
            // Water blocks are simple - no flow mechanics needed
        }
        
        // Function to refresh neighboring blocks' faces (for water/lava/block face culling)
        function refreshNeighborFaces(x, y, z) {
            const neighbors = [
                [x + 1, y, z], [x - 1, y, z],
                [x, y + 1, z], [x, y - 1, z],
                [x, y, z + 1], [x, y, z - 1]
            ];
            
            neighbors.forEach(([nx, ny, nz]) => {
                const nKey = key(nx, ny, nz);
                const neighborBlock = world[nKey];
                
                // If neighbor exists and is visible (has geometry)
                if (neighborBlock && neighborBlock.geometry) {
                    const blockType = neighborBlock.userData.blockType;
                    
                    // Skip doors and torches - they don't need face culling
                    if (blockType === DOOR_TYPE || blockType === TORCH_TYPE) return;
                    
                    // Regenerate geometry with updated face culling
                    const newGeometry = createCulledGeometry(nx, ny, nz, blockType);
                    const oldGeometry = neighborBlock.geometry;
                    
                    if (newGeometry) {
                        // Update to new culled geometry
                        neighborBlock.geometry = newGeometry;
                        oldGeometry.dispose();
                        
                        // Make sure it's visible
                        if (neighborBlock.userData.isHidden) {
                            scene.add(neighborBlock);
                            neighborBlock.userData.isHidden = false;
                        }
                    } else {
                        // All faces culled - hide the block
                        if (!neighborBlock.userData.isHidden) {
                            scene.remove(neighborBlock);
                            neighborBlock.userData.isHidden = true;
                        }
                        oldGeometry.dispose();
                    }
                }
            });
        }
        
        // Function to check and hide neighboring blocks that become completely surrounded
        function hideNeighbors(x, y, z) {
            const neighbors = [
                [x + 1, y, z], [x - 1, y, z],
                [x, y + 1, z], [x, y - 1, z],
                [x, y, z + 1], [x, y, z - 1]
            ];
            
            neighbors.forEach(([nx, ny, nz]) => {
                const nKey = key(nx, ny, nz);
                const neighborBlock = world[nKey];
                
                // If neighbor exists and is currently visible (not already hidden)
                if (neighborBlock && !neighborBlock.userData.isHidden && 
                    neighborBlock.userData.blockType !== DOOR_TYPE &&
                    neighborBlock.userData.blockType !== TORCH_TYPE) {
                    
                    // Check if it becomes completely hidden now
                    if (isBlockCompletelyHidden(nx, ny, nz)) {
                        const blockType = neighborBlock.userData.blockType;
                        
                        // Remove the visible mesh from scene
                        scene.remove(neighborBlock);
                        delete world[nKey];
                        
                        // Replace with invisible placeholder
                        const placeholder = new THREE.Object3D();
                        placeholder.position.set(nx * bs, ny * bs, nz * bs);
                        placeholder.userData.blockType = blockType;
                        placeholder.userData.isHidden = true;
                        world[nKey] = placeholder;
                    }
                }
            });
        }
        
        // --- LIQUID FLOW SYSTEM (Water & Lava) ---
        const MAX_FLOW_LEVEL = 7; // Source is 0, max flowing is 7
        
        function flowLiquids() {
            // Track all liquid blocks (both source and flowing)
            const liquidBlocks = [];
            
            for (const k in world) {
                const block = world[k];
                const blockType = block?.userData.blockType;
                if (blockType === WATER_TYPE || blockType === LAVA_TYPE) {
                    const [x, y, z] = k.split(',').map(Number);
                    const flowLevel = block.userData.flowLevel !== undefined ? block.userData.flowLevel : 0;
                    liquidBlocks.push({ x, y, z, type: blockType, flowLevel });
                }
            }
            
            // Process each liquid block
            const toAdd = [];
            const toCobblestone = [];
            
            for (const { x, y, z, type, flowLevel } of liquidBlocks) {
                // PRIORITY 1: Flow downward if possible (downward flow becomes source)
                const belowKey = key(x, y - 1, z);
                const belowBlock = world[belowKey];
                
                if (!belowBlock && y > 0) {
                    // Empty space below - flow down (becomes source at 0)
                    toAdd.push({ x, y: y - 1, z, type, flowLevel: 0 });
                    continue;
                }
                
                // PRIORITY 2: Flow horizontally if can't flow down
                // Stop flowing at MAX_FLOW_LEVEL
                if (flowLevel >= MAX_FLOW_LEVEL) {
                    continue; // Max flow distance reached
                }
                
                const horizontalDirections = [
                    [x + 1, y, z],
                    [x - 1, y, z],
                    [x, y, z + 1],
                    [x, y, z - 1]
                ];
                
                for (const [nx, ny, nz] of horizontalDirections) {
                    const nKey = key(nx, ny, nz);
                    const neighborBlock = world[nKey];
                    
                    // Check if space is empty
                    if (!neighborBlock) {
                        // Check if this position has a block below it (so liquid doesn't flow into air)
                        const supportKey = key(nx, ny - 1, nz);
                        const supportBlock = world[supportKey];
                        
                        if (supportBlock || ny === 0) {
                            // Has support or is at bedrock level - create flowing liquid
                            toAdd.push({ x: nx, y: ny, z: nz, type, flowLevel: flowLevel + 1 });
                        }
                    } else if (neighborBlock.userData.blockType === type) {
                        // If neighbor is same liquid type, update its flow level if ours is lower
                        const neighborFlowLevel = neighborBlock.userData.flowLevel !== undefined ? neighborBlock.userData.flowLevel : 0;
                        if (flowLevel + 1 < neighborFlowLevel) {
                            neighborBlock.userData.flowLevel = flowLevel + 1;
                        }
                    }
                    
                    // COBBLESTONE GENERATION: Check for water-lava interaction
                    if (type === WATER_TYPE && neighborBlock?.userData.blockType === LAVA_TYPE) {
                        // Water touches lava - create cobblestone
                        toCobblestone.push({ x: nx, y: ny, z: nz });
                    } else if (type === LAVA_TYPE && neighborBlock?.userData.blockType === WATER_TYPE) {
                        // Lava touches water - create cobblestone
                        toCobblestone.push({ x: nx, y: ny, z: nz });
                    }
                }
            }
            
            // Apply cobblestone generation first (replaces lava/water)
            const halfWorldSize = ws / 2;
            for (const { x, y, z } of toCobblestone) {
                if (x >= -halfWorldSize && x < halfWorldSize && 
                    z >= -halfWorldSize && z < halfWorldSize) {
                    // Remove existing liquid
                    const k = key(x, y, z);
                    if (world[k]) {
                        scene.remove(world[k]);
                        if (world[k].geometry) world[k].geometry.dispose();
                        delete world[k];
                    }
                    // Place cobblestone
                    add(x, y, z, COBBLESTONE_TYPE);
                }
            }
            
            // Then add new flowing liquid blocks
            for (const { x, y, z, type, flowLevel } of toAdd) {
                if (x >= -halfWorldSize && x < halfWorldSize && 
                    z >= -halfWorldSize && z < halfWorldSize) {
                    const k = key(x, y, z);
                    if (!world[k]) { // Only add if still empty
                        add(x, y, z, type);
                        // Set flow level on the newly created block
                        if (world[k]) {
                            world[k].userData.flowLevel = flowLevel;
                        }
                    }
                }
            }
        }
        
        // Function to remove all flowing liquid blocks connected to a removed liquid source
        function removeConnectedFlowingLiquid(x, y, z, liquidType) {
            // Get all liquid blocks of the same type
            const allLiquidBlocks = [];
            for (const k in world) {
                const block = world[k];
                const blockType = block?.userData.blockType;
                if (blockType === liquidType) {
                    const [bx, by, bz] = k.split(',').map(Number);
                    const flowLevel = block.userData.flowLevel !== undefined ? block.userData.flowLevel : 0;
                    allLiquidBlocks.push({ x: bx, y: by, z: bz, flowLevel, key: k });
                }
            }
            
            // Remove the destroyed block from the list
            const destroyedKey = key(x, y, z);
            const remainingBlocks = allLiquidBlocks.filter(b => b.key !== destroyedKey);
            
            // Find all source blocks (flowLevel === 0)
            const sourceBlocks = remainingBlocks.filter(b => b.flowLevel === 0);
            
            // If no source blocks remain, remove all liquid blocks
            if (sourceBlocks.length === 0) {
                for (const block of remainingBlocks) {
                    const k = block.key;
                    if (world[k]) {
                        scene.remove(world[k]);
                        if (world[k].geometry) world[k].geometry.dispose();
                        delete world[k];
                    }
                }
                return;
            }
            
            // Mark all blocks reachable from source blocks using BFS
            const reachable = new Set();
            const queue = [...sourceBlocks];
            
            for (const source of sourceBlocks) {
                reachable.add(source.key);
            }
            
            while (queue.length > 0) {
                const current = queue.shift();
                
                // Check all neighbors
                const neighbors = [
                    [current.x + 1, current.y, current.z],
                    [current.x - 1, current.y, current.z],
                    [current.x, current.y + 1, current.z],
                    [current.x, current.y - 1, current.z],
                    [current.x, current.y, current.z + 1],
                    [current.x, current.y, current.z - 1]
                ];
                
                for (const [nx, ny, nz] of neighbors) {
                    const nKey = key(nx, ny, nz);
                    const neighborBlock = world[nKey];
                    
                    if (neighborBlock && 
                        neighborBlock.userData.blockType === liquidType && 
                        !reachable.has(nKey)) {
                        reachable.add(nKey);
                        const neighborFlowLevel = neighborBlock.userData.flowLevel !== undefined ? neighborBlock.userData.flowLevel : 0;
                        queue.push({ x: nx, y: ny, z: nz, flowLevel: neighborFlowLevel, key: nKey });
                    }
                }
            }
            
            // Remove all liquid blocks that are NOT reachable from any source
            for (const block of remainingBlocks) {
                if (!reachable.has(block.key)) {
                    const k = block.key;
                    if (world[k]) {
                        scene.remove(world[k]);
                        if (world[k].geometry) world[k].geometry.dispose();
                        delete world[k];
                    }
                }
            }
        }

        function remove(x, y, z) {
            var k = key(x, y, z);
            if (world[k]) {
                const blockType = world[k].userData.blockType; 
                const mesh = world[k];
                
                // --- Bedrock Indestructibility Check ---
                // MODIFIED: Only indestructible in Survival mode
                if (blockType === BEDROCK_TYPE && !isCreativeMode) {
                     console.log("Bedrock cannot be destroyed in Survival Mode.");
                     return; 
                }
                
                // --- Water Indestructibility Check ---
                // Water can be destroyed in creative mode
                if (blockType === WATER_TYPE && !isCreativeMode) {
                     console.log("Water cannot be destroyed in survival mode.");
                     return;
                }
                
                // --- Remove Connected Flowing Water ---
                // If we're removing water or lava, clear dependent flowing blocks
                if (blockType === WATER_TYPE || blockType === LAVA_TYPE) {
                    removeConnectedFlowingLiquid(x, y, z, blockType);
                }
                // -------------------------------------------

                // Special handling for doors - remove both blocks
                if (blockType === DOOR_TYPE) {
                    const doorBottomY = mesh.userData.doorBottomY;
                    const kBottom = key(x, doorBottomY, z);
                    const kTop = key(x, doorBottomY + 1, z);
                    
                    // Create break particles at door position
                    createBreakParticles(x, doorBottomY, z, blockType);
                    playBreakSound(blockType);
                    
                    // Remove from scene and world
                    scene.remove(mesh);
                    delete world[kBottom];
                    delete world[kTop];
                    
                    // Add to inventory only if using correct tool or in creative
                    if (shouldDropBlock(blockType)) {
                        addToInventory(DOOR_TYPE, 1);
                    }
                    return;
                }
                
                // Special handling for torch - remove light
                if (blockType === TORCH_TYPE && mesh.userData.light) {
                    scene.remove(mesh.userData.light);
                }

                // Create break particles
                createBreakParticles(x, y, z, blockType);
                
                // Play breaking sound with block type
                playBreakSound(blockType);

                scene.remove(mesh);
                delete world[k];
                
                // Refresh neighboring blocks' faces (for water/lava/block face culling)
                refreshNeighborFaces(x, y, z);
                
                // Reveal neighboring blocks that may have been hidden
                revealNeighbors(x, y, z);
                
                // MODIFIED: Grass (type 0) drops Dirt (type 1)
                const dropType = (blockType === GRASS_TYPE) ? DIRT_TYPE : blockType; 

                // Only add to inventory if block should drop (correct tool used)
                // Grass and leaves always drop regardless of tool
                if (blockType === GRASS_TYPE || blockType === LEAVES_TYPE || shouldDropBlock(blockType)) {
                    addToInventory(dropType, 1);
                }
                
                // Water auto-fill will handle gaps
            }
        }
        
        // Function to check and reveal hidden neighboring blocks when a block is removed
        function revealNeighbors(x, y, z) {
            const neighbors = [
                [x + 1, y, z], [x - 1, y, z],
                [x, y + 1, z], [x, y - 1, z],
                [x, y, z + 1], [x, y, z - 1]
            ];
            
            neighbors.forEach(([nx, ny, nz]) => {
                const nKey = key(nx, ny, nz);
                const neighborBlock = world[nKey];
                
                // If neighbor exists and is marked as hidden
                if (neighborBlock && neighborBlock.userData.isHidden) {
                    const blockType = neighborBlock.userData.blockType;
                    
                    // Check if it's still completely hidden
                    if (!isBlockCompletelyHidden(nx, ny, nz)) {
                        // No longer hidden - need to render it with face culling
                        scene.remove(neighborBlock); // Remove placeholder
                        delete world[nKey];
                        
                        // Add it back as a visible block with culled geometry
                        const m = mats[blockType];
                        const culledGeometry = createCulledGeometry(nx, ny, nz, blockType);
                        
                        if (culledGeometry) {
                            const newMesh = new THREE.Mesh(culledGeometry, Array.isArray(m) ? m : [m, m, m, m, m, m]);
                            newMesh.position.set(nx * bs, ny * bs, nz * bs);
                            newMesh.castShadow = true;
                            newMesh.receiveShadow = true;
                            newMesh.userData.blockType = blockType;
                            scene.add(newMesh);
                            world[nKey] = newMesh;
                        } else {
                            // All faces still culled - keep as placeholder
                            const placeholder = new THREE.Object3D();
                            placeholder.position.set(nx * bs, ny * bs, nz * bs);
                            placeholder.userData.blockType = blockType;
                            placeholder.userData.isHidden = true;
                            world[nKey] = placeholder;
                        }
                    }
                }
            });
        }
        
        // Toggle door open/closed state (no animation - instant like Minecraft)
        function toggleDoor(x, y, z) {
            var k = key(x, y, z);
            var mesh = world[k];
            
            if (!mesh || mesh.userData.blockType !== DOOR_TYPE) return;
            
            // Toggle door state instantly
            const currentlyOpen = mesh.userData.doorOpen;
            mesh.userData.doorOpen = !currentlyOpen;
            
            // Get stored initial rotation and base position
            const initialRotation = mesh.userData.doorRotation;
            const baseX = mesh.userData.baseX;
            const baseZ = mesh.userData.baseZ;
            
            if (currentlyOpen) {
                // Closing door - return to block center position
                mesh.rotation.y = initialRotation;
                mesh.position.x = baseX;
                mesh.position.z = baseZ;
            } else {
                // Opening door - rotate 90 degrees (no position change)
                mesh.rotation.y = initialRotation + Math.PI / 2;
                mesh.position.x = baseX;
                mesh.position.z = baseZ;
            }
            
            // Play door sound
            playPlaceSound(WOOD_TYPE); // Use wood sound for door
        }

        // Helper function for collision check
        function isBlockPresent(x, y, z) {
            var tx = Math.round(x / bs);
            var ty = Math.round(y / bs); 
            var tz = Math.round(z / bs);
            var block = world[key(tx, ty, tz)];
            
            if (!block) return false;
            
            // Return false for torches (no collision)
            if (block.userData.isTorch) {
                return false;
            }
            
            // Return false for water and lava (no collision - can swim through)
            const blockType = block.userData.blockType;
            if (blockType === WATER_TYPE || blockType === LAVA_TYPE) {
                return false;
            }
            
            // Return false for open doors (no collision)
            if (block.userData.blockType === DOOR_TYPE && block.userData.doorOpen) {
                return false;
            }
            
            return true;
        }
        
        function generateWorld() {
             // Optimization: More efficient cleanup - don't dispose shared geometry
             for(var k in world) { 
                scene.remove(world[k]); 
             }
            world = {};
            
            if (isFlatWorld) {
                // --- FLAT WORLD GENERATION ---
                for (var x = -ws / 2; x < ws / 2; x++) {
                    for (var z = -ws / 2; z < ws / 2; z++) {
                        add(x, 0, z, BEDROCK_TYPE); // Bedrock at Y=0
                        add(x, 1, z, 2); // Stone at Y=1
                        add(x, 2, z, DIRT_TYPE); // Dirt at Y=2
                        add(x, 3, z, GRASS_TYPE); // Grass at Y=3
                    }
                }
                return; // Exit early for flat world
            }
            
            // Optimization: Pre-calculate noise values
            var noiseMap = {};
            for (var x = -ws / 2; x < ws / 2; x++) {
                for (var z = -ws / 2; z < ws / 2; z++) {
                    var seededX = x + WORLD_SEED / 100;
                    var seededZ = z + WORLD_SEED / 100;
                    
                    // Enhanced terrain generation with biomes
                    var baseHeight = Math.floor(
                        Math.sin(seededX * 0.1) * Math.cos(seededZ * 0.1) * 2 + 
                        Math.sin(seededX * 0.3) * 1.5 + 
                        Math.cos(seededZ * 0.2) * 1.5 + 
                        4
                    );
                    
                    // Biome determination (using noise for variation)
                    var biomeNoise = Math.sin(seededX * 0.05) * Math.cos(seededZ * 0.05);
                    var moistureNoise = Math.sin(seededX * 0.08) * Math.sin(seededZ * 0.08);
                    
                    // Store height and biome data
                    noiseMap[x + ',' + z] = {
                        height: baseHeight,
                        biome: biomeNoise,
                        moisture: moistureNoise
                    };
                }
            }
            
            // Generate terrain using pre-calculated noise
            for (var x = -ws / 2; x < ws / 2; x++) {
                for (var z = -ws / 2; z < ws / 2; z++) {
                    var data = noiseMap[x + ',' + z];
                    var h = data.height;
                    var biome = data.biome;
                    var moisture = data.moisture;
                    
                    // 1. ADD BEDROCK at Y=0 (type 5)
                    add(x, 0, z, BEDROCK_TYPE); 

                    // 2. Generate terrain from Y=1 up to h+1 with biome-specific blocks
                    for (var y = 1; y < h + 1; y++) { 
                        var bt = 2; // Default is Stone
                        
                        // Determine surface block based on biome
                        if (y === h) { 
                            // Desert/Beach biome (sand) - dry and low areas
                            if (biome > 0.3 && moisture < -0.2) {
                                bt = 4; // Sand
                            }
                            // Water-adjacent areas (beaches)
                            else if (h <= 3) {
                                bt = 4; // Sand at water level
                            }
                            // Normal grass
                            else {
                                bt = 0; // Grass
                            }
                        } 
                        // Subsurface layers
                        else if (y >= h - 2) {
                            // Sand continues deeper in desert biomes
                            if (biome > 0.3 && moisture < -0.2) {
                                bt = 4; // Sand
                            } else {
                                bt = 1; // Dirt
                            }
                        }
                        // Deep layers are stone
                        
                        add(x, y, z, bt); 
                    }

                    // 3. Tree Generation (only on grass, not sand)
                    var topBlockType = (biome > 0.3 && moisture < -0.2) || h <= 3 ? 4 : 0;
                    if (topBlockType === 0 && h >= 5 && Math.random() < 0.02) { 
                        generateTree(x, h + 1, z);
                    }
                }
            }
            
            // 4. REALISTIC WATER & LAVA GENERATION (Seas and Puddles only - NO water on grass)
            
            // Define water level (sea level)
            var SEA_LEVEL = 4;
            
            // First pass: Create oceans and seas by filling low-lying areas
            for (var x = -ws / 2; x < ws / 2; x++) {
                for (var z = -ws / 2; z < ws / 2; z++) {
                    var data = noiseMap[x + ',' + z];
                    var h = data.height;
                    var biome = data.biome;
                    var moisture = data.moisture;
                    
                    // Create ocean/sea if terrain is below sea level
                    if (h < SEA_LEVEL) {
                        // Fill with water above terrain up to sea level
                        for (var y = h + 1; y <= SEA_LEVEL; y++) {
                            add(x, y, z, WATER_TYPE);
                        }
                    }
                }
            }
            
            // Second pass: Create underground water puddles ONLY
            for (var x = -ws / 2; x < ws / 2; x++) {
                for (var z = -ws / 2; z < ws / 2; z++) {
                    var data = noiseMap[x + ',' + z];
                    var h = data.height;
                    var biome = data.biome;
                    
                    // Skip if already underwater (in ocean)
                    if (h < SEA_LEVEL) continue;
                    
                    var isSandBiome = (biome > 0.3 && data.moisture < -0.2);
                    
                    // Small water puddles underground in wet areas (NOT on surface)
                    if (!isSandBiome && data.moisture > 0.2 && h >= 4 && Math.random() < 0.002) {
                        var puddleDepth = Math.floor(Math.random() * 2) + 2; // 2-3 blocks underground
                        var puddleKey = key(x, h - puddleDepth, z);
                        // Only place puddle if there's a solid block there to replace
                        if (world[puddleKey]) {
                            remove(x, h - puddleDepth, z);
                            add(x, h - puddleDepth, z, WATER_TYPE);
                        }
                    }
                    
                    // Lava pools in desert biomes (underground)
                    if (isSandBiome && Math.random() < 0.001 && h >= 3) {
                        var lavaDepth = Math.floor(Math.random() * 2) + 2;
                        var lavaKey = key(x, h - lavaDepth, z);
                        if (world[lavaKey]) {
                            remove(x, h - lavaDepth, z);
                            add(x, h - lavaDepth, z, LAVA_TYPE);
                        }
                    }
                    
                    // Rare underground lava pockets (deep)
                    if (Math.random() < 0.0005 && h >= 5) {
                        var deepLavaDepth = Math.floor(Math.random() * 3) + 3;
                        var deepLavaKey = key(x, h - deepLavaDepth, z);
                        if (world[deepLavaKey]) {
                            remove(x, h - deepLavaDepth, z);
                            add(x, h - deepLavaDepth, z, LAVA_TYPE);
                        }
                    }
                }
            }
        }

        // --- Player/Movement variables ---
        var px = 0; var py = 20; var pz = 0; 
        var vx = 0; var vy = 0; var vz = 0; 
        var rx = 0; var ry = 0; 
        var ground = false;
        var keys = {};
        var locked = false;
        var paused = false; 
        var inventoryOpen = false;
        
        // --- Keybind System (defined at top of script) ---
        let waitingForKey = null;
        
        // --- FLYING VARS ---
        let isFlying = false; 
        let lastSpacePress = 0;
        let spaceHeld = false; // NEW: Track if space is held
        const DOUBLE_PRESS_TIME = 300; // ms
        // -------------------------
        
        // --- OXYGEN/BREATHING VARS ---
        let maxOxygen = 10; // Maximum oxygen (10 bubbles)
        let currentOxygen = maxOxygen; // Current oxygen level
        let isUnderwater = false; // Track if player is underwater
        const oxygenDepletionRate = 1; // Oxygen lost per second underwater (1 bubble per second)
        const oxygenRegenRate = 5; // Oxygen gained per second when not underwater (fast regen)
        const drownDamageRate = 2; // Damage per second when out of oxygen
        let drownDamageTimer = 0; // Timer for drowning damage
        const drownDamageInterval = 1.0; // Take damage every 1 second when drowning
        // -------------------------
        
        // --- HEALTH SYSTEM VARS ---
        let maxHealth = 20; // Maximum health (10 hearts = 20 half-hearts)
        let currentHealth = maxHealth; // Current health level
        let isDead = false; // Track if player is dead
        
        // --- LAVA DAMAGE SYSTEM ---
        let isInLava = false; // Track if player is in lava
        let lavaDamageTimer = 0; // Timer for lava damage
        const lavaDamageInterval = 0.5; // Take damage every 0.5 seconds in lava
        const lavaDamageAmount = 4; // 2 hearts of damage per tick (4 half-hearts)
        
        // --- FALL DAMAGE SYSTEM ---
        let fallStartY = 0; // Y position when player started falling
        let wasFalling = false; // Track if player was falling last frame
        const SAFE_FALL_DISTANCE = 3; // Blocks fallen before taking damage (3 blocks = safe)
        const FALL_DAMAGE_MULTIPLIER = 1; // Damage per block fallen beyond safe distance (1 heart per block)
        // -------------------------
        
        // --- Player Size Constants (1.8 blocks tall - Minecraft standard) ---
        var PLAYER_TOTAL_HEIGHT = bs * 1.8; // Total player height (1.8 blocks)
        var EYE_HEIGHT = bs * 1.62; // Camera eye height from feet (1.62 blocks from feet)
        var PLAYER_HEIGHT = PLAYER_TOTAL_HEIGHT; // For collision detection
        var PLAYER_RADIUS = bs * 0.3; // Player is 0.6 blocks wide (matches Minecraft)

        var pauseMenu = document.getElementById('pause-menu'); 
        var inventoryScreen = document.getElementById('inventory-screen'); 
        var uiElement = document.getElementById('ui'); 
        var settingsSeedInput = document.getElementById('settingsSeedInput'); 
        var settingsSeedInputStart = document.getElementById('settingsSeedInputStart'); 

        // --- NEW COOLDOWN VARIABLES ---
        const COOLDOWN_TIME_MS = 2000; // 2 seconds
        let isCooldownActive = false;
        const continueGameButton = document.getElementById('main-menu-btn-pause');
        
        // Respawn button cooldown variables
        let isRespawnCooldownActive = false;
        const respawnButton = document.getElementById('respawn-btn');
        
        // Track if buttons have been clicked to skip countdown
        let pauseMenuButtonsClicked = false;
        // --- END NEW COOLDOWN VARIABLES ---


        function resetPlayer() {
            px = 0; py = 20; pz = 0; vx = 0; vy = 0; vz = 0; rx = 0; ry = 0; 
            // Player height is constant at 2 blocks
            PLAYER_HEIGHT = PLAYER_TOTAL_HEIGHT; 
            camera.position.set(px, py, pz);
            camera.rotation.set(rx, ry, 0, 'YXZ');
            ground = false;
            
            // Reset oxygen to full
            currentOxygen = maxOxygen;
            isUnderwater = false;
            drownDamageTimer = 0;
            
            // Reset health to full
            currentHealth = maxHealth;
            isDead = false;
            
            // Reset lava damage
            isInLava = false;
            lavaDamageTimer = 0;
            
            // Reset fall damage tracking
            fallStartY = py;
            wasFalling = false;
            
            // Clear inventory in survival mode
            if (!isCreativeMode) {
                inventoryData = Array(TOTAL_SLOTS).fill(null);
                updateInventoryUI();
                updateToolbarSelection();
            }
            
            // Reset game modes
            // isCreativeMode is preserved across respawns (Fix for user request)
            isFlying = false;
            
            // Hide death screen
            document.getElementById('death-screen').style.display = 'none';
        }
        resetPlayer(); 

        
        // --- Health & Oxygen UI Update Functions ---
        function updateHealthUI() {
            const healthContainer = document.getElementById('health-container');
            if (!isCreativeMode) {
                healthContainer.style.display = 'block';
                healthContainer.innerHTML = '';
                
                const numHearts = 10; // Total 10 hearts (20 health points)
                for (let i = 0; i < numHearts; i++) {
                    const heart = document.createElement('span');
                    heart.className = 'heart';
                    
                    const heartValue = (i + 1) * 2; // Each heart represents 2 health
                    
                    if (currentHealth >= heartValue) {
                        // Full heart
                        heart.classList.add('full');
                    } else if (currentHealth >= heartValue - 1) {
                        // Half heart
                        heart.classList.add('half');
                    } else {
                        // Empty heart
                        heart.classList.add('empty');
                    }
                    
                    // Add low health animation
                    if (currentHealth <= 6) {
                        heart.classList.add('low');
                    }
                    
                    healthContainer.appendChild(heart);
                }
            } else {
                healthContainer.style.display = 'none';
            }
        }
        
        function updateOxygenUI() {
            const oxygenContainer = document.getElementById('oxygen-container');
            if (!isCreativeMode && (isUnderwater || currentOxygen < maxOxygen)) {
                oxygenContainer.style.display = 'block';
                oxygenContainer.innerHTML = '';
                
                const numBubbles = 10; // Total 10 bubbles
                for (let i = 0; i < numBubbles; i++) {
                    const bubble = document.createElement('span');
                    bubble.className = 'bubble';
                    
                    if (currentOxygen < (i + 1)) {
                        // Popped bubble
                        bubble.classList.add('popped');
                    }
                    
                    oxygenContainer.appendChild(bubble);
                }
            } else {
                oxygenContainer.style.display = 'none';
            }
        }
        
        function takeDamage(amount) {
            if (isCreativeMode || isDead) return;
            
            currentHealth = Math.max(0, currentHealth - amount);
            updateHealthUI();
            
            // Play damage sound
            playDamageSound();
            
            // Damage visual effects
            applyDamageEffects(amount);
            
            if (currentHealth <= 0) {
                playerDeath();
            }
        }
        
        // Damage visual effects: red flash and camera shake
        function applyDamageEffects(damageAmount) {
            // Create red damage overlay
            let damageOverlay = document.getElementById('damage-overlay');
            if (!damageOverlay) {
                damageOverlay = document.createElement('div');
                damageOverlay.id = 'damage-overlay';
                damageOverlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: radial-gradient(circle, transparent 40%, rgba(255, 0, 0, 0.4) 100%);
                    pointer-events: none;
                    z-index: 9999;
                    opacity: 0;
                    transition: opacity 0.05s ease-out;
                `;
                document.body.appendChild(damageOverlay);
            }
            
            // Flash red based on damage amount
            const intensity = Math.min(damageAmount / 20, 1); // Scale with damage
            damageOverlay.style.opacity = intensity;
            
            // Fade out
            setTimeout(() => {
                damageOverlay.style.opacity = '0';
            }, 100);
            
            // Camera shake effect
            const shakeIntensity = Math.min(damageAmount * 0.02, 0.3);
            const shakeDuration = 200 + damageAmount * 10; // Longer shake for more damage
            applyCameraShake(shakeIntensity, shakeDuration);
        }
        
        // Camera shake implementation
        let isShaking = false;
        let shakeOffset = { x: 0, y: 0, z: 0 };
        
        function applyCameraShake(intensity, duration) {
            if (isShaking) return; // Prevent multiple shakes
            
            isShaking = true;
            const startTime = Date.now();
            const originalRx = rx;
            
            function shake() {
                const elapsed = Date.now() - startTime;
                if (elapsed > duration) {
                    isShaking = false;
                    shakeOffset = { x: 0, y: 0, z: 0 };
                    return;
                }
                
                // Decay intensity over time
                const progress = elapsed / duration;
                const currentIntensity = intensity * (1 - progress);
                
                // Random shake offset
                shakeOffset.x = (Math.random() - 0.5) * currentIntensity;
                shakeOffset.y = (Math.random() - 0.5) * currentIntensity;
                shakeOffset.z = (Math.random() - 0.5) * currentIntensity;
                
                requestAnimationFrame(shake);
            }
            
            shake();
        }
        
        function playerDeath() {
            isDead = true;
            paused = true;
            
            // Exit pointer lock
            if (document.exitPointerLock) {
                document.exitPointerLock();
            }
            locked = false;
            
            // Hide crosshair, show death screen
            const crosshair = document.getElementById('crosshair');
            const deathScreen = document.getElementById('death-screen');
            const deathScore = document.getElementById('death-score');
            if (crosshair) crosshair.style.display = 'none';
            if (deathScreen) deathScreen.style.display = 'flex';
            
            // Calculate score
            const score = Math.floor((Date.now() - (window.gameStartTime || Date.now())) / 1000);
            if (deathScore) deathScore.textContent = score + ' seconds survived';
            
            // Stop player movement
            vx = 0;
            vy = 0;
            vz = 0;
        }


        
        // --- Game Mode Toggle Functions ---
        function updateGameModeButtonText() {
            if (gameModeToggleBtn) {
                gameModeToggleBtn.textContent = isCreativeMode ? 'Switch to Survival' : 'Switch to Creative';
            }
        }

        function toggleGameMode() {
            isCreativeMode = !isCreativeMode;
            
            if (isCreativeMode) {
                isFlying = false; // Disable flying when switching (will be re-enabled on double-space if desired)
            } else {
                isFlying = false; // MUST disable flying when switching to survival
            }
            
            updateGameModeButtonText();
            inventoryScreen.classList.toggle('creative-mode', isCreativeMode);
            
            // Refresh inventories to show/hide ''
            updateInventoryUI();
            updateToolbarSelection();
        }

        // --- Inventory Toggle Function ---
        function toggleInventory() {
            if (!locked) return; 
            inventoryOpen = !inventoryOpen;
            // Game no longer pauses when inventory is open - player just can't move/interact

            if (inventoryOpen) {
                inventoryScreen.style.display = 'flex';
                // Set class based on current game mode
                inventoryScreen.classList.toggle('creative-mode', isCreativeMode);
                updateGameModeButtonText(); // Update button text
                
                // Add animation class
                inventoryScreen.classList.remove('inventory-animate');
                setTimeout(() => {
                    inventoryScreen.classList.add('inventory-animate');
                }, 10);
                
                // Hide HUD elements when inventory is open
                document.getElementById('crosshair').style.display = 'none';
                document.getElementById('toolbar').style.display = 'none';
                document.getElementById('health-container').style.display = 'none';
                document.getElementById('oxygen-container').style.display = 'none';
                document.getElementById('fps').style.display = 'none';
                if (uiElement) uiElement.style.display = 'none';
                const debugInfoElement = document.getElementById('debug-info');
                if (debugInfoElement) debugInfoElement.style.display = 'none';
                
                // NEW: Show and reset fake cursor (will be centered by CSS transform)
                fakeCursorElement.style.display = 'block';
                fakeCursorX = window.innerWidth / 2;
                fakeCursorY = window.innerHeight / 2;
                fakeCursorElement.style.left = fakeCursorX + 'px';
                fakeCursorElement.style.top = fakeCursorY + 'px';
                
                // Initialize picked-up item position to match cursor
                if (pickedUpItemElement) {
                    pickedUpItemElement.style.left = fakeCursorX + 'px';
                    pickedUpItemElement.style.top = fakeCursorY + 'px';
                }
                
                // Initialize crafting UI and category tabs
                initCraftingUI();
                generateBlockPicker(currentCategory);
                initCategoryTabs();
                
                updateInventoryUI();
            } else {
                inventoryScreen.style.display = 'none';
                inventoryScreen.classList.remove('inventory-animate');
                
                // Show HUD elements when closing inventory
                document.getElementById('crosshair').style.display = 'block';
                document.getElementById('toolbar').style.display = 'flex';
                if (!isCreativeMode) {
                    document.getElementById('health-container').style.display = 'block';
                    document.getElementById('oxygen-container').style.display = 'block';
                }
                // Respect FPS and UI visibility settings
                const fpsElement = document.getElementById('fps');
                if (fpsElement) {
                    // Show FPS only when in game and setting is enabled
                    fpsElement.style.display = (fpsAlwaysVisible && currentGameState === GAME_STATE.IN_GAME) || showHitbox ? 'block' : 'none';
                }
                if (uiElement) {
                    uiElement.style.display = showHitbox ? 'block' : 'none';
                }
                const debugInfoElement = document.getElementById('debug-info');
                if (debugInfoElement) {
                    debugInfoElement.style.display = showHitbox ? 'block' : 'none';
                }
                
                // NEW: Hide fake cursor
                fakeCursorElement.style.display = 'none';
                
                // Return crafting grid items to inventory
                craftingGrid.forEach(item => {
                    if (item && !isCreativeMode) {
                        addToInventory(item.type, item.count);
                    }
                });
                craftingGrid = Array(9).fill(null);
                
                // When closing inventory, drop the item being held to prevent loss
                if (pickedUpItem) {
                    if (!isCreativeMode) {
                        // Add back to inventory in survival
                        addToInventory(pickedUpItem.type, pickedUpItem.count);
                    }
                    // In creative, item just disappears
                    pickedUpItem = null;
                }
                // NEW: Update UI to hide pickedUpItemElement when closing
                updateInventoryUI();
            }
            updateToolbarSelection();
        }
        
        // --- MODIFIED: Toggle Pause Function to handle cooldown ---
        function togglePause() {
            // Only allow unpausing if cooldown is not active
            if (!paused && isCooldownActive) return; 

            paused = !paused;
            if (!paused) {
                // Resume game: Request pointer lock
                setGameState(GAME_STATE.IN_GAME);
                
                requestLock(renderer.domElement);
                pauseMenu.style.display = 'none';
                // Music continues playing during gameplay
                
                // Show ALL HUD elements when resuming game
                document.getElementById('crosshair').style.display = 'block';
                document.getElementById('toolbar').style.display = 'flex';
                if (!isCreativeMode) {
                    document.getElementById('health-container').style.display = 'block';
                    document.getElementById('oxygen-container').style.display = 'block';
                }
                // Respect FPS and UI visibility settings
                const fpsElement = document.getElementById('fps');
                if (fpsElement) {
                    // Show FPS only when in game and setting is enabled
                    fpsElement.style.display = (fpsAlwaysVisible && currentGameState === GAME_STATE.IN_GAME) || showHitbox ? 'block' : 'none';
                }
                if (uiElement) {
                    uiElement.style.display = showHitbox ? 'block' : 'none';
                }
                const debugInfoElement = document.getElementById('debug-info');
                if (debugInfoElement) {
                    debugInfoElement.style.display = showHitbox ? 'block' : 'none';
                }
                
                // Reset button text (ESC no longer works to close pause menu)
                continueGameButton.textContent = 'CONTINUE GAME';
            } else {
                // Pause game: Exit pointer lock
                document.exitPointerLock();
                showPauseMenu();
            }
        }
        
        function showPauseMenu() {
            // Set game state to pause menu
            setGameState(GAME_STATE.PAUSE_MENU);
            
            // Only pause if inventory wasn't open
            if (!inventoryOpen) {
                paused = true;
            }
            inventoryOpen = false;
            inventoryScreen.style.display = 'none'; 
            pauseMenu.style.display = 'flex';
            
            // Add animation class (same as inventory)
            pauseMenu.classList.remove('inventory-animate');
            setTimeout(() => {
                pauseMenu.classList.add('inventory-animate');
            }, 10);
            
            startBackgroundMusic(); // Start music when paused
            
            // Hide ALL HUD elements when menu is open
            document.getElementById('crosshair').style.display = 'none';
            document.getElementById('toolbar').style.display = 'none';
            document.getElementById('health-container').style.display = 'none';
            document.getElementById('oxygen-container').style.display = 'none';
            document.getElementById('fps').style.display = 'none';
            if (uiElement) uiElement.style.display = 'none';
            const debugInfoElement = document.getElementById('debug-info');
            if (debugInfoElement) debugInfoElement.style.display = 'none';
            
            // NEW: Hide fake cursor if it was open
            if (fakeCursorElement) fakeCursorElement.style.display = 'none';
            // NEW: Hide floating item if it was visible
            if (pickedUpItemElement) pickedUpItemElement.style.display = 'none';


            settingsSeedInput.value = WORLD_SEED;
            
            // Display current world name
            const worldNameDisplay = document.getElementById('current-world-name');
            if (worldNameDisplay && currentWorldName) {
                worldNameDisplay.textContent = 'World: ' + currentWorldName;
            }
            
            // COUNTDOWN FOR BUTTONS WHEN PAUSE MENU OPENS (every time)
            const pauseMenuCountdown = 2000; // 2000 milliseconds (2 seconds)
            let remainingTime = pauseMenuCountdown;
            
            // Disable buttons and show countdown
            continueGameButton.disabled = true;
            respawnButton.disabled = true;
            continueGameButton.textContent = `CONTINUE GAME (${(remainingTime / 1000).toFixed(2)}s)`;
            respawnButton.textContent = `RESPAWN (${(remainingTime / 1000).toFixed(2)}s)`;
            
            // Update countdown every 100ms for smooth animation
            const pauseCountdownInterval = setInterval(() => {
                remainingTime -= 100;
                
                if (remainingTime <= 0) {
                    clearInterval(pauseCountdownInterval);
                    // Enable buttons and reset text (ESC no longer works in pause menu)
                    continueGameButton.disabled = false;
                    respawnButton.disabled = false;
                    continueGameButton.textContent = 'CONTINUE GAME';
                    respawnButton.textContent = 'RESPAWN';
                } else {
                    // Update button text with remaining time in seconds with 2 decimal places
                    continueGameButton.textContent = `CONTINUE GAME (${(remainingTime / 1000).toFixed(2)}s)`;
                    respawnButton.textContent = `RESPAWN (${(remainingTime / 1000).toFixed(2)}s)`;
                }
            }, 100);
            // END COUNTDOWN
        }
        
        // --- Event Listeners ---
        document.addEventListener('keydown', function(e) {
            // Keybind customization handler
            if (waitingForKey) {
                e.preventDefault();
                e.stopPropagation();
                
                // Don't allow F5, F11, or Tab as keybinds
                if (e.code === 'F5' || e.code === 'F11' || e.code === 'Tab') {
                    waitingForKey.textContent = keybinds[waitingForKey.dataset.action] ? getKeyDisplay(keybinds[waitingForKey.dataset.action]) : 'NONE';
                    waitingForKey.style.background = '#444';
                    waitingForKey = null;
                    return;
                }
                
                keybinds[waitingForKey.dataset.action] = e.code;
                waitingForKey.textContent = getKeyDisplay(e.code);
                waitingForKey.style.background = '#444';
                waitingForKey = null;
                saveSettings();
                playClickSound();
                return;
            }
            
            keys[e.code] = true; 
            
            // --- FLYING TOGGLE (Double Space) ---
            if (e.code === keybinds.jump && locked && !inventoryOpen && !paused) {
                // Double-tap to fly ONLY works in creative mode
                if (!isCreativeMode) return; 
                
                // NEW: Bug fix for hold-to-fly-toggle
                if (spaceHeld) return; // Don't process if key is already held
                
                spaceHeld = true;
                
                const now = Date.now();
                if (now - lastSpacePress < DOUBLE_PRESS_TIME) { 
                    isFlying = !isFlying; 
                    lastSpacePress = 0; // Reset to prevent triple-press
                } else {
                    lastSpacePress = now;
                }
            }
            
            // Inventory toggle (only when NOT in pause menu)
            if (e.code === keybinds.inventory && locked && !paused) { 
                inventoryOpen = !inventoryOpen;
                
                if (inventoryOpen) {
                    const inventoryScreen = document.getElementById('inventory-screen');
                    inventoryScreen.style.display = 'flex';
                    
                    // Add animation class
                    inventoryScreen.classList.remove('inventory-animate');
                    setTimeout(() => {
                        inventoryScreen.classList.add('inventory-animate');
                    }, 10);
                    
                    fakeCursorElement.style.display = 'block';
                    document.getElementById('crosshair').style.display = 'none'; 
                    
                    fakeCursorX = window.innerWidth / 2;
                    fakeCursorY = window.innerHeight / 2;
                    fakeCursorElement.style.left = fakeCursorX + 'px';
                    fakeCursorElement.style.top = fakeCursorY + 'px';
                    
                    playClickSound();
                } else {
                    const inventoryScreen = document.getElementById('inventory-screen');
                    inventoryScreen.style.display = 'none';
                    inventoryScreen.classList.remove('inventory-animate');
                    
                    fakeCursorElement.style.display = 'none';
                    document.getElementById('crosshair').style.display = 'block'; 
                    
                    if (pickedUpItem) { 
                        addItemToInventory(pickedUpItem.type, pickedUpItem.count, false);
                        pickedUpItem = null;
                        updateInventoryUI();
                    }
                    
                    playClickSound();
                }
            }
            
            // Pause menu toggle - ESC only opens pause menu from gameplay, NOT close it
            if (e.code === keybinds.pause && locked && !paused) { 
                togglePause();
            }
            
            // HUD selection 1-8 keys (only when NOT in inventory)
            if (!inventoryOpen && e.code.startsWith('Digit') && e.keyCode >= 49 && e.keyCode <= 56) { 
                sel = e.keyCode - 49; 
                updateToolbarSelection();
            }

        });

        document.addEventListener('keyup', function(e) { 
            keys[e.code] = false; 
            // NEW: Bug fix for fly toggle
            if (e.code === keybinds.jump) {
                spaceHeld = false;
            }
        });
        
        // --- NEW: Cross-browser Pointer Lock Change Handler ---
        function onPointerLockChange() { 
            locked = document.pointerLockElement === renderer.domElement ||
                     document.mozPointerLockElement === renderer.domElement || // Firefox prefix
                     document.webkitPointerLockElement === renderer.domElement; // Webkit prefix (Chrome)
                     
            // Check if lock is lost
            if (!locked) {
                // If inventory was open, we need to explicitly close it first, then transition to pause menu.
                if (inventoryOpen) {
                    // Manually perform the 'close inventory' steps from toggleInventory()
                    inventoryOpen = false; // State change
                    
                    inventoryScreen.style.display = 'none';
                    document.getElementById('crosshair').style.display = 'block'; 
                    
                    // Hide fake cursor/picked up item
                    if (fakeCursorElement) fakeCursorElement.style.display = 'none';
                    if (pickedUpItemElement) pickedUpItemElement.style.display = 'none';

                    // When closing inventory, drop the item being held to prevent loss
                    if (pickedUpItem) {
                        if (!isCreativeMode) {
                            // Add back to inventory in survival
                            addToInventory(pickedUpItem.type, pickedUpItem.count);
                        }
                        pickedUpItem = null;
                    }
                    updateInventoryUI();
                    
                    // Now, transition to the "Game Stopped" screen
                    showPauseMenu();

                } else if (!paused) { 
                    // If not in inventory and not already in pause menu, simply show pause menu (e.g., alt-tab from gameplay)
                    showPauseMenu();
                }
            }
        }
        
        document.addEventListener('pointerlockchange', onPointerLockChange, false);
        document.addEventListener('mozpointerlockchange', onPointerLockChange, false);
        document.addEventListener('webkitpointerlockchange', onPointerLockChange, false);
        // --- END NEW ---

        // MODIFIED: Continue Game button with cooldown (same as respawn button)
        continueGameButton.addEventListener('click', function() {
            // Immediately execute the continue game action
            togglePause();
        });
        // NEW: Save World button
        document.getElementById('save-world-btn').addEventListener('click', function() {
            if (currentWorldName) {
                saveWorld(currentWorldName);
                alert('World saved successfully!');
            }
        });
        
        // NEW: Settings button from pause menu
        document.getElementById('pause-settings-btn').addEventListener('click', function() {
            // Set flag to remember we came from pause menu
            openedSettingsFromPause = true;
            
            // Hide pause menu (HUD already hidden from showPauseMenu)
            pauseMenu.style.display = 'none';
            
            // Show main menu with settings view and dark overlay for in-game
            const mainMenu = document.getElementById('main-menu');
            mainMenu.style.display = 'flex';
            mainMenu.classList.add('in-game-overlay'); // Add overlay class
            mainMenu.style.animation = 'none'; // No parallax during gameplay
            
            // Set settings state
            setGameState(GAME_STATE.SETTINGS);
            
            // Add animation class (same as inventory and pause menu)
            mainMenu.classList.remove('inventory-animate');
            setTimeout(() => {
                mainMenu.classList.add('inventory-animate');
            }, 10);
            
            // Initialize sliders with current values
            const slider = document.getElementById('renderDistanceSlider');
            const valueSpan = document.getElementById('renderDistanceValue');
            if (slider && valueSpan) {
                slider.value = renderDistance;
                valueSpan.textContent = renderDistance;
            }
            
            const sensSlider = document.getElementById('sensitivitySlider');
            const sensValueSpan = document.getElementById('sensitivityValue');
            if (sensSlider && sensValueSpan) {
                sensSlider.value = mouseSensitivity * 100;
                sensValueSpan.textContent = Math.round(mouseSensitivity * 100);
            }
            
            const fovSlider = document.getElementById('fovSlider');
            const fovValueSpan = document.getElementById('fovValue');
            if (fovSlider && fovValueSpan) {
                fovSlider.value = fieldOfView;
                fovValueSpan.textContent = fieldOfView;
            }
            
            // Initialize Master Volume Slider
            const masterSlider = document.getElementById('masterVolumeSlider');
            const masterValueSpan = document.getElementById('masterVolumeValue');
            if (masterSlider && masterValueSpan) {
                masterSlider.value = masterVolume * 100;
                masterValueSpan.textContent = Math.round(masterVolume * 100);
            }
            
            // Initialize Music Volume Slider
            const musicSlider = document.getElementById('musicVolumeSlider');
            const musicValueSpan = document.getElementById('musicVolumeValue');
            if (musicSlider && musicValueSpan) {
                musicSlider.value = musicVolume * 100;
                musicValueSpan.textContent = Math.round(musicVolume * 100);
            }
            
            // Initialize SFX Volume Slider
            const sfxSlider = document.getElementById('sfxVolumeSlider');
            const sfxValueSpan = document.getElementById('sfxVolumeValue');
            if (sfxSlider && sfxValueSpan) {
                sfxSlider.value = sfxVolume * 100;
                sfxValueSpan.textContent = Math.round(sfxVolume * 100);
            }
            
            // Initialize Tab Out Mute Slider
            const tabOutSlider = document.getElementById('tabOutMuteSlider');
            const tabOutValueSpan = document.getElementById('tabOutMuteValue');
            if (tabOutSlider && tabOutValueSpan) {
                tabOutSlider.value = Math.round(tabOutMuteLevel * 100);
                tabOutValueSpan.textContent = Math.round(tabOutMuteLevel * 100);
            }
            
            showView('settings-view');
        });
        
        // Respawn button
        respawnButton.addEventListener('click', function() {
            // Immediately execute the respawn action
            resetPlayer();
            togglePause();
        });
        
        // Death screen respawn button
        document.getElementById('death-respawn-btn').addEventListener('click', function() {
            resetPlayer();
            // Request pointer lock again and show crosshair
            requestLock(renderer.domElement);
            document.getElementById('crosshair').style.display = 'block';
            paused = false;
        });
        
        // NEW: Exit to Menu button with save prompt
        document.getElementById('exit-to-menu-btn').addEventListener('click', function() { 
            if (currentWorldName) {
                const shouldSave = confirm('Do you want to save your world before exiting?');
                if (shouldSave) {
                    saveWorld(currentWorldName);
                }
            }
            stopAutoSave();
            window.location.reload(); 
        });

        // --- Menu View Switching Logic (Unchanged) ---
        // Function to reset button positions and transforms
        function resetMainMenuButtonTransforms() {
            mainMenuButtons.forEach(button => {
                button.style.transform = '';
                button.style.boxShadow = '';
            });
            if (mainMenuTitle) {
                mainMenuTitle.style.transform = '';
                mainMenuTitle.style.textShadow = '';
            }
        }
        
        function showView(viewId) {
            // Set appropriate game state based on view
            if (viewId === 'main-controls') {
                setGameState(GAME_STATE.MAIN_MENU);
            } else if (viewId === 'creation-view') {
                setGameState(GAME_STATE.CREATE_WORLD);
            } else if (viewId === 'saved-worlds-view') {
                setGameState(GAME_STATE.SAVED_WORLDS);
            } else if (viewId === 'credits-view') {
                setGameState(GAME_STATE.CREDITS);
            } else if (viewId === 'settings-view' || viewId === 'video-settings-view' || 
                       viewId === 'audio-settings-view' || viewId === 'controls-settings-view' || 
                       viewId === 'theme-settings-view') {
                setGameState(GAME_STATE.SETTINGS);
            }
            
            // Reset button transforms when leaving main-controls OR entering submenus
            const currentView = document.querySelector('#main-menu .menu-view[style*="display: flex"]');
            if (currentView && currentView.id === 'main-controls' && viewId !== 'main-controls') {
                resetMainMenuButtonTransforms();
            }
            
            // Also reset when entering creation, saved worlds, or settings
            if (['creation-view', 'saved-worlds-view', 'settings-view'].includes(viewId)) {
                resetMainMenuButtonTransforms();
            }
            
            // Show/hide fixed back buttons
            const backFromSettingsBtn = document.getElementById('backFromSettingsBtn');
            const backToSettingsBtn = document.getElementById('backToSettingsBtn');
            
            if (viewId === 'settings-view') {
                backFromSettingsBtn.style.display = 'block';
                backToSettingsBtn.style.display = 'none';
            } else {
                backFromSettingsBtn.style.display = 'none';
                backToSettingsBtn.style.display = 'none';
            }
            
            // Apply parallax animation to specific views
            const mainMenu = document.getElementById('main-menu');
            const viewsWithParallax = ['creation-view', 'saved-worlds-view', 'settings-view', 'credits-view', 'video-settings-view', 'controls-settings-view', 'audio-settings-view', 'theme-settings-view'];
            
            if (viewsWithParallax.includes(viewId)) {
                // Disable parallax if we came from pause menu (in-game)
                if (openedSettingsFromPause) {
                    mainMenu.style.animation = 'none';
                    mainMenu.style.backgroundColor = 'rgba(0, 0, 0, 0)';
                } else if (viewId === 'credits-view') {
                    // Consistent background for credits
                    mainMenu.style.animation = 'bgParallaxFast 30s linear infinite';
                    mainMenu.style.backgroundColor = 'rgba(0, 0, 0, 0)';
                } else {
                    // Normal parallax for other views - consistent background
                    mainMenu.style.animation = `bgParallax ${currentParallaxSpeed}s linear infinite`;
                    mainMenu.style.backgroundColor = 'rgba(0, 0, 0, 0)';
                }
            } else if (viewId === 'main-controls') {
                // Reset to default for main menu
                mainMenu.style.animation = 'bgParallax 120s linear infinite';
                mainMenu.style.backgroundColor = 'rgba(0, 0, 0, 0)';
            }
            
            // Hide all views first
            document.querySelectorAll('#main-menu .menu-view').forEach(view => { 
                view.style.display = 'none';
                view.classList.remove('menu-animate');
            });
            
            // Show the selected view with animation
            const targetView = document.getElementById(viewId);
            targetView.style.display = 'flex';
            
            // Apply enhanced frame styling if opened from pause menu (in-game)
            if (openedSettingsFromPause && targetView.id !== 'main-controls') {
                targetView.style.background = 'rgba(25, 50, 30, 0.95)';
                targetView.style.border = '6px solid rgba(140, 220, 100, 0.9)';
                targetView.style.outline = '3px solid rgba(0, 0, 0, 0.8)';
                targetView.style.outlineOffset = '-9px';
                targetView.style.boxShadow = '0 12px 0 0 rgba(0, 0, 0, 0.6), 0 0 40px rgba(0, 0, 0, 0.8), inset 0 0 60px rgba(0, 0, 0, 0.4)';
            }
            
            // Trigger animation after a tiny delay to ensure display is set
            setTimeout(() => {
                targetView.classList.add('menu-animate');
            }, 10);
            
            // Reset button transforms when returning to main-controls
            if (viewId === 'main-controls') {
                // Small delay to ensure display is set before resetting
                setTimeout(() => {
                    resetMainMenuButtonTransforms();
                }, 10);
            }
        }
        
        // --- Settings Category Navigation ---
        function showSettingsCategory(category) {
            // Set state to SETTINGS
            setGameState(GAME_STATE.SETTINGS);
            
            // Hide FPS when entering settings
            const fpsElement = document.getElementById('fps');
            if (fpsElement) fpsElement.style.display = 'none';
            
            // Hide all settings views
            document.querySelectorAll('#main-menu .menu-view').forEach(view => { 
                view.style.display = 'none';
                view.classList.remove('menu-animate');
            });
            
            // Show the category view
            let categoryView;
            if (category === 'video') {
                categoryView = document.getElementById('video-settings-view');
            } else if (category === 'controls') {
                categoryView = document.getElementById('controls-settings-view');
            } else if (category === 'audio') {
                categoryView = document.getElementById('audio-settings-view');
            } else if (category === 'theme') {
                categoryView = document.getElementById('theme-settings-view');
            }
            
            if (categoryView) {
                categoryView.style.display = 'flex';
                
                // Apply enhanced frame styling if opened from pause menu (in-game)
                if (openedSettingsFromPause) {
                    categoryView.style.background = 'rgba(25, 50, 30, 0.95)';
                    categoryView.style.border = '6px solid rgba(140, 220, 100, 0.9)';
                    categoryView.style.outline = '3px solid rgba(0, 0, 0, 0.8)';
                    categoryView.style.outlineOffset = '-9px';
                    categoryView.style.boxShadow = '0 12px 0 0 rgba(0, 0, 0, 0.6), 0 0 40px rgba(0, 0, 0, 0.8), inset 0 0 60px rgba(0, 0, 0, 0.4)';
                }
                
                setTimeout(() => {
                    categoryView.classList.add('menu-animate');
                }, 10);
            }
            
            // Show the "Back to Settings" button for detailed settings
            const backFromSettingsBtn = document.getElementById('backFromSettingsBtn');
            const backToSettingsBtn = document.getElementById('backToSettingsBtn');
            backFromSettingsBtn.style.display = 'none';
            backToSettingsBtn.style.display = 'block';
            
            // Reset button transforms
            resetMainMenuButtonTransforms();

            // Ensure audio sliders reflect current saved values when opening Audio tab
            if (category === 'audio') {
                const masterSlider = document.getElementById('masterVolumeSlider');
                const masterValueSpan = document.getElementById('masterVolumeValue');
                if (masterSlider && masterValueSpan) {
                    masterSlider.value = Math.round(masterVolume * 100);
                    masterValueSpan.textContent = Math.round(masterVolume * 100);
                }
                const musicSlider = document.getElementById('musicVolumeSlider');
                const musicValueSpan = document.getElementById('musicVolumeValue');
                if (musicSlider && musicValueSpan) {
                    musicSlider.value = Math.round(musicVolume * 100);
                    musicValueSpan.textContent = Math.round(musicVolume * 100);
                }
                const sfxSlider = document.getElementById('sfxVolumeSlider');
                const sfxValueSpan = document.getElementById('sfxVolumeValue');
                if (sfxSlider && sfxValueSpan) {
                    sfxSlider.value = Math.round(sfxVolume * 100);
                    sfxValueSpan.textContent = Math.round(sfxVolume * 100);
                }
                const tabOutSlider = document.getElementById('tabOutMuteSlider');
                const tabOutValueSpan = document.getElementById('tabOutMuteValue');
                if (tabOutSlider && tabOutValueSpan) {
                    tabOutSlider.value = Math.round(tabOutMuteLevel * 100);
                    tabOutValueSpan.textContent = Math.round(tabOutMuteLevel * 100);
                }
            }

            playClickSound();
        }
        
        function backToSettingsMenu() {
            // Still in settings, just going back to settings main menu
            setGameState(GAME_STATE.SETTINGS);
            
            // Hide FPS when in settings
            const fpsElement = document.getElementById('fps');
            if (fpsElement) fpsElement.style.display = 'none';
            
            // Hide all category views
            document.querySelectorAll('#main-menu .menu-view').forEach(view => { 
                view.style.display = 'none';
                view.classList.remove('menu-animate');
            });
            
            // Show main settings menu with animation
            const settingsView = document.getElementById('settings-view');
            settingsView.style.display = 'flex';
            
            // Show the main settings back button, hide category back button
            const backFromSettingsBtn = document.getElementById('backFromSettingsBtn');
            const backToSettingsBtn = document.getElementById('backToSettingsBtn');
            backFromSettingsBtn.style.display = 'block';
            backToSettingsBtn.style.display = 'none';
            
            // Trigger animation
            setTimeout(() => {
                settingsView.classList.add('menu-animate');
            }, 10);
            
            // Reset button transforms
            resetMainMenuButtonTransforms();
            
            // Clear search when returning
            const searchInput = document.getElementById('settingsSearchInput');
            if (searchInput) {
                searchInput.value = '';
            }
            
            playClickSound();
        }
        
        
        // Blur functionality removed - using solid grey backgrounds only
        
        
        // Wrapper functions for detailed settings buttons
        function showVideoSettings() {
            showSettingsCategory('video');
        }
        
        function showControlSettings() {
            showSettingsCategory('controls');
        }
        
        function showAudioSettings() {
            showSettingsCategory('audio');
        }
        
        function showThemeSettings() {
            showSettingsCategory('theme');
        }
        
        // Theme customization - using solid grey only
        let currentParallaxColor = 'transparent';
        let currentParallaxSpeed = 120;
        
        function setParallaxColor(color) {
            currentParallaxColor = color;
            const mainMenu = document.getElementById('main-menu');
            const currentView = document.querySelector('#main-menu .menu-view[style*="display: flex"]');
            
            // Update immediately if not in credits or main-controls
            if (currentView && currentView.id !== 'main-controls' && currentView.id !== 'credits-view') {
                mainMenu.style.backgroundColor = color;
            }
            
            // Visual feedback - highlight selected button
            document.querySelectorAll('.theme-color-btn').forEach(btn => {
                btn.style.border = '3px solid #666';
                btn.style.transform = 'scale(1)';
            });
            event.target.style.border = '3px solid var(--main-action)';
            event.target.style.transform = 'scale(1.1)';
            
            playClickSound();
        }
        
        function setMenuStyle(style, event) {
            // Menu style setting removed - always using dark green translucent
            const mainControls = document.getElementById('main-controls');
            
            mainControls.style.background = 'rgba(25, 50, 30, 0.85)';
            
            playClickSound();
        }
        
        function resetThemeSettings() {
            currentParallaxColor = 'transparent';
            currentParallaxSpeed = 120;
            
            const mainMenu = document.getElementById('main-menu');
            mainMenu.style.backgroundColor = currentParallaxColor;
            
            const mainControls = document.getElementById('main-controls');
            mainControls.style.background = 'rgba(25, 50, 30, 0.85)';
            
            const speedSlider = document.getElementById('parallaxSpeedSlider');
            const speedValue = document.getElementById('parallaxSpeedValue');
            if (speedSlider && speedValue) {
                speedSlider.value = 120;
                speedValue.textContent = '120';
            }
            
            // Reset button highlights
            document.querySelectorAll('.theme-color-btn').forEach(btn => {
                btn.style.border = '3px solid #666';
                btn.style.transform = 'scale(1)';
            });
            
            playClickSound();
        }
        
        // Settings Search Filter Function - Enhanced with auto-navigation
        function filterSettings(searchTerm) {
            searchTerm = searchTerm.toLowerCase().trim();
            
            // Get all settings views
            const views = [
                { id: 'video-settings-view', name: 'video' },
                { id: 'controls-settings-view', name: 'controls' },
                { id: 'audio-settings-view', name: 'audio' },
                { id: 'theme-settings-view', name: 'theme' }
            ];
            
            if (!searchTerm) {
                // If search is empty, show all settings and return to main menu
                views.forEach(view => {
                    const viewElement = document.getElementById(view.id);
                    if (viewElement) {
                        viewElement.querySelectorAll('.setting-item').forEach(item => {
                            item.style.display = '';
                        });
                    }
                });
                return;
            }
            
            let resultsFound = false;
            let firstMatchView = null;
            let matchCounts = {};
            
            // Search through all settings and count matches per view
            views.forEach(view => {
                const viewElement = document.getElementById(view.id);
                if (viewElement) {
                    let viewMatches = 0;
                    const settingItems = viewElement.querySelectorAll('.setting-item');
                    
                    settingItems.forEach(item => {
                        const label = item.querySelector('.setting-label');
                        const description = item.querySelector('.setting-description');
                        
                        const labelText = label ? label.textContent.toLowerCase() : '';
                        const descText = description ? description.textContent.toLowerCase() : '';
                        
                        if (labelText.includes(searchTerm) || descText.includes(searchTerm)) {
                            item.style.display = '';
                            viewMatches++;
                            resultsFound = true;
                            if (!firstMatchView) {
                                firstMatchView = view.name;
                            }
                        } else {
                            item.style.display = 'none';
                        }
                    });
                    
                    matchCounts[view.name] = viewMatches;
                }
            });
            
            // Auto-navigate to the view with most matches
            if (resultsFound && firstMatchView) {
                // Find view with most matches
                let bestView = firstMatchView;
                let maxMatches = matchCounts[firstMatchView] || 0;
                
                Object.keys(matchCounts).forEach(viewName => {
                    if (matchCounts[viewName] > maxMatches) {
                        maxMatches = matchCounts[viewName];
                        bestView = viewName;
                    }
                });
                
                // Navigate to the best matching view
                showSettingsCategory(bestView);
            }
        }
        
        document.getElementById('showCreationBtn').addEventListener('click', function() { showView('creation-view'); });
        document.getElementById('showSavedWorldsBtn').addEventListener('click', function() { 
            displaySavedWorlds(); 
            showView('saved-worlds-view'); 
        });
        document.getElementById('showSettingsBtn').addEventListener('click', function() {
            // NEW: Initialize Render Distance Slider (view distance, not world size)
            const slider = document.getElementById('renderDistanceSlider');
            const valueSpan = document.getElementById('renderDistanceValue');
            if (slider && valueSpan) {
                slider.value = renderDistance;
                valueSpan.textContent = renderDistance;
            }
            
            // Initialize Sensitivity Slider
            const sensSlider = document.getElementById('sensitivitySlider');
            const sensValueSpan = document.getElementById('sensitivityValue');
            if (sensSlider && sensValueSpan) {
                sensSlider.value = mouseSensitivity * 100;
                sensValueSpan.textContent = Math.round(mouseSensitivity * 100);
            }
            
            // Initialize FOV Slider
            const fovSlider = document.getElementById('fovSlider');
            const fovValueSpan = document.getElementById('fovValue');
            if (fovSlider && fovValueSpan) {
                fovSlider.value = fieldOfView;
                fovValueSpan.textContent = fieldOfView;
            }
            
            // Initialize Master Volume Slider
            const masterSlider = document.getElementById('masterVolumeSlider');
            const masterValueSpan = document.getElementById('masterVolumeValue');
            if (masterSlider && masterValueSpan) {
                masterSlider.value = masterVolume * 100;
                masterValueSpan.textContent = Math.round(masterVolume * 100);
            }
            
            // Initialize Music Volume Slider
            const musicSlider = document.getElementById('musicVolumeSlider');
            const musicValueSpan = document.getElementById('musicVolumeValue');
            if (musicSlider && musicValueSpan) {
                musicSlider.value = musicVolume * 100;
                musicValueSpan.textContent = Math.round(musicVolume * 100);
            }
            
            // Initialize SFX Volume Slider
            const sfxSlider = document.getElementById('sfxVolumeSlider');
            const sfxValueSpan = document.getElementById('sfxVolumeValue');
            if (sfxSlider && sfxValueSpan) {
                sfxSlider.value = sfxVolume * 100;
                sfxValueSpan.textContent = Math.round(sfxVolume * 100);
            }
            
            // Initialize Tab Out Mute Slider
            const tabOutSlider = document.getElementById('tabOutMuteSlider');
            const tabOutValueSpan = document.getElementById('tabOutMuteValue');
            if (tabOutSlider && tabOutValueSpan) {
                tabOutSlider.value = Math.round(tabOutMuteLevel * 100);
                tabOutValueSpan.textContent = Math.round(tabOutMuteLevel * 100);
            }
            // END NEW

            showView('settings-view');
        });
        document.getElementById('showCreditsBtn').addEventListener('click', function() { 
            showView('credits-view'); 
            initCreditsTracking();
            // Music visualizer removed from credits
        });
        document.getElementById('backFromCreationBtn').addEventListener('click', function() { showView('main-controls'); });
        document.getElementById('backFromSettingsBtn').addEventListener('click', function() { 
            // Persist any pending changes before leaving settings
            saveSettings();
            // Check if we came from pause menu
            if (openedSettingsFromPause) {
                // Reset flag
                openedSettingsFromPause = false;
                
                // Going back to pause menu
                setGameState(GAME_STATE.PAUSE_MENU);
                
                // Hide main menu and reset styling
                const mainMenu = document.getElementById('main-menu');
                mainMenu.style.display = 'none';
                mainMenu.classList.remove('in-game-overlay'); // Remove overlay class
                mainMenu.classList.remove('inventory-animate'); // Remove animation class
                mainMenu.style.animation = 'bgParallax 120s linear infinite';
                
                // Show pause menu again with animation
                pauseMenu.style.display = 'flex';
                pauseMenu.classList.remove('inventory-animate');
                setTimeout(() => {
                    pauseMenu.classList.add('inventory-animate');
                }, 10);
            } else {
                // Regular flow: go back to main menu
                setGameState(GAME_STATE.MAIN_MENU);
                
                // Reset main menu styling for main menu view
                const mainMenu = document.getElementById('main-menu');
                mainMenu.classList.remove('in-game-overlay'); // Remove overlay class
                mainMenu.classList.remove('inventory-animate'); // Remove animation class
                mainMenu.style.animation = 'bgParallax 120s linear infinite';
                showView('main-controls');
            }
        });
        document.getElementById('backFromSavedWorldsBtn').addEventListener('click', function() { showView('main-controls'); });
        document.getElementById('backFromCreditsBtn').addEventListener('click', function() { 
            showView('main-controls');
            disableCreditsTracking();
            // Music visualizer removed from credits
        });
        
        // ==================== CREDITS WINDOW TRACKING & EFFECTS ====================
        let creditsTrackingEnabled = false;
        let creditsContainer = null;
        let visualizerInterval = null;
        let easterEggClicks = 0;
        let easterEggTimer = null;
        let lastMouseX = window.innerWidth / 2;
        let lastMouseY = window.innerHeight / 2;
        
        function initCreditsTracking() {
            creditsTrackingEnabled = true;
            creditsContainer = document.querySelector('.credits-container');
            
            // Track globally on document (works anywhere in the window)
            document.addEventListener('mousemove', handleCreditsTracking);
            
            // Track mouse position even when it leaves the window
            document.addEventListener('mouseout', handleMouseLeave);
            document.addEventListener('mouseleave', handleMouseLeave);
            
            // Setup easter eggs
            setupEasterEggs();
        }
        
        function disableCreditsTracking() {
            creditsTrackingEnabled = false;
            
            // Remove global listeners
            document.removeEventListener('mousemove', handleCreditsTracking);
            document.removeEventListener('mouseout', handleMouseLeave);
            document.removeEventListener('mouseleave', handleMouseLeave);
            
            // Reset container position
            if (creditsContainer) {
                creditsContainer.style.transform = 'perspective(1500px) rotateX(0deg) rotateY(0deg) translateZ(0px)';
                creditsContainer.style.filter = 'none';
            }
        }
        
        function handleMouseLeave(e) {
            // When mouse leaves the window, keep using the last known position
            if (!creditsTrackingEnabled || !creditsContainer) return;
            
            // Continue tracking with the edge position
            if (e.clientX !== undefined) {
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
            
            updateCreditsPosition(lastMouseX, lastMouseY);
        }
        
        function handleCreditsTracking(e) {
            if (!creditsTrackingEnabled || !creditsContainer) return;
            
            // Update last known position
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            
            updateCreditsPosition(lastMouseX, lastMouseY);
        }
        
        function updateCreditsPosition(mouseX, mouseY) {
            if (!creditsContainer) return;
            
            const rect = creditsContainer.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            const deltaX = mouseX - centerX;
            const deltaY = mouseY - centerY;
            
            // Calculate rotation (make entire container "look" at mouse)
            const maxRotation = 15; // degrees
            const rotateY = (deltaX / window.innerWidth) * maxRotation;
            const rotateX = -(deltaY / window.innerHeight) * maxRotation;
            
            // Apply transform to container
            creditsContainer.style.transform = `
                perspective(1500px)
                rotateX(${rotateX}deg)
                rotateY(${rotateY}deg)
                translateZ(20px)
            `;
            
            // Add dynamic shadow based on rotation
            const shadowX = rotateY * 2;
            const shadowY = -rotateX * 2;
            creditsContainer.style.filter = `
                drop-shadow(${shadowX}px ${shadowY}px 30px rgba(121, 192, 90, 0.4))
            `;
        }
        
        // ==================== MUSIC VISUALIZER ====================
        function initMusicVisualizer() {
            const visualizerContainer = document.querySelector('.music-visualizer');
            if (!visualizerContainer) return;
            
            visualizerContainer.style.display = 'flex';
            
            // Create bars
            const bars = visualizerContainer.querySelectorAll('.visualizer-bar');
            
            // Animate bars with random heights
            visualizerInterval = setInterval(() => {
                bars.forEach((bar, index) => {
                    const height = Math.random() * 80 + 20; // 20-100%
                    const delay = index * 50;
                    setTimeout(() => {
                        bar.style.height = height + '%';
                    }, delay);
                });
            }, 200);
        }
        
        function stopMusicVisualizer() {
            if (visualizerInterval) {
                clearInterval(visualizerInterval);
                visualizerInterval = null;
            }
            const visualizerContainer = document.querySelector('.music-visualizer');
            if (visualizerContainer) {
                visualizerContainer.style.display = 'none';
            }
        }
        
        // ==================== EASTER EGGS ====================
        function setupEasterEggs() {
            const creditsView = document.getElementById('credits-view');
            const creditIcons = document.querySelectorAll('.credit-icon');
            
            // Easter Egg 1: Click icons 5 times quickly to unlock secret mode
            creditIcons.forEach(icon => {
                icon.addEventListener('click', function() {
                    easterEggClicks++;
                    
                    // Visual feedback
                    this.style.transform = 'scale(1.5) rotate(360deg)';
                    setTimeout(() => {
                        this.style.transform = '';
                    }, 300);
                    
                    if (easterEggClicks >= 5) {
                        activateEasterEgg1();
                        easterEggClicks = 0;
                    }
                    
                    // Reset counter after 2 seconds
                    clearTimeout(easterEggTimer);
                    easterEggTimer = setTimeout(() => {
                        easterEggClicks = 0;
                    }, 2000);
                });
            });
            
            // Easter Egg 2: Konami Code (up, up, down, down, left, right, left, right)
            let konamiCode = [];
            const konamiSequence = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight'];
            
            document.addEventListener('keydown', function(e) {
                if (!creditsTrackingEnabled) return;
                
                konamiCode.push(e.key);
                if (konamiCode.length > konamiSequence.length) {
                    konamiCode.shift();
                }
                
                if (JSON.stringify(konamiCode) === JSON.stringify(konamiSequence)) {
                    activateEasterEgg2();
                    konamiCode = [];
                }
            });
            
            // Easter Egg 3: Double-click the title
            const creditsTitle = document.querySelector('.credits-title');
            if (creditsTitle) {
                creditsTitle.addEventListener('dblclick', activateEasterEgg3);
            }
        }
        
        function activateEasterEgg1() {
            console.log(' Easter Egg 1 Activated: Party Mode!');
            const creditsView = document.getElementById('credits-view');
            
            // Rainbow colors animation
            creditsView.style.animation = 'none';
            creditsView.style.background = 'linear-gradient(45deg, red, orange, yellow, green, blue, indigo, violet)';
            creditsView.style.backgroundSize = '400% 400%';
            creditsView.style.animation = 'bgParallax 3s ease infinite';
            
            // Show message
            showEasterEggMessage(' PARTY MODE ACTIVATED! ');
            
            // Reset after 5 seconds
            setTimeout(() => {
                creditsView.style.animation = 'creditsGlow 3s ease-in-out infinite';
                creditsView.style.background = '';
            }, 5000);
        }
        
        function activateEasterEgg2() {
            console.log(' Easter Egg 2 Activated: Konami Code!');
            const creditCards = document.querySelectorAll('.credit-card');
            
            // Make cards spin
            creditCards.forEach((card, index) => {
                setTimeout(() => {
                    card.style.animation = 'none';
                    card.style.transform = 'rotateY(720deg) scale(1.2)';
                    setTimeout(() => {
                        card.style.transform = '';
                        card.style.animation = 'creditsEntrance 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) forwards';
                    }, 1000);
                }, index * 200);
            });
            
            showEasterEggMessage(' KONAMI CODE!');
        }
        
        function activateEasterEgg3() {
            console.log(' Easter Egg 3 Activated: Secret Message!');
            const particles = document.querySelector('.credits-particles');
            
            // Create explosion effect
            if (particles) {
                for (let i = 0; i < 20; i++) {
                    const particle = document.createElement('div');
                    particle.style.position = 'absolute';
                    particle.style.width = '10px';
                    particle.style.height = '10px';
                    particle.style.background = `hsl(${Math.random() * 360}, 100%, 50%)`;
                    particle.style.borderRadius = '50%';
                    particle.style.left = '50%';
                    particle.style.top = '20%';
                    particle.style.animation = `particleFloat ${2 + Math.random() * 2}s ease-out forwards`;
                    particle.style.transform = `rotate(${Math.random() * 360}deg) translateX(${Math.random() * 200 - 100}px)`;
                    particles.appendChild(particle);
                    
                    setTimeout(() => particle.remove(), 3000);
                }
            }
            
            showEasterEggMessage(' You found the secret! You are a true gamer! ');
        }
        
        function showEasterEggMessage(message) {
            const existingMsg = document.querySelector('.easter-egg-message');
            if (existingMsg) existingMsg.remove();
            
            const msgDiv = document.createElement('div');
            msgDiv.className = 'easter-egg-message';
            msgDiv.textContent = message;
            msgDiv.style.position = 'fixed';
            msgDiv.style.top = '50%';
            msgDiv.style.left = '50%';
            msgDiv.style.transform = 'translate(-50%, -50%)';
            msgDiv.style.background = 'rgba(0, 0, 0, 0.9)';
            msgDiv.style.color = '#79C05A';
            msgDiv.style.padding = '30px 50px';
            msgDiv.style.borderRadius = '12px';
            msgDiv.style.border = '3px solid #79C05A';
            msgDiv.style.fontSize = '24px';
            msgDiv.style.fontWeight = 'bold';
            msgDiv.style.zIndex = '10000';
            msgDiv.style.animation = 'scale-in 0.5s ease-out';
            msgDiv.style.textAlign = 'center';
            msgDiv.style.boxShadow = '0 0 50px rgba(121, 192, 90, 0.8)';
            
            document.body.appendChild(msgDiv);
            
            setTimeout(() => {
                msgDiv.style.animation = 'scale-out 0.5s ease-out';
                setTimeout(() => msgDiv.remove(), 500);
            }, 3000);
        }
        // ==================== END CREDITS EFFECTS ====================
        
        // NEW: World Size Slider (in creation menu)
        const worldSizeSlider = document.getElementById('worldSizeSlider');
        const worldSizeValueSpan = document.getElementById('worldSizeValue');

        if (worldSizeSlider && worldSizeValueSpan) {
            worldSizeSlider.addEventListener('input', function() {
                ws = parseInt(this.value);
                worldSizeValueSpan.textContent = ws;
            });
            // Initial sync
            worldSizeSlider.value = ws;
            worldSizeValueSpan.textContent = ws;
        }

        // NEW: View Distance Slider (in settings menu) - separate from world size
        const renderDistanceSlider = document.getElementById('renderDistanceSlider');
        const renderDistanceValueSpan = document.getElementById('renderDistanceValue');

        if (renderDistanceSlider && renderDistanceValueSpan) {
            renderDistanceSlider.addEventListener('input', function() {
                renderDistance = parseInt(this.value);
                renderDistanceValueSpan.textContent = renderDistance;
                updateDefaultIndicator(renderDistance, DEFAULT_RENDER_DISTANCE, 'renderDistanceDefault');
                
                // Sync with quick settings
                const quickSlider = document.getElementById('quick-renderDistance');
                const quickValue = document.getElementById('quick-renderDistance-value');
                const quickDefault = document.getElementById('quick-renderDistance-default');
                if (quickSlider && quickValue) {
                    quickSlider.value = renderDistance;
                    quickValue.textContent = renderDistance + ' blocks';
                    if (quickDefault) {
                        quickDefault.style.color = renderDistance === DEFAULT_RENDER_DISTANCE ? '#79C05A' : 'transparent';
                    }
                }
                
                saveSettings(); // Save to localStorage
            });
            // Initial sync
            renderDistanceSlider.value = renderDistance;
            renderDistanceValueSpan.textContent = renderDistance;
            updateDefaultIndicator(renderDistance, DEFAULT_RENDER_DISTANCE, 'renderDistanceDefault');
        }
        
        // NEW: Mouse Sensitivity Slider
        const sensitivitySlider = document.getElementById('sensitivitySlider');
        const sensitivityValueSpan = document.getElementById('sensitivityValue');

        if (sensitivitySlider && sensitivityValueSpan) {
            sensitivitySlider.addEventListener('input', function() {
                const value = parseInt(this.value);
                mouseSensitivity = value / 100;
                sensitivityValueSpan.textContent = value;
                updateDefaultIndicator(value, DEFAULT_MOUSE_SENSITIVITY, 'sensitivityDefault');
                
                // Sync with quick settings
                const quickSlider = document.getElementById('quick-sensitivity');
                const quickValue = document.getElementById('quick-sensitivity-value');
                const quickDefault = document.getElementById('quick-sensitivity-default');
                if (quickSlider && quickValue) {
                    quickSlider.value = value;
                    quickValue.textContent = value + '%';
                    if (quickDefault) {
                        quickDefault.style.color = value === DEFAULT_MOUSE_SENSITIVITY ? '#79C05A' : 'transparent';
                    }
                }
                
                saveSettings(); // Save to localStorage
            });
            // Initial sync
            sensitivitySlider.value = mouseSensitivity * 100;
            sensitivityValueSpan.textContent = Math.round(mouseSensitivity * 100);
            updateDefaultIndicator(Math.round(mouseSensitivity * 100), DEFAULT_MOUSE_SENSITIVITY, 'sensitivityDefault');
        }
        
        // NEW: FOV Slider
        const fovSlider = document.getElementById('fovSlider');
        const fovValueSpan = document.getElementById('fovValue');

        if (fovSlider && fovValueSpan) {
            fovSlider.addEventListener('input', function() {
                fieldOfView = parseInt(this.value);
                fovValueSpan.textContent = fieldOfView;
                updateDefaultIndicator(fieldOfView, DEFAULT_FOV, 'fovDefault');
                camera.fov = fieldOfView;
                camera.updateProjectionMatrix();
                
                // Sync with quick settings
                const quickSlider = document.getElementById('quick-fov');
                const quickValue = document.getElementById('quick-fov-value');
                const quickDefault = document.getElementById('quick-fov-default');
                if (quickSlider && quickValue) {
                    quickSlider.value = fieldOfView;
                    quickValue.textContent = fieldOfView + '';
                    if (quickDefault) {
                        quickDefault.style.color = fieldOfView === DEFAULT_FOV ? '#79C05A' : 'transparent';
                    }
                }
                
                saveSettings(); // Save to localStorage
            });
            // Initial sync
            fovSlider.value = fieldOfView;
            fovValueSpan.textContent = fieldOfView;
            updateDefaultIndicator(fieldOfView, DEFAULT_FOV, 'fovDefault');
        }
        
        // NEW: Shadows Toggle
        const shadowsToggle = document.getElementById('shadowsToggle');
        if (shadowsToggle) {
            shadowsToggle.addEventListener('change', function() {
                shadowsEnabled = this.checked;
                renderer.shadowMap.enabled = shadowsEnabled;
                saveSettings();
            });
            // Initial sync
            shadowsToggle.checked = shadowsEnabled;
        }
        
        // NEW: Show Item in Hand Toggle
        const showHandToggle = document.getElementById('showHandToggle');
        if (showHandToggle) {
            showHandToggle.addEventListener('change', function() {
                showItemInHand = this.checked;
                saveSettings();
            });
            showHandToggle.checked = showItemInHand;
        }
        
        // NEW: Hand Bob Toggle
        const handBobToggle = document.getElementById('handBobToggle');
        if (handBobToggle) {
            handBobToggle.addEventListener('change', function() {
                handBobEnabled = this.checked;
                saveSettings();
            });
            handBobToggle.checked = handBobEnabled;
        }
        
        // NEW: FPS Always Visible Toggle
        const fpsToggle = document.getElementById('fpsAlwaysVisibleToggle');
        if (fpsToggle) {
            fpsToggle.addEventListener('change', function() {
                fpsAlwaysVisible = this.checked;
                const fpsElement = document.getElementById('fps');
                if (fpsElement) {
                    // Show FPS only when in game and setting is enabled
                    fpsElement.style.display = (fpsAlwaysVisible && currentGameState === GAME_STATE.IN_GAME) ? 'block' : (showHitbox ? 'block' : 'none');
                }
                saveSettings();
            });
            fpsToggle.checked = fpsAlwaysVisible;
        }
        
        // NEW: Player Skin Upload System
        const uploadSkinBtn = document.getElementById('uploadSkinBtn');
        const exportSkinBtn = document.getElementById('exportSkinBtn');
        const skinFileInput = document.getElementById('skinFileInput');
        const downloadSkinTemplate = document.getElementById('downloadSkinTemplate');
        const showSkinLayersToggle = document.getElementById('showSkinLayersToggle');
        const slimSkinToggle = document.getElementById('slimSkinToggle');
        
        // Slim skin toggle handler
        if (slimSkinToggle) {
            slimSkinToggle.addEventListener('change', function() {
                isSlimSkin = this.checked;
                createArms(); // Recreate arms with new dimensions
                
                // Update UV maps
                const armUVs = getArmUVMaps();
                skinUVMaps.rightArm = armUVs.rightArm;
                skinUVMaps.rightArmLayer = armUVs.rightArmLayer;
                skinUVMaps.leftArm = armUVs.leftArm;
                skinUVMaps.leftArmLayer = armUVs.leftArmLayer;
                
                // Save old texture dimensions before updating
                const oldTextureDimensions = texturePartDimensions;
                
                // Update texture dimensions for editor
                texturePartDimensions = getTexturePartDimensions();
                
                // Preserve and scale arm textures to new dimensions
                const armParts = ['leftArm', 'leftArmLayer', 'rightArm', 'rightArmLayer', 'fpHand'];
                armParts.forEach(part => {
                    if (modelTextures[part]) {
                        const oldTextureData = modelTextures[part];
                        modelTextures[part] = {};
                        
                        for (let side in texturePartDimensions[part]) {
                            const newDims = texturePartDimensions[part][side];
                            const oldDims = oldTextureDimensions[part][side];
                            
                            // Create canvas for new dimensions
                            const newCanvas = document.createElement('canvas');
                            newCanvas.width = newDims.w;
                            newCanvas.height = newDims.h;
                            const newCtx = newCanvas.getContext('2d');
                            
                            // If we have existing texture data, preserve it by scaling
                            if (oldTextureData[side]) {
                                // Create temporary canvas with old texture
                                const oldCanvas = document.createElement('canvas');
                                oldCanvas.width = oldDims.w;
                                oldCanvas.height = oldDims.h;
                                const oldCtx = oldCanvas.getContext('2d');
                                oldCtx.putImageData(oldTextureData[side], 0, 0);
                                
                                // Scale the old texture to new dimensions
                                // Use nearest-neighbor scaling to preserve pixelated look
                                newCtx.imageSmoothingEnabled = false;
                                newCtx.drawImage(oldCanvas, 0, 0, oldDims.w, oldDims.h, 0, 0, newDims.w, newDims.h);
                            } else {
                                // Initialize with default color only if no texture exists
                                if (part.includes('Layer')) {
                                    newCtx.clearRect(0, 0, newDims.w, newDims.h);
                                } else {
                                    newCtx.fillStyle = '#d4a574';
                                    newCtx.fillRect(0, 0, newDims.w, newDims.h);
                                }
                            }
                            
                            modelTextures[part][side] = newCtx.getImageData(0, 0, newDims.w, newDims.h);
                        }
                    }
                });
                
                // Reapply textures with new UV maps
                applyTexturesToModels();
                
                // Recreate first-person hand with new dimensions
                if (fpHandMesh) handScene.remove(fpHandMesh);
                fpHandMesh = createHandMesh();
                if (fpHandMesh) {
                    // Make hand bigger and move to bottom-right corner
                    fpHandMesh.scale.set(1.5, 1.5, 1.5); // 1.5x bigger
                    fpHandMesh.userData.basePosition = { x: 0.4, y: -0.35, z: -0.5 }; // Bottom-right corner (Minecraft style)
                    fpHandMesh.userData.baseRotation = { x: 0.15, y: -0.2, z: 0.0 }; // Natural arm holding position (Minecraft style)
                    fpHandMesh.position.set(0.4, -0.35, -0.5);
                    fpHandMesh.rotation.set(0.15, -0.2, 0.0);
                    fpHandMesh.visible = showItemInHand; // Show based on setting
                    handScene.add(fpHandMesh);
                    // Apply textures after creating
                    applyTexturesToModels();
                }
                
                saveSettings();
            });
            slimSkinToggle.checked = isSlimSkin;
        }
        
        if (uploadSkinBtn && skinFileInput) {
            uploadSkinBtn.addEventListener('click', function() {
                skinFileInput.click();
            });
            
            skinFileInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        // Validate skin dimensions - support both 64x64 (modern) and 64x32 (pre-1.8 legacy)
                        if ((img.width === 64 && img.height === 64) || (img.width === 64 && img.height === 32)) {
                            const canvas = document.createElement('canvas');
                            canvas.width = 64;
                            canvas.height = 64; // Always use 64x64 internally
                            const ctx = canvas.getContext('2d');
                            
                            if (img.height === 32) {
                                // Legacy 64x32 format: duplicate top half to bottom half for layers
                                ctx.drawImage(img, 0, 0, 64, 32, 0, 0, 64, 32); // Top half
                                ctx.drawImage(img, 0, 0, 64, 32, 0, 32, 64, 32); // Duplicate to bottom half
                            } else {
                                // Modern 64x64 format
                                ctx.drawImage(img, 0, 0);
                            }
                            
                            const imageData = ctx.getImageData(0, 0, 64, 64);
                            const skinData = Array.from(imageData.data);
                            
                            // Helper function to extract region
                            function extractRegion(x, y, w, h) {
                                const regionCanvas = document.createElement('canvas');
                                regionCanvas.width = w;
                                regionCanvas.height = h;
                                const regionCtx = regionCanvas.getContext('2d');
                                regionCtx.drawImage(canvas, x, y, w, h, 0, 0, w, h);
                                return regionCanvas;
                            }
                            
                            // Apply base and layer textures to all body parts
                            // HEAD
                            if (headMesh) {
                                headMesh.material = createBodyPartMaterials(canvas, skinUVMaps.head, false);
                             }
                            // Remove old head layer if exists
                            if (headLayerMesh) {
                                playerModelGroup.remove(headLayerMesh);
                                headLayerMesh.geometry.dispose();
                                if (Array.isArray(headLayerMesh.material)) {
                                    headLayerMesh.material.forEach(m => m.dispose());
                                } else {
                                    headLayerMesh.material.dispose();
                                }
                            }
                            // Create new head layer (hat)
                             const headLayerGeometry = new THREE.BoxGeometry(0.52 * modelScale, 0.52 * modelScale, 0.52 * modelScale);
                             headLayerMesh = new THREE.Mesh(headLayerGeometry, createBodyPartMaterials(canvas, skinUVMaps.headLayer, true));
                             headLayerMesh.position.copy(headMesh.position);
                             headLayerMesh.visible = showSkinLayers;
                             headLayerMesh.renderOrder = 1;
                             playerModelGroup.add(headLayerMesh);
                            
                            // BODY
                             if (bodyMesh) {
                                 bodyMesh.material = createBodyPartMaterials(canvas, skinUVMaps.body, false);
                             }
                            // Remove old body layer if exists
                            if (bodyLayerMesh) {
                                playerModelGroup.remove(bodyLayerMesh);
                                bodyLayerMesh.geometry.dispose();
                                if (Array.isArray(bodyLayerMesh.material)) {
                                    bodyLayerMesh.material.forEach(m => m.dispose());
                                } else {
                                    bodyLayerMesh.material.dispose();
                                }
                            }
                             // Create new body layer (jacket)
                             const bodyLayerGeometry = new THREE.BoxGeometry(0.52 * modelScale, 0.77 * modelScale, 0.27 * modelScale);
                             bodyLayerMesh = new THREE.Mesh(bodyLayerGeometry, createBodyPartMaterials(canvas, skinUVMaps.bodyLayer, true));
                             bodyLayerMesh.position.copy(bodyMesh.position);
                             bodyLayerMesh.visible = showSkinLayers;
                             bodyLayerMesh.renderOrder = 1;
                             playerModelGroup.add(bodyLayerMesh);
                            
                            // RIGHT ARM
                             if (rightArm) {
                                 rightArm.material = createBodyPartMaterials(canvas, skinUVMaps.rightArm, false);
                             }
                            // Remove old right arm layer if exists
                            if (rightArmLayerMesh) {
                                rightArmPivot.remove(rightArmLayerMesh);
                                rightArmLayerMesh.geometry.dispose();
                                if (Array.isArray(rightArmLayerMesh.material)) {
                                    rightArmLayerMesh.material.forEach(m => m.dispose());
                                } else {
                                    rightArmLayerMesh.material.dispose();
                                }
                            }
                             // Create new right arm layer (sleeve) - adjust size based on slim skin
                             const rightArmLayerWidth = isSlimSkin ? 0.2075 * modelScale : 0.27 * modelScale;
                             const rightArmLayerGeometry = new THREE.BoxGeometry(rightArmLayerWidth, 0.77 * modelScale, 0.27 * modelScale);
                             rightArmLayerMesh = new THREE.Mesh(rightArmLayerGeometry, createBodyPartMaterials(canvas, skinUVMaps.rightArmLayer, true));
                             rightArmLayerMesh.position.copy(rightArm.position);
                             rightArmLayerMesh.visible = showSkinLayers;
                             rightArmLayerMesh.renderOrder = 1;
                             rightArmPivot.add(rightArmLayerMesh);
                            
                            // LEFT ARM
                             if (leftArm) {
                                 leftArm.material = createBodyPartMaterials(canvas, skinUVMaps.leftArm, false);
                             }
                            // Remove old left arm layer if exists
                            if (leftArmLayerMesh) {
                                leftArmPivot.remove(leftArmLayerMesh);
                                leftArmLayerMesh.geometry.dispose();
                                if (Array.isArray(leftArmLayerMesh.material)) {
                                    leftArmLayerMesh.material.forEach(m => m.dispose());
                                } else {
                                    leftArmLayerMesh.material.dispose();
                                }
                            }
                             // Create new left arm layer (sleeve) - adjust size based on slim skin
                             const leftArmLayerWidth = isSlimSkin ? 0.2075 * modelScale : 0.27 * modelScale;
                             const leftArmLayerGeometry = new THREE.BoxGeometry(leftArmLayerWidth, 0.77 * modelScale, 0.27 * modelScale);
                             leftArmLayerMesh = new THREE.Mesh(leftArmLayerGeometry, createBodyPartMaterials(canvas, skinUVMaps.leftArmLayer, true));
                             leftArmLayerMesh.position.copy(leftArm.position);
                             leftArmLayerMesh.visible = showSkinLayers;
                             leftArmLayerMesh.renderOrder = 1;
                             leftArmPivot.add(leftArmLayerMesh);
                            
                            // RIGHT LEG
                             if (rightLeg) {
                                 rightLeg.material = createBodyPartMaterials(canvas, skinUVMaps.rightLeg, false);
                             }
                            // Remove old right leg layer if exists
                            if (rightLegLayerMesh) {
                                rightLegPivot.remove(rightLegLayerMesh);
                                rightLegLayerMesh.geometry.dispose();
                                if (Array.isArray(rightLegLayerMesh.material)) {
                                    rightLegLayerMesh.material.forEach(m => m.dispose());
                                } else {
                                    rightLegLayerMesh.material.dispose();
                                }
                            }
                             // Create new right leg layer (pants)
                             const rightLegLayerGeometry = new THREE.BoxGeometry(0.27 * modelScale, 0.77 * modelScale, 0.27 * modelScale);
                             rightLegLayerMesh = new THREE.Mesh(rightLegLayerGeometry, createBodyPartMaterials(canvas, skinUVMaps.rightLegLayer, true));
                             rightLegLayerMesh.position.copy(rightLeg.position);
                             rightLegLayerMesh.visible = showSkinLayers;
                             rightLegLayerMesh.renderOrder = 1;
                             rightLegPivot.add(rightLegLayerMesh);
                            
                            // LEFT LEG
                             if (leftLeg) {
                                 leftLeg.material = createBodyPartMaterials(canvas, skinUVMaps.leftLeg, false);
                             }
                            // Remove old left leg layer if exists
                            if (leftLegLayerMesh) {
                                leftLegPivot.remove(leftLegLayerMesh);
                                leftLegLayerMesh.geometry.dispose();
                                if (Array.isArray(leftLegLayerMesh.material)) {
                                    leftLegLayerMesh.material.forEach(m => m.dispose());
                                } else {
                                    leftLegLayerMesh.material.dispose();
                                }
                            }
                             // Create new left leg layer (pants)
                             const leftLegLayerGeometry = new THREE.BoxGeometry(0.27 * modelScale, 0.77 * modelScale, 0.27 * modelScale);
                             leftLegLayerMesh = new THREE.Mesh(leftLegLayerGeometry, createBodyPartMaterials(canvas, skinUVMaps.leftLegLayer, true));
                             leftLegLayerMesh.position.copy(leftLeg.position);
                             leftLegLayerMesh.visible = showSkinLayers;
                             leftLegLayerMesh.renderOrder = 1;
                             leftLegPivot.add(leftLegLayerMesh);
                             
                             // Store the full skin texture for hand mesh
                            customSkinTexture = {
                                width: 64,
                                height: 64,
                                data: skinData
                            };
                            
                            // IMPORTANT: Extract and store texture data for the texture editor
                            // This makes the uploaded skin editable in the model customization system
                            if (!modelTextures) modelTextures = {};
                            
                            // Extract each body part's BASE and LAYER textures from the uploaded skin
                            const bodyPartMappings = {
                                'head': { base: skinUVMaps.head, layer: skinUVMaps.headLayer },
                                'torso': { base: skinUVMaps.body, layer: skinUVMaps.bodyLayer },
                                'leftArm': { base: skinUVMaps.leftArm, layer: skinUVMaps.leftArmLayer },
                                'rightArm': { base: skinUVMaps.rightArm, layer: skinUVMaps.rightArmLayer },
                                'leftLeg': { base: skinUVMaps.leftLeg, layer: skinUVMaps.leftLegLayer },
                                'rightLeg': { base: skinUVMaps.rightLeg, layer: skinUVMaps.rightLegLayer }
                            };
                            
                            for (let part in bodyPartMappings) {
                                const maps = bodyPartMappings[part];
                                
                                // Extract base layer textures
                                if (!modelTextures[part]) modelTextures[part] = {};
                                const sides = ['right', 'left', 'top', 'bottom', 'front', 'back'];
                                sides.forEach(side => {
                                    const uv = maps.base[side];
                                    const extractedCanvas = extractSkinRegion(canvas, uv.x, uv.y, uv.w, uv.h);
                                    const extractedCtx = extractedCanvas.getContext('2d');
                                    const extractedData = extractedCtx.getImageData(0, 0, uv.w, uv.h);
                                    modelTextures[part][side] = extractedData;
                                });
                                
                                // Extract outer layer textures (hat, jacket, sleeves, pants)
                                const layerPartName = part + 'Layer';
                                if (!modelTextures[layerPartName]) modelTextures[layerPartName] = {};
                                sides.forEach(side => {
                                    const uv = maps.layer[side];
                                    const extractedCanvas = extractSkinRegion(canvas, uv.x, uv.y, uv.w, uv.h);
                                    const extractedCtx = extractedCanvas.getContext('2d');
                                    const extractedData = extractedCtx.getImageData(0, 0, uv.w, uv.h);
                                    modelTextures[layerPartName][side] = extractedData;
                                });
                            }
                            
                            // Save the texture data to localStorage so it persists
                            saveModelTextures();
                            
                            saveSettings();
                            
                            // Recreate hand mesh with skin texture (including layer)
                            if (fpHandMesh) handScene.remove(fpHandMesh);
                            fpHandMesh = createHandMesh();
                            if (fpHandMesh) {
                                // Make hand bigger and move to bottom-right corner
                                fpHandMesh.scale.set(1.5, 1.5, 1.5); // 1.5x bigger
                                fpHandMesh.userData.basePosition = { x: 0.4, y: -0.35, z: -0.5 }; // Bottom-right corner (Minecraft style)
                                fpHandMesh.userData.baseRotation = { x: 0.15, y: -0.2, z: 0.0 }; // Natural arm holding position (Minecraft style)
                                fpHandMesh.position.set(0.4, -0.35, -0.5);
                                fpHandMesh.rotation.set(0.15, -0.2, 0.0);
                                fpHandMesh.visible = showItemInHand; // Show based on setting
                                handScene.add(fpHandMesh);
                                // Apply textures after creating
                                applyTexturesToModels();
                            }
                            
                            alert(' Skin uploaded successfully! Your custom Minecraft skin with all layers is now active.\n' + 
                                  (img.height === 32 ? '(Legacy 64x32 format - layers duplicated)' : '(Modern 64x64 format)'));
                            saveSettings(); // Save the uploaded skin
                        } else {
                            alert(' Invalid skin dimensions. Please use a 64x64 (modern) or 64x32 (legacy) PNG file following Minecraft skin format.');
                        }
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            });
        }
        
        // NEW: Export Skin System
        if (exportSkinBtn) {
            exportSkinBtn.addEventListener('click', function() {
                // Check if we have a custom skin to export
                if (!customSkinTexture || !customSkinTexture.data) {
                    alert(' No custom skin to export. Please upload a skin first or the default skin cannot be exported.');
                    return;
                }
                
                try {
                    // Create a canvas to reconstruct the skin
                    const canvas = document.createElement('canvas');
                    canvas.width = customSkinTexture.width;
                    canvas.height = customSkinTexture.height;
                    const ctx = canvas.getContext('2d');
                    
                    // Create ImageData from the stored skin data
                    const imageData = ctx.createImageData(canvas.width, canvas.height);
                    for (let i = 0; i < customSkinTexture.data.length; i++) {
                        imageData.data[i] = customSkinTexture.data[i];
                    }
                    ctx.putImageData(imageData, 0, 0);
                    
                    // Convert canvas to blob and download
                    canvas.toBlob(function(blob) {
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'minecraft-skin-' + Date.now() + '.png';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        
                        alert(' Skin exported successfully! Check your downloads folder.');
                    }, 'image/png');
                } catch (error) {
                    console.error('Error exporting skin:', error);
                    alert(' Error exporting skin. Please try again.');
                }
            });
        }
        
        // Download skin template
        if (downloadSkinTemplate) {
            downloadSkinTemplate.addEventListener('click', function(e) {
                e.preventDefault();
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, 64, 64);
                ctx.strokeStyle = '#888888';
                ctx.lineWidth = 1;
                
                // Draw template guides
                ctx.strokeRect(0, 0, 32, 16); // Head layer 1
                ctx.strokeRect(32, 0, 32, 16); // Head layer 2
                ctx.strokeRect(16, 16, 24, 16); // Body layer 1
                ctx.strokeRect(16, 32, 24, 16); // Body layer 2
                ctx.strokeRect(40, 16, 16, 16); // Right arm
                ctx.strokeRect(32, 48, 16, 16); // Left arm
                ctx.strokeRect(0, 16, 16, 16); // Right leg
                ctx.strokeRect(16, 48, 16, 16); // Left leg
                
                canvas.toBlob(function(blob) {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'minecraft_skin_template.png';
                    a.click();
                    URL.revokeObjectURL(url);
                });
            });
        }
        
        // Skin layers toggle
        if (showSkinLayersToggle) {
            showSkinLayersToggle.addEventListener('change', function() {
                showSkinLayers = this.checked;
                saveSettings();
                
                // Update all layer visibility
                updateSkinLayers();
                
                // Recreate hand mesh to update its layer
                if (fpHandMesh) handScene.remove(fpHandMesh);
                fpHandMesh = createHandMesh();
                if (fpHandMesh && showItemInHand) {
                    // Make hand bigger and move to bottom-right corner
                    fpHandMesh.scale.set(1.5, 1.5, 1.5); // 1.5x bigger
                    fpHandMesh.userData.basePosition = { x: 0.4, y: -0.35, z: -0.5 }; // Bottom-right corner (Minecraft style)
                    fpHandMesh.userData.baseRotation = { x: 0.15, y: -0.2, z: 0.0 }; // Natural arm holding position (Minecraft style)
                    fpHandMesh.position.set(0.4, -0.35, -0.5);
                    fpHandMesh.rotation.set(0.15, -0.2, 0.0);
                    handScene.add(fpHandMesh);
                }
            });
            showSkinLayersToggle.checked = showSkinLayers;
        }
        
        // NEW: Hand Bob Intensity Slider
        const handBobIntensitySlider = document.getElementById('handBobIntensitySlider');
        const handBobIntensityValueSpan = document.getElementById('handBobIntensityValue');
        
        if (handBobIntensitySlider && handBobIntensityValueSpan) {
            handBobIntensitySlider.addEventListener('input', function() {
                handBobIntensity = parseInt(this.value);
                handBobIntensityValueSpan.textContent = handBobIntensity;
                updateDefaultIndicator(handBobIntensity, DEFAULT_HAND_BOB_INTENSITY, 'handBobIntensityDefault');
                
                // Sync with quick settings
                const quickSlider = document.getElementById('quick-handBob');
                const quickValue = document.getElementById('quick-handBob-value');
                const quickDefault = document.getElementById('quick-handBob-default');
                if (quickSlider && quickValue) {
                    quickSlider.value = handBobIntensity;
                    quickValue.textContent = handBobIntensity + '%';
                    if (quickDefault) {
                        quickDefault.style.color = handBobIntensity === DEFAULT_HAND_BOB_INTENSITY ? '#79C05A' : 'transparent';
                    }
                }
                
                saveSettings();
            });
            handBobIntensitySlider.value = handBobIntensity;
            handBobIntensityValueSpan.textContent = handBobIntensity;
            updateDefaultIndicator(handBobIntensity, DEFAULT_HAND_BOB_INTENSITY, 'handBobIntensityDefault');
        }
        
        // --- KEYBIND CUSTOMIZATION SYSTEM ---
        
        // Open keybinds modal
        const openKeybindsModalBtn = document.getElementById('openKeybindsModalBtn');
        const keybindsModal = document.getElementById('keybinds-modal');
        const closeKeybindsModalBtn = document.getElementById('closeKeybindsModalBtn');
        
        if (openKeybindsModalBtn && keybindsModal) {
            openKeybindsModalBtn.addEventListener('click', function() {
                keybindsModal.style.display = 'flex';
                initKeybindButtons();
                playClickSound();
            });
        }
        
        if (closeKeybindsModalBtn && keybindsModal) {
            closeKeybindsModalBtn.addEventListener('click', function() {
                keybindsModal.style.display = 'none';
                if (waitingForKey) {
                    waitingForKey.textContent = getKeyDisplay(keybinds[waitingForKey.dataset.action]);
                    waitingForKey.style.background = 'rgba(0, 191, 255, 0.2)';
                    waitingForKey = null;
                }
                playClickSound();
            });
        }
        
        function getKeyDisplay(code) {
            const keyMap = {
                'Space': 'SPACE',
                'ShiftLeft': 'SHIFT',
                'ShiftRight': 'R.SHIFT',
                'ControlLeft': 'CTRL',
                'ControlRight': 'R.CTRL',
                'AltLeft': 'ALT',
                'AltRight': 'R.ALT',
                'Escape': 'ESC',
                'Enter': 'ENTER',
                'Backspace': 'BKSP',
                'Tab': 'TAB',
                'CapsLock': 'CAPS',
                'ArrowUp': '',
                'ArrowDown': '',
                'ArrowLeft': '',
                'ArrowRight': ''
            };
            
            if (keyMap[code]) return keyMap[code];
            if (code.startsWith('Key')) return code.substring(3);
            if (code.startsWith('Digit')) return code.substring(5);
            return code;
        }
        
        // Initialize keybind buttons
        function initKeybindButtons() {
            document.querySelectorAll('.keybind-btn').forEach(btn => {
                const action = btn.dataset.action;
                btn.textContent = getKeyDisplay(keybinds[action]);
                
                btn.addEventListener('click', function(e) {
                    e.preventDefault();
                    if (waitingForKey) {
                        waitingForKey.textContent = getKeyDisplay(keybinds[waitingForKey.dataset.action]);
                        waitingForKey.style.background = 'rgba(0, 191, 255, 0.2)';
                    }
                    
                    waitingForKey = this;
                    this.textContent = 'Press any key...';
                    this.style.background = 'rgba(0, 191, 255, 0.6)';
                    this.style.borderColor = '#00bfff';
                    playClickSound();
                });
            });
        }
        
        // Reset keybinds button
        const resetKeybindsBtn = document.getElementById('resetKeybindsBtn');
        if (resetKeybindsBtn) {
            resetKeybindsBtn.addEventListener('click', function() {
                keybinds = {...DEFAULT_KEYBINDS};
                saveSettings();
                initKeybindButtons();
                playClickSound();
            });
        }
        
        // --- FULLSCREEN WITH KEYBOARD LOCK ---
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        let isFullscreen = false;
        
        async function enterFullscreen() {
            try {
                const elem = document.documentElement;
                
                // Request fullscreen with options to prevent accidental exit
                const options = { navigationUI: "hide" };
                
                if (elem.requestFullscreen) {
                    await elem.requestFullscreen(options);
                } else if (elem.webkitRequestFullscreen) {
                    await elem.webkitRequestFullscreen();
                } else if (elem.mozRequestFullScreen) {
                    await elem.mozRequestFullScreen();
                } else if (elem.msRequestFullscreen) {
                    await elem.msRequestFullscreen();
                }
                
                // Request keyboard lock to prevent browser shortcuts
                try {
                    if (navigator.keyboard && navigator.keyboard.lock) {
                        await navigator.keyboard.lock([
                            'KeyW', 'KeyA', 'KeyS', 'KeyD',
                            'Space', 'ShiftLeft', 'ShiftRight',
                            'ControlLeft', 'ControlRight',
                            'Escape', 'Tab', 'KeyE', 'F11'
                        ]);
                        console.log(' Keyboard lock activated');
                    }
                } catch (e) {
                    console.log(' Keyboard lock not supported:', e.message);
                }
                
                isFullscreen = true;
                if (fullscreenBtn) {
                    fullscreenBtn.textContent = 'EXIT FULLSCREEN';
                    fullscreenBtn.style.background = '#d9534f';
                }
                
                console.log(' Fullscreen activated');
            } catch (err) {
                console.error(' Fullscreen error:', err);
                alert('Fullscreen failed. Try pressing F11 or check browser settings.');
            }
        }
        
        async function exitFullscreen() {
            try {
                if (document.exitFullscreen) {
                    await document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    await document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    await document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    await document.msExitFullscreen();
                }
                
                // Unlock keyboard
                if (navigator.keyboard && navigator.keyboard.unlock) {
                    try {
                        navigator.keyboard.unlock();
                        console.log(' Keyboard unlocked');
                    } catch (e) {
                        console.log(' Keyboard unlock error:', e.message);
                    }
                }
                
                isFullscreen = false;
                if (fullscreenBtn) {
                    fullscreenBtn.textContent = 'ENTER FULLSCREEN';
                    fullscreenBtn.style.background = 'var(--main-action)';
                }
                
                console.log(' Exited fullscreen');
            } catch (err) {
                console.error(' Exit fullscreen error:', err);
            }
        }
        
        if (fullscreenBtn) {
            fullscreenBtn.addEventListener('click', async function() {
                if (!isFullscreen) {
                    await enterFullscreen();
                } else {
                    await exitFullscreen();
                }
                playClickSound();
            });
        }
        
        // F11 key support for fullscreen toggle
        document.addEventListener('keydown', function(e) {
            if (e.key === 'F11') {
                e.preventDefault();
                if (!isFullscreen) {
                    enterFullscreen();
                } else {
                    exitFullscreen();
                }
            }
            
            // F3 key for debug hitbox and info visualization
            if (e.key === 'F3') {
                e.preventDefault();
                showHitbox = !showHitbox;
                hitboxWireframe.visible = showHitbox;
                
                // Show/hide debug info indicator
                const debugInfo = document.getElementById('debug-info');
                debugInfo.style.display = showHitbox ? 'block' : 'none';
                
                // Show/hide game info UI (Day, Time, Coordinates, etc.)
                const uiElement = document.getElementById('ui');
                if (uiElement) {
                    uiElement.style.display = showHitbox ? 'block' : 'none';
                }
                
                // Show/hide FPS based on settings and game state
                const fpsElement = document.getElementById('fps');
                if (fpsElement) {
                    // Show FPS when: (always visible setting + in game) OR debug mode is on
                    fpsElement.style.display = ((fpsAlwaysVisible && currentGameState === GAME_STATE.IN_GAME) || showHitbox) ? 'block' : 'none';
                }
                
                console.log('Debug mode: ' + (showHitbox ? 'ON' : 'OFF'));
            }
            
            // F5 key for perspective switching
            if (e.key === 'F5') {
                e.preventDefault();
                perspectiveMode = (perspectiveMode + 1) % 3;
                console.log('Perspective mode: ' + (perspectiveMode === 0 ? 'First Person' : perspectiveMode === 1 ? 'Third Person (Back)' : 'Third Person (Front)'));
            }
        }, true);
        
        // Handle fullscreen change events - Enhanced stability
        const handleFullscreenChange = () => {
            const fullscreenElement = document.fullscreenElement || 
                                     document.webkitFullscreenElement || 
                                     document.mozFullScreenElement || 
                                     document.msFullscreenElement;
            
            if (!fullscreenElement) {
                isFullscreen = false;
                if (fullscreenBtn) {
                    fullscreenBtn.textContent = 'ENTER FULLSCREEN';
                    fullscreenBtn.style.background = 'var(--main-action)';
                }
                if (navigator.keyboard && navigator.keyboard.unlock) {
                    try {
                        navigator.keyboard.unlock();
                    } catch (e) {
                        console.log('Keyboard unlock error:', e);
                    }
                }
            } else {
                isFullscreen = true;
                if (fullscreenBtn) {
                    fullscreenBtn.textContent = 'EXIT FULLSCREEN';
                    fullscreenBtn.style.background = '#d9534f';
                }
            }
        };
        
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('msfullscreenchange', handleFullscreenChange);
        
        // Prevent default behavior for common browser shortcuts when in game
        document.addEventListener('keydown', function(e) {
            if (locked && !paused) {
                // Prevent browser shortcuts when playing
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                }
            }
        }, true);
        
        // Initialize keybind buttons on load
        initKeybindButtons();
        
        // ==================== AUDIO SLIDERS INITIALIZATION ====================
        // Initialize audio sliders with proper event listeners and saved values
        
        // Helper function to update default indicator
        function updateDefaultIndicator(value, defaultValue, indicatorId) {
            const indicator = document.getElementById(indicatorId);
            if (indicator) {
                indicator.style.display = (value === defaultValue) ? 'inline' : 'none';
            }
        }
        
        function initAudioSliders() {
            if (window.__audioSlidersInitialized) return;
            window.__audioSlidersInitialized = true;
            console.log(' INIT AUDIO SLIDERS - Current values:', {masterVolume, musicVolume, sfxVolume, tabOutMuteLevel});
            
            // Master Volume Slider
            const masterVolumeSlider = document.getElementById('masterVolumeSlider');
            const masterVolumeValueSpan = document.getElementById('masterVolumeValue');
            if (masterVolumeSlider && masterVolumeValueSpan) {
                // Set initial values from loaded settings
                masterVolumeSlider.value = masterVolume * 100;
                masterVolumeValueSpan.textContent = Math.round(masterVolume * 100);
                updateDefaultIndicator(Math.round(masterVolume * 100), DEFAULT_MASTER_VOLUME, 'masterVolumeDefault');
                console.log(' Set master volume slider to:', masterVolume * 100);
                
                // Add event listener
                masterVolumeSlider.addEventListener('input', function() {
                    const value = parseInt(this.value);
                    masterVolumeValueSpan.textContent = value;
                    updateDefaultIndicator(value, DEFAULT_MASTER_VOLUME, 'masterVolumeDefault');
                    updateMasterVolume(value);
                    saveSettings();
                });
            }
            
            // Music Volume Slider
            const musicVolumeSlider = document.getElementById('musicVolumeSlider');
            const musicVolumeValueSpan = document.getElementById('musicVolumeValue');

            if (musicVolumeSlider && musicVolumeValueSpan) {
                // Set initial values from loaded settings
                musicVolumeSlider.value = musicVolume * 100;
                musicVolumeValueSpan.textContent = Math.round(musicVolume * 100);
                updateDefaultIndicator(Math.round(musicVolume * 100), DEFAULT_MUSIC_VOLUME, 'musicVolumeDefault');
                
                // Add event listener
                musicVolumeSlider.addEventListener('input', function() {
                    const value = parseInt(this.value);
                    musicVolumeValueSpan.textContent = value;
                    updateDefaultIndicator(value, DEFAULT_MUSIC_VOLUME, 'musicVolumeDefault');
                    updateMusicVolume(value);
                    saveSettings();
                });
            }
            
            // SFX Volume Slider
            const sfxVolumeSlider = document.getElementById('sfxVolumeSlider');
            const sfxVolumeValueSpan = document.getElementById('sfxVolumeValue');

            if (sfxVolumeSlider && sfxVolumeValueSpan) {
                // Set initial values from loaded settings
                sfxVolumeSlider.value = sfxVolume * 100;
                sfxVolumeValueSpan.textContent = Math.round(sfxVolume * 100);
                updateDefaultIndicator(Math.round(sfxVolume * 100), DEFAULT_SFX_VOLUME, 'sfxVolumeDefault');
                
                // Add event listener
                sfxVolumeSlider.addEventListener('input', function() {
                    const value = parseInt(this.value);
                    sfxVolumeValueSpan.textContent = value;
                    updateDefaultIndicator(value, DEFAULT_SFX_VOLUME, 'sfxVolumeDefault');
                    updateSFXVolume(value);
                    saveSettings();
                });
            }
            
            // Tab Out Mute Slider
            const tabOutMuteSlider = document.getElementById('tabOutMuteSlider');
            const tabOutMuteValueSpan = document.getElementById('tabOutMuteValue');

            if (tabOutMuteSlider && tabOutMuteValueSpan) {
                // Set initial values from loaded settings
                tabOutMuteSlider.value = tabOutMuteLevel * 100;
                tabOutMuteValueSpan.textContent = Math.round(tabOutMuteLevel * 100);
                updateDefaultIndicator(Math.round(tabOutMuteLevel * 100), DEFAULT_TAB_OUT_MUTE, 'tabOutMuteDefault');
                
                // Add event listener
                tabOutMuteSlider.addEventListener('input', function() {
                    const value = parseInt(this.value);
                    tabOutMuteValueSpan.textContent = value;
                    updateDefaultIndicator(value, DEFAULT_TAB_OUT_MUTE, 'tabOutMuteDefault');
                    updateTabOutMuteLevel(value);
                    saveSettings();
                });
            }
            
            // Show Music Toast Toggle
            const showMusicToastToggle = document.getElementById('showMusicToastToggle');
            if (showMusicToastToggle) {
                // Load saved state (default: true)
                const savedState = localStorage.getItem('showMusicToast');
                showMusicToastToggle.checked = savedState !== 'false';
                
                // Update visibility on load
                updateToastVisibility();
                
                // Add event listener
                showMusicToastToggle.addEventListener('change', function() {
                    // Only allow disabling from pause menu, not during active gameplay
                    if (!this.checked && currentGameState === GAME_STATE.IN_GAME) {
                        // Prevent disabling during active gameplay
                        this.checked = true;
                        console.log(' Music toast can only be disabled from the pause menu');
                        return;
                    }
                    
                    // Show notification when disabling from pause menu
                    if (!this.checked && currentGameState === GAME_STATE.PAUSE_MENU) {
                        // Create temporary notification
                        const notification = document.createElement('div');
                        notification.style.cssText = `
                            position: fixed;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            background: rgba(0, 0, 0, 0.9);
                            color: #fff;
                            padding: 20px 40px;
                            border-radius: 8px;
                            border: 2px solid #79C05A;
                            font-family: 'Pixelify Sans', monospace;
                            font-size: 16px;
                            z-index: 10000;
                            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
                            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
                            animation: fadeIn 0.3s ease;
                        `;
                        notification.textContent = ' Music Toast Disabled';
                        document.body.appendChild(notification);
                        
                        // Remove notification after 2 seconds
                        setTimeout(() => {
                            notification.style.opacity = '0';
                            notification.style.transition = 'opacity 0.3s ease';
                            setTimeout(() => notification.remove(), 300);
                        }, 2000);
                    }
                    
                    localStorage.setItem('showMusicToast', this.checked);
                    updateToastVisibility();
                    playClickSound();
                });
            }
            
            // Music Toast Position Selector
            const musicToastPositionSelector = document.getElementById('musicToastPositionSelector');
            const musicToast = document.getElementById('music-toast');
            
            if (musicToastPositionSelector && musicToast) {
                // Load saved position (default: top-left)
                const savedPosition = localStorage.getItem('musicToastPosition') || 'top-left';
                musicToastPositionSelector.value = savedPosition;
                
                // Apply position class
                musicToast.classList.add(`position-${savedPosition}`);
                
                // Add event listener
                musicToastPositionSelector.addEventListener('change', function() {
                    // Remove all position classes
                    musicToast.classList.remove('position-top-left', 'position-top-right', 'position-bottom-left', 'position-bottom-right');
                    
                    // Add new position class
                    musicToast.classList.add(`position-${this.value}`);
                    
                    // Save to localStorage
                    localStorage.setItem('musicToastPosition', this.value);
                    playClickSound();
                });
            }
            
            // Music Toast Click to Expand
            let toastExpandTimeout = null;
            
            if (musicToast) {
                musicToast.addEventListener('click', function() {
                    // Only expand if in pill mode
                    if (!this.classList.contains('pill-mode')) return;
                    
                    console.log(' Expanding music toast...');
                    
                    // Clear any existing timeout
                    if (toastExpandTimeout) {
                        clearTimeout(toastExpandTimeout);
                    }
                    
                    // Add expanded class
                    this.classList.add('expanded');
                    this.classList.remove('pill-mode');
                    
                    // Revert to pill mode after 5 seconds
                    toastExpandTimeout = setTimeout(() => {
                        if (currentGameState === GAME_STATE.IN_GAME) {
                            musicToast.classList.remove('expanded');
                            musicToast.classList.add('pill-mode');
                            console.log(' Reverting to pill mode');
                        }
                    }, 5000);
                });
            }
            
            // Music Track Selector
            const musicTrackSelector = document.getElementById('musicTrackSelector');
            if (musicTrackSelector) {
                // Set initial value from loaded settings
                musicTrackSelector.value = selectedMusicTrack;
                
                // Add event listener
                musicTrackSelector.addEventListener('change', function() {
                    selectedMusicTrack = this.value;
                    saveSettings();
                    
                    // If music is playing, restart it with the new track
                    if (isMusicPlaying) {
                        stopBackgroundMusic();
                        setTimeout(() => {
                            startBackgroundMusic();
                        }, 100);
                    }
                    
                    playClickSound();
                });
            }
            
            // Parallax Speed Slider
            const parallaxSpeedSlider = document.getElementById('parallaxSpeedSlider');
            const parallaxSpeedValueSpan = document.getElementById('parallaxSpeedValue');
            if (parallaxSpeedSlider && parallaxSpeedValueSpan) {
                parallaxSpeedSlider.value = currentParallaxSpeed;
                parallaxSpeedValueSpan.textContent = currentParallaxSpeed;
                
                // Add event listener
                parallaxSpeedSlider.addEventListener('input', function() {
                    const value = parseInt(this.value);
                    currentParallaxSpeed = value;
                    parallaxSpeedValueSpan.textContent = value;
                    
                    // Update animation immediately if in a parallax view
                    const mainMenu = document.getElementById('main-menu');
                    const currentView = document.querySelector('#main-menu .menu-view[style*="display: flex"]');
                    if (currentView && currentView.id !== 'main-controls' && currentView.id !== 'credits-view') {
                        mainMenu.style.animation = `bgParallax ${value}s linear infinite`;
                    }
                });
            }
        }
        
        // Reset Audio Settings Button
        const resetAudioBtn = document.getElementById('resetAudioBtn');
        if (resetAudioBtn) {
            resetAudioBtn.addEventListener('click', function() {
                // Reset all audio settings to defaults
                masterVolume = DEFAULT_MASTER_VOLUME / 100;
                musicVolume = DEFAULT_MUSIC_VOLUME / 100;
                sfxVolume = DEFAULT_SFX_VOLUME / 100;
                tabOutMuteLevel = DEFAULT_TAB_OUT_MUTE / 100;
                
                // Update sliders and displays
                const masterVolumeSlider = document.getElementById('masterVolumeSlider');
                const masterVolumeValueSpan = document.getElementById('masterVolumeValue');
                if (masterVolumeSlider && masterVolumeValueSpan) {
                    masterVolumeSlider.value = DEFAULT_MASTER_VOLUME;
                    masterVolumeValueSpan.textContent = DEFAULT_MASTER_VOLUME;
                    updateDefaultIndicator(DEFAULT_MASTER_VOLUME, DEFAULT_MASTER_VOLUME, 'masterVolumeDefault');
                }
                
                const musicVolumeSlider = document.getElementById('musicVolumeSlider');
                const musicVolumeValueSpan = document.getElementById('musicVolumeValue');
                if (musicVolumeSlider && musicVolumeValueSpan) {
                    musicVolumeSlider.value = DEFAULT_MUSIC_VOLUME;
                    musicVolumeValueSpan.textContent = DEFAULT_MUSIC_VOLUME;
                    updateDefaultIndicator(DEFAULT_MUSIC_VOLUME, DEFAULT_MUSIC_VOLUME, 'musicVolumeDefault');
                }
                
                const sfxVolumeSlider = document.getElementById('sfxVolumeSlider');
                const sfxVolumeValueSpan = document.getElementById('sfxVolumeValue');
                if (sfxVolumeSlider && sfxVolumeValueSpan) {
                    sfxVolumeSlider.value = DEFAULT_SFX_VOLUME;
                    sfxVolumeValueSpan.textContent = DEFAULT_SFX_VOLUME;
                    updateDefaultIndicator(DEFAULT_SFX_VOLUME, DEFAULT_SFX_VOLUME, 'sfxVolumeDefault');
                }
                
                const tabOutMuteSlider = document.getElementById('tabOutMuteSlider');
                const tabOutMuteValueSpan = document.getElementById('tabOutMuteValue');
                if (tabOutMuteSlider && tabOutMuteValueSpan) {
                    tabOutMuteSlider.value = DEFAULT_TAB_OUT_MUTE;
                    tabOutMuteValueSpan.textContent = DEFAULT_TAB_OUT_MUTE;
                    updateDefaultIndicator(DEFAULT_TAB_OUT_MUTE, DEFAULT_TAB_OUT_MUTE, 'tabOutMuteDefault');
                }
                
                // Reset music track selector to random
                selectedMusicTrack = 'random';
                const musicTrackSelector = document.getElementById('musicTrackSelector');
                if (musicTrackSelector) {
                    musicTrackSelector.value = 'random';
                }
                
                // Apply the volume changes
                updateMasterVolume(DEFAULT_MASTER_VOLUME);
                updateMusicVolume(DEFAULT_MUSIC_VOLUME);
                updateSFXVolume(DEFAULT_SFX_VOLUME);
                updateTabOutMuteLevel(DEFAULT_TAB_OUT_MUTE);
                
                // Save settings
                saveSettings();
                
                // Play confirmation sound
                playClickSound();
                
                console.log(' Audio settings reset to defaults');
            });
        }
        
        // Reset Video Settings Button
        const resetVideoBtn = document.getElementById('resetVideoBtn');
        if (resetVideoBtn) {
            resetVideoBtn.addEventListener('click', function() {
                // Reset video settings to defaults
                renderDistance = DEFAULT_RENDER_DISTANCE;
                fieldOfView = DEFAULT_FOV;
                
                // Update sliders and displays
                const renderDistanceSlider = document.getElementById('renderDistanceSlider');
                const renderDistanceValueSpan = document.getElementById('renderDistanceValue');
                if (renderDistanceSlider && renderDistanceValueSpan) {
                    renderDistanceSlider.value = DEFAULT_RENDER_DISTANCE;
                    renderDistanceValueSpan.textContent = DEFAULT_RENDER_DISTANCE;
                    updateDefaultIndicator(DEFAULT_RENDER_DISTANCE, DEFAULT_RENDER_DISTANCE, 'renderDistanceDefault');
                }
                
                const fovSlider = document.getElementById('fovSlider');
                const fovValueSpan = document.getElementById('fovValue');
                if (fovSlider && fovValueSpan) {
                    fovSlider.value = DEFAULT_FOV;
                    fovValueSpan.textContent = DEFAULT_FOV;
                    updateDefaultIndicator(DEFAULT_FOV, DEFAULT_FOV, 'fovDefault');
                    camera.fov = DEFAULT_FOV;
                    camera.updateProjectionMatrix();
                }
                
                // Save settings
                saveSettings();
                
                // Play feedback sound
                playClickSound();
                
                console.log(' Video settings reset to defaults');
            });
        }
        
        // Reset Controls Settings Button
        const resetControlsBtn = document.getElementById('resetControlsBtn');
        if (resetControlsBtn) {
            resetControlsBtn.addEventListener('click', function() {
                // Reset controls settings to defaults
                mouseSensitivity = DEFAULT_MOUSE_SENSITIVITY / 100;
                handBobIntensity = DEFAULT_HAND_BOB_INTENSITY;
                
                // Update sliders and displays
                const sensitivitySlider = document.getElementById('sensitivitySlider');
                const sensitivityValueSpan = document.getElementById('sensitivityValue');
                if (sensitivitySlider && sensitivityValueSpan) {
                    sensitivitySlider.value = DEFAULT_MOUSE_SENSITIVITY;
                    sensitivityValueSpan.textContent = DEFAULT_MOUSE_SENSITIVITY;
                    updateDefaultIndicator(DEFAULT_MOUSE_SENSITIVITY, DEFAULT_MOUSE_SENSITIVITY, 'sensitivityDefault');
                }
                
                const handBobIntensitySlider = document.getElementById('handBobIntensitySlider');
                const handBobIntensityValueSpan = document.getElementById('handBobIntensityValue');
                if (handBobIntensitySlider && handBobIntensityValueSpan) {
                    handBobIntensitySlider.value = DEFAULT_HAND_BOB_INTENSITY;
                    handBobIntensityValueSpan.textContent = DEFAULT_HAND_BOB_INTENSITY;
                    updateDefaultIndicator(DEFAULT_HAND_BOB_INTENSITY, DEFAULT_HAND_BOB_INTENSITY, 'handBobIntensityDefault');
                }
                
                // Save settings
                saveSettings();
                
                // Play feedback sound
                playClickSound();
                
                console.log(' Controls settings reset to defaults');
            });
        }
        
        // ==================== GRAPHICS PRESETS SYSTEM ====================
        const graphicsPresets = {
            ultra: {
                name: 'Ultra',
                renderDistance: 50
            },
            high: {
                name: 'High',
                renderDistance: 40
            },
            medium: {
                name: 'Medium',
                renderDistance: 30
            },
            low: {
                name: 'Low',
                renderDistance: 20
            },
            potato: {
                name: 'Potato',
                renderDistance: 15
            }
        };
        
        function applyGraphicsPreset(presetName) {
            if (!presetName || !graphicsPresets[presetName]) return;
            
            const preset = graphicsPresets[presetName];
            
            // Apply render distance (in blocks)
            const quickRenderSlider = document.getElementById('quick-renderDistance');
            const quickRenderValue = document.getElementById('quick-renderDistance-value');
            const detailedRenderSlider = document.getElementById('renderDistanceSlider');
            const detailedRenderValue = document.getElementById('renderDistanceValue');
            
            if (quickRenderSlider && quickRenderValue) {
                quickRenderSlider.value = preset.renderDistance;
                quickRenderValue.textContent = preset.renderDistance + ' blocks';
            }
            
            if (detailedRenderSlider && detailedRenderValue) {
                detailedRenderSlider.value = preset.renderDistance;
                detailedRenderValue.textContent = preset.renderDistance;
                updateDefaultIndicator(preset.renderDistance, DEFAULT_RENDER_DISTANCE, 'renderDistanceDefault');
            }
            
            // Update global renderDistance
            renderDistance = preset.renderDistance;
            
            // Track the change
            trackSettingChange('Graphics Preset', preset.name);
            
            // Save settings
            saveSettings();
            
            // Play feedback sound
            playClickSound();
            
            console.log(` Applied ${preset.name} graphics preset`);
        }
        
        // Graphics preset selector event listener
        const graphicsPresetSelect = document.getElementById('graphicsPreset');
        if (graphicsPresetSelect) {
            graphicsPresetSelect.addEventListener('change', function() {
                const presetName = this.value;
                if (presetName) {
                    applyGraphicsPreset(presetName);
                }
            });
        }
        
        // ==================== SETTINGS HISTORY SYSTEM ====================
        let settingsHistory = [];
        const MAX_HISTORY_ITEMS = 10;
        
        function trackSettingChange(settingName, newValue) {
            const timestamp = new Date().toLocaleTimeString();
            const historyItem = {
                setting: settingName,
                value: newValue,
                time: timestamp
            };
            
            // Add to beginning of array
            settingsHistory.unshift(historyItem);
            
            // Keep only the last MAX_HISTORY_ITEMS
            if (settingsHistory.length > MAX_HISTORY_ITEMS) {
                settingsHistory = settingsHistory.slice(0, MAX_HISTORY_ITEMS);
            }
            
            // Update the display
            updateSettingsHistoryDisplay();
            
            // Save to localStorage
            try {
                localStorage.setItem('settingsHistory', JSON.stringify(settingsHistory));
            } catch (e) {
                console.warn('Could not save settings history:', e);
            }
        }
        
        function updateSettingsHistoryDisplay() {
            const historyContainer = document.getElementById('settings-history');
            if (!historyContainer) return;
            
            if (settingsHistory.length === 0) {
                historyContainer.innerHTML = '<p style="font-size: 12px; color: #666; text-align: center; padding: 20px;">No recent changes</p>';
                return;
            }
            
            let html = '<div style="display: flex; flex-direction: column; gap: 8px;">';
            settingsHistory.forEach((item, index) => {
                html += `
                    <div style="padding: 10px; background: rgba(0,0,0,0.3); border-radius: 4px; border: 1px solid rgba(255,255,255,0.1);">
                        <div style="font-size: 12px; font-weight: bold; color: var(--main-action); margin-bottom: 4px;">${item.setting}</div>
                        <div style="font-size: 11px; color: #ccc;">Value: ${item.value}</div>
                        <div style="font-size: 10px; color: #666; margin-top: 4px;">${item.time}</div>
                    </div>
                `;
            });
            html += '</div>';
            
            historyContainer.innerHTML = html;
        }
        
        function clearSettingsHistory() {
            settingsHistory = [];
            updateSettingsHistoryDisplay();
            try {
                localStorage.removeItem('settingsHistory');
            } catch (e) {
                console.warn('Could not clear settings history:', e);
            }
            playClickSound();
            console.log(' Settings history cleared');
        }
        
        // Load settings history on startup
        function loadSettingsHistory() {
            try {
                const saved = localStorage.getItem('settingsHistory');
                if (saved) {
                    settingsHistory = JSON.parse(saved);
                    updateSettingsHistoryDisplay();
                }
            } catch (e) {
                console.warn('Could not load settings history:', e);
            }
        }
        
        // Initialize settings history
        loadSettingsHistory();
        
        // ==================== SETTINGS SEARCH FILTER ====================
        const allSettings = [
            { name: 'Render Distance', page: 'video', element: 'renderDistanceSlider' },
            { name: 'Field of View', page: 'video', element: 'fovSlider' },
            { name: 'FOV', page: 'video', element: 'fovSlider' },
            { name: 'Mouse Sensitivity', page: 'controls', element: 'sensitivitySlider' },
            { name: 'Sensitivity', page: 'controls', element: 'sensitivitySlider' },
            { name: 'Keybinds', page: 'controls', element: 'openKeybindsModalBtn' },
            { name: 'Controls', page: 'controls', element: 'sensitivitySlider' },
            { name: 'Hand Bobbing', page: 'controls', element: 'handBobToggle' },
            { name: 'Bob Intensity', page: 'controls', element: 'handBobIntensitySlider' },
            { name: 'Master Volume', page: 'audio', element: 'masterVolumeSlider' },
            { name: 'Music Volume', page: 'audio', element: 'musicVolumeSlider' },
            { name: 'Volume', page: 'audio', element: 'masterVolumeSlider' },
            { name: 'Audio', page: 'audio', element: 'masterVolumeSlider' },
            { name: 'Sound', page: 'audio', element: 'masterVolumeSlider' }
        ];
        
        function searchSettings(searchTerm) {
            const searchResults = document.getElementById('searchResults');
            if (!searchResults) return;
            
            if (!searchTerm || searchTerm.length < 2) {
                searchResults.style.display = 'none';
                return;
            }
            
            const term = searchTerm.toLowerCase();
            const matches = allSettings.filter(setting => 
                setting.name.toLowerCase().includes(term)
            );
            
            if (matches.length === 0) {
                searchResults.style.display = 'block';
                searchResults.innerHTML = '<p style="color: #888; font-size: 12px; padding: 10px;">No settings found</p>';
                return;
            }
            
            let html = '<div style="display: flex; flex-direction: column; gap: 5px;">';
            // Remove duplicates based on page
            const uniqueMatches = matches.filter((match, index, self) => 
                index === self.findIndex(m => m.page === match.page && m.element === match.element)
            );
            
            uniqueMatches.forEach(match => {
                html += `
                    <button onclick="navigateToSetting('${match.page}')" style="padding: 10px; background: rgba(0,191,255,0.2); border: 1px solid var(--main-action); border-radius: 4px; color: white; font-family: inherit; cursor: pointer; text-align: left; transition: all 0.2s;" onmouseover="this.style.background='rgba(0,191,255,0.3)'" onmouseout="this.style.background='rgba(0,191,255,0.2)'">
                        <div style="font-size: 13px; font-weight: bold;">${match.name}</div>
                        <div style="font-size: 11px; color: #aaa; text-transform: uppercase;">${match.page} settings</div>
                    </button>
                `;
            });
            html += '</div>';
            
            searchResults.style.display = 'block';
            searchResults.innerHTML = html;
        }
        
        function navigateToSetting(page) {
            // Hide search results
            const searchResults = document.getElementById('searchResults');
            if (searchResults) searchResults.style.display = 'none';
            
            // Clear search input
            const searchInput = document.getElementById('settingsSearchInput');
            if (searchInput) searchInput.value = '';
            
            // Navigate to appropriate settings page
            if (page === 'video') {
                showVideoSettings();
            } else if (page === 'controls') {
                showControlSettings();
            } else if (page === 'audio') {
                showAudioSettings();
            }
            
            playClickSound();
        }
        
        // ==================== UPDATE FUNCTIONS ====================
        function updateRenderDistance() {
            const renderSlider = document.getElementById('quick-render-distance');
            if (renderSlider) {
                renderDistance = parseInt(renderSlider.value);
                saveSettings();
            }
        }
        
        function updateFOV() {
            const fovSlider = document.getElementById('quick-fov');
            if (fovSlider && camera) {
                fieldOfView = parseInt(fovSlider.value);
                camera.fov = fieldOfView;
                camera.updateProjectionMatrix();
                saveSettings();
            }
        }
        
        // ==================== END NEW SETTINGS FEATURES ====================
        
        // ==================== PRESET COMPARISON TOOL ====================
        let selectedComparisonPreset = null;
        
        function showPresetComparison() {
            const modal = document.getElementById('preset-comparison-modal');
            const presetSelect = document.getElementById('graphicsPreset');
            const compareSelect = document.getElementById('presetCompareSelect');
            
            if (!modal || !presetSelect) return;
            
            // Set initial comparison preset
            if (compareSelect) {
                compareSelect.value = 'ultra';
                selectedComparisonPreset = 'ultra';
            }
            
            updateComparisonTable();
            modal.style.display = 'flex';
            playClickSound();
        }
        
        function closePresetComparison() {
            const modal = document.getElementById('preset-comparison-modal');
            if (modal) {
                modal.style.display = 'none';
                playClickSound();
            }
        }
        
        function updateComparisonTable() {
            const compareSelect = document.getElementById('presetCompareSelect');
            const comparisonTable = document.getElementById('comparisonTable');
            
            if (!compareSelect || !comparisonTable) return;
            
            const presetName = compareSelect.value;
            selectedComparisonPreset = presetName;
            const preset = graphicsPresets[presetName];
            
            if (!preset) return;
            
            // Get current values
            const currentRenderDist = renderDistance || 5;
            
            let html = `
                <table style="width: 100%; color: white; font-size: 13px;">
                    <thead>
                        <tr style="border-bottom: 2px solid rgba(255,255,255,0.2);">
                            <th style="padding: 10px; text-align: left;">Setting</th>
                            <th style="padding: 10px; text-align: center;">Current</th>
                            <th style="padding: 10px; text-align: center;">${preset.name}</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr style="border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <td style="padding: 10px;">Render Distance</td>
                            <td style="padding: 10px; text-align: center;">${currentRenderDist} chunks</td>
                            <td style="padding: 10px; text-align: center; color: var(--main-action); font-weight: bold;">${preset.renderDistance} chunks</td>
                        </tr>
                    </tbody>
                </table>
            `;
            
            comparisonTable.innerHTML = html;
        }
        
        function applyComparedPreset() {
            if (selectedComparisonPreset) {
                const presetSelect = document.getElementById('graphicsPreset');
                if (presetSelect) {
                    presetSelect.value = selectedComparisonPreset;
                }
                applyGraphicsPreset(selectedComparisonPreset);
            }
            closePresetComparison();
        }
        
        // Update comparison table when preset selection changes
        const compareSelect = document.getElementById('presetCompareSelect');
        if (compareSelect) {
            compareSelect.addEventListener('change', updateComparisonTable);
        }
        
        // ==================== QUICK SETTINGS CUSTOMIZATION ====================
        const availableQuickSettings = [
            { id: 'renderDistance', name: 'Render Distance', type: 'slider', min: 10, max: 50, value: 'renderDistance', suffix: ' blocks' },
            { id: 'fov', name: 'Field of View', type: 'slider', min: 50, max: 110, value: 'fieldOfView', suffix: '' },
            { id: 'sensitivity', name: 'Mouse Sensitivity', type: 'slider', min: 25, max: 200, value: 'mouseSensitivity', suffix: '%' },
            { id: 'masterVolume', name: 'Master Volume', type: 'slider', min: 0, max: 100, value: 'masterVolume', suffix: '%' },
            { id: 'musicVolume', name: 'Music Volume', type: 'slider', min: 0, max: 100, value: 'musicVolume', suffix: '%' },
            { id: 'handBob', name: 'Hand Bob Intensity', type: 'slider', min: 0, max: 200, value: 'handBobIntensity', suffix: '%' }
        ];
        
        let activeQuickSettings = ['renderDistance', 'fov', 'sensitivity']; // Default
        
        function customizeQuickSettings() {
            const modal = document.getElementById('quick-settings-modal');
            const optionsContainer = document.getElementById('quickSettingsOptions');
            
            if (!modal || !optionsContainer) return;
            
            // Generate options
            let html = '';
            availableQuickSettings.forEach(setting => {
                const isActive = activeQuickSettings.includes(setting.id);
                html += `
                    <label style="display: flex; align-items: center; gap: 10px; padding: 12px; background: rgba(0,0,0,0.4); border-radius: 4px; cursor: pointer; border: 2px solid ${isActive ? 'var(--main-action)' : 'rgba(255,255,255,0.1)'};">
                        <input type="checkbox" value="${setting.id}" ${isActive ? 'checked' : ''} style="width: 20px; height: 20px; cursor: pointer;">
                        <span style="color: white; flex: 1;">${setting.name}</span>
                    </label>
                `;
            });
            
            optionsContainer.innerHTML = html;
            modal.style.display = 'flex';
            playClickSound();
        }
        
        function closeQuickSettingsModal() {
            const modal = document.getElementById('quick-settings-modal');
            if (modal) {
                modal.style.display = 'none';
                playClickSound();
            }
        }
        
        function saveQuickSettings() {
            const optionsContainer = document.getElementById('quickSettingsOptions');
            if (!optionsContainer) return;
            
            const checkboxes = optionsContainer.querySelectorAll('input[type="checkbox"]');
            activeQuickSettings = [];
            
            checkboxes.forEach(checkbox => {
                if (checkbox.checked && activeQuickSettings.length < 6) {
                    activeQuickSettings.push(checkbox.value);
                }
            });
            
            // Save to localStorage
            try {
                localStorage.setItem('activeQuickSettings', JSON.stringify(activeQuickSettings));
            } catch (e) {
                console.warn('Could not save quick settings:', e);
            }
            
            // Regenerate quick settings panel
            generateQuickSettingsPanel();
            
            closeQuickSettingsModal();
            playClickSound();
            console.log(' Quick settings saved');
        }
        
        function generateQuickSettingsPanel() {
            const container = document.getElementById('quickSettingsContainer');
            if (!container) return;
            
            let html = '';
            activeQuickSettings.forEach(settingId => {
                const setting = availableQuickSettings.find(s => s.id === settingId);
                if (!setting) return;
                
                const currentValue = getCurrentSettingValue(setting);
                
                // Get default value for this setting
                let defaultValue;
                if (settingId === 'renderDistance') defaultValue = DEFAULT_RENDER_DISTANCE;
                else if (settingId === 'fov') defaultValue = DEFAULT_FOV;
                else if (settingId === 'sensitivity') defaultValue = DEFAULT_MOUSE_SENSITIVITY;
                else if (settingId === 'handBob') defaultValue = DEFAULT_HAND_BOB_INTENSITY;
                else defaultValue = null;
                
                const isDefault = defaultValue !== null && currentValue === defaultValue;
                
                html += `
                    <div style="padding: 15px; background: rgba(0,0,0,0.3); border-radius: 4px; border: 1px solid rgba(255,255,255,0.1);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="font-size: 13px; color: white;">${setting.name}</span>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span id="quick-${setting.id}-value" style="font-size: 13px; color: var(--main-action); font-weight: bold;">${currentValue}${setting.suffix}</span>
                                ${defaultValue !== null ? '<span style="color: ' + (isDefault ? '#79C05A' : 'transparent') + '; font-size: 0.9em;" id="quick-' + setting.id + '-default"> Default</span>' : ''}
                            </div>
                        </div>
                        <input type="range" id="quick-${setting.id}" class="custom-slider" min="${setting.min}" max="${setting.max}" value="${currentValue}" oninput="updateQuickSetting('${setting.id}')" style="width: 100%;">
                    </div>
                `;
            });
            
            container.innerHTML = html || '<p style="color: #888; text-align: center; padding: 20px;">No quick settings selected</p>';
        }
        
        function getCurrentSettingValue(setting) {
            // Return current value based on setting type
            if (setting.id === 'renderDistance') return renderDistance || DEFAULT_RENDER_DISTANCE;
            if (setting.id === 'fov') return (camera ? camera.fov : 75);
            if (setting.id === 'sensitivity') return Math.round((mouseSensitivity || 1.0) * 100);
            if (setting.id === 'masterVolume') return 100; // Placeholder
            if (setting.id === 'musicVolume') return 50; // Placeholder
            if (setting.id === 'handBob') return handBobIntensity || 100;
            return setting.min;
        }
        
        function updateQuickSetting(settingId) {
            const slider = document.getElementById(`quick-${settingId}`);
            const valueDisplay = document.getElementById(`quick-${settingId}-value`);
            const defaultIndicator = document.getElementById(`quick-${settingId}-default`);
            const setting = availableQuickSettings.find(s => s.id === settingId);
            
            if (!slider || !valueDisplay || !setting) return;
            
            const value = parseInt(slider.value);
            valueDisplay.textContent = value + setting.suffix;
            
            // Get default value for this setting
            let defaultValue;
            if (settingId === 'renderDistance') defaultValue = DEFAULT_RENDER_DISTANCE;
            else if (settingId === 'fov') defaultValue = DEFAULT_FOV;
            else if (settingId === 'sensitivity') defaultValue = DEFAULT_MOUSE_SENSITIVITY;
            else if (settingId === 'handBob') defaultValue = DEFAULT_HAND_BOB_INTENSITY;
            else defaultValue = null;
            
            // Update default indicator for quick settings
            if (defaultIndicator && defaultValue !== null) {
                if (value === defaultValue) {
                    defaultIndicator.style.color = '#79C05A';
                    defaultIndicator.textContent = ' Default';
                } else {
                    defaultIndicator.style.color = 'transparent';
                }
            }
            
            // Update the actual setting and sync with detailed settings
            if (settingId === 'renderDistance') {
                renderDistance = value;
                const detailedSlider = document.getElementById('renderDistanceSlider');
                if (detailedSlider) {
                    detailedSlider.value = value;
                    const detailedValue = document.getElementById('renderDistanceValue');
                    if (detailedValue) detailedValue.textContent = value;
                    updateDefaultIndicator(value, DEFAULT_RENDER_DISTANCE, 'renderDistanceDefault');
                }
            } else if (settingId === 'fov') {
                if (camera) {
                    camera.fov = value;
                    camera.updateProjectionMatrix();
                }
                fieldOfView = value;
                const detailedSlider = document.getElementById('fovSlider');
                if (detailedSlider) {
                    detailedSlider.value = value;
                    const detailedValue = document.getElementById('fovValue');
                    if (detailedValue) detailedValue.textContent = value;
                    updateDefaultIndicator(value, DEFAULT_FOV, 'fovDefault');
                }
            } else if (settingId === 'sensitivity') {
                mouseSensitivity = value / 100;
                const detailedSlider = document.getElementById('sensitivitySlider');
                if (detailedSlider) {
                    detailedSlider.value = value;
                    const detailedValue = document.getElementById('sensitivityValue');
                    if (detailedValue) detailedValue.textContent = value;
                    updateDefaultIndicator(value, DEFAULT_MOUSE_SENSITIVITY, 'sensitivityDefault');
                }
            } else if (settingId === 'handBob') {
                handBobIntensity = value;
                const detailedSlider = document.getElementById('handBobIntensitySlider');
                if (detailedSlider) {
                    detailedSlider.value = value;
                    const detailedValue = document.getElementById('handBobIntensityValue');
                    if (detailedValue) detailedValue.textContent = value;
                    updateDefaultIndicator(value, DEFAULT_HAND_BOB_INTENSITY, 'handBobIntensityDefault');
                }
            }
            
            trackSettingChange(setting.name, value + setting.suffix);
            saveSettings();
        }
        
        // Load quick settings on startup
        function loadQuickSettings() {
            try {
                const saved = localStorage.getItem('activeQuickSettings');
                if (saved) {
                    activeQuickSettings = JSON.parse(saved);
                }
            } catch (e) {
                console.warn('Could not load quick settings:', e);
            }
            generateQuickSettingsPanel();
        }
        
        // Initialize quick settings
        loadQuickSettings();
        
        // ==================== MODEL TEXTURE CUSTOMIZATION SYSTEM ====================
        let currentBodyPart = 'head';
        let currentTextureSide = 'front';
        let selectedTextureColor = '#d4a574';
        let isTexturePainting = false;
        
        // Texture dimensions for each body part (width x height in pixels for each side)
        // Function to get texture dimensions based on skin type
        function getTexturePartDimensions() {
            const armWidth = isSlimSkin ? 3 : 4;
            return {
                head: { front: {w: 8, h: 8}, back: {w: 8, h: 8}, left: {w: 8, h: 8}, right: {w: 8, h: 8}, top: {w: 8, h: 8}, bottom: {w: 8, h: 8} },
                headLayer: { front: {w: 8, h: 8}, back: {w: 8, h: 8}, left: {w: 8, h: 8}, right: {w: 8, h: 8}, top: {w: 8, h: 8}, bottom: {w: 8, h: 8} },
                torso: { front: {w: 8, h: 12}, back: {w: 8, h: 12}, left: {w: 4, h: 12}, right: {w: 4, h: 12}, top: {w: 8, h: 4}, bottom: {w: 8, h: 4} },
                torsoLayer: { front: {w: 8, h: 12}, back: {w: 8, h: 12}, left: {w: 4, h: 12}, right: {w: 4, h: 12}, top: {w: 8, h: 4}, bottom: {w: 8, h: 4} },
                leftArm: { front: {w: armWidth, h: 12}, back: {w: armWidth, h: 12}, left: {w: armWidth, h: 12}, right: {w: armWidth, h: 12}, top: {w: armWidth, h: 4}, bottom: {w: armWidth, h: 4} },
                leftArmLayer: { front: {w: armWidth, h: 12}, back: {w: armWidth, h: 12}, left: {w: armWidth, h: 12}, right: {w: armWidth, h: 12}, top: {w: armWidth, h: 4}, bottom: {w: armWidth, h: 4} },
                rightArm: { front: {w: armWidth, h: 12}, back: {w: armWidth, h: 12}, left: {w: armWidth, h: 12}, right: {w: armWidth, h: 12}, top: {w: armWidth, h: 4}, bottom: {w: armWidth, h: 4} },
                rightArmLayer: { front: {w: armWidth, h: 12}, back: {w: armWidth, h: 12}, left: {w: armWidth, h: 12}, right: {w: armWidth, h: 12}, top: {w: armWidth, h: 4}, bottom: {w: armWidth, h: 4} },
                leftLeg: { front: {w: 4, h: 12}, back: {w: 4, h: 12}, left: {w: 4, h: 12}, right: {w: 4, h: 12}, top: {w: 4, h: 4}, bottom: {w: 4, h: 4} },
                leftLegLayer: { front: {w: 4, h: 12}, back: {w: 4, h: 12}, left: {w: 4, h: 12}, right: {w: 4, h: 12}, top: {w: 4, h: 4}, bottom: {w: 4, h: 4} },
                rightLeg: { front: {w: 4, h: 12}, back: {w: 4, h: 12}, left: {w: 4, h: 12}, right: {w: 4, h: 12}, top: {w: 4, h: 4}, bottom: {w: 4, h: 4} },
                rightLegLayer: { front: {w: 4, h: 12}, back: {w: 4, h: 12}, left: {w: 4, h: 12}, right: {w: 4, h: 12}, top: {w: 4, h: 4}, bottom: {w: 4, h: 4} },
                fpHand: { front: {w: armWidth, h: 12}, back: {w: armWidth, h: 12}, left: {w: armWidth, h: 12}, right: {w: armWidth, h: 12}, top: {w: armWidth, h: 4}, bottom: {w: armWidth, h: 4} }
            };
        }
        
        let texturePartDimensions = getTexturePartDimensions();
        
        // Store textures as ImageData for each part and side
        let modelTextures = {};
        
        function initializeModelTextures() {
            for (let part in texturePartDimensions) {
                modelTextures[part] = {};
                for (let side in texturePartDimensions[part]) {
                    const dims = texturePartDimensions[part][side];
                    const canvas = document.createElement('canvas');
                    canvas.width = dims.w;
                    canvas.height = dims.h;
                    const ctx = canvas.getContext('2d');
                    
                    // Default color based on part
                    // Layer parts (hat, jacket, sleeves, pants) are transparent by default
                    if (part.includes('Layer')) {
                        // Transparent - don't fill
                        ctx.clearRect(0, 0, dims.w, dims.h);
                    } else {
                        // Base parts have colors
                        let defaultColor = '#d4a574'; // skin tone
                        if (part === 'torso') defaultColor = '#4080ff'; // blue shirt
                        if (part.includes('Leg')) defaultColor = '#404080'; // blue pants
                        
                        ctx.fillStyle = defaultColor;
                        ctx.fillRect(0, 0, dims.w, dims.h);
                    }
                    
                    modelTextures[part][side] = ctx.getImageData(0, 0, dims.w, dims.h);
                }
            }
        }
        
        function openModelCustomizer() {
            const modal = document.getElementById('model-customizer-modal');
            if (!modal) return;
            loadModelTextures();
            if (Object.keys(modelTextures).length === 0) {
                initializeModelTextures();
            }
            initTextureColorPalette();
            selectBodyPart('head');
            selectTextureSide('front');
            modal.style.display = 'flex';
            
            // Initialize 3D preview
            if (!previewScene) {
                init3DPreview();
            }
            
            // Apply current textures to both game models and preview
            applyTexturesToModels();
            update3DPreview();
            
            playClickSound();
        }
        
        function closeModelCustomizer() {
            const modal = document.getElementById('model-customizer-modal');
            if (modal) {
                modal.style.display = 'none';
                playClickSound();
            }
        }
        
        function selectBodyPart(part) {
            currentBodyPart = part;
            document.querySelectorAll('.part-selector-btn').forEach(btn => {
                if (btn.dataset.part === part) {
                    btn.style.background = 'var(--main-action)';
                } else {
                    btn.style.background = 'rgba(255,255,255,0.2)';
                }
            });
            renderTextureCanvas();
            playClickSound();
        }
        
        function selectTextureSide(side) {
            currentTextureSide = side;
            document.querySelectorAll('.side-selector-btn').forEach(btn => {
                if (btn.dataset.side === side) {
                    btn.style.background = 'var(--main-action)';
                } else {
                    btn.style.background = 'rgba(255,255,255,0.2)';
                }
            });
            renderTextureCanvas();
            playClickSound();
        }
        
        function initTextureColorPalette() {
            const palette = document.getElementById('textureColorPalette');
            if (!palette) return;
            
            const colors = [
                '#d4a574', '#8b5a2b', '#4a2511', '#2c1810',
                '#f5deb3', '#ffffff', '#000000', '#808080',
                '#4080ff', '#404080', '#00ff00', '#ff0000',
                '#ffff00', '#ff8800', '#8b4513', '#a0522d'
            ];
            
            palette.innerHTML = '';
            colors.forEach(color => {
                const btn = document.createElement('button');
                btn.style.cssText = `width: 30px; height: 30px; background: ${color}; border: 2px solid #666; cursor: pointer; border-radius: 3px; transition: all 0.2s;`;
                btn.onclick = () => {
                    selectedTextureColor = color;
                    document.getElementById('textureCustomColor').value = color;
                    playClickSound();
                };
                btn.onmouseenter = () => { btn.style.transform = 'scale(1.1)'; };
                btn.onmouseleave = () => { btn.style.transform = 'scale(1)'; };
                palette.appendChild(btn);
            });
            
            const customColorPicker = document.getElementById('textureCustomColor');
            if (customColorPicker) {
                customColorPicker.addEventListener('input', (e) => {
                    selectedTextureColor = e.target.value;
                });
            }
        }
        
        function renderTextureCanvas() {
            const canvas = document.getElementById('texturePixelGrid');
            if (!canvas) return;
            
            const dims = texturePartDimensions[currentBodyPart][currentTextureSide];
            const texture = modelTextures[currentBodyPart]?.[currentTextureSide];
            
            if (!texture) return;
            
            const ctx = canvas.getContext('2d');
            const pixelSize = 192 / Math.max(dims.w, dims.h);
            
            // Clear canvas with checkerboard
            ctx.fillStyle = '#555';
            ctx.fillRect(0, 0, 192, 192);
            
            // Draw texture with pixel grid
            for (let y = 0; y < dims.h; y++) {
                for (let x = 0; x < dims.w; x++) {
                    const i = (y * dims.w + x) * 4;
                    const r = texture.data[i];
                    const g = texture.data[i + 1];
                    const b = texture.data[i + 2];
                    const a = texture.data[i + 3];
                    
                    if (a > 0) {
                        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a / 255})`;
                        ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                    }
                }
            }
            
            // Draw grid lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.lineWidth = 1;
            for (let y = 0; y <= dims.h; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * pixelSize);
                ctx.lineTo(dims.w * pixelSize, y * pixelSize);
                ctx.stroke();
            }
            for (let x = 0; x <= dims.w; x++) {
                ctx.beginPath();
                ctx.moveTo(x * pixelSize, 0);
                ctx.lineTo(x * pixelSize, dims.h * pixelSize);
                ctx.stroke();
            }
            
            // Update 3D preview in real-time
            update3DPreview();
        }
        
        // ========== 3D PREVIEW SYSTEM ==========
        let previewScene, previewCamera, previewRenderer;
        let previewPlayerGroup, previewHead, previewBody, previewLeftArm, previewRightArm, previewLeftLeg, previewRightLeg;
        let previewHeadLayer, previewBodyLayer, previewLeftArmLayer, previewRightArmLayer, previewLeftLegLayer, previewRightLegLayer;
        let previewRotation = 0;
        let previewAutoRotate = true;
        
        function init3DPreview() {
            const canvas = document.getElementById('texturePreview3D');
            if (!canvas) return;
            
            // Create scene
            previewScene = new THREE.Scene();
            previewScene.background = new THREE.Color(0x87CEEB);
            
            // Camera
            previewCamera = new THREE.PerspectiveCamera(45, 300/400, 0.1, 1000);
            previewCamera.position.set(0, 1.5, 4);
            previewCamera.lookAt(0, 1, 0);
            
            // Renderer
            previewRenderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            previewRenderer.setSize(300, 400);
            previewRenderer.shadowMap.enabled = true;
            
            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            previewScene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 5);
            dirLight.castShadow = true;
            previewScene.add(dirLight);
            
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
            fillLight.position.set(-5, 5, -5);
            previewScene.add(fillLight);
            
            // Create player model
            const modelScale = 2;
            previewPlayerGroup = new THREE.Group();
            
            // Head
            const headGeometry = new THREE.BoxGeometry(0.5 * modelScale, 0.5 * modelScale, 0.5 * modelScale);
            previewHead = new THREE.Mesh(headGeometry, new THREE.MeshLambertMaterial({ color: 0xd4a574 }));
            previewHead.position.set(0, 1.5 * modelScale, 0);
            previewPlayerGroup.add(previewHead);
            
            // Head layer
            const headLayerGeometry = new THREE.BoxGeometry(0.52 * modelScale, 0.52 * modelScale, 0.52 * modelScale);
            previewHeadLayer = new THREE.Mesh(headLayerGeometry, new THREE.MeshLambertMaterial({ transparent: true, opacity: 0 }));
            previewHeadLayer.position.copy(previewHead.position);
            previewPlayerGroup.add(previewHeadLayer);
            
            // Body
            const bodyGeometry = new THREE.BoxGeometry(0.5 * modelScale, 0.75 * modelScale, 0.25 * modelScale);
            previewBody = new THREE.Mesh(bodyGeometry, new THREE.MeshLambertMaterial({ color: 0x4080ff }));
            previewBody.position.set(0, 0.875 * modelScale, 0);
            previewPlayerGroup.add(previewBody);
            
            // Body layer
            const bodyLayerGeometry = new THREE.BoxGeometry(0.52 * modelScale, 0.77 * modelScale, 0.27 * modelScale);
            previewBodyLayer = new THREE.Mesh(bodyLayerGeometry, new THREE.MeshLambertMaterial({ transparent: true, opacity: 0 }));
            previewBodyLayer.position.copy(previewBody.position);
            previewPlayerGroup.add(previewBodyLayer);
            
            // Arms
            const armWidth = isSlimSkin ? 0.1875 * modelScale : 0.25 * modelScale;
            const armGeometry = new THREE.BoxGeometry(armWidth, 0.75 * modelScale, 0.25 * modelScale);
            
            previewRightArm = new THREE.Mesh(armGeometry, new THREE.MeshLambertMaterial({ color: 0xd4a574 }));
            previewRightArm.position.set(-0.375 * modelScale, 0.875 * modelScale, 0);
            previewPlayerGroup.add(previewRightArm);
            
            previewLeftArm = new THREE.Mesh(armGeometry, new THREE.MeshLambertMaterial({ color: 0xd4a574 }));
            previewLeftArm.position.set(0.375 * modelScale, 0.875 * modelScale, 0);
            previewPlayerGroup.add(previewLeftArm);
            
            // Arm layers
            const armLayerWidth = isSlimSkin ? 0.2075 * modelScale : 0.27 * modelScale;
            const armLayerGeometry = new THREE.BoxGeometry(armLayerWidth, 0.77 * modelScale, 0.27 * modelScale);
            
            previewRightArmLayer = new THREE.Mesh(armLayerGeometry, new THREE.MeshLambertMaterial({ transparent: true, opacity: 0 }));
            previewRightArmLayer.position.copy(previewRightArm.position);
            previewPlayerGroup.add(previewRightArmLayer);
            
            previewLeftArmLayer = new THREE.Mesh(armLayerGeometry, new THREE.MeshLambertMaterial({ transparent: true, opacity: 0 }));
            previewLeftArmLayer.position.copy(previewLeftArm.position);
            previewPlayerGroup.add(previewLeftArmLayer);
            
            // Legs
            const legGeometry = new THREE.BoxGeometry(0.25 * modelScale, 0.75 * modelScale, 0.25 * modelScale);
            
            previewRightLeg = new THREE.Mesh(legGeometry, new THREE.MeshLambertMaterial({ color: 0x404080 }));
            previewRightLeg.position.set(-0.125 * modelScale, 0.125 * modelScale, 0);
            previewPlayerGroup.add(previewRightLeg);
            
            previewLeftLeg = new THREE.Mesh(legGeometry, new THREE.MeshLambertMaterial({ color: 0x404080 }));
            previewLeftLeg.position.set(0.125 * modelScale, 0.125 * modelScale, 0);
            previewPlayerGroup.add(previewLeftLeg);
            
            // Leg layers
            const legLayerGeometry = new THREE.BoxGeometry(0.27 * modelScale, 0.77 * modelScale, 0.27 * modelScale);
            
            previewRightLegLayer = new THREE.Mesh(legLayerGeometry, new THREE.MeshLambertMaterial({ transparent: true, opacity: 0 }));
            previewRightLegLayer.position.copy(previewRightLeg.position);
            previewPlayerGroup.add(previewRightLegLayer);
            
            previewLeftLegLayer = new THREE.Mesh(legLayerGeometry, new THREE.MeshLambertMaterial({ transparent: true, opacity: 0 }));
            previewLeftLegLayer.position.copy(previewLeftLeg.position);
            previewPlayerGroup.add(previewLeftLegLayer);
            
            previewScene.add(previewPlayerGroup);
            
            // Auto-rotate toggle
            const autoRotateToggle = document.getElementById('autoRotateToggle');
            if (autoRotateToggle) {
                autoRotateToggle.addEventListener('change', (e) => {
                    previewAutoRotate = e.target.checked;
                });
            }
            
            // Start animation loop
            animate3DPreview();
        }
        
        function update3DPreview() {
            if (!previewPlayerGroup) return;
            
            // Update all body part textures
            const createMaterialArray = (partTextures, partName) => {
                if (!partTextures) return null;
                
                const sides = ['right', 'left', 'top', 'bottom', 'front', 'back'];
                const isLayer = partName.includes('Layer');
                
                return sides.map(side => {
                    const textureData = partTextures[side];
                    if (!textureData) {
                        let color = 0xd4a574;
                        if (partName === 'torso') color = 0x4080ff;
                        if (partName.includes('Leg')) color = 0x404080;
                        return new THREE.MeshLambertMaterial({ 
                            color,
                            transparent: isLayer,
                            opacity: isLayer ? 0 : 1,
                            depthWrite: !isLayer
                        });
                    }
                    
                    const dims = texturePartDimensions[partName][side];
                    const canvas = document.createElement('canvas');
                    canvas.width = dims.w;
                    canvas.height = dims.h;
                    const ctx = canvas.getContext('2d');
                    ctx.putImageData(textureData, 0, 0);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    texture.magFilter = THREE.NearestFilter;
                    texture.minFilter = THREE.NearestFilter;
                    
                    return new THREE.MeshLambertMaterial({ 
                        map: texture,
                        transparent: isLayer,
                        alphaTest: isLayer ? 0.1 : 0,
                        depthWrite: !isLayer
                    });
                });
            };
            
            if (modelTextures.head) previewHead.material = createMaterialArray(modelTextures.head, 'head');
            if (modelTextures.headLayer) previewHeadLayer.material = createMaterialArray(modelTextures.headLayer, 'headLayer');
            if (modelTextures.torso) previewBody.material = createMaterialArray(modelTextures.torso, 'torso');
            if (modelTextures.torsoLayer) previewBodyLayer.material = createMaterialArray(modelTextures.torsoLayer, 'torsoLayer');
            if (modelTextures.leftArm) previewLeftArm.material = createMaterialArray(modelTextures.leftArm, 'leftArm');
            if (modelTextures.leftArmLayer) previewLeftArmLayer.material = createMaterialArray(modelTextures.leftArmLayer, 'leftArmLayer');
            if (modelTextures.rightArm) previewRightArm.material = createMaterialArray(modelTextures.rightArm, 'rightArm');
            if (modelTextures.rightArmLayer) previewRightArmLayer.material = createMaterialArray(modelTextures.rightArmLayer, 'rightArmLayer');
            if (modelTextures.leftLeg) previewLeftLeg.material = createMaterialArray(modelTextures.leftLeg, 'leftLeg');
            if (modelTextures.leftLegLayer) previewLeftLegLayer.material = createMaterialArray(modelTextures.leftLegLayer, 'leftLegLayer');
            if (modelTextures.rightLeg) previewRightLeg.material = createMaterialArray(modelTextures.rightLeg, 'rightLeg');
            if (modelTextures.rightLegLayer) previewRightLegLayer.material = createMaterialArray(modelTextures.rightLegLayer, 'rightLegLayer');
        }
        
        function animate3DPreview() {
            requestAnimationFrame(animate3DPreview);
            
            if (previewPlayerGroup && previewAutoRotate) {
                previewRotation += 0.01;
                previewPlayerGroup.rotation.y = previewRotation;
            }
            
            if (previewRenderer && previewScene && previewCamera) {
                previewRenderer.render(previewScene, previewCamera);
            }
        }
        
        function renderTextureCanvas() {
            const canvas = document.getElementById('texturePixelGrid');
            if (!canvas) return;
            
            const dims = texturePartDimensions[currentBodyPart][currentTextureSide];
            const texture = modelTextures[currentBodyPart]?.[currentTextureSide];
            
            if (!texture) return;
            
            const ctx = canvas.getContext('2d');
            const pixelSize = 192 / Math.max(dims.w, dims.h);
            
            // Clear canvas with checkerboard background
            ctx.fillStyle = '#444';
            ctx.fillRect(0, 0, 192, 192);
            
            // Draw texture with transparency support
            for (let y = 0; y < dims.h; y++) {
                for (let x = 0; x < dims.w; x++) {
                    const i = (y * dims.w + x) * 4;
                    const r = texture.data[i];
                    const g = texture.data[i + 1];
                    const b = texture.data[i + 2];
                    const a = texture.data[i + 3];
                    
                    if (a > 0) {
                        ctx.fillStyle = `rgba(${r},${g},${b},${a / 255})`;
                        ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                    }
                }
            }
            
            // Draw pixel grid
            ctx.strokeStyle = 'rgba(255,255,255,0.15)';
            ctx.lineWidth = 1;
            for (let x = 0; x <= dims.w; x++) {
                ctx.beginPath();
                ctx.moveTo(x * pixelSize, 0);
                ctx.lineTo(x * pixelSize, dims.h * pixelSize);
                ctx.stroke();
            }
            for (let y = 0; y <= dims.h; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * pixelSize);
                ctx.lineTo(dims.w * pixelSize, y * pixelSize);
                ctx.stroke();
            }
            
            // Update 3D preview
            update3DPreview();
        }
        
        function setupTextureCanvasEvents() {
            const canvas = document.getElementById('texturePixelGrid');
            if (!canvas) return;
            
            const paintPixel = (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const dims = texturePartDimensions[currentBodyPart][currentTextureSide];
                const pixelSize = 192 / Math.max(dims.w, dims.h);
                
                const px = Math.floor(x / pixelSize);
                const py = Math.floor(y / pixelSize);
                
                if (px >= 0 && px < dims.w && py >= 0 && py < dims.h) {
                    const texture = modelTextures[currentBodyPart][currentTextureSide];
                    const i = (py * dims.w + px) * 4;
                    
                    // Shift+Click to erase (make transparent)
                    if (e.shiftKey) {
                        texture.data[i] = 0;
                        texture.data[i + 1] = 0;
                        texture.data[i + 2] = 0;
                        texture.data[i + 3] = 0;
                    } else {
                        // Parse selected color and paint
                        const hex = selectedTextureColor.replace('#', '');
                        const r = parseInt(hex.substr(0, 2), 16);
                        const g = parseInt(hex.substr(2, 2), 16);
                        const b = parseInt(hex.substr(4, 2), 16);
                        
                        texture.data[i] = r;
                        texture.data[i + 1] = g;
                        texture.data[i + 2] = b;
                        texture.data[i + 3] = 255;
                    }
                    
                    renderTextureCanvas();
                }
            };
            
            canvas.onmousedown = (e) => {
                isTexturePainting = true;
                paintPixel(e);
            };
            
            canvas.onmousemove = (e) => {
                if (isTexturePainting) paintPixel(e);
            };
            
            canvas.onmouseup = () => { isTexturePainting = false; };
            canvas.onmouseleave = () => { isTexturePainting = false; };
        }
        
        function clearCurrentTexture() {
            const dims = texturePartDimensions[currentBodyPart][currentTextureSide];
            const texture = modelTextures[currentBodyPart][currentTextureSide];
            
            for (let i = 0; i < texture.data.length; i += 4) {
                texture.data[i] = 0;
                texture.data[i + 1] = 0;
                texture.data[i + 2] = 0;
                texture.data[i + 3] = 0;
            }
            
            renderTextureCanvas();
            playClickSound();
        }
        
        function resetAllTextures() {
            if (!confirm('Reset all textures to default?')) return;
            initializeModelTextures();
            renderTextureCanvas();
            playClickSound();
        }
        
        function saveModelTextures() {
            try {
                // Auto-sync fpHand with rightArm
                if (modelTextures.rightArm) {
                    modelTextures.fpHand = {};
                    for (let side in modelTextures.rightArm) {
                        // Deep copy the texture data
                        const sourceData = modelTextures.rightArm[side];
                        const newData = new Uint8ClampedArray(sourceData.data);
                        modelTextures.fpHand[side] = new ImageData(newData, sourceData.width, sourceData.height);
                    }
                }
                
                // Convert ImageData to serializable format with dimensions
                // Save EVERY layer and texture with complete information
                const serialized = {};
                const dimensions = {};
                
                for (let part in modelTextures) {
                    if (!modelTextures[part]) continue;
                    
                    serialized[part] = {};
                    dimensions[part] = {};
                    
                    for (let side in modelTextures[part]) {
                        const textureData = modelTextures[part][side];
                        if (!textureData) continue;
                        
                        // Save texture pixel data
                        serialized[part][side] = Array.from(textureData.data);
                        
                        // Save dimensions for each side
                        if (texturePartDimensions[part] && texturePartDimensions[part][side]) {
                            dimensions[part][side] = {
                                w: textureData.width || texturePartDimensions[part][side].w,
                                h: textureData.height || texturePartDimensions[part][side].h
                            };
                        } else {
                            dimensions[part][side] = {
                                w: textureData.width,
                                h: textureData.height
                            };
                        }
                    }
                }
                
                // Save to localStorage with metadata
                const saveData = {
                    textures: serialized,
                    dimensions: dimensions,
                    skinType: isSlimSkin ? 'slim' : 'classic',
                    timestamp: Date.now(),
                    version: '2.0' // Version for future compatibility
                };
                
                localStorage.setItem('modelTextures', JSON.stringify(saveData));
                
                // Also save dimensions separately for backward compatibility
                localStorage.setItem('modelTextureDimensions', JSON.stringify(texturePartDimensions));
                
                // Apply textures to 3D models
                applyTexturesToModels();
                
                // Also save to settings for persistence
                saveSettings();
                
                alert(' All model textures and layers saved successfully!\n(FP Hand synced with Right Arm)');
            } catch (e) {
                console.error('Could not save model textures:', e);
                alert(' Error saving textures: ' + e.message);
            }
            closeModelCustomizer();
        }
        
        function loadModelTextures() {
            try {
                const saved = localStorage.getItem('modelTextures');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    
                    // Handle new format (v2.0) with dimensions
                    let serialized, savedDimensions;
                    if (parsed.textures && parsed.dimensions) {
                        // New format
                        serialized = parsed.textures;
                        savedDimensions = parsed.dimensions;
                        
                        // Restore skin type if saved
                        if (parsed.skinType === 'slim' && !isSlimSkin) {
                            isSlimSkin = true;
                            texturePartDimensions = getTexturePartDimensions();
                            if (typeof createArms === 'function') createArms();
                        } else if (parsed.skinType === 'classic' && isSlimSkin) {
                            isSlimSkin = false;
                            texturePartDimensions = getTexturePartDimensions();
                            if (typeof createArms === 'function') createArms();
                        }
                    } else {
                        // Old format (backward compatibility)
                        serialized = parsed;
                        savedDimensions = {};
                    }
                    
                    // Load all textures with their saved dimensions
                    for (let part in serialized) {
                        if (!modelTextures[part]) modelTextures[part] = {};
                        
                        for (let side in serialized[part]) {
                            // Get dimensions from saved data or fallback
                            let dims;
                            if (savedDimensions[part] && savedDimensions[part][side]) {
                                dims = savedDimensions[part][side];
                            } else if (texturePartDimensions[part] && texturePartDimensions[part][side]) {
                                dims = texturePartDimensions[part][side];
                            } else {
                                dims = { w: 8, h: 8 }; // Fallback
                            }
                            
                            const data = new Uint8ClampedArray(serialized[part][side]);
                            modelTextures[part][side] = new ImageData(data, dims.w, dims.h);
                        }
                    }
                    
                    console.log(' Loaded all model textures and layers from localStorage');
                }
                
                // If no saved textures, ensure defaults are initialized
                if (Object.keys(modelTextures).length === 0) {
                    initializeModelTextures();
                }
            } catch (e) {
                console.warn('Could not load model textures:', e);
                // Initialize defaults on error
                if (Object.keys(modelTextures).length === 0) {
                    initializeModelTextures();
                }
            }
        }
        
        function applyTexturesToModels() {
            // Safety check - don't apply if textures aren't initialized
            if (!modelTextures || Object.keys(modelTextures).length === 0) {
                return;
            }
            if (!texturePartDimensions || Object.keys(texturePartDimensions).length === 0) {
                return;
            }
            
            // Helper to create material array for a body part
            // Three.js BoxGeometry face order: [right, left, top, bottom, front, back]
            const createMaterialArray = (partTextures, partName) => {
                if (!partTextures) return null;
                
                const sides = ['right', 'left', 'top', 'bottom', 'front', 'back'];
                const isLayer = partName.includes('Layer'); // Check if this is a layer part
                
                return sides.map(side => {
                    const textureData = partTextures[side];
                    if (!textureData) {
                        // Fallback to default color
                        let color = 0xd4a574;
                        if (partName === 'torso') color = 0x4080ff;
                        if (partName.includes('Leg')) color = 0x404080;
                        return new THREE.MeshLambertMaterial({ 
                            color,
                            transparent: isLayer,
                            opacity: isLayer ? 0 : 1,
                            depthWrite: !isLayer
                        });
                    }
                    
                    const dims = texturePartDimensions && texturePartDimensions[partName] && texturePartDimensions[partName][side]
                        ? texturePartDimensions[partName][side]
                        : { w: 8, h: 8 }; // Fallback dimensions
                    const canvas = document.createElement('canvas');
                    canvas.width = dims.w;
                    canvas.height = dims.h;
                    const ctx = canvas.getContext('2d');
                    ctx.putImageData(textureData, 0, 0);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    texture.magFilter = THREE.NearestFilter;
                    texture.minFilter = THREE.NearestFilter;
                    
                    return new THREE.MeshLambertMaterial({ 
                        map: texture,
                        transparent: isLayer, // Layers support transparency
                        alphaTest: isLayer ? 0.1 : 0, // Only render pixels with alpha > 0.1 for layers
                        depthWrite: !isLayer
                    });
                });
            };
            
            // Apply to head
            if (headMesh && modelTextures.head) {
                const materials = createMaterialArray(modelTextures.head, 'head');
                if (materials) {
                    headMesh.material = materials;
                }
            }
            
            // Apply to torso
            if (bodyMesh && modelTextures.torso) {
                const materials = createMaterialArray(modelTextures.torso, 'torso');
                if (materials) {
                    bodyMesh.material = materials;
                }
            }
            
            // Apply to left arm
            if (leftArm && modelTextures.leftArm) {
                const materials = createMaterialArray(modelTextures.leftArm, 'leftArm');
                if (materials) {
                    leftArm.material = materials;
                }
            }
            
            // Apply to right arm
            if (rightArm && modelTextures.rightArm) {
                const materials = createMaterialArray(modelTextures.rightArm, 'rightArm');
                if (materials) {
                    rightArm.material = materials;
                }
            }
            
            // Apply to left leg
            if (leftLeg && modelTextures.leftLeg) {
                const materials = createMaterialArray(modelTextures.leftLeg, 'leftLeg');
                if (materials) {
                    leftLeg.material = materials;
                }
            }
            
            // Apply to right leg
            if (rightLeg && modelTextures.rightLeg) {
                const materials = createMaterialArray(modelTextures.rightLeg, 'rightLeg');
                if (materials) {
                    rightLeg.material = materials;
                }
            }
            
            // Apply to first-person hand - always use rightArm texture
            // fpHandMesh is a Group, so we need to find the child meshes
            if (fpHandMesh && modelTextures.rightArm) {
                const materials = createMaterialArray(modelTextures.rightArm, 'rightArm');
                if (materials) {
                    // Find the base hand mesh (renderOrder 0)
                    fpHandMesh.traverse((child) => {
                        if (child.type === 'Mesh' && child.renderOrder === 0) {
                            child.material = materials;
                        }
                    });
                }
            }
            
            // Apply to first-person hand layer (sleeve)
            // fpHandLayerMesh is stored globally but is also a child of fpHandMesh group
            if (fpHandLayerMesh && modelTextures.rightArmLayer) {
                const layerMaterials = createMaterialArray(modelTextures.rightArmLayer, 'rightArmLayer');
                if (layerMaterials) {
                    fpHandLayerMesh.material = layerMaterials;
                    fpHandLayerMesh.visible = showSkinLayers; // Show based on setting
                }
            } else if (fpHandMesh && modelTextures.rightArmLayer) {
                // Fallback: find layer mesh in group if fpHandLayerMesh not set
                const layerMaterials = createMaterialArray(modelTextures.rightArmLayer, 'rightArmLayer');
                if (layerMaterials) {
                    fpHandMesh.traverse((child) => {
                        if (child.type === 'Mesh' && child.renderOrder === 1) {
                            child.material = layerMaterials;
                            child.visible = showSkinLayers;
                        }
                    });
                }
            }
            
            // Also apply if old heldItemMesh was a hand (legacy support)
            if (heldItemMesh && heldItemMesh.type === 'Mesh' && !heldItemMesh.userData.isItem) {
                const materials = createMaterialArray(modelTextures.rightArm, 'rightArm');
                if (materials) {
                    heldItemMesh.material = materials;
                }
            }
            
            // Apply LAYER textures (hat, jacket, sleeves, pants)
            // Apply to head layer (hat)
            if (headLayerMesh && modelTextures.headLayer) {
                const materials = createMaterialArray(modelTextures.headLayer, 'headLayer');
                if (materials) {
                    headLayerMesh.material = materials;
                    headLayerMesh.visible = showSkinLayers; // Only show when texture is applied
                }
            }
            
            // Apply to torso layer (jacket)
            if (bodyLayerMesh && modelTextures.torsoLayer) {
                const materials = createMaterialArray(modelTextures.torsoLayer, 'torsoLayer');
                if (materials) {
                    bodyLayerMesh.material = materials;
                    bodyLayerMesh.visible = showSkinLayers; // Only show when texture is applied
                }
            }
            
            // Apply to left arm layer (sleeve)
            if (leftArmLayerMesh && modelTextures.leftArmLayer) {
                const materials = createMaterialArray(modelTextures.leftArmLayer, 'leftArmLayer');
                if (materials) {
                    leftArmLayerMesh.material = materials;
                    leftArmLayerMesh.visible = showSkinLayers; // Only show when texture is applied
                }
            }
            
            // Apply to right arm layer (sleeve)
            if (rightArmLayerMesh && modelTextures.rightArmLayer) {
                const materials = createMaterialArray(modelTextures.rightArmLayer, 'rightArmLayer');
                if (materials) {
                    rightArmLayerMesh.material = materials;
                    rightArmLayerMesh.visible = showSkinLayers; // Only show when texture is applied
                }
            }
            
            // Apply to left leg layer (pants)
            if (leftLegLayerMesh && modelTextures.leftLegLayer) {
                const materials = createMaterialArray(modelTextures.leftLegLayer, 'leftLegLayer');
                if (materials) {
                    leftLegLayerMesh.material = materials;
                    leftLegLayerMesh.visible = showSkinLayers; // Only show when texture is applied
                }
            }
            
            // Apply to right leg layer (pants)
            if (rightLegLayerMesh && modelTextures.rightLegLayer) {
                const materials = createMaterialArray(modelTextures.rightLegLayer, 'rightLegLayer');
                if (materials) {
                    rightLegLayerMesh.material = materials;
                    rightLegLayerMesh.visible = showSkinLayers; // Only show when texture is applied
                }
            }
            
            // Apply to first-person hand layer (sleeve)
            if (fpHandLayerMesh && modelTextures.rightArmLayer) {
                const materials = createMaterialArray(modelTextures.rightArmLayer, 'rightArmLayer');
                if (materials) {
                    fpHandLayerMesh.material = materials;
                }
            }
            
            console.log(' Textures applied to all 6 sides of 3D models (base + layers)');
        }
        
        // Initialize texture system when modal opens
        setTimeout(() => {
            setupTextureCanvasEvents();
        }, 100);
        
        // ==================== END NEW FEATURES ====================
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initAudioSliders);
        } else {
            initAudioSliders();
        }
        // ==================== END AUDIO SLIDERS INITIALIZATION ====================
        
        
        // ==================== ADD SOUND EFFECTS TO ALL BUTTONS ====================
        // Add click sound to all buttons
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize audio sliders after DOM is ready
            initAudioSliders();
            
            const allButtons = document.querySelectorAll('button, .main-menu-btn');
            
            allButtons.forEach(button => {
                // Click sound
                button.addEventListener('click', function() {
                    playClickSound();
                });
                
                // Hover sound (only once per hover)
                let isHovering = false;
                button.addEventListener('mouseenter', function() {
                    if (!isHovering) {
                        isHovering = true;
                        playHoverSound();
                    }
                });
                button.addEventListener('mouseleave', function() {
                    isHovering = false;
                });
            });
            
            // Start background music when main menu is visible
            setTimeout(() => {
                if (document.getElementById('main-menu').style.display !== 'none') {
                    startBackgroundMusic();
                }
            }, 500);
        });
        // END NEW
        
        // NEW: Game Mode Toggle Listener
        if (gameModeToggleBtn) {
            gameModeToggleBtn.addEventListener('click', toggleGameMode);
        }


        // --- Game Start Logic (CREATE WORLD) ---
        document.getElementById('createWorldBtn').addEventListener('click', function() {
            const seedInput = document.getElementById('seedInput').value;
            const flatWorldCheckbox = document.getElementById('flatWorldCheckbox');
            const worldBorderCheckbox = document.getElementById('worldBorderCheckbox');
            
            WORLD_SEED = seedInput ? parseInt(seedInput) : Math.floor(Math.random() * 1000000); 
            isFlatWorld = flatWorldCheckbox.checked; // NEW: Set flat world option
            worldBorderEnabled = worldBorderCheckbox.checked; // NEW: Set world border option
            
            // Prompt for world name
            let worldName = prompt('Enter a name for your world:', 'My World ' + WORLD_SEED);
            
            // FIX: Only proceed if user didn't cancel the prompt
            if (worldName === null) {
                // User cancelled, don't create the world
                return;
            }
            
            // Use default name if empty string
            if (!worldName || worldName.trim() === '') {
                worldName = 'World_' + WORLD_SEED;
            }
            
            resetPlayer();
            generateWorld();
            generateInventorySlots(); // This now also generates the block picker
            updateToolbarSelection(); 
            updateGameModeButtonText(); // Set initial button text
            
            // Initialize game start time
            window.gameStartTime = Date.now();
            
            // Save the new world
            const savedWorldName = saveWorld(worldName);
            
            // If save failed (quota exceeded), don't start the game
            if (!savedWorldName) {
                // Reset to prevent being stuck
                return;
            }
            
            startAutoSave(worldName);

            const mainMenuEl = document.getElementById('main-menu');
            mainMenuEl.style.display = 'none';
            // Stop parallax animation completely during gameplay
            mainMenuEl.style.animation = 'none';
            mainMenuEl.style.backgroundColor = 'transparent';
            
            // Set game state to IN_GAME
            setGameState(GAME_STATE.IN_GAME);
            
            // Hide parallax/starfield effect when game starts
            const starfieldCanvas = document.getElementById('starfield-bg');
            if (starfieldCanvas) {
                starfieldCanvas.classList.remove('active');
                starfieldCanvas.style.opacity = '0';
            }
            
            // Music continues playing during gameplay
            // MODIFIED: Use cross-browser requestLock function
            requestLock(renderer.domElement); 
            document.getElementById('crosshair').style.display = 'block';
            document.getElementById('toolbar').style.display = 'flex'; // FIX: Show the hotbar
            document.getElementById('health-container').style.display = 'block'; // Show health
            document.getElementById('fps').style.display = (fpsAlwaysVisible && currentGameState === GAME_STATE.IN_GAME) ? 'block' : 'none'; // FPS only in-game
            const uiElement = document.getElementById('ui');
            if (uiElement) uiElement.style.display = 'none'; // Hidden by default, toggle with F3
            const debugInfoElement = document.getElementById('debug-info');
            if (debugInfoElement) debugInfoElement.style.display = 'none'; // Hidden by default, toggle with F3
            
            if (!window.gameLoopStarted) {
                loop();
                window.gameLoopStarted = true;
            }
        });
        
        // --- Input and Raycasting ---
        
        // --- REFACTORED: Global Mouse Move Listener ---
        document.addEventListener('mousemove', function(e) {
            if (inventoryOpen) {
                // --- FAKE CURSOR MOVEMENT ---
                if (locked) {
                    // Pointer lock active: use deltas
                    fakeCursorX += e.movementX;
                    fakeCursorY += e.movementY;
                } else {
                    // No pointer lock: use absolute mouse position
                    fakeCursorX = e.clientX;
                    fakeCursorY = e.clientY;
                }

                // Clamp to screen bounds
                fakeCursorX = Math.max(0, Math.min(window.innerWidth - 1, fakeCursorX));
                fakeCursorY = Math.max(0, Math.min(window.innerHeight - 1, fakeCursorY));

                // Apply style
                if (fakeCursorElement) {
                    fakeCursorElement.style.left = fakeCursorX + 'px';
                    fakeCursorElement.style.top = fakeCursorY + 'px';
                }
                
                // Handle scrollbar dragging
                const scrollbarWrapper = document.getElementById('crafting-recipes-wrapper');
                if (scrollbarWrapper && window.isDraggingScrollbar && window.handleScrollbarDrag) {
                    window.handleScrollbarDrag(fakeCursorY);
                }
                
                // Make picked-up item follow cursor
                if (pickedUpItem && pickedUpItemElement) {
                    pickedUpItemElement.style.left = fakeCursorX + 'px';
                    pickedUpItemElement.style.top = fakeCursorY + 'px'; 
                }

            } else if (locked && !paused && !inventoryOpen) {
                // --- CAMERA ROTATION (with sensitivity) ---
                ry -= e.movementX * 0.002 * mouseSensitivity;
                rx -= e.movementY * 0.002 * mouseSensitivity;
                // Clamp pitch to avoid gimbal and oscillations in 3rd-person while still allowing near-vertical look
                const PITCH_LIMIT = Math.PI / 2 - 0.05;
                rx = Math.max(-PITCH_LIMIT, Math.min(PITCH_LIMIT, rx));
            }
        });


        renderer.domElement.addEventListener('wheel', function(e) {
            if (!locked || paused || inventoryOpen) return; // Prevent hotbar changes when inventory is open
            e.preventDefault();
            
            const HUD_SIZE = HUD_WIDTH; 

            if (e.deltaY > 0) { sel = (sel + 1) % HUD_SIZE; } 
            else if (e.deltaY < 0) { sel = (sel - 1 + HUD_SIZE) % HUD_SIZE; }
            
            updateToolbarSelection();
        });

        var ray = new THREE.Raycaster();
        ray.far = 15;
        
        // --- MINECRAFT-ACCURATE MINING SYSTEM ---
        let isLeftMouseDown = false;
        let miningTarget = null; // {x, y, z, progress, requiredTime, crackOverlay}
        let isRightMouseDown = false;
        let placingCooldown = 0;
        let breakingCooldown = 0; // Cooldown after breaking a block
        const PLACE_DELAY = 1.0; // 1 second between placements
        const BREAK_COOLDOWN_SURVIVAL = 0.1; // 0.1 second cooldown after breaking in survival
        const BREAK_COOLDOWN_CREATIVE = 0.25; // 0.25 second cooldown after breaking in creative
        
        // Mining times in seconds (based on Minecraft)
        const MINING_TIMES = {
            // Block types with their mining times
            stone: { hand: 6.0, pickaxe: 1.5 },
            dirt: { hand: 2.0, tool: 0.5 },
            wood: { hand: 3.2, axe: 0.8 },
            planks: { hand: 2.8, axe: 0.7 },
            sand: { hand: 1.6, tool: 0.4 },
            grass: { hand: 0.5, tool: 0.5 },
            leaves: { hand: 0.2, tool: 0.2 }
        };
        
        // Function to determine mining time based on block and tool
        function getMiningTime(blockType, toolType) {
            if (isCreativeMode) return 0; // Instant break in creative
            
            const hudIndex = getHUDIndex(sel);
            const heldItem = inventoryData[hudIndex];
            const itemType = heldItem ? heldItem.type : null;
            
            // Check if holding a tool
            const isPickaxe = itemType < 0 && itemDefinitions[itemType]?.isPickaxe;
            const isAxe = itemType < 0 && itemDefinitions[itemType]?.isAxe;
            const hasTool = isPickaxe || isAxe || (itemType < 0 && itemDefinitions[itemType]?.isTool);
            
            // Map block types to mining times
            switch(blockType) {
                case 2: // Stone (STONE_TYPE)
                case 5: // Bedrock (BEDROCK_TYPE) 
                case 12: // Cobblestone (COBBLESTONE_TYPE)
                    return isPickaxe ? MINING_TIMES.stone.pickaxe : MINING_TIMES.stone.hand;
                    
                case 1: // Dirt (DIRT_TYPE)
                    return hasTool ? MINING_TIMES.dirt.tool : MINING_TIMES.dirt.hand;
                    
                case 3: // Wood (WOOD_TYPE)
                    return isAxe ? MINING_TIMES.wood.axe : MINING_TIMES.wood.hand;
                    
                case 12: // Planks (PLANKS_TYPE)
                    return isAxe ? MINING_TIMES.planks.axe : MINING_TIMES.planks.hand;
                    
                case 4: // Sand (SAND_TYPE)
                    return hasTool ? MINING_TIMES.sand.tool : MINING_TIMES.sand.hand;
                    
                case 0: // Grass (GRASS_TYPE)
                    return MINING_TIMES.grass.hand; // Always 0.5s
                    
                case 6: // Leaves (LEAVES_TYPE)
                    return MINING_TIMES.leaves.hand; // Always 0.2s
                    
                case 7: // Glass (GLASS_TYPE)
                    return hasTool ? 0.3 : 1.2;
                    
                case 8: // Door (DOOR_TYPE)
                case 9: // Torch (TORCH_TYPE)
                    return isAxe ? 0.5 : 2.0;
                    
                default:
                    return hasTool ? 1.0 : 3.0; // Default times
            }
        }
        
        // Function to check if block drops when mined with current tool
        function shouldDropBlock(blockType) {
            if (isCreativeMode) return false; // Creative doesn't need drops
            
            const hudIndex = getHUDIndex(sel);
            const heldItem = inventoryData[hudIndex];
            const itemType = heldItem ? heldItem.type : null;
            const isPickaxe = itemType < 0 && itemDefinitions[itemType]?.isPickaxe;
            
            // Stone, cobblestone, bedrock require pickaxe
            if (blockType === 2 || blockType === 5 || blockType === 12) {
                return isPickaxe;
            }
            
            // All other blocks always drop (grass, leaves, dirt, sand, wood, etc.)
            return true;
        }
        
        // Create crack overlay mesh for mining animation
        function createCrackOverlay(x, y, z, progress) {
            // Calculate crack stage (0-9 based on progress 0-1)
            const stage = Math.floor(progress * 10);
            if (stage >= 10 || stage < 0) return null; // Safety check for invalid stages
            
            // Create a slightly larger box around the block to show cracks
            const crackGeometry = new THREE.BoxGeometry(bs * 1.005, bs * 1.005, bs * 1.005);
            
            // Create canvas for crack texture
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // Draw crack pattern based on stage
            ctx.fillStyle = 'rgba(0, 0, 0, 0)';
            ctx.fillRect(0, 0, 64, 64);
            
            // Draw realistic fracture-style cracks
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1.5 + (stage * 0.3);
            ctx.globalAlpha = 0.7 + (stage * 0.03);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // Use a seed based on block position for consistent crack patterns
            const seed = (x * 73856093) ^ (y * 19349663) ^ (z * 83492791);
            const random = (n) => {
                const val = Math.sin(seed + n) * 43758.5453123;
                return val - Math.floor(val);
            };
            
            // Draw main crack lines with branches
            const numMainCracks = 1 + Math.floor(stage / 3);
            for (let i = 0; i < numMainCracks; i++) {
                // Start from a random edge point
                const startSide = Math.floor(random(i * 4) * 4);
                let startX, startY;
                
                switch(startSide) {
                    case 0: // Top
                        startX = random(i * 4 + 1) * 64;
                        startY = 0;
                        break;
                    case 1: // Right
                        startX = 64;
                        startY = random(i * 4 + 1) * 64;
                        break;
                    case 2: // Bottom
                        startX = random(i * 4 + 1) * 64;
                        startY = 64;
                        break;
                    default: // Left
                        startX = 0;
                        startY = random(i * 4 + 1) * 64;
                }
                
                // Draw main crack line with organic curves
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                
                let currentX = startX;
                let currentY = startY;
                let targetX = 32 + (random(i * 4 + 2) - 0.5) * 40;
                let targetY = 32 + (random(i * 4 + 3) - 0.5) * 40;
                
                const segments = 3 + Math.floor(stage / 2);
                for (let j = 0; j < segments; j++) {
                    const t = (j + 1) / segments;
                    const nextX = currentX + (targetX - currentX) * 0.7 + (random(i * 10 + j) - 0.5) * 15;
                    const nextY = currentY + (targetY - currentY) * 0.7 + (random(i * 10 + j + 100) - 0.5) * 15;
                    
                    ctx.lineTo(nextX, nextY);
                    
                    // Add branch cracks as stage increases
                    if (stage > 3 && j > 0 && random(i * 20 + j) > 0.6) {
                        const branchLength = 10 + stage * 2;
                        const branchAngle = (random(i * 30 + j) - 0.5) * Math.PI;
                        const branchX = nextX + Math.cos(branchAngle) * branchLength;
                        const branchY = nextY + Math.sin(branchAngle) * branchLength;
                        
                        ctx.moveTo(nextX, nextY);
                        ctx.lineTo(branchX, branchY);
                        ctx.moveTo(nextX, nextY);
                    }
                    
                    currentX = nextX;
                    currentY = nextY;
                }
                ctx.stroke();
            }
            
            // Add small crack details for higher stages
            if (stage > 5) {
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.5;
                const numSmallCracks = (stage - 5) * 2;
                
                for (let i = 0; i < numSmallCracks; i++) {
                    ctx.beginPath();
                    const sx = random(i * 50) * 64;
                    const sy = random(i * 50 + 25) * 64;
                    const ex = sx + (random(i * 50 + 50) - 0.5) * 15;
                    const ey = sy + (random(i * 50 + 75) - 0.5) * 15;
                    
                    ctx.moveTo(sx, sy);
                    ctx.lineTo(ex, ey);
                    ctx.stroke();
                }
            }
            
            // Create texture from canvas
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            
            // Create materials for all 6 faces with the crack texture
            const materials = [];
            for (let i = 0; i < 6; i++) {
                materials.push(new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    opacity: 0.8,
                    depthTest: true,
                    depthWrite: false,
                    side: THREE.FrontSide
                }));
            }
            
            const crackMesh = new THREE.Mesh(crackGeometry, materials);
            crackMesh.position.set(x * bs, y * bs, z * bs);
            
            return crackMesh;
        }
        
        // --- REFACTORED: Global Mousedown Listener ---
        renderer.domElement.addEventListener('mousedown', function(e) {
            // Request pointer lock if not already locked and not in menu/inventory
            if (!locked && !paused && !inventoryOpen && !isDead) {
                requestLock(renderer.domElement);
                return;
            }
            
            if (inventoryOpen) {
                // --- FAKE CURSOR CLICK LOGIC ---
                // We are in the inventory. Do not fire a raycaster.
                
                // 1. Get the element under the *fake cursor*
                if (!fakeCursorElement) return; // Safety check
                fakeCursorElement.style.display = 'none'; // Hide cursor to perform hit test
                let elementUnderCursor = document.elementFromPoint(fakeCursorX, fakeCursorY);
                fakeCursorElement.style.display = 'block'; // Show it again

                if (!elementUnderCursor) return;

                const slotElement = elementUnderCursor.closest('.inventory-slot');
                
                if (slotElement) {
                    // We clicked a slot in *either* inventory or block picker
                    if (slotElement.closest('#creative-block-picker')) {
                        // --- Clicked on Block Picker ---
                        if (!isCreativeMode) return;
                        const type = parseInt(slotElement.dataset.type);
                        
                        // Check if it's a tool
                        const isTool = type < 0 && itemDefinitions[type] && itemDefinitions[type].isTool;
                        
                        if (isTool) {
                            // Tools: grab 1 with full durability
                            const itemDef = itemDefinitions[type];
                            pickedUpItem = { 
                                type: type, 
                                count: 1,
                                durability: itemDef.maxDurability 
                            };
                        } else {
                            // Regular items: grab a stack
                            pickedUpItem = { type: type, count: 64 };
                        }
                        
                        playClickSound(); // Audio feedback
                        updateInventoryUI();

                    } else if (slotElement.closest('.inventory-container')) {
                        // --- Clicked on Main Inventory ---
                        
                        // Move keyboard cursor to match (for visual feedback)
                        cursorX = parseInt(slotElement.dataset.x);
                        cursorY = parseInt(slotElement.dataset.y);
                        const slotIndex = parseInt(slotElement.dataset.index);

                        if (e.button === 0) { // Left-Click
                            playClickSound(); // Audio feedback
                            swapItems(slotIndex);
                        } else if (e.button === 2) { // Right-Click
                            e.preventDefault();
                            playClickSound(); // Audio feedback
                            handleInventoryRightClick(slotIndex); // Use new function
                        }
                    }
                } else if (elementUnderCursor.classList && elementUnderCursor.classList.contains('crafting-slot')) {
                    // --- Clicked on Crafting Grid ---
                    const craftIndex = parseInt(elementUnderCursor.dataset.index);
                    
                    if (e.button === 0) { // Left-Click
                        const craftItem = craftingGrid[craftIndex];
                        
                        if (pickedUpItem) {
                            playClickSound(); // Audio feedback
                            // Placing item in crafting grid
                            if (craftItem && pickedUpItem.type === craftItem.type) {
                                // Stack items
                                craftItem.count += pickedUpItem.count;
                                pickedUpItem = null;
                            } else {
                                // Swap items
                                craftingGrid[craftIndex] = { ...pickedUpItem, count: 1 };
                                pickedUpItem.count--;
                                if (pickedUpItem.count === 0) pickedUpItem = null;
                            }
                        } else if (craftItem) {
                            playClickSound(); // Audio feedback
                            // Picking up item from crafting grid
                            pickedUpItem = craftItem;
                            craftingGrid[craftIndex] = null;
                        }
                        
                        updateCraftingUI();
                        updateInventoryUI();
                    }
                } else if (elementUnderCursor.id === 'crafting-output') {
                    // --- Clicked on Crafting Output ---
                    if (craftingOutput && e.button === 0) {
                        playClickSound(); // Audio feedback
                        craftItem();
                    }
                } else if (elementUnderCursor.id === 'gameModeToggleBtn') {
                    // Clicked the toggle button
                    toggleGameMode();
                } else if (elementUnderCursor.classList && elementUnderCursor.classList.contains('category-tab')) {
                    // --- Clicked on Category Tab ---
                    const category = elementUnderCursor.dataset.category;
                    if (category) {
                        currentCategory = category;
                        
                        // Update active tab
                        const tabs = document.querySelectorAll('.category-tab');
                        tabs.forEach(t => t.classList.remove('active'));
                        elementUnderCursor.classList.add('active');
                        
                        // Regenerate picker with new category
                        generateBlockPicker(category);
                        
                        // Play click sound
                        playClickSound();
                    }
                } else if (elementUnderCursor.closest('#delete-slot')) {
                    // --- NEW: Clicked on Delete Slot ---
                    if (pickedUpItem) {
                        playClickSound(); // Audio feedback
                        pickedUpItem = null;
                        updateInventoryUI(); // Update UI to remove item from keyboard slot
                    }
                }

                return; // IMPORTANT: Stop processing, don't break/place blocks
            }

            // --- Original Raycasting Logic (if inventory is not open) ---
            if (!locked || paused || isDead) return;

            ray.setFromCamera(new THREE.Vector2(0, 0), camera);
            
            var objs = Object.values(world); 
            var hits = ray.intersectObjects(objs);
            
            if (hits.length > 0) {
                var hit = hits[0];
                var pos = hit.object.position;
                var bx = Math.round(pos.x / bs);
                var by = Math.round(pos.y / bs);
                var bz = Math.round(pos.z / bs);
                
                // Check if clicked block is a door
                const clickedBlock = world[key(bx, by, bz)];
                const isDoor = clickedBlock && clickedBlock.userData.blockType === DOOR_TYPE;

                if (e.button === 0) { // Left-Click (Start Mining)
                    isLeftMouseDown = true;
                    breakingCooldown = 0; // Reset cooldown on new click to allow immediate mining
                    
                    // Start mining this block
                    if (!miningTarget || miningTarget.x !== bx || miningTarget.y !== by || miningTarget.z !== bz) {
                        const requiredTime = getMiningTime(clickedBlock.userData.blockType);
                        miningTarget = {
                            x: bx,
                            y: by,
                            z: bz,
                            progress: 0,
                            requiredTime: requiredTime,
                            crackOverlay: null
                        };
                    }
                    
                    // Trigger hand swing animation
                    isSwinging = true;
                    handSwingTimer = 0;
                    
                } else if (e.button === 1) { // Middle-Click (Block Picker)
                    e.preventDefault();
                    
                    // Get the block type being looked at
                    if (clickedBlock && clickedBlock.userData.blockType !== undefined) {
                        const blockType = clickedBlock.userData.blockType;
                        handleMiddleClickBlockPick(blockType);
                    }
                    
                } else if (e.button === 2) { // Right-Click
                    isRightMouseDown = true; // Track right mouse down for continuous placing
                    
                    // If clicking on a door, toggle it instead of placing a block
                    if (isDoor) {
                        toggleDoor(bx, by, bz);
                        return; // Don't place blocks when clicking on door
                    }
                    
                    // Get current held item
                    const hudIndex = getHUDIndex(sel);
                    const item = inventoryData[hudIndex];
                    
                    // Otherwise, place block as normal
                    if (item && item.count > 0) {
                        // Check if it's a placeable item (like planks)
                        let placeableType = item.type;
                        if (item.type < 0) {
                            // It's an item, check if placeable
                            const itemDef = itemDefinitions[item.type];
                            if (!itemDef || !itemDef.isPlaceable) {
                                return; // Can't place tools/non-placeable items
                            }
                            // Place planks as planks blocks (not wood)
                            placeableType = PLANKS_TYPE;
                        }
                        
                        if (window.activeBlockType !== null || placeableType >= 0) {
                            var n = hit.face.normal;
                            // Determine placement coords
                            var plx, ply, plz;
                            const clickedType = clickedBlock?.userData.blockType;
                            if (clickedType === WATER_TYPE || clickedType === LAVA_TYPE) {
                                // Place inside the liquid block (replace it)
                                plx = bx; ply = by; plz = bz;
                            } else {
                                plx = bx + Math.round(n.x);
                                ply = by + Math.round(n.y);
                                plz = bz + Math.round(n.z);
                            }
                            
                            var pbx = Math.round(px / bs);
                            var pby = Math.round(py / bs);
                            var pbz = Math.round(pz / bs);
                            
                            var ok = true;
                            if (plx === pbx && ply === pby && plz === pbz) ok = false;
                            if (plx === pbx && ply === pby - 1 && plz === pbz) ok = false; 
                            
                            // Check occupancy, but allow replacing liquids
                            const targetBlock = world[key(plx, ply, plz)];
                            if (targetBlock) {
                                const tType = targetBlock.userData.blockType;
                                const isLiquid = (tType === WATER_TYPE || tType === LAVA_TYPE);
                                if (!isLiquid) ok = false; // solid or non-replaceable blocks prevent placement
                            }
                            
                            // For doors, also check if space above is free (unless replacing a liquid there)
                            if (placeableType === DOOR_TYPE) {
                                const aboveBlock = world[key(plx, ply + 1, plz)];
                                const aboveIsLiquid = aboveBlock && (aboveBlock.userData.blockType === WATER_TYPE || aboveBlock.userData.blockType === LAVA_TYPE);
                                if (aboveBlock && !aboveIsLiquid) ok = false;
                            }

                            if (ok) {
                                // Calculate camera facing angle for door placement
                                const facingAngle = ry; // Camera's yaw rotation
                                add(plx, ply, plz, placeableType, facingAngle);
                                playPlaceSound(placeableType);

                                // --- SURVIVAL MODE: Consume Block ---
                                if (!isCreativeMode) {
                                    item.count--; 
                                    if (item.count <= 0) { inventoryData[hudIndex] = null; } 
                                }

                                updateInventoryUI();
                                updateToolbarSelection();
                                
                                // Trigger hand placing animation
                                isSwinging = true;
                                handSwingTimer = 0;
                                
                                // Set cooldown for continuous placing
                                placingCooldown = PLACE_DELAY;
                            }
                        }
                    }
                }
            }
        });

        renderer.domElement.addEventListener('contextmenu', function(e) { e.preventDefault(); });
        
        // --- MOUSEUP: Stop continuous mining and placing ---
        renderer.domElement.addEventListener('mouseup', function(e) {
            if (e.button === 0) {
                isLeftMouseDown = false;
                // Reset mining target and remove crack overlay
                if (miningTarget) {
                    if (miningTarget.crackOverlay) {
                        scene.remove(miningTarget.crackOverlay);
                    }
                    miningTarget = null;
                }
            } else if (e.button === 2) {
                isRightMouseDown = false;
            }
        });

        btns.forEach(function(btn, index) {
            btn.addEventListener('click', function() {
                sel = index; 
                updateToolbarSelection();
            });
        });
        
        updateToolbarSelection(); 

        
        function check(x, y, z, r) {
            // OPTIMIZED: Efficient hitbox collision detection with sweep test
            // Only check immediately adjacent blocks
            var cx = Math.round(x / bs);
            var cy = Math.round(y / bs);
            var cz = Math.round(z / bs);
            
            // Reduced test area - only check blocks that could actually collide
            var tests = [
                [0, 0, 0],                         // Current position
                [0, -1, 0], [0, 1, 0],            // Vertical
                [-1, 0, 0], [1, 0, 0],             // X-axis
                [0, 0, -1], [0, 0, 1]              // Z-axis
            ]; 
            
            for (var i = 0; i < tests.length; i++) {
                var tx = cx + tests[i][0];
                var ty = cy + tests[i][1];
                var tz = cz + tests[i][2];
                
                var blockKey = key(tx, ty, tz);
                if (world[blockKey]) {
                    var block = world[blockKey];
                    
                    // Skip collision for torches
                    if (block.userData.isTorch) {
                        continue;
                    }
                    
                    // Skip collision for water and lava (allow swimming through)
                    if (block.userData.blockType === WATER_TYPE || block.userData.blockType === LAVA_TYPE) {
                        continue;
                    }
                    
                    // Skip collision for open doors
                    if (block.userData.blockType === DOOR_TYPE && block.userData.doorOpen) {
                        continue;
                    }
                    
                    // For closed doors, check both blocks (2 blocks tall) with thin hitbox
                    if (block.userData.blockType === DOOR_TYPE) {
                        var doorBottomY = block.userData.doorBottomY;
                        var doorTopY = doorBottomY + 1;
                        
                        // Check collision for full 2-block height
                        if (ty === doorBottomY || ty === doorTopY) {
                            var bpx = tx * bs;
                            var bpz = tz * bs;
                            
                            var margin = 0.02;
                            var doorThickness = bs * 0.125; // Door is 0.25 blocks wide, so half is 0.125
                            
                            // Get door rotation to determine orientation
                            var doorRotation = block.rotation.y % (Math.PI * 2);
                            var isNorthSouth = Math.abs(Math.sin(doorRotation)) > 0.5; // N/S or E/W
                            
                            // Full 2-block height collision
                            var doorBottomWorldY = doorBottomY * bs;
                            var doorTopWorldY = (doorTopY + 1) * bs; // Top of the 2nd block
                            
                            // Thin collision box based on door orientation
                            if (isNorthSouth) {
                                // Door runs North-South (thin on X axis)
                                if (x + r > bpx - doorThickness + margin && 
                                    x - r < bpx + doorThickness - margin &&
                                    z + r > bpz - bs/2 + margin && 
                                    z - r < bpz + bs/2 - margin &&
                                    y + margin > doorBottomWorldY && 
                                    y - PLAYER_HEIGHT < doorTopWorldY - margin) {
                                    return block;
                                }
                            } else {
                                // Door runs East-West (thin on Z axis)
                                if (x + r > bpx - bs/2 + margin && 
                                    x - r < bpx + bs/2 - margin &&
                                    z + r > bpz - doorThickness + margin && 
                                    z - r < bpz + doorThickness - margin &&
                                    y + margin > doorBottomWorldY && 
                                    y - PLAYER_HEIGHT < doorTopWorldY - margin) {
                                    return block;
                                }
                            }
                        }
                        continue;
                    }
                    
                    var bpx = tx * bs;
                    var bpy = ty * bs;
                    var bpz = tz * bs;
                    
                    // OPTIMIZED: Slightly tighter boundaries with margin to prevent sticking
                    var halfBlock = bs / 2;
                    var margin = 0.02; // Small margin to prevent edge cases
                    
                    // AABB collision with margin
                    if (x + r > bpx - halfBlock + margin && 
                        x - r < bpx + halfBlock - margin &&
                        z + r > bpz - halfBlock + margin && 
                        z - r < bpz + halfBlock - margin &&
                        y + margin > bpy - halfBlock && 
                        y - PLAYER_HEIGHT < bpy + halfBlock - margin) {
                        return world[blockKey]; 
                    }
                }
            }
            return null;
        }
        
        // Camera collision detection for third-person view
        function checkCameraCollision(playerX, playerY, playerZ, cameraX, cameraY, cameraZ, maxDistance) {
            // Calculate direction from player to camera
            const dx = cameraX - playerX;
            const dy = cameraY - playerY;
            const dz = cameraZ - playerZ;
            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
            
            if (distance < 0.1) return maxDistance; // Too close, no need to check
            
            // Normalize direction
            const dirX = dx / distance;
            const dirY = dy / distance;
            const dirZ = dz / distance;
            
            // Step along the ray from player to camera
            const steps = Math.ceil(distance / (bs * 0.5)); // Check every half block
            let closestHitDistance = maxDistance;
            
            for (let i = 1; i <= steps; i++) {
                const t = (i / steps) * distance;
                const testX = playerX + dirX * t;
                const testY = playerY + dirY * t;
                const testZ = playerZ + dirZ * t;
                
                // Convert to block coordinates
                const bx = Math.floor(testX / bs);
                const by = Math.floor(testY / bs);
                const bz = Math.floor(testZ / bs);
                
                const blockKey = key(bx, by, bz);
                if (world[blockKey]) {
                    const block = world[blockKey];
                    
                    // Skip non-solid blocks
                    if (block.userData.isTorch || 
                        block.userData.blockType === WATER_TYPE || 
                        block.userData.blockType === LAVA_TYPE ||
                        (block.userData.blockType === DOOR_TYPE && block.userData.doorOpen)) {
                        continue;
                    }
                    
                    // Found a collision - return distance minus padding
                    closestHitDistance = Math.max(0.5, t - CAMERA_COLLISION_PADDING);
                    break;
                }
            }
            
            return closestHitDistance;
        }

        var last = performance.now();
        var fc = 0; var ft = 0;
        var fpsElement = document.getElementById('fps');
        
        // Minecraft-style physics values (tuned for better feel)
        var BASE_SPD = 9; // Walking speed (blocks/sec) - increased for better feel
        var SPRINT_MULTIPLIER = 1.3; // Sprinting speed multiplier
        var SNEAK_MULTIPLIER = 0.3; // Sneaking speed multiplier
        var JUMP_FORCE = 20; // Jump velocity - allows jumping over 1 block easily
        var GRAVITY = 73; // Gravity acceleration (blocks/sec)
        var TERMINAL_VELOCITY = -78.4; // Maximum falling speed (blocks/sec)
        var FRICTION = 0.6; // Ground friction
        var AIR_RESISTANCE = 0.02; // Air resistance while falling
        
        var dt = 0; // Make dt global for sand physics
        var isSprinting = false; // Sprint state
        var isSneaking = false; // Sneak state
        var sprintFOVBoost = 10; // FOV increase when sprinting (additive)
        var currentFOVOffset = 0; // Current FOV offset from base
        var fovTransitionSpeed = 10; // FOV transition speed
        
        // Performance optimization: Frustum culling
        var frustum = new THREE.Frustum();
        var cameraViewProjectionMatrix = new THREE.Matrix4();
        var lastCullingUpdate = 0;
        var CULLING_UPDATE_INTERVAL = 0.1; // Update culling 10 times per second

        function loop() {
            requestAnimationFrame(loop);
            
            var now = performance.now();
            
            if (!paused) { 
                dt = Math.min((now - last) / 1000, 0.1); 
                last = now;

                fc++; ft += dt;
                if (ft >= 1) { 
                    fpsElement.textContent = fc + ' FPS'; 
                    
                    // Update debug info with player position
                    if (showHitbox) {
                        const debugInfo = document.getElementById('debug-info');
                        const blockX = Math.round(px / bs);
                        const blockY = Math.round((py - EYE_HEIGHT) / bs);
                        const blockZ = Math.round(pz / bs);
                        debugInfo.innerHTML = `DEBUG MODE: Hitbox ON<br>Position: ${px.toFixed(1)}, ${py.toFixed(1)}, ${pz.toFixed(1)}<br>Block: ${blockX}, ${blockY}, ${blockZ}<br>Ground: ${ground ? 'YES' : 'NO'}`;
                    }
                    
                    fc = 0; 
                    ft = 0; 
                }
                
                // --- ANIMATE WATER & LAVA TEXTURES ---
                // Water flows smoothly and continuously
                waterTexture.offset.x += dt * 0.05; // Slow horizontal flow
                waterTexture.offset.y += dt * 0.03; // Slight vertical movement
                
                // Lava flows slower and more dramatically
                lavaTexture.offset.x += dt * 0.02; // Very slow horizontal flow
                lavaTexture.offset.y -= dt * 0.015; // Downward flow effect
                
                // Keep offsets in 0-1 range for performance
                if (waterTexture.offset.x > 1) waterTexture.offset.x -= 1;
                if (waterTexture.offset.y > 1) waterTexture.offset.y -= 1;
                if (lavaTexture.offset.x > 1) lavaTexture.offset.x -= 1;
                if (lavaTexture.offset.y < -1) lavaTexture.offset.y += 1;
                // -------------------------------------
                
                // Performance: Update frustum culling less frequently
                lastCullingUpdate += dt;
                if (lastCullingUpdate >= CULLING_UPDATE_INTERVAL) {
                    lastCullingUpdate = 0;
                    camera.updateMatrixWorld();
                    camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
                    cameraViewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
                    frustum.setFromProjectionMatrix(cameraViewProjectionMatrix);
                    
                    // Hide/show blocks based on frustum
                    for (var k in world) {
                        var block = world[k];
                        if (block && block.geometry) {
                            var wasVisible = block.visible;
                            var inFrustum = frustum.intersectsObject(block);
                            
                            // Only update if visibility changed
                            if (wasVisible !== inFrustum) {
                                block.visible = inFrustum;
                            }
                        }
                    }
                }
                
                // --- MINECRAFT-ACCURATE CONTINUOUS MINING & PLACING ---
                
                // Performance: Reduce raycast frequency to every other frame
                var shouldRaycast = fc % 2 === 0;
                
                // Update cooldowns
                if (breakingCooldown > 0) {
                    breakingCooldown -= dt;
                }
                
                // Mining logic
                if (isLeftMouseDown && locked && !inventoryOpen && !isDead && shouldRaycast) {
                    // Perform raycast to get block player is looking at
                    ray.setFromCamera(new THREE.Vector2(0, 0), camera);
                    
                    // Performance: Only raycast against visible blocks
                    var objs = Object.values(world).filter(function(obj) { return obj.visible !== false; });
                    var hits = ray.intersectObjects(objs);
                    
                    if (hits.length > 0) {
                        var hit = hits[0];
                        var distance = hit.distance;
                        
                        // Only mine if within reach (5 blocks)
                        if (distance < 5 * bs) {
                            var pos = hit.object.position;
                            var bx = Math.round(pos.x / bs);
                            var by = Math.round(pos.y / bs);
                            var bz = Math.round(pos.z / bs);
                            
                            const clickedBlock = world[key(bx, by, bz)];
                            
                            // Check if we're still mining the same block
                            if (!miningTarget || miningTarget.x !== bx || miningTarget.y !== by || miningTarget.z !== bz) {
                                // Started mining a new block - check cooldown only for continuous mining
                                if (breakingCooldown <= 0) {
                                    // Reset progress
                                    if (miningTarget && miningTarget.crackOverlay) {
                                        scene.remove(miningTarget.crackOverlay);
                                    }
                                    
                                    const requiredTime = getMiningTime(clickedBlock.userData.blockType);
                                    miningTarget = {
                                        x: bx,
                                        y: by,
                                        z: bz,
                                        progress: 0,
                                        requiredTime: requiredTime,
                                        crackOverlay: null
                                    };
                                }
                            }
                            
                            // Update mining progress
                            if (miningTarget) {
                                miningTarget.progress += dt / miningTarget.requiredTime;
                                
                                // Update crack overlay
                                if (miningTarget.crackOverlay) {
                                    scene.remove(miningTarget.crackOverlay);
                                }
                                miningTarget.crackOverlay = createCrackOverlay(bx, by, bz, miningTarget.progress);
                                if (miningTarget.crackOverlay) {
                                    scene.add(miningTarget.crackOverlay);
                                }
                                
                                // Trigger hand swing animation periodically
                                if (!isSwinging) {
                                    isSwinging = true;
                                    handSwingTimer = 0;
                                }
                                
                                // Break block when progress complete
                                if (miningTarget.progress >= 1.0) {
                                    // Remove crack overlay
                                    if (miningTarget.crackOverlay) {
                                        scene.remove(miningTarget.crackOverlay);
                                    }
                                    
                                    // Break the block
                                    var k = key(bx, by, bz);
                                    if (world[k]) {
                                        const blockType = world[k].userData.blockType;
                                        const shouldDrop = shouldDropBlock(blockType);
                                        
                                        // Special handling for bedrock in survival
                                        if (blockType === 5 && !isCreativeMode) {
                                            console.log("Bedrock cannot be destroyed in Survival Mode.");
                                            miningTarget = null;
                                            breakingCooldown = isCreativeMode ? BREAK_COOLDOWN_CREATIVE : BREAK_COOLDOWN_SURVIVAL;
                                            return;
                                        }
                                        
                                        // Remove block
                                        remove(bx, by, bz);
                                        
                                        // Reset if not creative (creative doesn't add to inventory)
                                        if (!shouldDrop && !isCreativeMode) {
                                            // Block was broken but didn't drop (wrong tool)
                                            console.log("Block broken but didn't drop - wrong tool!");
                                        }
                                    }
                                    
                                    // Reset mining target and set cooldown before next break
                                    miningTarget = null;
                                    breakingCooldown = isCreativeMode ? BREAK_COOLDOWN_CREATIVE : BREAK_COOLDOWN_SURVIVAL; // 0.25s in creative, 0.1s in survival
                                }
                            }
                        } else {
                            // Out of reach - reset mining
                            if (miningTarget) {
                                if (miningTarget.crackOverlay) {
                                    scene.remove(miningTarget.crackOverlay);
                                }
                                miningTarget = null;
                            }
                        }
                    } else {
                        // Not looking at a block - reset mining
                        if (miningTarget) {
                            if (miningTarget.crackOverlay) {
                                scene.remove(miningTarget.crackOverlay);
                            }
                            miningTarget = null;
                        }
                    }
                }
                
                // Continuous placing logic
                if (isRightMouseDown && locked && !inventoryOpen && !isDead && shouldRaycast) {
                    placingCooldown -= dt;
                    
                    if (placingCooldown <= 0) {
                        // Perform raycast to get block placement location
                        ray.setFromCamera(new THREE.Vector2(0, 0), camera);
                        
                        // Performance: Only raycast against visible blocks
                        var objs = Object.values(world).filter(function(obj) { return obj.visible !== false; });
                        var hits = ray.intersectObjects(objs);
                        
                        if (hits.length > 0) {
                            var hit = hits[0];
                            var distance = hit.distance;
                            
                            // Only place if within reach (5 blocks)
                            if (distance < 5 * bs) {
                                var pos = hit.object.position;
                                var bx = Math.round(pos.x / bs);
                                var by = Math.round(pos.y / bs);
                                var bz = Math.round(pos.z / bs);
                                
                                const clickedBlock = world[key(bx, by, bz)];
                                const isDoor = clickedBlock && clickedBlock.userData.blockType === 8;
                                
                                // Don't place if it's a door
                                if (!isDoor) {
                                    // Get current held item
                                    const hudIndex = getHUDIndex(sel);
                                    const item = inventoryData[hudIndex];
                                    
                                    if (item && item.count > 0) {
                                        let placeableType = item.type;
                                        if (item.type < 0) {
                                            const itemDef = itemDefinitions[item.type];
                                            if (!itemDef || !itemDef.isPlaceable) {
                                                // Can't place tools/non-placeable items
                                                placingCooldown = PLACE_DELAY;
                                            } else {
                                                placeableType = 3; // Wood type
                                            }
                                        }
                                        
                                        if ((window.activeBlockType !== null || placeableType >= 0) && placeableType !== undefined) {
                                            var n = hit.face.normal;
                                            var plx, ply, plz;
                                            const clickedType = clickedBlock?.userData.blockType;
                                            if (clickedType === 10 || clickedType === 11) { // Water or lava
                                                plx = bx; ply = by; plz = bz;
                                            } else {
                                                plx = bx + Math.round(n.x);
                                                ply = by + Math.round(n.y);
                                                plz = bz + Math.round(n.z);
                                            }
                                            
                                            var pbx = Math.round(px / bs);
                                            var pby = Math.round(py / bs);
                                            var pbz = Math.round(pz / bs);
                                            
                                            var ok = true;
                                            if (plx === pbx && ply === pby && plz === pbz) ok = false;
                                            if (plx === pbx && ply === (pby + 1) && plz === pbz) ok = false;
                                            
                                            if (ok && !world[key(plx, ply, plz)]) {
                                                add(plx, ply, plz, window.activeBlockType !== null ? window.activeBlockType : placeableType);
                                                playPlaceSound(window.activeBlockType !== null ? window.activeBlockType : placeableType);
                                                
                                                if (!isCreativeMode) {
                                                    item.count--;
                                                    if (item.count <= 0) { inventoryData[hudIndex] = null; }
                                                }
                                                
                                                updateInventoryUI();
                                                updateToolbarSelection();
                                                
                                                // Trigger hand placing animation
                                                isSwinging = true;
                                                handSwingTimer = 0;
                                            }
                                        }
                                    }
                                }
                                
                                placingCooldown = PLACE_DELAY; // Reset cooldown
                            }
                        }
                    }
                }
                // --- END MINECRAFT-ACCURATE MINING & PLACING ---
                
                const roundedX = px.toFixed(2);
                const roundedY = py.toFixed(2);
                const roundedZ = pz.toFixed(2);
                
                // Check if player's head is underwater
                const headY = py + (PLAYER_TOTAL_HEIGHT - EYE_HEIGHT);
                const headBlockX = Math.round(px / bs);
                const headBlockY = Math.round(headY / bs);
                const headBlockZ = Math.round(pz / bs);
                const headBlock = world[key(headBlockX, headBlockY, headBlockZ)];
                isUnderwater = headBlock && headBlock.userData.blockType === WATER_TYPE;
                
                // Oxygen and Health system (only in survival mode)
                if (!isCreativeMode && !isDead) {
                    if (isUnderwater) {
                        // Deplete oxygen when underwater
                        currentOxygen -= oxygenDepletionRate * dt;
                        currentOxygen = Math.max(0, currentOxygen);
                        
                        // Update oxygen UI
                        updateOxygenUI();
                        
                        // Drowning damage when oxygen runs out
                        if (currentOxygen <= 0) {
                            drownDamageTimer += dt;
                            if (drownDamageTimer >= drownDamageInterval) {
                                takeDamage(drownDamageRate);
                                drownDamageTimer = 0;
                            }
                        }
                    } else {
                        // Regenerate oxygen when not underwater
                        if (currentOxygen < maxOxygen) {
                            currentOxygen += oxygenRegenRate * dt;
                            currentOxygen = Math.min(maxOxygen, currentOxygen);
                            updateOxygenUI();
                        } else {
                            updateOxygenUI(); // Will hide when full
                        }
                        
                        drownDamageTimer = 0;
                    }
                    
                    // --- LAVA DAMAGE SYSTEM ---
                    // Check if player is touching lava (ANY part of player, not just center)
                    isInLava = false;
                    
                    // Check multiple points around the player's body
                    const playerBlockX = Math.round(px / bs);
                    const playerBlockZ = Math.round(pz / bs);
                    const feetBlockY = Math.floor((py - EYE_HEIGHT) / bs);
                    const headBlockY = Math.ceil((py - EYE_HEIGHT + PLAYER_TOTAL_HEIGHT) / bs);
                    
                    // Check from feet to head
                    for (let checkY = feetBlockY; checkY <= headBlockY; checkY++) {
                        // Check center and around the player's radius
                        const checkPositions = [
                            [playerBlockX, checkY, playerBlockZ],
                            [playerBlockX + 1, checkY, playerBlockZ],
                            [playerBlockX - 1, checkY, playerBlockZ],
                            [playerBlockX, checkY, playerBlockZ + 1],
                            [playerBlockX, checkY, playerBlockZ - 1]
                        ];
                        
                        for (const [cx, cy, cz] of checkPositions) {
                            const checkBlock = world[key(cx, cy, cz)];
                            if (checkBlock && checkBlock.userData.blockType === LAVA_TYPE) {
                                isInLava = true;
                                break;
                            }
                        }
                        if (isInLava) break;
                    }
                    
                    if (isInLava) {
                        // Take damage while in lava
                        lavaDamageTimer += dt;
                        if (lavaDamageTimer >= lavaDamageInterval) {
                            takeDamage(lavaDamageAmount);
                            lavaDamageTimer = 0;
                        }
                    } else {
                        lavaDamageTimer = 0;
                    }
                    // ---------------------------
                    
                    // Update health UI
                    updateHealthUI();
                } else if (isCreativeMode) {
                    // Creative mode - keep oxygen and health full, hide UI
                    currentOxygen = maxOxygen;
                    currentHealth = maxHealth;
                    document.getElementById('oxygen-container').style.display = 'none';
                    document.getElementById('health-container').style.display = 'none';
                }
                
                // Note: UI will be updated below after time calculation

                // --- DAY/NIGHT CYCLE UPDATE ---
                dayTime += dt;
                if (dayTime >= dayLength) {
                    dayTime -= dayLength; // Loop the cycle
                    dayCounter++; // Increment day counter when a full day passes
                    moonPhase = (moonPhase + 1) % 8; // Cycle through 8 moon phases
                    updateMoonPhase(); // Update moon texture
                }
                
                // Calculate cycle progress (0 to 1)
                const cycleProgress = dayTime / dayLength;
                
                // Correct angle mapping: 6 AM = -/2 (horizon east), noon = 0 (overhead), 6 PM = /2 (horizon west), midnight = -
                const angle = (cycleProgress * Math.PI * 2) - Math.PI;
                
                // Position sun and moon fixed in sky (follows player position, not camera rotation)
                // Like Minecraft: they stay in world space based on day/night cycle
                const camX = camera.position.x;
                const camY = camera.position.y;
                const camZ = camera.position.z;
                
                // Sun position in sky - circular path around player
                // At 6 AM (angle = -/2): sun is at horizon in east
                // At noon (angle = 0): sun is directly overhead
                // At 6 PM (angle = /2): sun is at horizon in west
                sun.position.set(
                    camX + Math.sin(angle) * celestialDistance,
                    camY + Math.cos(angle) * celestialDistance,
                    camZ
                );
                
                // Moon is opposite to sun (12 hours offset)
                moon.position.set(
                    camX - Math.sin(angle) * celestialDistance,
                    camY - Math.cos(angle) * celestialDistance,
                    camZ
                );
                
                // Make planes face the camera position (billboard effect)
                sun.lookAt(camera.position);
                moon.lookAt(camera.position);
                
                // Calculate game time in hours (0-24)
                const gameHour = (dayTime / dayLength) * 24;
                
                // Calculate precise time components
                const hours = Math.floor(gameHour);
                const minutes = Math.floor((gameHour - hours) * 60);
                const seconds = Math.floor(((gameHour - hours) * 60 - minutes) * 60);
                
                // Format time string
                const timeString = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                
                // Calculate player speed in blocks per second (3 decimal places like Minecraft)
                const horizontalSpeed = Math.sqrt(vx * vx + vz * vz);
                const speedBPS = horizontalSpeed.toFixed(3);
                
                // Update UI element with all game info including time, day, and speed
                uiElement.innerHTML = `Day ${dayCounter} | Time: ${timeString}\nGame Mode: ${isCreativeMode ? 'Creative' : 'Survival'}\nFly Mode: ${isFlying ? 'ON' : 'OFF'}\nSpeed: ${speedBPS} blocks/sec\nSeed: ${WORLD_SEED}\nWorld Size: ${ws}\nX: ${roundedX}\nY: ${roundedY}\nZ: ${roundedZ}`;
                
                // Enhanced sun/moon visibility with twilight transitions
                // Both sun and moon are visible during sunrise and sunset
                // Sunrise: 6:00 AM - 7:00 AM (gameHour 6-7)
                // Sunset: 6:00 PM - 7:00 PM (gameHour 18-19)
                
                const sunriseStart = 6.0;
                const sunriseEnd = 7.0;
                const sunsetStart = 18.0;
                const sunsetEnd = 19.0;
                
                // Calculate sun and moon opacity based on time
                let sunOpacity = 1.0;
                let moonOpacity = 1.0;
                
                if (gameHour >= sunriseStart && gameHour < sunriseEnd) {
                    // Sunrise transition - sun fading in, moon fading out
                    const progress = (gameHour - sunriseStart) / (sunriseEnd - sunriseStart);
                    sunOpacity = progress;
                    moonOpacity = 1.0 - progress;
                    sun.visible = true;
                    moon.visible = true;
                } else if (gameHour >= sunsetStart && gameHour < sunsetEnd) {
                    // Sunset transition - sun fading out, moon fading in
                    const progress = (gameHour - sunsetStart) / (sunsetEnd - sunsetStart);
                    sunOpacity = 1.0 - progress;
                    moonOpacity = progress;
                    sun.visible = true;
                    moon.visible = true;
                } else if (gameHour >= sunriseEnd && gameHour < sunsetStart) {
                    // Full daytime - only sun visible
                    sun.visible = true;
                    moon.visible = false;
                    sunOpacity = 1.0;
                } else {
                    // Full nighttime - only moon visible
                    sun.visible = false;
                    moon.visible = true;
                    moonOpacity = 1.0;
                }
                
                // Apply opacity to materials
                sunMaterial.opacity = sunOpacity;
                moonMaterial.opacity = moonOpacity;
                
                // Calculate light intensity based on sun height
                // Day is when sun is above horizon (cos(angle) > 0)
                const sunHeight = Math.cos(angle);
                const isDay = sunHeight > 0;
                
                // Smooth transition for lighting with moon phase effects
                let lightIntensity;
                if (sunHeight > 0.1) {
                    // Full day - bright lighting
                    lightIntensity = 0.4 + sunHeight * 0.3;
                } else if (sunHeight > -0.1) {
                    // Twilight transition
                    lightIntensity = 0.2 + (sunHeight + 0.1) * 1.0;
                } else {
                    // Night - brightness affected by moon phase
                    // Full moon (phase 0) = brighter, New moon (phase 4) = darkest
                    const moonBrightness = moonPhase === 4 ? 0.10 : // New moon - very dark
                                          moonPhase === 0 ? 0.20 : // Full moon - brightest night
                                          moonPhase === 1 || moonPhase === 7 ? 0.18 : // Gibbous - bright
                                          moonPhase === 2 || moonPhase === 6 ? 0.15 : // Quarter - medium
                                          0.12; // Crescent - dim
                    lightIntensity = moonBrightness;
                }
                
                // Update ambient light (reduced brightness)
                aLight.intensity = lightIntensity;
                dLight.intensity = lightIntensity * 0.8;
                
                // Calculate sky color based on time of day and moon phase
                let skyColor;
                if (sunHeight > 0.2) {
                    // Day - bright blue
                    skyColor = new THREE.Color(0x87CEEB);
                } else if (sunHeight > 0) {
                    // Dawn/Dusk - orange/pink
                    const t = sunHeight / 0.2;
                    skyColor = new THREE.Color().lerpColors(
                        new THREE.Color(0xFF6B35), // Orange
                        new THREE.Color(0x87CEEB), // Blue
                        t
                    );
                } else if (sunHeight > -0.2) {
                    // Twilight - dark blue
                    const t = (sunHeight + 0.2) / 0.2;
                    skyColor = new THREE.Color().lerpColors(
                        new THREE.Color(0x1a1a2e), // Dark blue
                        new THREE.Color(0xFF6B35), // Orange
                        t
                    );
                } else {
                    // Night - color varies slightly with moon phase
                    if (moonPhase === 0) {
                        // Full moon - slightly lighter night sky
                        skyColor = new THREE.Color(0x1e1e3e);
                    } else if (moonPhase === 4) {
                        // New moon - darkest night
                        skyColor = new THREE.Color(0x0a0a1a);
                    } else {
                        // Other phases - normal dark blue
                        skyColor = new THREE.Color(0x1a1a2e);
                    }
                }
                
                scene.background = skyColor;
                scene.fog.color = skyColor;
                
                // --- UNDERWATER VISUAL EFFECT ---
                if (isUnderwater) {
                    // Apply blue underwater tint and close fog
                    const underwaterColor = new THREE.Color(0x1a4d6d); // Dark blue-green underwater color
                    scene.background = underwaterColor;
                    scene.fog.color = underwaterColor;
                    scene.fog.near = 10;
                    scene.fog.far = 30;
                } else {
                    // Reset fog to normal distance
                    scene.fog.near = 500;
                    scene.fog.far = 1000;
                }
                
                // --- UPDATE PARTICLES ---
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.lifetime -= dt;
                    
                    if (p.lifetime <= 0) {
                        scene.remove(p);
                        particles.splice(i, 1);
                    } else {
                        p.velocity.y -= GRAVITY * dt;
                        p.position.x += p.velocity.x * dt;
                        p.position.y += p.velocity.y * dt;
                        p.position.z += p.velocity.z * dt;
                        p.material.opacity = p.lifetime;
                        // Billboard effect - make particles face camera
                        p.lookAt(camera.position);
                    }
                }
                
                // --- UPDATE BLOCK OUTLINE ---
                // Performance: Only update outline every few frames when not mining/placing
                if (shouldRaycast && !inventoryOpen) {
                    ray.setFromCamera(new THREE.Vector2(0, 0), camera);
                    
                    // Performance: Only raycast against visible blocks
                    var objs = Object.values(world).filter(function(obj) { return obj.visible !== false; });
                    var hits = ray.intersectObjects(objs);
                    
                    if (hits.length > 0) {
                        var hit = hits[0];
                        var distance = hit.distance;
                        
                        // Only show outline if within reach (5 blocks)
                        if (distance < 5 * bs) {
                            const hitBlock = hit.object;
                            
                            // Check if looking at a door
                            if (hitBlock.userData.blockType === DOOR_TYPE) {
                                // Switch to door outline geometry
                                blockOutline.geometry = doorOutlineGeometry;
                            } else {
                                // Use regular block outline
                                blockOutline.geometry = outlineGeometry;
                            }
                            
                            blockOutline.position.copy(hitBlock.position);
                            blockOutline.rotation.copy(hitBlock.rotation);
                            blockOutline.visible = true;
                        } else {
                            blockOutline.visible = false;
                        }
                    } else {
                        blockOutline.visible = false;
                    }
                } else if (inventoryOpen) {
                    blockOutline.visible = false;
                }

                // Visibility culling handled after camera position update below



                if (locked && !isDead) { 
                    var fx = Math.sin(ry); 
                    var fz = Math.cos(ry); 
                    var rx2 = Math.sin(ry + Math.PI / 2); 
                    var rz = Math.cos(ry + Math.PI / 2); 
                    
                    var inputX = 0; var inputZ = 0;
                    
                    // Sprint and sneak detection (Ctrl for sprint while moving forward, Shift for sneak)
                    // Sprinting now works when jumping and only when moving forward
                    isSprinting = keys['ControlLeft'] && keys[keybinds.forward] && !inventoryOpen && !isSneaking;
                    isSneaking = keys['ShiftLeft'] && !inventoryOpen && !isSprinting;
                    
                    // Calculate speed based on movement state
                    var currentSpeed = BASE_SPD;
                    if (isSprinting) {
                        currentSpeed *= SPRINT_MULTIPLIER;
                    } else if (isSneaking) {
                        currentSpeed *= SNEAK_MULTIPLIER;
                    }

                    if (keys[keybinds.forward] && !inventoryOpen) { inputX -= fx; inputZ -= fz; } 
                    if (keys[keybinds.backward] && !inventoryOpen) { inputX += fx; inputZ += fz; } 
                    if (keys[keybinds.left] && !inventoryOpen) { inputX -= rx2; inputZ -= rz; } 
                    if (keys[keybinds.right] && !inventoryOpen) { inputX += rx2; inputZ += rz; }
                    
                    // Check if player is moving for hand bob
                    isMovingForBob = (inputX !== 0 || inputZ !== 0) && ground;
                    
                    if (isFlying) { 
                        // --- FLYING LOGIC WITH MINECRAFT-STYLE AABB COLLISION ---
                        ground = false;
                        vx = 0; vy = 0; vz = 0;
                        
                        let flySpeed = currentSpeed * dt;
                        
                        var mag = Math.sqrt(inputX * inputX + inputZ * inputZ);
                        if (mag > 0) {
                            inputX /= mag; inputZ /= mag;
                            vx = inputX * flySpeed;
                            vz = inputZ * flySpeed;
                        }
                        
                        if (keys[keybinds.jump] && !inventoryOpen) { vy = flySpeed; }
                        if (keys[keybinds.sneak] && !inventoryOpen) { vy = -flySpeed; }
                        
                        // Create player AABB (eye position is reference point)
                        const feetY = py - EYE_HEIGHT;
                        const playerAABB = AABB.fromCenter(px, feetY, pz, 0.6 * bs, 1.8 * bs);
                        
                        // Use Minecraft-style per-axis collision (no step-up in flying)
                        const collision = moveWithCollision(playerAABB, vx, vy, vz, 0);
                        
                        px += collision.dx;
                        py += collision.dy;
                        pz += collision.dz;
                        
                        if (collision.collidedX) vx = 0;
                        if (collision.collidedY) vy = 0;
                        if (collision.collidedZ) vz = 0;
                        
                    } else {
                        // --- WALKING/FALLING LOGIC WITH MINECRAFT-STYLE AABB COLLISION ---
                        
                        // Check if player is in water or lava (check at feet/waist level, not head)
                        const feetY = py - EYE_HEIGHT; // Player's feet position
                        const waterCheckY = feetY + (PLAYER_TOTAL_HEIGHT * 0.4); // Check at about waist height (40% up from feet)
                        const playerBlockX = Math.round(px / bs);
                        const playerBlockY = Math.round(waterCheckY / bs); // Changed from py to waterCheckY
                        const playerBlockZ = Math.round(pz / bs);
                        const playerBlock = world[key(playerBlockX, playerBlockY, playerBlockZ)];
                        const inFluid = playerBlock && (playerBlock.userData.blockType === WATER_TYPE || playerBlock.userData.blockType === LAVA_TYPE);
                        const inWater = playerBlock && playerBlock.userData.blockType === WATER_TYPE;
                        const inLava = playerBlock && playerBlock.userData.blockType === LAVA_TYPE;
                        
                        var mag = Math.sqrt(inputX * inputX + inputZ * inputZ);

                        if (mag > 0) {
                            inputX /= mag; inputZ /= mag;
                            // Slower movement in fluids
                            const fluidMultiplier = inFluid ? 0.6 : 1.0;
                            vx = inputX * currentSpeed * dt * fluidMultiplier;
                            vz = inputZ * currentSpeed * dt * fluidMultiplier;
                        } else {
                            vx *= FRICTION; vz *= FRICTION; 
                        }
                        
                        // Modified gravity for fluids - Minecraft-style water physics
                        if (inFluid) {
                            // Reset fall damage when entering water/lava
                            if (wasFalling) {
                                wasFalling = false;
                            }
                            
                        // Minecraft-style buoyancy - natural floating
                        if (inWater) {
                            // Check if there's a solid block above water level to jump onto
                            const blockAboveWater = world[key(playerBlockX, playerBlockY + 1, playerBlockZ)];
                            const canJumpOut = !blockAboveWater || blockAboveWater.userData.blockType === WATER_TYPE;
                            
                            // Very slow sinking when idle (almost floating)
                            vy -= GRAVITY * dt * 0.15; // 15% gravity in water - feels like floating
                            
                            // Add slight upward buoyancy force for natural floating
                            vy += GRAVITY * dt * 0.08; // Upward buoyancy
                            
                            // Swimming controls - Minecraft style
                            if (keys[keybinds.jump] && !inventoryOpen) {
                                // Jump out of water with normal jump force
                                vy = JUMP_FORCE;
                            }
                            if (keys[keybinds.sneak] && !inventoryOpen) {
                                vy = -JUMP_FORCE * 0.4; // Swim down
                            }
                            
                            // Apply drag only if not jumping (allow jump momentum to work)
                            if (!keys[keybinds.jump] || vy < 0) {
                                vy *= 0.85; // Strong drag in water for realistic feel
                            }
                            vx *= 0.92;
                            vz *= 0.92;
                            } else if (inLava) {
                                // Lava physics - same as water for easy escape
                                vy -= GRAVITY * dt * 0.15; // Same gravity as water
                                vy += GRAVITY * dt * 0.08; // Same buoyancy as water
                                
                                if (keys[keybinds.jump] && !inventoryOpen) {
                                    vy = JUMP_FORCE; // Full jump force - same as water
                                }
                                if (keys[keybinds.sneak] && !inventoryOpen) {
                                    vy = -JUMP_FORCE * 0.4; // Same sink speed as water
                                }
                                
                                // Apply drag only if not jumping (same as water)
                                if (!keys[keybinds.jump] || vy < 0) {
                                    vy *= 0.85; // Same drag as water
                                }
                                vx *= 0.92; // Same horizontal movement as water
                                vz *= 0.92; // Same horizontal movement as water
                            }
                        } else {
                            // Minecraft-accurate gravity with terminal velocity
                            vy -= GRAVITY * dt;
                            
                            // Apply terminal velocity limit
                            if (vy < TERMINAL_VELOCITY) {
                                vy = TERMINAL_VELOCITY;
                            }
                            
                            // Apply air resistance when falling
                            if (vy < 0) {
                                vy *= (1 - AIR_RESISTANCE);
                            }
                            
                            // --- FALL DAMAGE TRACKING ---
                            // Track when player starts falling
                            if (!ground && vy < 0 && !wasFalling && !isCreativeMode) {
                                fallStartY = py; // Record height when fall started
                                wasFalling = true;
                            }
                            // ---------------------------
                            
                            if (keys[keybinds.jump] && ground && !inventoryOpen) { 
                                vy = JUMP_FORCE; 
                                ground = false; 
                                const blockUnderPlayer = getBlockUnderPlayer();
                                playJumpSound(blockUnderPlayer); // Play jump sound based on block type
                            }
                        }
                        
                        // Create player AABB (feet position as base)
                        // feetY already declared above
                        let playerAABB = AABB.fromCenter(px, feetY, pz, 0.6 * bs, 1.8 * bs);
                        
                        // Use Minecraft-style per-axis collision with 0.6 block step-up
                        const stepUpHeight = 0.6 * bs;
                        const collision = moveWithCollision(playerAABB, vx, vy * dt, vz, stepUpHeight);
                        
                        // --- FALL DAMAGE CALCULATION ---
                        if (collision.onGround && wasFalling && !isCreativeMode && !isDead && !inFluid) {
                            const fallDistance = (fallStartY - py) / bs; // Convert to blocks
                            if (fallDistance > SAFE_FALL_DISTANCE) {
                                const damageBlocks = fallDistance - SAFE_FALL_DISTANCE;
                                const fallDamage = Math.floor(damageBlocks * FALL_DAMAGE_MULTIPLIER * 2); // *2 for half-hearts
                                if (fallDamage > 0) {
                                    takeDamage(fallDamage);
                                }
                            }
                            wasFalling = false;
                        }
                        // -----------------------------
                        
                        // Update position
                        px += collision.dx;
                        py += collision.dy;
                        pz += collision.dz;
                        
                        // Update ground state
                        ground = collision.onGround;
                        
                        // Update velocities
                        if (collision.collidedX) vx = 0;
                        if (collision.collidedY) vy = 0;
                        if (collision.collidedZ) vz = 0;
                        
                        // Sneaking - prevent falling off edges
                        if (isSneaking && ground) {
                            // Check if player is near an edge
                            const sneakCheckDist = 0.4 * bs;
                            const futureX = px + (vx * dt);
                            const futureZ = pz + (vz * dt);
                            const feetY = py - EYE_HEIGHT;
                            const blockBelowFuture = world[key(Math.round(futureX / bs), Math.round((feetY - 0.1) / bs), Math.round(futureZ / bs))];
                            
                            // If no block below future position, stop movement
                            if (!blockBelowFuture) {
                                vx = 0;
                                vz = 0;
                            }
                        }
                        
                        // Smooth FOV transition for sprinting (relative to user's FOV setting)
                        const targetFOVOffset = isSprinting ? sprintFOVBoost : 0;
                        if (Math.abs(currentFOVOffset - targetFOVOffset) > 0.1) {
                            currentFOVOffset += (targetFOVOffset - currentFOVOffset) * fovTransitionSpeed * dt;
                            camera.fov = fieldOfView + currentFOVOffset;
                            camera.updateProjectionMatrix();
                        }
                        
                        // Update movement status indicator
                        const movementStatus = document.getElementById('movement-status');
                        if (movementStatus) {
                            if (isSprinting) {
                                movementStatus.textContent = ' SPRINTING (Ctrl)';
                                movementStatus.className = 'sprinting';
                            } else if (isSneaking) {
                                movementStatus.textContent = ' SNEAKING (Shift)';
                                movementStatus.className = 'sneaking';
                            } else {
                                movementStatus.className = '';
                                movementStatus.style.display = 'none';
                            }
                        }
                        
                        // --- WORLD BORDER COLLISION ---
                        if (worldBorderEnabled) {
                            const halfWorldSize = (ws / 2) * bs; // World size in world units (matches generation range)
                            const borderMargin = PLAYER_RADIUS + 0.1;
                            
                            // Check X boundaries
                            if (px > halfWorldSize - borderMargin) {
                                px = halfWorldSize - borderMargin;
                                vx = 0;
                            } else if (px < -halfWorldSize + borderMargin) {
                                px = -halfWorldSize + borderMargin;
                                vx = 0;
                            }
                            
                            // Check Z boundaries
                            if (pz > halfWorldSize - borderMargin) {
                                pz = halfWorldSize - borderMargin;
                                vz = 0;
                            } else if (pz < -halfWorldSize + borderMargin) {
                                pz = -halfWorldSize + borderMargin;
                                vz = 0;
                            }
                        }
                        
                        // Handle entity pushing
                        const currentPlayerAABB = AABB.fromCenter(px, py - EYE_HEIGHT, pz, 0.6 * bs, 1.8 * bs);
                        handleEntityPushing(currentPlayerAABB, vx, vz);
                        
                        // --- WALKING SOUND SYSTEM WITH BLOCK DETECTION ---
                        // Footsteps now react to movement speed
                        const isMoving = mag > 0 && ground;
                        if (isMoving) {
                            // Adjust step interval based on speed (faster when sprinting)
                            const speedMultiplier = isSprinting ? SPRINT_MULTIPLIER : (isSneaking ? SNEAK_MULTIPLIER : 1.0);
                            stepTimer += dt * speedMultiplier;
                            if (stepTimer >= stepInterval) {
                                const blockUnderPlayer = getBlockUnderPlayer();
                                playStepSound(blockUnderPlayer);
                                stepTimer = 0;
                            }
                            wasMoving = true;
                            
                            // Update walking animation timer
                            walkAnimationTimer += dt * WALK_ANIMATION_SPEED;
                        } else {
                            stepTimer = 0;
                            wasMoving = false;
                            
                            // Reset animation timer when not moving
                            walkAnimationTimer = 0;
                        }
                    }
                    
                    // --- STUCK DETECTION SYSTEM REMOVED ---
                    // (Teleporting disabled to prevent unexpected movement)
                    
                    // --- PERSPECTIVE SWITCHING ---
                    if (perspectiveMode === 0) {
                        // First person view with camera shake effect
                        camera.position.set(px, py, pz);
                        camera.rotation.set(rx + shakeOffset.x, ry + shakeOffset.y, shakeOffset.z, 'YXZ');
                        playerModelGroup.visible = false;
                    } else {
                        // Third person view with collision detection
                        let distance = THIRD_PERSON_DISTANCE;
                        const direction = perspectiveMode === 1 ? 1 : -1; // 1 = back, -1 = front
                        
                        // Calculate intended camera position
                        const cosPitch = Math.cos(rx);
                        const offsetX = Math.sin(ry) * cosPitch * distance * direction;
                        const offsetZ = Math.cos(ry) * cosPitch * distance * direction;
                        const offsetY = Math.sin(rx) * distance;
                        
                        const intendedCameraX = px - offsetX;
                        const intendedCameraY = py - 0.8 + offsetY;
                        const intendedCameraZ = pz - offsetZ;
                        
                        // Check for collision and adjust distance
                        const safeDistance = checkCameraCollision(px, py, pz, intendedCameraX, intendedCameraY, intendedCameraZ, distance);
                        
                        // Recalculate camera position with safe distance
                        const finalOffsetX = Math.sin(ry) * cosPitch * safeDistance * direction;
                        const finalOffsetZ = Math.cos(ry) * cosPitch * safeDistance * direction;
                        const finalOffsetY = Math.sin(rx) * safeDistance;
                        
                        camera.position.set(
                          px - finalOffsetX,
                          py - 0.8 + finalOffsetY,
                          pz - finalOffsetZ
                        );
                        
                        // Show and update player model
        playerModelGroup.visible = true;
        // Position model properly - account for scaled model and eye height
        const feetY = py - EYE_HEIGHT; // Player's feet position
        // Add small downward offset to prevent floating appearance (1 pixel up from previous = 0.0625 blocks)
        const MODEL_OFFSET_Y = -0.1125 * bs; // Offset to lower model (adjusted up by 1 pixel)
        const modelCenterY = feetY + (PLAYER_TOTAL_HEIGHT * modelScale) / 2 + MODEL_OFFSET_Y; // Center of scaled model with offset
        playerModelGroup.position.set(px, modelCenterY, pz);
        playerModelGroup.rotation.y = ry + Math.PI; // Face correct direction
        
        // Camera locked on head position
        const headWorldY = modelCenterY + (0.125 * modelScale); // Head offset from model center
        camera.lookAt(px, headWorldY, pz);
                        
                        // Apply animations to limbs
                        const isCurrentlyMoving = (Math.abs(vx) > 0.01 || Math.abs(vz) > 0.01) && ground;
                        
                        if (isCurrentlyMoving) {
                            // Walking animation
                            const swingAngle = Math.sin(walkAnimationTimer);
                            
                            // Animate arms (opposite swing)
                            leftArmPivot.rotation.x = swingAngle * ARM_SWING_AMPLITUDE;
                            rightArmPivot.rotation.x = -swingAngle * ARM_SWING_AMPLITUDE;
                            leftArmPivot.rotation.z = 0;
                            rightArmPivot.rotation.z = 0;
                            
                            // Animate legs (opposite swing)
                            leftLegPivot.rotation.x = -swingAngle * LEG_SWING_AMPLITUDE;
                            rightLegPivot.rotation.x = swingAngle * LEG_SWING_AMPLITUDE;
                            
                            // Reset head and body to neutral when moving
                            headMesh.position.y = 0.125 * modelScale;
                            bodyMesh.rotation.y = 0;
                        } else {
                            // Idle animation (Minecraft-style breathing)
                            idleAnimationTimer += 0.016 * IDLE_ANIMATION_SPEED; // ~60 FPS
                            const idleSway = Math.sin(idleAnimationTimer);
                            const idleBreathe = Math.sin(idleAnimationTimer * 0.7); // Slower breathing
                            
                            // Subtle arm sway (arms swing slightly inward/outward)
                            leftArmPivot.rotation.x = idleBreathe * IDLE_ARM_SWAY;
                            rightArmPivot.rotation.x = idleBreathe * IDLE_ARM_SWAY;
                            leftArmPivot.rotation.z = idleSway * IDLE_ARM_SWAY * 0.5;
                            rightArmPivot.rotation.z = -idleSway * IDLE_ARM_SWAY * 0.5;
                            
                            // Legs stay still during idle
                            leftLegPivot.rotation.x = 0;
                            rightLegPivot.rotation.x = 0;
                            
                            // Subtle head bob
                            headMesh.position.y = (0.125 * modelScale) + (idleBreathe * IDLE_HEAD_BOB);
                            
                            // Very subtle body rotation (breathing effect)
                            bodyMesh.rotation.y = idleSway * IDLE_BODY_SWAY;
                        }
                    }
                    // --- END PERSPECTIVE SWITCHING ---
                    
                    
                    // --- UPDATE DEBUG HITBOX POSITION ---
                    if (showHitbox) {
                        // Position hitbox at player's center (feet + half height)
                        const feetY = py - EYE_HEIGHT;
                        const centerY = feetY + PLAYER_TOTAL_HEIGHT / 2;
                        hitboxWireframe.position.set(px, centerY, pz);
                    }
                    // --- END DEBUG HITBOX UPDATE ---

                    if (py < -50) { 
                        resetPlayer();
                    }
                } else {
                    // Paused - apply same perspective logic
                    if (perspectiveMode === 0) {
                        camera.position.set(px, py, pz);
                        camera.rotation.set(rx, ry, 0, 'YXZ');
                        playerModelGroup.visible = false;
                    } else {
                    // Third person view with collision detection (paused)
                    let distance = THIRD_PERSON_DISTANCE;
                    const direction = perspectiveMode === 1 ? 1 : -1;
                    
                    const cosPitch = Math.cos(rx);
                    const offsetX = Math.sin(ry) * cosPitch * distance * direction;
                    const offsetZ = Math.cos(ry) * cosPitch * distance * direction;
                    const offsetY = Math.sin(rx) * distance;
                    
                    const intendedCameraX = px - offsetX;
                    const intendedCameraY = py - 0.8 + offsetY;
                    const intendedCameraZ = pz - offsetZ;
                    
                    // Check for collision and adjust distance
                    const safeDistance = checkCameraCollision(px, py, pz, intendedCameraX, intendedCameraY, intendedCameraZ, distance);
                    
                    // Recalculate with safe distance
                    const finalOffsetX = Math.sin(ry) * cosPitch * safeDistance * direction;
                    const finalOffsetZ = Math.cos(ry) * cosPitch * safeDistance * direction;
                    const finalOffsetY = Math.sin(rx) * safeDistance;
                    
                    playerModelGroup.visible = true;
                    const feetY = py - EYE_HEIGHT;
                    // Add small downward offset to prevent floating appearance (1 pixel up from previous = 0.0625 blocks)
                    const MODEL_OFFSET_Y = -0.1125 * bs; // Offset to lower model (adjusted up by 1 pixel)
                    const modelCenterY = feetY + (PLAYER_TOTAL_HEIGHT * modelScale) / 2 + MODEL_OFFSET_Y;
                    playerModelGroup.position.set(px, modelCenterY, pz);
                    playerModelGroup.rotation.y = ry + Math.PI;
                    
                    // Apply idle animation even when paused
                    idleAnimationTimer += 0.016 * IDLE_ANIMATION_SPEED;
                    const idleSway = Math.sin(idleAnimationTimer);
                    const idleBreathe = Math.sin(idleAnimationTimer * 0.7);
                    
                    leftArmPivot.rotation.x = idleBreathe * IDLE_ARM_SWAY;
                    rightArmPivot.rotation.x = idleBreathe * IDLE_ARM_SWAY;
                    leftArmPivot.rotation.z = idleSway * IDLE_ARM_SWAY * 0.5;
                    rightArmPivot.rotation.z = -idleSway * IDLE_ARM_SWAY * 0.5;
                    leftLegPivot.rotation.x = 0;
                    rightLegPivot.rotation.x = 0;
                    headMesh.position.y = (0.125 * modelScale) + (idleBreathe * IDLE_HEAD_BOB);
                    bodyMesh.rotation.y = idleSway * IDLE_BODY_SWAY;
                    
                    // Camera locked on head position
                    const headWorldY = modelCenterY + (0.125 * modelScale);
                    camera.position.set(px - finalOffsetX, py - 0.8 + finalOffsetY, pz - finalOffsetZ);
                    camera.lookAt(px, headWorldY, pz);
                    }
                    
                    // --- UPDATE DEBUG HITBOX POSITION (paused) ---
                    if (showHitbox) {
                        const feetY = py - EYE_HEIGHT;
                        const centerY = feetY + PLAYER_TOTAL_HEIGHT / 2;
                        hitboxWireframe.position.set(px, centerY, pz);
                    }
                    // --- END DEBUG HITBOX UPDATE ---
                }
            } else { last = now; }
            
            // --- UPDATE LOOKING-AT DISPLAY (Raycast from eye) ---
            if (locked && !paused && !inventoryOpen) {
                // Get camera direction
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                
                // Perform raycast from eye position
                const rayResult = raycastFromEye(
                    px, py, pz,
                    direction.x, direction.y, direction.z,
                    8 * bs // Max distance: 8 blocks
                );
                
                const lookingAtInfo = document.getElementById('looking-at-info');
                if (rayResult.hit) {
                    const block = rayResult.block;
                    const blockType = block.userData.blockType;
                    
                    // Get block name from type
                    let blockName = '';
                    for (const [name, type] of Object.entries(window)) {
                        if (name.endsWith('_TYPE') && type === blockType) {
                            blockName = name.replace('_TYPE', '').toLowerCase()
                                .split('_')
                                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                                .join(' ');
                            break;
                        }
                    }
                    
                    if (blockName) {
                        lookingAtInfo.textContent = `${blockName} [${rayResult.blockX}, ${rayResult.blockY}, ${rayResult.blockZ}]`;
                        lookingAtInfo.style.display = 'block';
                    } else {
                        lookingAtInfo.style.display = 'none';
                    }
                } else {
                    lookingAtInfo.style.display = 'none';
                }
            } else {
                const lookingAtInfo = document.getElementById('looking-at-info');
                if (lookingAtInfo) lookingAtInfo.style.display = 'none';
            }
            // --- END LOOKING-AT DISPLAY ---
            
            // --- OPTIMIZED VISIBILITY CULLING (for large worlds) ---
            // Per-face culling is handled at geometry creation time in createCulledGeometry()
            (function(){
                var playerBlockX = Math.round(px / bs);
                var playerBlockY = Math.round(py / bs);
                var playerBlockZ = Math.round(pz / bs);
                var forward = new THREE.Vector3();
                camera.getWorldDirection(forward);
                var vFovRad = camera.fov * Math.PI / 180;
                var hFovRad = 2 * Math.atan(Math.tan(vFovRad / 2) * camera.aspect);
                var halfAngle = Math.max(vFovRad, hFovRad) * 0.5 + 1.2;
                var cosThreshold = Math.cos(halfAngle);
                
                // Optimization: Only check blocks within a reasonable range
                const checkRadius = renderDistance + 5;

                for (var k in world) {
                    var mesh = world[k];
                    var bx = Math.round(mesh.position.x / bs);
                    var by = Math.round(mesh.position.y / bs);
                    var bz = Math.round(mesh.position.z / bs);
                    
                    // Quick distance check before expensive calculations
                    var blockDistX = Math.abs(bx - playerBlockX);
                    var blockDistZ = Math.abs(bz - playerBlockZ);
                    var blockDistY = Math.abs(by - playerBlockY);
                    
                    // Fast rejection for blocks way outside render distance
                    if (blockDistX > checkRadius || blockDistZ > checkRadius || blockDistY > checkRadius) {
                        mesh.visible = false;
                        continue;
                    }
                    
                    var distanceBlocks = Math.sqrt(
                        blockDistX * blockDistX +
                        blockDistZ * blockDistZ
                    );

                    if (distanceBlocks > renderDistance) { 
                        mesh.visible = false; 
                        continue; 
                    }
                    
                    // FOV culling (only for distant blocks to save performance)
                    if (distanceBlocks > renderDistance * 0.5) {
                        var dx = mesh.position.x - camera.position.x;
                        var dy = mesh.position.y - camera.position.y;
                        var dz = mesh.position.z - camera.position.z;
                        var len = Math.sqrt(dx*dx + dy*dy + dz*dz) || 1;
                        var ux = dx / len, uy = dy / len, uz = dz / len;
                        var cosA = ux*forward.x + uy*forward.y + uz*forward.z;
                        
                        if (cosA < cosThreshold) { 
                            mesh.visible = false; 
                            continue; 
                        }
                    }

                    mesh.visible = true;
                }
            })();

            // --- Sand Falling Physics (Falls through water) ---
            if (!paused && dt > 0) { 
                sandFallTimer += dt;
                if (sandFallTimer >= SAND_FALL_CHECK_INTERVAL) {
                    sandFallTimer = 0;

                    const fallingBlocks = [];
                    for (const k in world) {
                        const mesh = world[k];
                        if (mesh.userData.blockType === SAND_TYPE) {
                            const [bx, by, bz] = k.split(',').map(Number);
                            const blockBelow = world[key(bx, by - 1, bz)];
                            
                            // Sand falls if there's nothing below OR if there's water below
                            if (by > 1 && (!blockBelow || blockBelow.userData.blockType === WATER_TYPE)) {
                                fallingBlocks.push({ oldKey: k, x: bx, y: by, z: bz, type: SAND_TYPE });
                            }
                        }
                    }
                    
                    for (const block of fallingBlocks) {
                        const { oldKey, x, y, z, type } = block;
                        
                        const meshToRemove = world[oldKey];
                        if (meshToRemove) {
                            scene.remove(meshToRemove);
                            if (meshToRemove.geometry) meshToRemove.geometry.dispose(); 
                            delete world[oldKey];
                            refreshNeighborFaces(x, y, z);
                        }

                        // If landing position has water, remove the water first
                        const targetKey = key(x, y - 1, z);
                        const targetBlock = world[targetKey];
                        if (targetBlock && targetBlock.userData.blockType === WATER_TYPE) {
                            scene.remove(targetBlock);
                            delete world[targetKey];
                        }

                        add(x, y - 1, z, type); 
                    }
                }
            }
            
            // --- NEW: Grass Spreading Physics ---
            if (!paused && dt > 0) {
                grassSpreadTimer += dt;
                
                if (grassSpreadTimer >= GRASS_SPREAD_CHECK_INTERVAL) {
                    grassSpreadTimer = 0;

                    // Calculate the chance of growth for this interval (1/300 for an average 5 minute spread)
                    const spreadChance = GRASS_SPREAD_CHECK_INTERVAL / GRASS_SPREAD_CHANCE_MAX_SECONDS; 

                    // Only process a small, random number of dirt blocks for performance
                    const dirtBlocks = [];
                    for (const k in world) {
                        const mesh = world[k];
                        if (mesh.userData.blockType === DIRT_TYPE) { // 1 is DIRT
                            dirtBlocks.push(k);
                        }
                    }
                    
                    // Shuffle the dirt blocks and only check a fraction (e.g., 50 max)
                    dirtBlocks.sort(() => Math.random() - 0.5);
                    const maxChecks = Math.min(dirtBlocks.length, 50); 
                    
                    for (let i = 0; i < maxChecks; i++) {
                        const k = dirtBlocks[i];
                        const [bx, by, bz] = k.split(',').map(Number);
                        
                        // 1. Check for light (Air/Non-solid block above it)
                        const hasLight = !world[key(bx, by + 1, bz)]; 
                        
                        if (hasLight) {
                            let hasGrassNeighbor = false;
                            
                            // 2. Check for an adjacent Grass block (source) in a 3x3 horizontal area
                            for (let dx = -1; dx <= 1; dx++) {
                                for (let dz = -1; dz <= 1; dz++) {
                                    if (dx === 0 && dz === 0) continue; // Skip self

                                    const neighbor = world[key(bx + dx, by, bz + dz)];
                                    if (neighbor && neighbor.userData.blockType === GRASS_TYPE) {
                                        hasGrassNeighbor = true;
                                        break;
                                    }
                                }
                                if (hasGrassNeighbor) break;
                            }
                            
                            if (hasGrassNeighbor) {
                                // 3. Random chance check
                                if (Math.random() < spreadChance) {
                                    
                                    // Remove old dirt block
                                    const meshToRemove = world[k];
                                    if (meshToRemove) {
                                        scene.remove(meshToRemove);
                                        if (meshToRemove.geometry) meshToRemove.geometry.dispose(); 
                                        delete world[k];
                                    }
                                    
                                    // Add new grass block (type 0) silently
                                    const grassKey = key(bx, by, bz);
                                    var m = mats[GRASS_TYPE];
                                    var mesh = new THREE.Mesh(blockGeometry, Array.isArray(m) ? m : [m, m, m, m, m, m]); 
                                    mesh.position.set(bx * bs, by * bs, bz * bs);
                                    mesh.castShadow = true;
                                    mesh.receiveShadow = true;
                                    mesh.userData.blockType = GRASS_TYPE;
                                    mesh.userData.silentPlace = true; // Flag to prevent sound
                                    scene.add(mesh);
                                    world[grassKey] = mesh;
                                }
                            }
                        }
                    }
                }
            }
            // --- END NEW: Grass Spreading Physics ---
            
            // --- LIQUID FLOW SYSTEM UPDATE ---
            if (!paused && dt > 0) {
                liquidFlowTimer += dt;
                if (liquidFlowTimer >= LIQUID_FLOW_INTERVAL) {
                    liquidFlowTimer = 0;
                    flowLiquids();
                }
            }
            // --- END LIQUID FLOW SYSTEM ---
            
            // --- HAND SWING & BOB ANIMATION ---
            // Apply animations to whichever mesh is visible (hand or item)
            const activeHandMesh = (fpHandMesh && fpHandMesh.visible) ? fpHandMesh : heldItemMesh;
            
            if (activeHandMesh && !inventoryOpen && !isDead && showItemInHand) {
                // Get base position and rotation
                const basePos = activeHandMesh.userData.basePosition || { x: 0.2, y: -0.15, z: -0.4 };
                const baseRot = activeHandMesh.userData.baseRotation || { x: -0.6, y: 0.3, z: -0.1 };
                
                // Update swing animation
                let swingOffsetY = 0;
                let swingRotX = 0;
                let swingRotZ = 0;
                
                if (isSwinging) {
                    handSwingTimer += dt;
                    
                    if (handSwingTimer >= SWING_DURATION) {
                        // Swing complete
                        isSwinging = false;
                        handSwingTimer = 0;
                    } else {
                        // Calculate swing progress (0 to 1)
                        const progress = handSwingTimer / SWING_DURATION;
                        
                        // Minecraft-style swing: fast down, slower return
                        // Use ease-out-quad for smooth deceleration
                        const easeOut = 1 - Math.pow(1 - progress, 2);
                        
                        // Swing motion: rotate around X axis (pitch) and translate Y
                        swingRotX = Math.sin(easeOut * Math.PI) * -1.2; // Big downward swing
                        swingRotZ = Math.sin(easeOut * Math.PI) * 0.3;  // Slight roll
                        swingOffsetY = Math.sin(easeOut * Math.PI) * 0.15; // Move down during swing
                    }
                }
                
                // Update bob timer only if bobbing is enabled and not swinging
                // Hand bobbing now reacts to movement speed (faster when sprinting, slower when sneaking)
                if (handBobEnabled && isMovingForBob && !isSwinging) {
                    const speedMultiplier = isSprinting ? SPRINT_MULTIPLIER : (isSneaking ? SNEAK_MULTIPLIER : 1.0);
                    handBobTimer += dt * 6.28 * speedMultiplier; // Speed-reactive bobbing
                } else {
                    handBobTimer = 0;
                }
                
                // Apply Minecraft-style bobbing motion with intensity multiplier
                const intensityMultiplier = handBobIntensity / 100; // Convert percentage to multiplier
                
                // Minecraft bobbing: primarily vertical with slight horizontal sway
                const bobY = (handBobEnabled && !isSwinging) ? 
                    Math.abs(Math.sin(handBobTimer)) * 0.04 * intensityMultiplier : 0;
                    
                const bobX = (handBobEnabled && !isSwinging) ? 
                    Math.sin(handBobTimer * 2) * 0.01 * intensityMultiplier : 0;
                
                // Minecraft bobbing also includes Z movement (forward/back)
                // When hand bobbing is disabled, use resting position (same as handBobTimer = 0)
                const bobZ = (handBobEnabled && !isSwinging) ? 
                    Math.cos(handBobTimer * 2) * 0.015 * intensityMultiplier : 0.015 * intensityMultiplier;
                
                // Apply combined position (base + bob + swing)
                activeHandMesh.position.set(
                    basePos.x + bobX,
                    basePos.y - bobY + swingOffsetY, // Negative because hand bobs down
                    basePos.z + bobZ
                );
                
                // Apply Minecraft-style rotation bobbing (more pronounced tilt)
                const tiltX = (handBobEnabled && !isSwinging) ? 
                    Math.sin(handBobTimer) * 0.15 * intensityMultiplier : 0;
                // When hand bobbing is disabled, use resting rotation (same as handBobTimer = 0)
                const tiltZ = (handBobEnabled && !isSwinging) ? 
                    Math.cos(handBobTimer * 2) * 0.08 * intensityMultiplier : 0.08 * intensityMultiplier;
                
                activeHandMesh.rotation.set(
                    baseRot.x + tiltX + swingRotX, // Natural pitch animation like Minecraft
                    baseRot.y, // Keep base yaw
                    baseRot.z + tiltZ + swingRotZ // Natural roll without flip
                );
            }
            
            // Render main scene
            renderer.render(scene, camera);
            
            // Render hand/item overlay in separate 3D dimension (always on top)
            // Only show in first-person mode - render whichever is visible
            if (!inventoryOpen && !isDead && showItemInHand && perspectiveMode === 0) {
                const shouldRenderHand = fpHandMesh && fpHandMesh.visible;
                const shouldRenderItem = heldItemMesh && (!fpHandMesh || !fpHandMesh.visible);
                
                if (shouldRenderHand || shouldRenderItem) {
                    renderer.autoClear = false; // Don't clear color buffer
                    renderer.clearDepth(); // Clear depth buffer - puts hand in separate 3D layer
                    renderer.render(handScene, handCamera);
                    renderer.autoClear = true; // Re-enable for next frame
                }
            }
        }
        
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            handCamera.aspect = window.innerWidth / window.innerHeight;
            handCamera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Reset fake cursor on resize
            fakeCursorX = window.innerWidth / 2;
            fakeCursorY = window.innerHeight / 2;
        });
        
        // ==================== MAIN MENU MOUSE TRACKING ====================
        let mainMenuTracking = true;
        let mainMenuButtons = [];
        let mainMenuMouseX = window.innerWidth / 2;
        let mainMenuMouseY = window.innerHeight / 2;
        let mainMenuTitle = null;
        
        function initMainMenuTracking() {
            // Get all main menu buttons EXCEPT fixed-position back buttons
            mainMenuButtons = Array.from(document.querySelectorAll('.main-menu-btn:not(.fixed-back-btn)'));
            mainMenuTitle = document.querySelector('#main-menu h1');
            
            // Track mouse globally - even outside window
            document.addEventListener('mousemove', handleMainMenuTracking);
            window.addEventListener('mouseout', handleMainMenuMouseLeave);
            window.addEventListener('mouseleave', handleMainMenuMouseLeave);
            
            // Start animation loop
            animateMainMenuButtons();
        }
        
        function handleMainMenuTracking(e) {
            mainMenuMouseX = e.clientX;
            mainMenuMouseY = e.clientY;
        }
        
        function handleMainMenuMouseLeave(e) {
            // Keep the last known position when mouse leaves
            if (e.clientX !== undefined) {
                mainMenuMouseX = e.clientX;
                mainMenuMouseY = e.clientY;
            }
        }
        
        function animateMainMenuButtons() {
            if (!mainMenuTracking) {
                requestAnimationFrame(animateMainMenuButtons);
                return;
            }
            
            // Only apply if main menu is visible
            const mainMenu = document.getElementById('main-menu');
            const mainControls = document.getElementById('main-controls');
            
            if (mainMenu && mainMenu.style.display !== 'none' && mainControls && mainControls.style.display !== 'none') {
                // Animate title
                if (mainMenuTitle) {
                    const titleRect = mainMenuTitle.getBoundingClientRect();
                    const titleCenterX = titleRect.left + titleRect.width / 2;
                    const titleCenterY = titleRect.top + titleRect.height / 2;
                    
                    const titleDeltaX = mainMenuMouseX - titleCenterX;
                    const titleDeltaY = mainMenuMouseY - titleCenterY;
                    
                    const titleRotateY = (titleDeltaX / window.innerWidth) * 5;
                    const titleRotateX = -(titleDeltaY / window.innerHeight) * 5;
                    
                    mainMenuTitle.style.transform = `
                        perspective(1200px)
                        rotateX(${titleRotateX}deg)
                        rotateY(${titleRotateY}deg)
                        translateZ(10px)
                    `;
                    
                    const titleDistance = Math.sqrt(titleDeltaX * titleDeltaX + titleDeltaY * titleDeltaY);
                    const maxDist = Math.sqrt(window.innerWidth * window.innerWidth + window.innerHeight * window.innerHeight);
                    const titleGlow = 1 - (titleDistance / maxDist);
                    mainMenuTitle.style.textShadow = `
                        4px 4px 0px rgba(0, 0, 0, 0.5),
                        0 0 ${20 + titleGlow * 40}px rgba(121, 192, 90, ${titleGlow * 0.6})
                    `;
                }
                
                // Animate buttons
                mainMenuButtons.forEach((button, index) => {
                    if (!button.getBoundingClientRect) return;
                    
                    const rect = button.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    
                    const deltaX = mainMenuMouseX - centerX;
                    const deltaY = mainMenuMouseY - centerY;
                    
                    // Calculate distance for proximity effect
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    const maxDistance = 400; // Proximity threshold
                    const proximityFactor = Math.max(0, 1 - (distance / maxDistance));
                    
                    // More dramatic rotation when mouse is closer
                    const maxRotation = 12 + (proximityFactor * 8);
                    const maxTranslate = 8 + (proximityFactor * 12);
                    const rotateY = (deltaX / window.innerWidth) * maxRotation * (1 + proximityFactor);
                    const rotateX = -(deltaY / window.innerHeight) * maxRotation * (1 + proximityFactor);
                    const translateX = (deltaX / window.innerWidth) * maxTranslate;
                    const translateY = (deltaY / window.innerHeight) * maxTranslate;
                    const translateZ = 5 + (proximityFactor * 15);
                    
                    // Apply dramatic 3D effect
                    button.style.transform = `
                        perspective(800px)
                        rotateX(${rotateX}deg)
                        rotateY(${rotateY}deg)
                        translateX(${translateX}px)
                        translateY(${translateY}px)
                        translateZ(${translateZ}px)
                        scale(${1 + proximityFactor * 0.05})
                    `;
                    
                    // Dynamic glow and shadow
                    const normalizedDist = distance / Math.sqrt(window.innerWidth * window.innerWidth + window.innerHeight * window.innerHeight);
                    const glowIntensity = 1 - normalizedDist;
                    const shadowX = rotateY * 3;
                    const shadowY = -rotateX * 3;
                    
                    button.style.boxShadow = `
                        inset 0 -4px 0 0 rgba(0, 0, 0, 0.4),
                        inset 0 4px 0 0 rgba(255, 255, 255, ${0.25 + glowIntensity * 0.2}),
                        ${shadowX}px ${shadowY}px ${20 + proximityFactor * 30}px rgba(0, 0, 0, ${0.3 + proximityFactor * 0.2}),
                        0 0 ${15 + glowIntensity * 35}px rgba(121, 192, 90, ${glowIntensity * 0.5 + proximityFactor * 0.3})
                    `;
                });
            }
            
            requestAnimationFrame(animateMainMenuButtons);
        }
        
        // Initialize main menu tracking when page loads
        window.addEventListener('load', () => {
            setTimeout(initMainMenuTracking, 100);
            
            // Trigger main menu fade-in animation on page load
            const mainMenu = document.getElementById('main-menu');
            if (mainMenu && mainMenu.style.display !== 'none') {
                setTimeout(() => {
                    mainMenu.classList.add('menu-fade-in');
                    // Also trigger animation for main-controls view
                    const mainControls = document.getElementById('main-controls');
                    if (mainControls) {
                        mainControls.classList.add('menu-animate');
                    }
                }, 50);
            }
        });
        
        // ==================== STARFIELD BACKGROUND ====================
        const starfieldCanvas = document.getElementById('starfield-bg');
        const starCtx = starfieldCanvas.getContext('2d');
        let starMouseX = window.innerWidth / 2;
        let starMouseY = window.innerHeight / 2;
        let targetStarMouseX = starMouseX;
        let targetStarMouseY = starMouseY;
        
        // Star and shooting star arrays
        const stars = [];
        const shootingStars = [];
        const NUM_STARS = 300;
        
        // Star class for parallax effect
        class Star {
            constructor() {
                this.reset();
            }
            
            reset() {
                this.x = Math.random() * starfieldCanvas.width;
                this.y = Math.random() * starfieldCanvas.height;
                this.z = Math.random() * 3; // Depth layer (0-3 for parallax)
                this.size = Math.floor((1 + this.z) * 1) + 1; // Blocky sizes: 1, 2, 3, 4 pixels
                this.baseX = this.x;
                this.baseY = this.y;
                this.twinkleSpeed = Math.random() * 0.02 + 0.01;
                this.twinkleOffset = Math.random() * Math.PI * 2;
                // Color variations - white or light blue only (no green)
                const colorChoice = Math.random();
                if (colorChoice < 0.7) {
                    this.color = `rgba(255, 255, 255, ${0.4 + Math.random() * 0.6})`;
                } else {
                    this.color = `rgba(200, 220, 255, ${0.4 + Math.random() * 0.6})`;
                }
            }
            
            update(mouseX, mouseY) {
                // Parallax effect based on mouse position
                const parallaxStrength = (this.z + 1) * 20;
                const centerX = starfieldCanvas.width / 2;
                const centerY = starfieldCanvas.height / 2;
                
                const offsetX = (mouseX - centerX) / centerX;
                const offsetY = (mouseY - centerY) / centerY;
                
                this.x = this.baseX - offsetX * parallaxStrength;
                this.y = this.baseY - offsetY * parallaxStrength;
                
                // Wrap around screen
                if (this.x < -10) this.baseX += starfieldCanvas.width + 20;
                if (this.x > starfieldCanvas.width + 10) this.baseX -= starfieldCanvas.width + 20;
                if (this.y < -10) this.baseY += starfieldCanvas.height + 20;
                if (this.y > starfieldCanvas.height + 10) this.baseY -= starfieldCanvas.height + 20;
            }
            
            draw(ctx, time) {
                // Twinkling effect
                const twinkle = Math.sin(time * this.twinkleSpeed + this.twinkleOffset) * 0.3 + 0.7;
                const alpha = parseFloat(this.color.match(/[\d.]+\)$/)[0]);
                const baseColor = this.color.substring(0, this.color.lastIndexOf(','));
                
                // Draw blocky star (rectangle instead of circle)
                ctx.fillStyle = `${baseColor}, ${alpha * twinkle})`;
                const roundedX = Math.floor(this.x);
                const roundedY = Math.floor(this.y);
                ctx.fillRect(roundedX, roundedY, this.size, this.size);
                
                // Add blocky glow for larger stars
                if (this.size >= 3 && twinkle > 0.8) {
                    ctx.fillStyle = `${baseColor}, ${alpha * twinkle * 0.3})`;
                    ctx.fillRect(roundedX - 1, roundedY - 1, this.size + 2, this.size + 2);
                    
                    ctx.fillStyle = `${baseColor}, ${alpha * twinkle * 0.15})`;
                    ctx.fillRect(roundedX - 2, roundedY - 2, this.size + 4, this.size + 4);
                }
            }
        }
        
        // Shooting star class
        class ShootingStar {
            constructor() {
                this.reset();
            }
            
            reset() {
                // Start from random position on top or sides
                const side = Math.random();
                if (side < 0.5) {
                    this.x = Math.random() * starfieldCanvas.width;
                    this.y = -10;
                } else {
                    this.x = starfieldCanvas.width + 10;
                    this.y = Math.random() * starfieldCanvas.height * 0.5;
                }
                
                // Direction (always moving down-right or down-left)
                this.angle = Math.PI / 4 + (Math.random() - 0.5) * 0.5;
                this.speed = 3 + Math.random() * 4;
                this.length = 40 + Math.random() * 60;
                this.thickness = 1 + Math.random() * 1.5;
                this.life = 1;
                this.fadeSpeed = 0.01 + Math.random() * 0.02;
                
                // Greenish shooting star
                this.color = Math.random() < 0.3 ? 
                    'rgba(121, 192, 90' : 
                    'rgba(255, 255, 255';
            }
            
            update() {
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                this.life -= this.fadeSpeed;
                
                return this.life > 0 && 
                       this.x < starfieldCanvas.width + 100 && 
                       this.y < starfieldCanvas.height + 100;
            }
            
            draw(ctx) {
                const tailX = this.x - Math.cos(this.angle) * this.length;
                const tailY = this.y - Math.sin(this.angle) * this.length;
                
                // Create gradient for tail
                const gradient = ctx.createLinearGradient(this.x, this.y, tailX, tailY);
                gradient.addColorStop(0, `${this.color}, ${this.life * 0.9})`);
                gradient.addColorStop(0.5, `${this.color}, ${this.life * 0.5})`);
                gradient.addColorStop(1, `${this.color}, 0)`);
                
                ctx.strokeStyle = gradient;
                ctx.lineWidth = this.thickness;
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                ctx.moveTo(tailX, tailY);
                ctx.lineTo(this.x, this.y);
                ctx.stroke();
                
                // Bright head
                ctx.fillStyle = `${this.color}, ${this.life})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.thickness * 1.5, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Initialize starfield canvas
        function initStarfieldCanvas() {
            starfieldCanvas.width = window.innerWidth;
            starfieldCanvas.height = window.innerHeight;
            
            // Create stars
            stars.length = 0;
            for (let i = 0; i < NUM_STARS; i++) {
                stars.push(new Star());
            }
        }
        
        // Track mouse for starfield parallax
        document.addEventListener('mousemove', (e) => {
            targetStarMouseX = e.clientX;
            targetStarMouseY = e.clientY;
        });
        
        window.addEventListener('mouseout', (e) => {
            if (e.clientX !== undefined) {
                targetStarMouseX = e.clientX;
                targetStarMouseY = e.clientY;
            }
        });
        
        // Smooth interpolation for starfield
        function updateStarfieldMouse() {
            starMouseX += (targetStarMouseX - starMouseX) * 0.05;
            starMouseY += (targetStarMouseY - starMouseY) * 0.05;
        }
        
        // Spawn shooting stars randomly
        function maybeSpawnShootingStar() {
            if (Math.random() < 0.01 && shootingStars.length < 3) {
                shootingStars.push(new ShootingStar());
            }
        }
        
        // Draw starfield
        function drawStarfield() {
            const width = starfieldCanvas.width;
            const height = starfieldCanvas.height;
            const time = Date.now() * 0.001;
            
            // Clear canvas
            starCtx.clearRect(0, 0, width, height);
            
            // Update and draw stars
            stars.forEach(star => {
                star.update(starMouseX, starMouseY);
                star.draw(starCtx, time);
            });
            
            // Update and draw shooting stars
            maybeSpawnShootingStar();
            
            for (let i = shootingStars.length - 1; i >= 0; i--) {
                const shootingStar = shootingStars[i];
                if (!shootingStar.update()) {
                    shootingStars.splice(i, 1);
                } else {
                    shootingStar.draw(starCtx);
                }
            }
        }
        
        // Animation loop for starfield
        function animateStarfield() {
            const mainMenu = document.getElementById('main-menu');
            
            // Show starfield whenever main menu is visible (keep enabled in menus)
            if (mainMenu && mainMenu.style.display !== 'none') {
                starfieldCanvas.classList.add('active');
                updateStarfieldMouse();
                drawStarfield();
            } else {
                starfieldCanvas.classList.remove('active');
            }
            
            requestAnimationFrame(animateStarfield);
        }
        
        // ==================== GRID BACKGROUND REMOVED ====================
        // Replaced with cleaner blocky Minecraft aesthetic
        
        // Handle window resize for starfield
        window.addEventListener('resize', () => {
            initStarfieldCanvas();
        });
        
        // Initialize starfield and start background music
        window.addEventListener('load', () => {
            initStarfieldCanvas();
            animateStarfield();
            // Start background music when page loads (in main menu)
            setTimeout(() => {
                // Set initial game state
                setGameState(GAME_STATE.MAIN_MENU);
                startBackgroundMusic();
            }, 500); // Small delay to ensure audio context is ready
        });
        
    </script>
</body>
</html>